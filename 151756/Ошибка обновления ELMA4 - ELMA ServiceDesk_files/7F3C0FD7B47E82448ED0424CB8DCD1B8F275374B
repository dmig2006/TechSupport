//Start files

/**
 * Version: 1.0 Alpha-1 
 * Build Date: 13-Nov-2007
 * Copyright (c) 2006-2007, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * License: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * Website: http://www.datejs.com/ or http://www.coolite.com/datejs/
 */
Date.CultureInfo = {name: "en-US", englishName: "English (United States)", nativeName: "English (United States)", dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], abbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], shortestDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], firstLetterDayNames: ["S", "M", "T", "W", "T", "F", "S"], monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], abbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], amDesignator: "AM", pmDesignator: "PM", firstDayOfWeek: 0, twoDigitYearMax: 2029, dateElementOrder: "mdy", formatPatterns: { shortDate: "M/d/yyyy", longDate: "dddd, MMMM dd, yyyy", shortTime: "h:mm tt", longTime: "h:mm:ss tt", fullDateTime: "dddd, MMMM dd, yyyy h:mm:ss tt", sortableDateTime: "yyyy-MM-ddTHH:mm:ss", universalSortableDateTime: "yyyy-MM-dd HH:mm:ssZ", rfc1123: "ddd, dd MMM yyyy HH:mm:ss GMT", monthDay: "MMMM dd", yearMonth: "MMMM, yyyy" }, regexPatterns: { jan: /^jan(uary)?/i, feb: /^feb(ruary)?/i, mar: /^mar(ch)?/i, apr: /^apr(il)?/i, may: /^may/i, jun: /^jun(e)?/i, jul: /^jul(y)?/i, aug: /^aug(ust)?/i, sep: /^sep(t(ember)?)?/i, oct: /^oct(ober)?/i, nov: /^nov(ember)?/i, dec: /^dec(ember)?/i, sun: /^su(n(day)?)?/i, mon: /^mo(n(day)?)?/i, tue: /^tu(e(s(day)?)?)?/i, wed: /^we(d(nesday)?)?/i, thu: /^th(u(r(s(day)?)?)?)?/i, fri: /^fr(i(day)?)?/i, sat: /^sa(t(urday)?)?/i, future: /^next/i, past: /^last|past|prev(ious)?/i, add: /^(\+|after|from)/i, subtract: /^(\-|before|ago)/i, yesterday: /^yesterday/i, today: /^t(oday)?/i, tomorrow: /^tomorrow/i, now: /^n(ow)?/i, millisecond: /^ms|milli(second)?s?/i, second: /^sec(ond)?s?/i, minute: /^min(ute)?s?/i, hour: /^h(ou)?rs?/i, week: /^w(ee)?k/i, month: /^m(o(nth)?s?)?/i, day: /^d(ays?)?/i, year: /^y((ea)?rs?)?/i, shortMeridian: /^(a|p)/i, longMeridian: /^(a\.?m?\.?|p\.?m?\.?)/i, timezone: /^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt)/i, ordinalSuffix: /^\s*(st|nd|rd|th)/i, timeContext: /^\s*(\:|a|p)/i }, abbreviatedTimeZoneStandard: { GMT: "-000", EST: "-0400", CST: "-0500", MST: "-0600", PST: "-0700" }, abbreviatedTimeZoneDST: { GMT: "-000", EDT: "-0500", CDT: "-0600", MDT: "-0700", PDT: "-0800" }};
Date.getMonthNumberFromName = function (name) {
    var n = Date.CultureInfo.monthNames, m = Date.CultureInfo.abbreviatedMonthNames, s = name.toLowerCase(); for (var i = 0; i < n.length; i++) { if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) { return i; } }
    return -1;
};
Date.getDayNumberFromName = function (name) {
    var n = Date.CultureInfo.dayNames, m = Date.CultureInfo.abbreviatedDayNames, o = Date.CultureInfo.shortestDayNames, s = name.toLowerCase(); for (var i = 0; i < n.length; i++) { if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) { return i; } }
    return -1;
};
Date.isLeapYear = function (year) { return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0)); };
Date.getDaysInMonth = function (year, month) { return [31, (Date.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]; };
Date.getTimezoneOffset = function (s, dst) { return (dst || false) ? Date.CultureInfo.abbreviatedTimeZoneDST[s.toUpperCase()] : Date.CultureInfo.abbreviatedTimeZoneStandard[s.toUpperCase()]; };
Date.getTimezoneAbbreviation = function (offset, dst) {
    var n = (dst || false) ? Date.CultureInfo.abbreviatedTimeZoneDST : Date.CultureInfo.abbreviatedTimeZoneStandard, p; for (p in n) { if (n[p] === offset) { return p; } }
    return null;
};
Date.prototype.clone = function () { return new Date(this.getTime()); };
Date.prototype.compareTo = function (date) {
    if (isNaN(this)) { throw new Error(this); }
    if (date instanceof Date && !isNaN(date)) { return (this > date) ? 1 : (this < date) ? -1 : 0; } else { throw new TypeError(date); }
};
Date.prototype.equals = function (date) { return (this.compareTo(date) === 0); };
Date.prototype.between = function (start, end) { var t = this.getTime(); return t >= start.getTime() && t <= end.getTime(); };
Date.prototype.addMilliseconds = function (value) { this.setMilliseconds(this.getMilliseconds() + value); return this; };
Date.prototype.addSeconds = function (value) { return this.addMilliseconds(value * 1000); };
Date.prototype.addMinutes = function (value) { return this.addMilliseconds(value * 60000); };
Date.prototype.addHours = function (value) { return this.addMilliseconds(value * 3600000); };
Date.prototype.addDays = function (value) { return this.addMilliseconds(value * 86400000); };
Date.prototype.addWeeks = function (value) { return this.addMilliseconds(value * 604800000); };
Date.prototype.addMonths = function (value) { var n = this.getDate(); this.setDate(1); this.setMonth(this.getMonth() + value); this.setDate(Math.min(n, this.getDaysInMonth())); return this; };
Date.prototype.addYears = function (value) { return this.addMonths(value * 12); };
Date.prototype.add = function (config) {
    if (typeof config == "number") { this._orient = config; return this; }
    var x = config; if (x.millisecond || x.milliseconds) { this.addMilliseconds(x.millisecond || x.milliseconds); }
    if (x.second || x.seconds) { this.addSeconds(x.second || x.seconds); }
    if (x.minute || x.minutes) { this.addMinutes(x.minute || x.minutes); }
    if (x.hour || x.hours) { this.addHours(x.hour || x.hours); }
    if (x.month || x.months) { this.addMonths(x.month || x.months); }
    if (x.year || x.years) { this.addYears(x.year || x.years); }
    if (x.day || x.days) { this.addDays(x.day || x.days); }
    return this;
};
Date._validate = function (value, min, max, name) {
    if (typeof value != "number") { throw new TypeError(value + " is not a Number."); } else if (value < min || value > max) { throw new RangeError(value + " is not a valid value for " + name + "."); }
    return true;
};
Date.validateMillisecond = function (n) { return Date._validate(n, 0, 999, "milliseconds"); };
Date.validateSecond = function (n) { return Date._validate(n, 0, 59, "seconds"); };
Date.validateMinute = function (n) { return Date._validate(n, 0, 59, "minutes"); };
Date.validateHour = function (n) { return Date._validate(n, 0, 23, "hours"); };
Date.validateDay = function (n, year, month) { return Date._validate(n, 1, Date.getDaysInMonth(year, month), "days"); };
Date.validateMonth = function (n) { return Date._validate(n, 0, 11, "months"); };
Date.validateYear = function (n) { return Date._validate(n, 1, 9999, "seconds"); };
Date.prototype.set = function (config) {
    var x = config; if (!x.millisecond && x.millisecond !== 0) { x.millisecond = -1; }
    if (!x.second && x.second !== 0) { x.second = -1; }
    if (!x.minute && x.minute !== 0) { x.minute = -1; }
    if (!x.hour && x.hour !== 0) { x.hour = -1; }
    if (!x.day && x.day !== 0) { x.day = -1; }
    if (!x.month && x.month !== 0) { x.month = -1; }
    if (!x.year && x.year !== 0) { x.year = -1; }
    if (x.millisecond != -1 && Date.validateMillisecond(x.millisecond)) { this.addMilliseconds(x.millisecond - this.getMilliseconds()); }
    if (x.second != -1 && Date.validateSecond(x.second)) { this.addSeconds(x.second - this.getSeconds()); }
    if (x.minute != -1 && Date.validateMinute(x.minute)) { this.addMinutes(x.minute - this.getMinutes()); }
    if (x.hour != -1 && Date.validateHour(x.hour)) { this.addHours(x.hour - this.getHours()); }
    if (x.month !== -1 && Date.validateMonth(x.month)) { this.addMonths(x.month - this.getMonth()); }
    if (x.year != -1 && Date.validateYear(x.year)) { this.addYears(x.year - this.getFullYear()); }
    if (x.day != -1 && Date.validateDay(x.day, this.getFullYear(), this.getMonth())) { this.addDays(x.day - this.getDate()); }
    if (x.timezone) { this.setTimezone(x.timezone); }
    if (x.timezoneOffset) { this.setTimezoneOffset(x.timezoneOffset); }
    return this;
};
Date.prototype.clearTime = function () { this.setHours(0); this.setMinutes(0); this.setSeconds(0); this.setMilliseconds(0); return this; };
Date.prototype.isLeapYear = function () { var y = this.getFullYear(); return (((y % 4 === 0) && (y % 100 !== 0)) || (y % 400 === 0)); };
Date.prototype.isWeekday = function () { return !(this.is().sat() || this.is().sun()); };
Date.prototype.getDaysInMonth = function () { return Date.getDaysInMonth(this.getFullYear(), this.getMonth()); };
Date.prototype.moveToFirstDayOfMonth = function () { return this.set({ day: 1 }); };
Date.prototype.moveToLastDayOfMonth = function () { return this.set({ day: this.getDaysInMonth() }); };
Date.prototype.moveToDayOfWeek = function (day, orient) { var diff = (day - this.getDay() + 7 * (orient || +1)) % 7; return this.addDays((diff === 0) ? diff += 7 * (orient || +1) : diff); };
Date.prototype.moveToMonth = function (month, orient) { var diff = (month - this.getMonth() + 12 * (orient || +1)) % 12; return this.addMonths((diff === 0) ? diff += 12 * (orient || +1) : diff); };
Date.prototype.getDayOfYear = function () { return Math.floor((this - new Date(this.getFullYear(), 0, 1)) / 86400000); };
Date.prototype.getWeekOfYear = function (firstDayOfWeek) {
    var y = this.getFullYear(), m = this.getMonth(), d = this.getDate(); var dow = firstDayOfWeek || Date.CultureInfo.firstDayOfWeek; var offset = 7 + 1 - new Date(y, 0, 1).getDay(); if (offset == 8) { offset = 1; }
    var daynum = ((Date.UTC(y, m, d, 0, 0, 0) - Date.UTC(y, 0, 1, 0, 0, 0)) / 86400000) + 1; var w = Math.floor((daynum - offset + 7) / 7); if (w === dow) { y--; var prevOffset = 7 + 1 - new Date(y, 0, 1).getDay(); if (prevOffset == 2 || prevOffset == 8) { w = 53; } else { w = 52; } }
    return w;
};
Date.prototype.isDST = function () { console.log('isDST'); return this.toString().match(/(E|C|M|P)(S|D)T/)[2] == "D"; };
Date.prototype.getTimezone = function () { return Date.getTimezoneAbbreviation(this.getUTCOffset, this.isDST()); };
Date.prototype.setTimezoneOffset = function (s) { var here = this.getTimezoneOffset(), there = Number(s) * -6 / 10; this.addMinutes(there - here); return this; };
Date.prototype.setTimezone = function (s) { return this.setTimezoneOffset(Date.getTimezoneOffset(s)); };
Date.prototype.getUTCOffset = function () { var n = this.getTimezoneOffset() * -10 / 6, r; if (n < 0) { r = (n - 10000).toString(); return r[0] + r.substr(2); } else { r = (n + 10000).toString(); return "+" + r.substr(1); } };
Date.prototype.getDayName = function (abbrev) { return abbrev ? Date.CultureInfo.abbreviatedDayNames[this.getDay()] : Date.CultureInfo.dayNames[this.getDay()]; };
Date.prototype.getMonthName = function (abbrev) { return abbrev ? Date.CultureInfo.abbreviatedMonthNames[this.getMonth()] : Date.CultureInfo.monthNames[this.getMonth()]; }; Date.prototype._toString = Date.prototype.toString;
Date.prototype.toString = function (format) { var self = this; var p = function p(s) { return (s.toString().length == 1) ? "0" + s : s; }; return format ? format.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?/g, function (format) { switch (format) { case "hh": return p(self.getHours() < 13 ? self.getHours() : (self.getHours() - 12)); case "h": return self.getHours() < 13 ? self.getHours() : (self.getHours() - 12); case "HH": return p(self.getHours()); case "H": return self.getHours(); case "mm": return p(self.getMinutes()); case "m": return self.getMinutes(); case "ss": return p(self.getSeconds()); case "s": return self.getSeconds(); case "yyyy": return self.getFullYear(); case "yy": return self.getFullYear().toString().substring(2, 4); case "dddd": return self.getDayName(); case "ddd": return self.getDayName(true); case "dd": return p(self.getDate()); case "d": return self.getDate().toString(); case "MMMM": return self.getMonthName(); case "MMM": return self.getMonthName(true); case "MM": return p((self.getMonth() + 1)); case "M": return self.getMonth() + 1; case "t": return self.getHours() < 12 ? Date.CultureInfo.amDesignator.substring(0, 1) : Date.CultureInfo.pmDesignator.substring(0, 1); case "tt": return self.getHours() < 12 ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator; case "zzz": case "zz": case "z": return ""; } }) : this._toString(); };
Date.now = function () { return new Date(); };
Date.today = function () { return Date.now().clearTime(); }; Date.prototype._orient = +1;
Date.prototype.next = function () { this._orient = +1; return this; };
Date.prototype.last = Date.prototype.prev = Date.prototype.previous = function () { this._orient = -1; return this; };
Date.prototype._is = false; Date.prototype.is = function () { this._is = true; return this; }; Number.prototype._dateElement = "day";
Number.prototype.fromNow = function () { var c = {}; c[this._dateElement] = this; return Date.now().add(c); };
Number.prototype.ago = function () { var c = {}; c[this._dateElement] = this * -1; return Date.now().add(c); };
(function () {
    var $D = Date.prototype, $N = Number.prototype; var dx = ("sunday monday tuesday wednesday thursday friday saturday").split(/\s/), mx = ("january february march april may june july august september october november december").split(/\s/), px = ("Millisecond Second Minute Hour Day Week Month Year").split(/\s/), de; var df = function (n) {
        return function () {
            if (this._is) { this._is = false; return this.getDay() == n; }
            return this.moveToDayOfWeek(n, this._orient);
        };
    }; for (var i = 0; i < dx.length; i++) { $D[dx[i]] = $D[dx[i].substring(0, 3)] = df(i); }
    var mf = function (n) {
        return function () {
            if (this._is) { this._is = false; return this.getMonth() === n; }
            return this.moveToMonth(n, this._orient);
        };
    }; for (var j = 0; j < mx.length; j++) { $D[mx[j]] = $D[mx[j].substring(0, 3)] = mf(j); }
    var ef = function (j) {
        return function () {
            if (j.substring(j.length - 1) != "s") { j += "s"; }
            return this["add" + j](this._orient);
        };
    }; var nf = function (n) { return function () { this._dateElement = n; return this; }; }; for (var k = 0; k < px.length; k++) { de = px[k].toLowerCase(); $D[de] = $D[de + "s"] = ef(px[k]); $N[de] = $N[de + "s"] = nf(de); }
}());
Date.prototype.toJSONString = function () { return this.toString("yyyy-MM-ddThh:mm:ssZ"); };
Date.prototype.toShortDateString = function () { return this.toString(Date.CultureInfo.formatPatterns.shortDatePattern); };
Date.prototype.toLongDateString = function () { return this.toString(Date.CultureInfo.formatPatterns.longDatePattern); };
Date.prototype.toShortTimeString = function () { return this.toString(Date.CultureInfo.formatPatterns.shortTimePattern); };
Date.prototype.toLongTimeString = function () { return this.toString(Date.CultureInfo.formatPatterns.longTimePattern); };
Date.prototype.getOrdinal = function () { switch (this.getDate()) { case 1: case 21: case 31: return "st"; case 2: case 22: return "nd"; case 3: case 23: return "rd"; default: return "th"; } };
(function () {
    Date.Parsing = { Exception: function (s) { this.message = "Parse error at '" + s.substring(0, 10) + " ...'"; } }; var $P = Date.Parsing; var _ = $P.Operators = {
        rtoken: function (r) { return function (s) { var mx = s.match(r); if (mx) { return ([mx[0], s.substring(mx[0].length)]); } else { throw new $P.Exception(s); } }; }, token: function (s) { return function (s) { return _.rtoken(new RegExp("^\s*" + s + "\s*"))(s); }; }, stoken: function (s) { return _.rtoken(new RegExp("^" + s)); }, until: function (p) {
            return function (s) {
                var qx = [], rx = null; while (s.length) {
                    try { rx = p.call(this, s); } catch (e) { qx.push(rx[0]); s = rx[1]; continue; }
                    break;
                }
                return [qx, s];
            };
        }, many: function (p) {
            return function (s) {
                var rx = [], r = null; while (s.length) {
                    try { r = p.call(this, s); } catch (e) { return [rx, s]; }
                    rx.push(r[0]); s = r[1];
                }
                return [rx, s];
            };
        }, optional: function (p) {
            return function (s) {
                var r = null; try { r = p.call(this, s); } catch (e) { return [null, s]; }
                return [r[0], r[1]];
            };
        }, not: function (p) {
            return function (s) {
                try { p.call(this, s); } catch (e) { return [null, s]; }
                throw new $P.Exception(s);
            };
        }, ignore: function (p) { return p ? function (s) { var r = null; r = p.call(this, s); return [null, r[1]]; } : null; }, product: function () {
            var px = arguments[0], qx = Array.prototype.slice.call(arguments, 1), rx = []; for (var i = 0; i < px.length; i++) { rx.push(_.each(px[i], qx)); }
            return rx;
        }, cache: function (rule) {
            var cache = {}, r = null; return function (s) {
                try { r = cache[s] = (cache[s] || rule.call(this, s)); } catch (e) { r = cache[s] = e; }
                if (r instanceof $P.Exception) { throw r; } else { return r; }
            };
        }, any: function () {
            var px = arguments; return function (s) {
                var r = null; for (var i = 0; i < px.length; i++) {
                    if (px[i] == null) { continue; }
                    try { r = (px[i].call(this, s)); } catch (e) { r = null; }
                    if (r) { return r; }
                }
                throw new $P.Exception(s);
            };
        }, each: function () {
            var px = arguments; return function (s) {
                var rx = [], r = null; for (var i = 0; i < px.length; i++) {
                    if (px[i] == null) { continue; }
                    try { r = (px[i].call(this, s)); } catch (e) { throw new $P.Exception(s); }
                    rx.push(r[0]); s = r[1];
                }
                return [rx, s];
            };
        }, all: function () { var px = arguments, _ = _; return _.each(_.optional(px)); }, sequence: function (px, d, c) {
            d = d || _.rtoken(/^\s*/); c = c || null; if (px.length == 1) { return px[0]; }
            return function (s) {
                var r = null, q = null; var rx = []; for (var i = 0; i < px.length; i++) {
                    try { r = px[i].call(this, s); } catch (e) { break; }
                    rx.push(r[0]); try { q = d.call(this, r[1]); } catch (ex) { q = null; break; }
                    s = q[1];
                }
                if (!r) { throw new $P.Exception(s); }
                if (q) { throw new $P.Exception(q[1]); }
                if (c) { try { r = c.call(this, r[1]); } catch (ey) { throw new $P.Exception(r[1]); } }
                return [rx, (r ? r[1] : s)];
            };
        }, between: function (d1, p, d2) { d2 = d2 || d1; var _fn = _.each(_.ignore(d1), p, _.ignore(d2)); return function (s) { var rx = _fn.call(this, s); return [[rx[0][0], r[0][2]], rx[1]]; }; }, list: function (p, d, c) { d = d || _.rtoken(/^\s*/); c = c || null; return (p instanceof Array ? _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) : _.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c))); }, set: function (px, d, c) {
            d = d || _.rtoken(/^\s*/); c = c || null; return function (s) {
                var r = null, p = null, q = null, rx = null, best = [[], s], last = false; for (var i = 0; i < px.length; i++) {
                    q = null; p = null; r = null; last = (px.length == 1); try { r = px[i].call(this, s); } catch (e) { continue; }
                    rx = [[r[0]], r[1]]; if (r[1].length > 0 && !last) { try { q = d.call(this, r[1]); } catch (ex) { last = true; } } else { last = true; }
                    if (!last && q[1].length === 0) { last = true; }
                    if (!last) {
                        var qx = []; for (var j = 0; j < px.length; j++) { if (i != j) { qx.push(px[j]); } }
                        p = _.set(qx, d).call(this, q[1]); if (p[0].length > 0) { rx[0] = rx[0].concat(p[0]); rx[1] = p[1]; }
                    }
                    if (rx[1].length < best[1].length) { best = rx; }
                    if (best[1].length === 0) { break; }
                }
                if (best[0].length === 0) { return best; }
                if (c) {
                    try { q = c.call(this, best[1]); } catch (ey) { throw new $P.Exception(best[1]); }
                    best[1] = q[1];
                }
                return best;
            };
        }, forward: function (gr, fname) { return function (s) { return gr[fname].call(this, s); }; }, replace: function (rule, repl) { return function (s) { var r = rule.call(this, s); return [repl, r[1]]; }; }, process: function (rule, fn) { return function (s) { var r = rule.call(this, s); return [fn.call(this, r[0]), r[1]]; }; }, min: function (min, rule) {
            return function (s) {
                var rx = rule.call(this, s); if (rx[0].length < min) { throw new $P.Exception(s); }
                return rx;
            };
        }
    }; var _generator = function (op) {
        return function () {
            var args = null, rx = []; if (arguments.length > 1) { args = Array.prototype.slice.call(arguments); } else if (arguments[0] instanceof Array) { args = arguments[0]; }
            if (args) { for (var i = 0, px = args.shift() ; i < px.length; i++) { args.unshift(px[i]); rx.push(op.apply(null, args)); args.shift(); return rx; } } else { return op.apply(null, arguments); }
        };
    }; var gx = "optional not ignore cache".split(/\s/); for (var i = 0; i < gx.length; i++) { _[gx[i]] = _generator(_[gx[i]]); }
    var _vector = function (op) { return function () { if (arguments[0] instanceof Array) { return op.apply(null, arguments[0]); } else { return op.apply(null, arguments); } }; }; var vx = "each any all".split(/\s/); for (var j = 0; j < vx.length; j++) { _[vx[j]] = _vector(_[vx[j]]); }
}());
(function () {
    var flattenAndCompact = function (ax) {
        var rx = []; for (var i = 0; i < ax.length; i++) { if (ax[i] instanceof Array) { rx = rx.concat(flattenAndCompact(ax[i])); } else { if (ax[i]) { rx.push(ax[i]); } } }
        return rx;
    };
    Date.Grammar = {};
    Date.Translator = {
        hour: function (s) { return function () { this.hour = Number(s); }; }, minute: function (s) { return function () { this.minute = Number(s); }; }, second: function (s) { return function () { this.second = Number(s); }; }, meridian: function (s) { return function () { this.meridian = s.slice(0, 1).toLowerCase(); }; }, timezone: function (s) { return function () { var n = s.replace(/[^\d\+\-]/g, ""); if (n.length) { this.timezoneOffset = Number(n); } else { this.timezone = s.toLowerCase(); } }; }, day: function (x) { var s = x[0]; return function () { this.day = Number(s.match(/\d+/)[0]); }; }, month: function (s) { return function () { this.month = ((s.length == 3) ? Date.getMonthNumberFromName(s) : (Number(s) - 1)); }; }, year: function (s) { return function () { var n = Number(s); this.year = ((s.length > 2) ? n : (n + (((n + 2000) < Date.CultureInfo.twoDigitYearMax) ? 2000 : 1900))); }; }, rday: function (s) { return function () { switch (s) { case "yesterday": this.days = -1; break; case "tomorrow": this.days = 1; break; case "today": this.days = 0; break; case "now": this.days = 0; this.now = true; break; } }; }, finishExact: function (x) {
            x = (x instanceof Array) ? x : [x]; var now = new Date(); this.year = now.getFullYear(); this.month = now.getMonth(); this.day = 1; this.hour = 0; this.minute = 0; this.second = 0; for (var i = 0; i < x.length; i++) { if (x[i]) { x[i].call(this); } }
            this.hour = (this.meridian == "p" && this.hour < 13) ? this.hour + 12 : this.hour; if (this.day > Date.getDaysInMonth(this.year, this.month)) { throw new RangeError(this.day + " is not a valid value for days."); }
            var r = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second); if (this.timezone) { r.set({ timezone: this.timezone }); } else if (this.timezoneOffset) { r.set({ timezoneOffset: this.timezoneOffset }); }
            return r;
        }, finish: function (x) {
            x = (x instanceof Array) ? flattenAndCompact(x) : [x]; if (x.length === 0) { return null; }
            for (var i = 0; i < x.length; i++) { if (typeof x[i] == "function") { x[i].call(this); } }
            if (this.now) { return new Date(); }
            var today = Date.today(); var method = null; var expression = !!(this.days != null || this.orient || this.operator); if (expression) {
                var gap, mod, orient; orient = ((this.orient == "past" || this.operator == "subtract") ? -1 : 1); if (this.weekday) { this.unit = "day"; gap = (Date.getDayNumberFromName(this.weekday) - today.getDay()); mod = 7; this.days = gap ? ((gap + (orient * mod)) % mod) : (orient * mod); }
                if (this.month) { this.unit = "month"; gap = (this.month - today.getMonth()); mod = 12; this.months = gap ? ((gap + (orient * mod)) % mod) : (orient * mod); this.month = null; }
                if (!this.unit) { this.unit = "day"; }
                if (this[this.unit + "s"] == null || this.operator != null) {
                    if (!this.value) { this.value = 1; }
                    if (this.unit == "week") { this.unit = "day"; this.value = this.value * 7; }
                    this[this.unit + "s"] = this.value * orient;
                }
                return today.add(this);
            } else {
                if (this.meridian && this.hour) { this.hour = (this.hour < 13 && this.meridian == "p") ? this.hour + 12 : this.hour; }
                if (this.weekday && !this.day) { this.day = (today.addDays((Date.getDayNumberFromName(this.weekday) - today.getDay()))).getDate(); }
                if (this.month && !this.day) { this.day = 1; }
                return today.set(this);
            }
        }
    };
    var _ = Date.Parsing.Operators, g = Date.Grammar, t = Date.Translator, _fn; g.datePartDelimiter = _.rtoken(/^([\s\-\.\,\/\x27]+)/); g.timePartDelimiter = _.stoken(":"); g.whiteSpace = _.rtoken(/^\s*/); g.generalDelimiter = _.rtoken(/^(([\s\,]|at|on)+)/); var _C = {}; g.ctoken = function (keys) {
        var fn = _C[keys]; if (!fn) {
            var c = Date.CultureInfo.regexPatterns; var kx = keys.split(/\s+/), px = []; for (var i = 0; i < kx.length; i++) { px.push(_.replace(_.rtoken(c[kx[i]]), kx[i])); }
            fn = _C[keys] = _.any.apply(null, px);
        }
        return fn;
    }; g.ctoken2 = function (key) { return _.rtoken(Date.CultureInfo.regexPatterns[key]); };
    g.h = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/), t.hour));
    g.hh = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/), t.hour));
    g.H = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/), t.hour));
    g.HH = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/), t.hour));
    g.m = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.minute));
    g.mm = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.minute));
    g.s = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.second));
    g.ss = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.second));
    g.hms = _.cache(_.sequence([g.H, g.mm, g.ss], g.timePartDelimiter));
    g.t = _.cache(_.process(g.ctoken2("shortMeridian"), t.meridian));
    g.tt = _.cache(_.process(g.ctoken2("longMeridian"), t.meridian));
    g.z = _.cache(_.process(_.rtoken(/^(\+|\-)?\s*\d\d\d\d?/), t.timezone));
    g.zz = _.cache(_.process(_.rtoken(/^(\+|\-)\s*\d\d\d\d/), t.timezone));
    g.zzz = _.cache(_.process(g.ctoken2("timezone"), t.timezone));
    g.timeSuffix = _.each(_.ignore(g.whiteSpace), _.set([g.tt, g.zzz]));
    g.time = _.each(_.optional(_.ignore(_.stoken("T"))), g.hms, g.timeSuffix);
    g.d = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/), _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.dd = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/), _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.ddd = g.dddd = _.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"), function (s) { return function () { this.weekday = s; }; }));
    g.M = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/), t.month));
    g.MM = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/), t.month));
    g.MMM = g.MMMM = _.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"), t.month));
    g.y = _.cache(_.process(_.rtoken(/^(\d\d?)/), t.year)); g.yy = _.cache(_.process(_.rtoken(/^(\d\d)/), t.year));
    g.yyy = _.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/), t.year));
    g.yyyy = _.cache(_.process(_.rtoken(/^(\d\d\d\d)/), t.year));
    _fn = function () { return _.each(_.any.apply(null, arguments), _.not(g.ctoken2("timeContext"))); };
    g.day = _fn(g.d, g.dd); g.month = _fn(g.M, g.MMM);
    g.year = _fn(g.yyyy, g.yy);
    g.orientation = _.process(g.ctoken("past future"), function (s) { return function () { this.orient = s; }; });
    g.operator = _.process(g.ctoken("add subtract"), function (s) { return function () { this.operator = s; }; });
    g.rday = _.process(g.ctoken("yesterday tomorrow today now"), t.rday);
    g.unit = _.process(g.ctoken("minute hour day week month year"), function (s) { return function () { this.unit = s; }; }); g.value = _.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/), function (s) { return function () { this.value = s.replace(/\D/g, ""); }; }); g.expression = _.set([g.rday, g.operator, g.value, g.unit, g.orientation, g.ddd, g.MMM]); _fn = function () { return _.set(arguments, g.datePartDelimiter); }; g.mdy = _fn(g.ddd, g.month, g.day, g.year); g.ymd = _fn(g.ddd, g.year, g.month, g.day); g.dmy = _fn(g.ddd, g.day, g.month, g.year); g.date = function (s) { return ((g[Date.CultureInfo.dateElementOrder] || g.mdy).call(this, s)); };
    g.format = _.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/), function (fmt) { if (g[fmt]) { return g[fmt]; } else { throw Date.Parsing.Exception(fmt); } }), _.process(_.rtoken(/^[^dMyhHmstz]+/), function (s) { return _.ignore(_.stoken(s)); }))), function (rules) { return _.process(_.each.apply(null, rules), t.finishExact); }); var _F = {}; var _get = function (f) { return _F[f] = (_F[f] || g.format(f)[0]); }; g.formats = function (fx) {
        if (fx instanceof Array) {
            var rx = []; for (var i = 0; i < fx.length; i++) { rx.push(_get(fx[i])); }
            return _.any.apply(null, rx);
        } else { return _get(fx); }
    };
    g._formats = g.formats(["yyyy-MM-ddTHH:mm:ss", "ddd, MMM dd, yyyy H:mm:ss tt", "ddd MMM d yyyy HH:mm:ss zzz", "d"]);
    g._start = _.process(_.set([g.date, g.time, g.expression], g.generalDelimiter, g.whiteSpace), t.finish);
    g.start = function (s) {
        try { var r = g._formats.call({}, s); if (r[1].length === 0) { return r; } } catch (e) { }
        return g._start.call({}, s);
    };
}());
Date._parse = Date.parse;
Date.parse = function (s) {
    var r = null; if (!s) { return null; }
    try { r = Date.Grammar.start.call({}, s); } catch (e) { return null; }
    return ((r[1].length === 0) ? r[0] : null);
};
Date.getParseFunction = function (fx) {
    var fn = Date.Grammar.formats(fx); return function (s) {
        var r = null; try { r = fn.call({}, s); } catch (e) { return null; }
        return ((r[1].length === 0) ? r[0] : null);
    };
};
Date.parseExact = function (s, fx) { return Date.getParseFunction(fx)(s); };

Date.prototype.getWeekNum = function () {
    if (Date.CultureInfo.firstDayOfWeek == "1") {
        var day = this.getDate();
        var month = this.getMonth() + 1;
        var year = this.getFullYear();
        var a = Math.floor((14 - month) / 12);
        var y = year + 4800 - a;
        var m = month + 12 * a - 3;
        var J = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) -
            Math.floor(y / 100) + Math.floor(y / 400) - 32045;
        d4 = (((J + 31741 - (J % 7)) % 146097) % 36524) % 1461;
        var L = Math.floor(d4 / 1460);
        var d1 = ((d4 - L) % 365) + L;
        var week = Math.floor(d1 / 7) + 1;
        if (week < 10) week = '0' + week; //first 0
        return week;
    }
    if (Date.CultureInfo.firstDayOfWeek == "0") {
        var endDate = new Date(this);
        var day = endDate.getDay();
        endDate.addDays(6 - day);
        if (endDate.getMonth() == 0 && endDate.getDate() == 1) endDate.addDays(-1); //31 december its 31 decemder, not 1 january
        day = endDate.getDayOfYear();
        var week = (day / 7 | 0) + 1;
        if (week < 10) week = '0' + week;
        return week;
    }
    return "";
};


Date.prototype.dateTimePickerTitleFormatDate = function (format) {
    return Date.dateTimePickerTitleFormatDates(this, null, format);
};

Date.dateTimePickerTitleFormatDates = function (date1, date2, format) {
    var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
    if (translationMode) {
        format = elma.ExtractTargetString(format);
    }
    var date = date1,
    otherDate = date2,
    i, len = format.length, c,
    i2, formatter,
    res = '';
    for (i = 0; i < len; i++) {
        c = format.charAt(i);
        if (c == "'") {
            for (i2 = i + 1; i2 < len; i2++) {
                if (format.charAt(i2) == "'") {
                    if (date) {
                        if (i2 == i + 1) {
                            res += "'";
                        } else {
                            res += format.substring(i + 1, i2);
                        }
                        i = i2;
                    }
                    break;
                }
            }
        }
        else if (c == '(') {
            for (i2 = i + 1; i2 < len; i2++) {
                if (format.charAt(i2) == ')') {
                    var subres = date.dateTimePickerTitleFormatDate(format.substring(i + 1, i2));
                    if (parseInt(subres.replace(/\D/, ''), 10)) {
                        res += subres;
                    }
                    i = i2;
                    break;
                }
            }
        }
        else if (c == '[') {
            for (i2 = i + 1; i2 < len; i2++) {
                if (format.charAt(i2) == ']') {
                    var subformat = format.substring(i + 1, i2);
                    var subres = date.dateTimePickerTitleFormatDate(subformat);
                    if (subres != otherDate.dateTimePickerTitleFormatDate(subformat)) {
                        res += subres;
                    }
                    i = i2;
                    break;
                }
            }
        }
        else if (c == '{') {
            date = date2;
            otherDate = date1;
        }
        else if (c == '}') {
            date = date1;
            otherDate = date2;
        }
        else {
            for (i2 = len; i2 > i; i2--) {
                if (formatter = Date.dateTimePickerTitleFormatters[format.substring(i, i2)]) {
                    if (date) {
                        res += formatter(date);
                    }
                    i = i2 - 1;
                    break;
                }
            }
            if (i2 == i) {
                if (date) {
                    res += c;
                }
            }
        }
    }
    return res;
};

Date.dateTimePickerTitleFormatters = {
    s: function (d) { return d.getSeconds(); },
    ss: function (d) { var n = d.getSeconds(); return (n < 10 ? '0' : '') + n; },
    m: function (d) { return d.getMinutes(); },
    mm: function (d) { var n = d.getMinutes(); return (n < 10 ? '0' : '') + n; },
    h: function (d) { return d.getHours() % 12 || 12; },
    hh: function (d) { var n = d.getHours() % 12 || 12; return (n < 10 ? '0' : '') + n; },
    H: function (d) { return d.getHours(); },
    HH: function (d) { var n = d.getHours(); return (n < 10 ? '0' : '') + n; },
    d: function (d) { return d.getDate(); },
    dd: function (d) { var n = d.getDate(); return (n < 10 ? '0' : '') + n; },
    ddd: function (d) { return Date.CultureInfo.dayNames[d.getDay()]; },
    dddd: function (d) { return Date.CultureInfo.dayNames[d.getDay()]; },
    M: function (d) { return d.getMonth() + 1; },
    MM: function (d) { var n = d.getMonth() + 1; return (n < 10 ? '0' : '') + n; },
    MMM: function (d) { return Date.CultureInfo.monthNames[d.getMonth()]; },
    MMMM: function (d) { return Date.CultureInfo.monthNames[d.getMonth()]; },
    yy: function (d) { return (d.getFullYear() + '').substring(2); },
    yyyy: function (d) { return d.getFullYear(); },
    t: function (d) { return d.getHours() < 12 ? 'a' : 'p'; },
    tt: function (d) { return d.getHours() < 12 ? 'am' : 'pm'; },
    T: function (d) { return d.getHours() < 12 ? 'A' : 'P'; },
    TT: function (d) { return d.getHours() < 12 ? 'AM' : 'PM'; },
    u: function (d) { return d.dateTimePickerTitleFormatDate("yyyy-MM-dd'T'HH:mm:ss'Z'"); },
    S: function (d) {
        var date = d.getDate();
        if (date > 10 && date < 20) {
            return 'th';
        }
        return ['st', 'nd', 'rd'][date % 10 - 1] || 'th';
    }
};

Date.reInit = function () {
    Date.CultureInfo = {
        name: $.telerik.cultureInfo.name,
        englishName: $.telerik.cultureInfo.englishName,
        nativeName: $.telerik.cultureInfo.nativeName,
        dayNames: $.telerik.cultureInfo.days,
        abbreviatedDayNames: $.telerik.cultureInfo.abbrDays,
        shortestDayNames: $.telerik.cultureInfo.abbrDays,
        firstLetterDayNames: [
            $.telerik.cultureInfo.days[0].charAt(0).toUpperCase(),
            $.telerik.cultureInfo.days[1].charAt(0).toUpperCase(),
            $.telerik.cultureInfo.days[2].charAt(0).toUpperCase(),
            $.telerik.cultureInfo.days[3].charAt(0).toUpperCase(),
            $.telerik.cultureInfo.days[4].charAt(0).toUpperCase(),
            $.telerik.cultureInfo.days[5].charAt(0).toUpperCase(),
            $.telerik.cultureInfo.days[6].charAt(0).toUpperCase()
        ],
        monthNames: $.telerik.cultureInfo.months,
        abbreviatedMonthNames: $.telerik.cultureInfo.abbrMonths,
        amDesignator: $.telerik.cultureInfo.am,
        pmDesignator: $.telerik.cultureInfo.pm,
        firstDayOfWeek: $.telerik.cultureInfo.firstDayOfWeek,
        twoDigitYearMax: $.telerik.cultureInfo.twoDigitYearMax,
        dateElementOrder: $.telerik.cultureInfo.dateElementOrder,
        formatPatterns: {
            shortDate: $.telerik.cultureInfo.shortDate,
            longDate: $.telerik.cultureInfo.longDate,
            shortTime: $.telerik.cultureInfo.shortTime,
            longTime: $.telerik.cultureInfo.longTime,
            fullDateTime: $.telerik.cultureInfo.fullDateTime,
            sortableDateTime: $.telerik.cultureInfo.sortableDateTime,
            universalSortableDateTime: $.telerik.cultureInfo.universalSortableDateTime,
            rfc1123: $.telerik.cultureInfo.rfc1123,
            monthDay: $.telerik.cultureInfo.monthDay,
            yearMonth: $.telerik.cultureInfo.monthYear
        }
    };
};

// ReSharper disable once InconsistentNaming
Date = function(Date) {

    // new Date() вернет текущее пользовательское время
    // остальные конструкторы вернут время без преобразования
    function elmaDate() {
        var date = new (Function.bind.bind(Function.bind)(Date, null).apply(null, arguments));
        if (arguments.length === 0) {
            return this.toClientDateTimeFromBrowser.call(date);
        }
        return date;
    }

    // Копируем функционал Date
    elmaDate.prototype = Date.prototype;
    elmaDate.CultureInfo = Date.CultureInfo;
    elmaDate.getMonthNumberFromName = Date.getMonthNumberFromName;
    elmaDate.getDayNumberFromName = Date.getDayNumberFromName;
    elmaDate.isLeapYear = Date.isLeapYear;
    elmaDate.getDaysInMonth = Date.getDaysInMonth;
    elmaDate.getTimezoneOffset = Date.getTimezoneOffset;
    elmaDate.getTimezoneAbbreviation = Date.getTimezoneAbbreviation;
    elmaDate._validate = Date._validate;
    elmaDate.validateMillisecond = Date.validateMillisecond;
    elmaDate.validateSecond = Date.validateSecond;
    elmaDate.validateMinute = Date.validateMinute;
    elmaDate.validateHour = Date.validateHour;
    elmaDate.validateDay = Date.validateDay;
    elmaDate.validateMonth = Date.validateMonth;
    elmaDate.validateYear = Date.validateYear;
    elmaDate.now = Date.now;
    elmaDate.today = Date.today;
    elmaDate.dateTimePickerTitleFormatDates = Date.dateTimePickerTitleFormatDates;
    elmaDate.parse = Date.parse;
    elmaDate.getParseFunction = Date.getParseFunction;
    elmaDate.parseExact = Date.parseExact;
    elmaDate.reInit = Date.reInit;
    elmaDate.Parsing = Date.Parsing;
    elmaDate.Grammar = Date.Grammar;
    elmaDate.Translator = Date.Translator;
    elmaDate.dateTimePickerTitleFormatters = Date.dateTimePickerTitleFormatters;
    elmaDate.UTC = Date.UTC;

    var getTimeZoneOffsetFromCookie = function (key) {
        var matches = document.cookie.match(new RegExp("(?:^|; )" + key.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"));
        return matches ? parseInt(decodeURIComponent(matches[1])) : undefined;
    }

    // Browser --> Client
    elmaDate.prototype.toClientDateTimeFromBrowser = function (offset) {
        if (offset == undefined) {
            offset = getTimeZoneOffsetFromCookie("ElmaUserTimeZoneOffset");
        }
        var browserTimeZoneOffset = -this.getTimezoneOffset(); // getTimezoneOffset() negative offset
        return offset == undefined ? this : this.addMinutes(offset - browserTimeZoneOffset);
    }

    // Browser --> Server
    elmaDate.prototype.toServerDateTimeFromBrowser = function() {
        var serverTimeZoneOffset = getTimeZoneOffsetFromCookie("ElmaServerTimeZoneOffset");
        var browserTimeZoneOffset = -this.getTimezoneOffset(); // getTimezoneOffset() negative offset
        return serverTimeZoneOffset == undefined ? this : this.addMinutes(serverTimeZoneOffset - browserTimeZoneOffset);
    }

    // Browser --> Runtime
    elmaDate.prototype.toRuntimeDateTimeFromBrowser = function() {
        var runtimeTimeZoneOffset = getTimeZoneOffsetFromCookie("ElmaRuntimeTimeZoneOffset");
        var browserTimeZoneOffset = -this.getTimezoneOffset(); // getTimezoneOffset() negative offset
        return runtimeTimeZoneOffset == undefined ? this : this.addMinutes(runtimeTimeZoneOffset - browserTimeZoneOffset);
    }

    // Client --> Browser
    elmaDate.prototype.toBrowserDateTimeFromClient = function (offset) {
        if (offset == undefined) {
            offset = getTimeZoneOffsetFromCookie("ElmaUserTimeZoneOffset");
        }
        var browserTimeZoneOffset = -this.getTimezoneOffset(); // getTimezoneOffset() negative offset
        return offset == undefined ? this : this.addMinutes(browserTimeZoneOffset - offset);
    }

    return elmaDate;
}(Date);


/*! jQuery v1.6.4 http://jquery.com/ | http://jquery.org/license */
(function(a,b){function cu(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cr(a){if(!cg[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){ch||(ch=c.createElement("iframe"),ch.frameBorder=ch.width=ch.height=0),b.appendChild(ch);if(!ci||!ch.createElement)ci=(ch.contentWindow||ch.contentDocument).document,ci.write((c.compatMode==="CSS1Compat"?"<!doctype html>":"")+"<html><body>"),ci.close();d=ci.createElement(a),ci.body.appendChild(d),e=f.css(d,"display"),b.removeChild(ch)}cg[a]=e}return cg[a]}function cq(a,b){var c={};f.each(cm.concat.apply([],cm.slice(0,b)),function(){c[this]=a});return c}function cp(){cn=b}function co(){setTimeout(cp,0);return cn=f.now()}function cf(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ce(){try{return new a.XMLHttpRequest}catch(b){}}function b$(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function bZ(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function bY(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bA.test(a)?d(a,e):bY(a+"["+(typeof e=="object"||f.isArray(e)?b:"")+"]",e,c,d)});else if(!c&&b!=null&&typeof b=="object")for(var e in b)bY(a+"["+e+"]",b[e],c,d);else d(a,b)}function bX(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function bW(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bP,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=bW(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=bW(a,c,d,e,"*",g));return l}function bV(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bL),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function by(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?bt:bu;if(d>0){c!=="border"&&f.each(e,function(){c||(d-=parseFloat(f.css(a,"padding"+this))||0),c==="margin"?d+=parseFloat(f.css(a,c+this))||0:d-=parseFloat(f.css(a,"border"+this+"Width"))||0});return d+"px"}d=bv(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0,c&&f.each(e,function(){d+=parseFloat(f.css(a,"padding"+this))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+this+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+this))||0)});return d+"px"}function bl(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bd,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)}function bk(a){f.nodeName(a,"input")?bj(a):"getElementsByTagName"in a&&f.grep(a.getElementsByTagName("input"),bj)}function bj(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bi(a){return"getElementsByTagName"in a?a.getElementsByTagName("*"):"querySelectorAll"in a?a.querySelectorAll("*"):[]}function bh(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c==="object")b.outerHTML=a.outerHTML;else if(c!=="input"||a.type!=="checkbox"&&a.type!=="radio"){if(c==="option")b.selected=a.defaultSelected;else if(c==="input"||c==="textarea")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bg(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c=f.expando,d=f.data(a),e=f.data(b,d);if(d=d[c]){var g=d.events;e=e[c]=f.extend({},d);if(g){delete e.handle,e.events={};for(var h in g)for(var i=0,j=g[h].length;i<j;i++)f.event.add(b,h+(g[h][i].namespace?".":"")+g[h][i].namespace,g[h][i],g[h][i].data)}}}}function bf(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function V(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(Q.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function U(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function M(a,b){return(a&&a!=="*"?a+".":"")+b.replace(y,"`").replace(z,"&")}function L(a){var b,c,d,e,g,h,i,j,k,l,m,n,o,p=[],q=[],r=f._data(this,"events");if(!(a.liveFired===this||!r||!r.live||a.target.disabled||a.button&&a.type==="click")){a.namespace&&(n=new RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)")),a.liveFired=this;var s=r.live.slice(0);for(i=0;i<s.length;i++)g=s[i],g.origType.replace(w,"")===a.type?q.push(g.selector):s.splice(i--,1);e=f(a.target).closest(q,a.currentTarget);for(j=0,k=e.length;j<k;j++){m=e[j];for(i=0;i<s.length;i++){g=s[i];if(m.selector===g.selector&&(!n||n.test(g.namespace))&&!m.elem.disabled){h=m.elem,d=null;if(g.preType==="mouseenter"||g.preType==="mouseleave")a.type=g.preType,d=f(a.relatedTarget).closest(g.selector)[0],d&&f.contains(h,d)&&(d=h);(!d||d!==h)&&p.push({elem:h,handleObj:g,level:m.level})}}}for(j=0,k=p.length;j<k;j++){e=p[j];if(c&&e.level>c)break;a.currentTarget=e.elem,a.data=e.handleObj.data,a.handleObj=e.handleObj,o=e.handleObj.origHandler.apply(e.elem,arguments);if(o===!1||a.isPropagationStopped()){c=e.level,o===!1&&(b=!1);if(a.isImmediatePropagationStopped())break}}return b}}function J(a,c,d){var e=f.extend({},d[0]);e.type=a,e.originalEvent={},e.liveFired=b,f.event.handle.call(c,e),e.isDefaultPrevented()&&d[0].preventDefault()}function D(){return!0}function C(){return!1}function m(a,c,d){var e=c+"defer",g=c+"queue",h=c+"mark",i=f.data(a,e,b,!0);i&&(d==="queue"||!f.data(a,g,b,!0))&&(d==="mark"||!f.data(a,h,b,!0))&&setTimeout(function(){!f.data(a,g,b,!0)&&!f.data(a,h,b,!0)&&(f.removeData(a,e,!0),i.resolve())},0)}function l(a){for(var b in a)if(b!=="toJSON")return!1;return!0}function k(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(j,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNaN(d)?i.test(d)?f.parseJSON(d):d:parseFloat(d)}catch(g){}f.data(a,c,d)}else d=b}return d}var c=a.document,d=a.navigator,e=a.location,f=function(){function K(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(K,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/\d/,n=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,o=/^[\],:{}\s]*$/,p=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,q=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,r=/(?:^|:|,)(?:\s*\[)+/g,s=/(webkit)[ \/]([\w.]+)/,t=/(opera)(?:.*version)?[ \/]([\w.]+)/,u=/(msie) ([\w.]+)/,v=/(mozilla)(?:.*? rv:([\w.]+))?/,w=/-([a-z]|[0-9])/ig,x=/^-ms-/,y=function(a,b){return(b+"").toUpperCase()},z=d.userAgent,A,B,C,D=Object.prototype.toString,E=Object.prototype.hasOwnProperty,F=Array.prototype.push,G=Array.prototype.slice,H=String.prototype.trim,I=Array.prototype.indexOf,J={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=n.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.6.4",length:0,size:function(){return this.length},toArray:function(){return G.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?F.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),B.done(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(G.apply(this,arguments),"slice",G.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:F,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;B.resolveWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").unbind("ready")}},bindReady:function(){if(!B){B=e._Deferred();if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",C,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",C),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&K()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNaN:function(a){return a==null||!m.test(a)||isNaN(a)},type:function(a){return a==null?String(a):J[D.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!E.call(a,"constructor")&&!E.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||E.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw a},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(o.test(b.replace(p,"@").replace(q,"]").replace(r,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(x,"ms-").replace(w,y)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:H?function(a){return a==null?"":H.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?F.call(c,a):e.merge(c,a)}return c},inArray:function(a,b){if(!b)return-1;if(I)return I.call(b,a);for(var c=0,d=b.length;c<d;c++)if(b[c]===a)return c;return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=G.call(arguments,2),g=function(){return a.apply(c,f.concat(G.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c=="object"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=s.exec(a)||t.exec(a)||u.exec(a)||a.indexOf("compatible")<0&&v.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){J["[object "+b+"]"]=b.toLowerCase()}),A=e.uaMatch(z),A.browser&&(e.browser[A.browser]=!0,e.browser.version=A.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?C=function(){c.removeEventListener("DOMContentLoaded",C,!1),e.ready()}:c.attachEvent&&(C=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",C),e.ready())});return e}(),g="done fail isResolved isRejected promise then always pipe".split(" "),h=[].slice;f.extend({_Deferred:function(){var a=[],b,c,d,e={done:function(){if(!d){var c=arguments,g,h,i,j,k;b&&(k=b,b=0);for(g=0,h=c.length;g<h;g++)i=c[g],j=f.type(i),j==="array"?e.done.apply(e,i):j==="function"&&a.push(i);k&&e.resolveWith(k[0],k[1])}return this},resolveWith:function(e,f){if(!d&&!b&&!c){f=f||[],c=1;try{while(a[0])a.shift().apply(e,f)}finally{b=[e,f],c=0}}return this},resolve:function(){e.resolveWith(this,arguments);return this},isResolved:function(){return!!c||!!b},cancel:function(){d=1,a=[];return this}};return e},Deferred:function(a){var b=f._Deferred(),c=f._Deferred(),d;f.extend(b,{then:function(a,c){b.done(a).fail(c);return this},always:function(){return b.done.apply(b,arguments).fail.apply(this,arguments)},fail:c.done,rejectWith:c.resolveWith,reject:c.resolve,isRejected:c.isResolved,pipe:function(a,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[c,"reject"]},function(a,c){var e=c[0],g=c[1],h;f.isFunction(e)?b[a](function(){h=e.apply(this,arguments),h&&f.isFunction(h.promise)?h.promise().then(d.resolve,d.reject):d[g+"With"](this===b?d:this,[h])}):b[a](d[g])})}).promise()},promise:function(a){if(a==null){if(d)return d;d=a={}}var c=g.length;while(c--)a[g[c]]=b[g[c]];return a}}),b.done(c.cancel).fail(b.cancel),delete b.cancel,a&&a.call(b,b);return b},when:function(a){function i(a){return function(c){b[a]=arguments.length>1?h.call(arguments,0):c,--e||g.resolveWith(g,h.call(b,0))}}var b=arguments,c=0,d=b.length,e=d,g=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred();if(d>1){for(;c<d;c++)b[c]&&f.isFunction(b[c].promise)?b[c].promise().then(i(c),g.reject):--e;e||g.resolveWith(g,b)}else g!==a&&g.resolveWith(g,d?[a]:[]);return g.promise()}}),f.support=function(){var a=c.createElement("div"),b=c.documentElement,d,e,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u;a.setAttribute("className","t"),a.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=a.getElementsByTagName("*"),e=a.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=a.getElementsByTagName("input")[0],k={leadingWhitespace:a.firstChild.nodeType===3,tbody:!a.getElementsByTagName("tbody").length,htmlSerialize:!!a.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55$/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:a.className!=="t",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,k.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,k.optDisabled=!h.disabled;try{delete a.test}catch(v){k.deleteExpando=!1}!a.addEventListener&&a.attachEvent&&a.fireEvent&&(a.attachEvent("onclick",function(){k.noCloneEvent=!1}),a.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),k.radioValue=i.value==="t",i.setAttribute("checked","checked"),a.appendChild(i),l=c.createDocumentFragment(),l.appendChild(a.firstChild),k.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,a.innerHTML="",a.style.width=a.style.paddingLeft="1px",m=c.getElementsByTagName("body")[0],o=c.createElement(m?"div":"body"),p={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},m&&f.extend(p,{position:"absolute",left:"-1000px",top:"-1000px"});for(t in p)o.style[t]=p[t];o.appendChild(a),n=m||b,n.insertBefore(o,n.firstChild),k.appendChecked=i.checked,k.boxModel=a.offsetWidth===2,"zoom"in a.style&&(a.style.display="inline",a.style.zoom=1,k.inlineBlockNeedsLayout=a.offsetWidth===2,a.style.display="",a.innerHTML="<div style='width:4px;'></div>",k.shrinkWrapBlocks=a.offsetWidth!==2),a.innerHTML="<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>",q=a.getElementsByTagName("td"),u=q[0].offsetHeight===0,q[0].style.display="",q[1].style.display="none",k.reliableHiddenOffsets=u&&q[0].offsetHeight===0,a.innerHTML="",c.defaultView&&c.defaultView.getComputedStyle&&(j=c.createElement("div"),j.style.width="0",j.style.marginRight="0",a.appendChild(j),k.reliableMarginRight=(parseInt((c.defaultView.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0),o.innerHTML="",n.removeChild(o);if(a.attachEvent)for(t in{submit:1,change:1,focusin:1})s="on"+t,u=s in a,u||(a.setAttribute(s,"return;"),u=typeof a[s]=="function"),k[t+"Bubbles"]=u;o=l=g=h=m=j=a=i=null;return k}(),f.boxModel=f.support.boxModel;var i=/^(?:\{.*\}|\[.*\])$/,j=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!l(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i=f.expando,j=typeof c=="string",k=a.nodeType,l=k?f.cache:a,m=k?a[f.expando]:a[f.expando]&&f.expando;if((!m||e&&m&&l[m]&&!l[m][i])&&j&&d===b)return;m||(k?a[f.expando]=m=++f.uuid:m=f.expando),l[m]||(l[m]={},k||(l[m].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?l[m][i]=f.extend(l[m][i],c):l[m]=f.extend(l[m],c);g=l[m],e&&(g[i]||(g[i]={}),g=g[i]),d!==b&&(g[f.camelCase(c)]=d);if(c==="events"&&!g[c])return g[i]&&g[i].events;j?(h=g[c],h==null&&(h=g[f.camelCase(c)])):h=g;return h}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e=f.expando,g=a.nodeType,h=g?f.cache:a,i=g?a[f.expando]:f.expando;if(!h[i])return;if(b){d=c?h[i][e]:h[i];if(d){d[b]||(b=f.camelCase(b)),delete d[b];if(!l(d))return}}if(c){delete h[i][e];if(!l(h[i]))return}var j=h[i][e];f.support.deleteExpando||!h.setInterval?delete h[i]:h[i]=null,j?(h[i]={},g||(h[i].toJSON=f.noop),h[i][e]=j):g&&(f.support.deleteExpando?delete a[f.expando]:a.removeAttribute?a.removeAttribute(f.expando):a[f.expando]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d=null;if(typeof a=="undefined"){if(this.length){d=f.data(this[0]);if(this[0].nodeType===1){var e=this[0].attributes,g;for(var h=0,i=e.length;h<i;h++)g=e[h].name,g.indexOf("data-")===0&&(g=f.camelCase(g.substring(5)),k(this[0],g,d[g]))}}return d}if(typeof a=="object")return this.each(function(){f.data(this,a)});var j=a.split(".");j[1]=j[1]?"."+j[1]:"";if(c===b){d=this.triggerHandler("getData"+j[1]+"!",[j[0]]),d===b&&this.length&&(d=f.data(this[0],a),d=k(this[0],a,d));return d===b&&j[1]?this.data(j[0]):d}return this.each(function(){var b=f(this),d=[j[0],c];b.triggerHandler("setData"+j[1]+"!",d),f.data(this,a,c),b.triggerHandler("changeData"+j[1]+"!",d)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,c){a&&(c=(c||"fx")+"mark",f.data(a,c,(f.data(a,c,b,!0)||0)+1,!0))},_unmark:function(a,c,d){a!==!0&&(d=c,c=a,a=!1);if(c){d=d||"fx";var e=d+"mark",g=a?0:(f.data(c,e,b,!0)||1)-1;g?f.data(c,e,g,!0):(f.removeData(c,e,!0),m(c,d,"mark"))}},queue:function(a,c,d){if(a){c=(c||"fx")+"queue";var e=f.data(a,c,b,!0);d&&(!e||f.isArray(d)?e=f.data(a,c,f.makeArray(d),!0):e.push(d));return e||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e;d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),d.call(a,function(){f.dequeue(a,b)})),c.length||(f.removeData(a,b+"queue",!0),m(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){typeof a!="string"&&(c=a,a="fx");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(){var c=this;setTimeout(function(){f.dequeue(c,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f._Deferred(),!0))h++,l.done(m);m();return d.promise()}});var n=/[\n\t\r]/g,o=/\s+/,p=/\r/g,q=/^(?:button|input)$/i,r=/^(?:button|input|object|select|textarea)$/i,s=/^a(?:rea)?$/i,t=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,u,v;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(o);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(o);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(n," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(o);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ";for(var c=0,d=this.length;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(n," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e=this[0];if(!arguments.length){if(e){c=f.valHooks[e.nodeName.toLowerCase()]||f.valHooks[e.type];if(c&&"get"in c&&(d=c.get(e,"value"))!==b)return d;d=e.value;return typeof d=="string"?d.replace(p,""):d==null?"":d}return b}var g=f.isFunction(a);return this.each(function(d){var e=f(this),h;if(this.nodeType===1){g?h=a.call(this,d,e.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c=a.selectedIndex,d=[],e=a.options,g=a.type==="select-one";if(c<0)return null;for(var h=g?c:0,i=g?c+1:e.length;h<i;h++){var j=e[h];if(j.selected&&(f.support.optDisabled?!j.disabled:j.getAttribute("disabled")===null)&&(!j.parentNode.disabled||!f.nodeName(j.parentNode,"optgroup"))){b=f(j).val();if(g)return b;d.push(b)}}if(g&&!d.length&&e.length)return f(e[c]).val();return d},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attrFix:{tabindex:"tabIndex"},attr:function(a,c,d,e){var g=a.nodeType;if(!a||g===3||g===8||g===2)return b;if(e&&c in f.attrFn)return f(a)[c](d);if(!("getAttribute"in a))return f.prop(a,c,d);var h,i,j=g!==1||!f.isXMLDoc(a);j&&(c=f.attrFix[c]||c,i=f.attrHooks[c],i||(t.test(c)?i=v:u&&(i=u)));if(d!==b){if(d===null){f.removeAttr(a,c);return b}if(i&&"set"in i&&j&&(h=i.set(a,d,c))!==b)return h;a.setAttribute(c,""+d);return d}if(i&&"get"in i&&j&&(h=i.get(a,c))!==null)return h;h=a.getAttribute(c);return h===null?b:h},removeAttr:function(a,b){var c;a.nodeType===1&&(b=f.attrFix[b]||b,f.attr(a,b,""),a.removeAttribute(b),t.test(b)&&(c=f.propFix[b]||b)in a&&(a[c]=!1))},attrHooks:{type:{set:function(a,b){if(q.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(u&&f.nodeName(a,"button"))return u.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(u&&f.nodeName(a,"button"))return u.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e=a.nodeType;if(!a||e===3||e===8||e===2)return b;var g,h,i=e!==1||!f.isXMLDoc(a);i&&(c=f.propFix[c]||c,h=f.propHooks[c]);return d!==b?h&&"set"in h&&(g=h.set(a,d,c))!==b?g:a[c]=d:h&&"get"in h&&(g=h.get(a,c))!==null?g:a[c]},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):r.test(a.nodeName)||s.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabIndex=f.propHooks.tabIndex,v={get:function(a,c){var d;return f.prop(a,c)===!0||(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},f.support.getSetAttribute||(u=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&d.nodeValue!==""?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})})),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var w=/\.(.*)$/,x=/^(?:textarea|input|select)$/i,y=/\./g,z=/ /g,A=/[^\w\s.|`]/g,B=function(a){return a.replace(A,"\\$&")};f.event={add:function(a,c,d,e){if(a.nodeType!==3&&a.nodeType!==8){if(d===!1)d=C;else if(!d)return;var g,h;d.handler&&(g=d,d=g.handler),d.guid||(d.guid=f.guid++);var i=f._data(a);if(!i)return;var j=i.events,k=i.handle;j||(i.events=j={}),k||(i.handle=k=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.handle.apply(k.elem,arguments):b}),k.elem=a,c=c.split(" ");var l,m=0,n;while(l=c[m++]){h=g?f.extend({},g):{handler:d,data:e},l.indexOf(".")>-1?(n=l.split("."),l=n.shift(),h.namespace=n.slice(0).sort().join(".")):(n=[],h.namespace=""),h.type=l,h.guid||(h.guid=d.guid);var o=j[l],p=f.event.special[l]||{};if(!o){o=j[l]=[];if(!p.setup||p.setup.call(a,e,n,k)===!1)a.addEventListener?a.addEventListener(l,k,!1):a.attachEvent&&a.attachEvent("on"+l,k)}p.add&&(p.add.call(a,h),h.handler.guid||(h.handler.guid=d.guid)),o.push(h),f.event.global[l]=!0}a=null}},global:{},remove:function(a,c,d,e){if(a.nodeType!==3&&a.nodeType!==8){d===!1&&(d=C);var g,h,i,j,k=0,l,m,n,o,p,q,r,s=f.hasData(a)&&f._data(a),t=s&&s.events;if(!s||!t)return;c&&c.type&&(d=c.handler,c=c.type);if(!c||typeof c=="string"&&c.charAt(0)==="."){c=c||"";for(h in t)f.event.remove(a,h+c);return}c=c.split(" ");while(h=c[k++]){r=h,q=null,l=h.indexOf(".")<0,m=[],l||(m=h.split("."),h=m.shift(),n=new RegExp("(^|\\.)"+f.map(m.slice(0).sort(),B).join("\\.(?:.*\\.)?")+"(\\.|$)")),p=t[h];if(!p)continue;if(!d){for(j=0;j<p.length;j++){q=p[j];if(l||n.test(q.namespace))f.event.remove(a,r,q.handler,j),p.splice(j--,1)}continue}o=f.event.special[h]||{};for(j=e||0;j<p.length;j++){q=p[j];if(d.guid===q.guid){if(l||n.test(q.namespace))e==null&&p.splice(j--,1),o.remove&&o.remove.call(a,q);if(e!=null)break}}if(p.length===0||e!=null&&p.length===1)(!o.teardown||o.teardown.call(a,m)===!1)&&f.removeEvent(a,h,s.handle),g=null,delete 
t[h]}if(f.isEmptyObject(t)){var u=s.handle;u&&(u.elem=null),delete s.events,delete s.handle,f.isEmptyObject(s)&&f.removeData(a,b,!0)}}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){var h=c.type||c,i=[],j;h.indexOf("!")>=0&&(h=h.slice(0,-1),j=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if(!!e&&!f.event.customEvent[h]||!!f.event.global[h]){c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.exclusive=j,c.namespace=i.join("."),c.namespace_re=new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)");if(g||!e)c.preventDefault(),c.stopPropagation();if(!e){f.each(f.cache,function(){var a=f.expando,b=this[a];b&&b.events&&b.events[h]&&f.event.trigger(c,d,b.handle.elem)});return}if(e.nodeType===3||e.nodeType===8)return;c.result=b,c.target=e,d=d!=null?f.makeArray(d):[],d.unshift(c);var k=e,l=h.indexOf(":")<0?"on"+h:"";do{var m=f._data(k,"handle");c.currentTarget=k,m&&m.apply(k,d),l&&f.acceptData(k)&&k[l]&&k[l].apply(k,d)===!1&&(c.result=!1,c.preventDefault()),k=k.parentNode||k.ownerDocument||k===c.target.ownerDocument&&a}while(k&&!c.isPropagationStopped());if(!c.isDefaultPrevented()){var n,o=f.event.special[h]||{};if((!o._default||o._default.call(e.ownerDocument,c)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)){try{l&&e[h]&&(n=e[l],n&&(e[l]=null),f.event.triggered=h,e[h]())}catch(p){}n&&(e[l]=n),f.event.triggered=b}}return c.result}},handle:function(c){c=f.event.fix(c||a.event);var d=((f._data(this,"events")||{})[c.type]||[]).slice(0),e=!c.exclusive&&!c.namespace,g=Array.prototype.slice.call(arguments,0);g[0]=c,c.currentTarget=this;for(var h=0,i=d.length;h<i;h++){var j=d[h];if(e||c.namespace_re.test(j.namespace)){c.handler=j.handler,c.data=j.data,c.handleObj=j;var k=j.handler.apply(this,g);k!==b&&(c.result=k,k===!1&&(c.preventDefault(),c.stopPropagation()));if(c.isImmediatePropagationStopped())break}}return c.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),fix:function(a){if(a[f.expando])return a;var d=a;a=f.Event(d);for(var e=this.props.length,g;e;)g=this.props[--e],a[g]=d[g];a.target||(a.target=a.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),!a.relatedTarget&&a.fromElement&&(a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement);if(a.pageX==null&&a.clientX!=null){var h=a.target.ownerDocument||c,i=h.documentElement,j=h.body;a.pageX=a.clientX+(i&&i.scrollLeft||j&&j.scrollLeft||0)-(i&&i.clientLeft||j&&j.clientLeft||0),a.pageY=a.clientY+(i&&i.scrollTop||j&&j.scrollTop||0)-(i&&i.clientTop||j&&j.clientTop||0)}a.which==null&&(a.charCode!=null||a.keyCode!=null)&&(a.which=a.charCode!=null?a.charCode:a.keyCode),!a.metaKey&&a.ctrlKey&&(a.metaKey=a.ctrlKey),!a.which&&a.button!==b&&(a.which=a.button&1?1:a.button&2?3:a.button&4?2:0);return a},guid:1e8,proxy:f.proxy,special:{ready:{setup:f.bindReady,teardown:f.noop},live:{add:function(a){f.event.add(this,M(a.origType,a.selector),f.extend({},a,{handler:L,guid:a.handler.guid}))},remove:function(a){f.event.remove(this,M(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}}},f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!this.preventDefault)return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?D:C):this.type=a,b&&f.extend(this,b),this.timeStamp=f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=D;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=D;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=D,this.stopPropagation()},isDefaultPrevented:C,isPropagationStopped:C,isImmediatePropagationStopped:C};var E=function(a){var b=a.relatedTarget,c=!1,d=a.type;a.type=a.data,b!==this&&(b&&(c=f.contains(this,b)),c||(f.event.handle.apply(this,arguments),a.type=d))},F=function(a){a.type=a.data,f.event.handle.apply(this,arguments)};f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={setup:function(c){f.event.add(this,b,c&&c.selector?F:E,a)},teardown:function(a){f.event.remove(this,b,a&&a.selector?F:E)}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(a,b){if(!f.nodeName(this,"form"))f.event.add(this,"click.specialSubmit",function(a){var b=a.target,c=f.nodeName(b,"input")||f.nodeName(b,"button")?b.type:"";(c==="submit"||c==="image")&&f(b).closest("form").length&&J("submit",this,arguments)}),f.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,c=f.nodeName(b,"input")||f.nodeName(b,"button")?b.type:"";(c==="text"||c==="password")&&f(b).closest("form").length&&a.keyCode===13&&J("submit",this,arguments)});else return!1},teardown:function(a){f.event.remove(this,".specialSubmit")}});if(!f.support.changeBubbles){var G,H=function(a){var b=f.nodeName(a,"input")?a.type:"",c=a.value;b==="radio"||b==="checkbox"?c=a.checked:b==="select-multiple"?c=a.selectedIndex>-1?f.map(a.options,function(a){return a.selected}).join("-"):"":f.nodeName(a,"select")&&(c=a.selectedIndex);return c},I=function(c){var d=c.target,e,g;if(!!x.test(d.nodeName)&&!d.readOnly){e=f._data(d,"_change_data"),g=H(d),(c.type!=="focusout"||d.type!=="radio")&&f._data(d,"_change_data",g);if(e===b||g===e)return;if(e!=null||g)c.type="change",c.liveFired=b,f.event.trigger(c,arguments[1],d)}};f.event.special.change={filters:{focusout:I,beforedeactivate:I,click:function(a){var b=a.target,c=f.nodeName(b,"input")?b.type:"";(c==="radio"||c==="checkbox"||f.nodeName(b,"select"))&&I.call(this,a)},keydown:function(a){var b=a.target,c=f.nodeName(b,"input")?b.type:"";(a.keyCode===13&&!f.nodeName(b,"textarea")||a.keyCode===32&&(c==="checkbox"||c==="radio")||c==="select-multiple")&&I.call(this,a)},beforeactivate:function(a){var b=a.target;f._data(b,"_change_data",H(b))}},setup:function(a,b){if(this.type==="file")return!1;for(var c in G)f.event.add(this,c+".specialChange",G[c]);return x.test(this.nodeName)},teardown:function(a){f.event.remove(this,".specialChange");return x.test(this.nodeName)}},G=f.event.special.change.filters,G.focus=G.beforeactivate}f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){function e(a){var c=f.event.fix(a);c.type=b,c.originalEvent={},f.event.trigger(c,null,c.target),c.isDefaultPrevented()&&a.preventDefault()}var d=0;f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.each(["bind","one"],function(a,c){f.fn[c]=function(a,d,e){var g;if(typeof a=="object"){for(var h in a)this[c](h,d,a[h],e);return this}if(arguments.length===2||d===!1)e=d,d=b;c==="one"?(g=function(a){f(this).unbind(a,g);return e.apply(this,arguments)},g.guid=e.guid||f.guid++):g=e;if(a==="unload"&&c!=="one")this.one(a,d,e);else for(var i=0,j=this.length;i<j;i++)f.event.add(this[i],a,g,d);return this}}),f.fn.extend({unbind:function(a,b){if(typeof a=="object"&&!a.preventDefault)for(var c in a)this.unbind(c,a[c]);else for(var d=0,e=this.length;d<e;d++)f.event.remove(this[d],a,b);return this},delegate:function(a,b,c,d){return this.live(b,c,d,a)},undelegate:function(a,b,c){return arguments.length===0?this.unbind("live"):this.die(b,null,c,a)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f.data(this,"lastToggle"+a.guid)||0)%d;f.data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var K={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};f.each(["live","die"],function(a,c){f.fn[c]=function(a,d,e,g){var h,i=0,j,k,l,m=g||this.selector,n=g?this:f(this.context);if(typeof a=="object"&&!a.preventDefault){for(var o in a)n[c](o,d,a[o],m);return this}if(c==="die"&&!a&&g&&g.charAt(0)==="."){n.unbind(g);return this}if(d===!1||f.isFunction(d))e=d||C,d=b;a=(a||"").split(" ");while((h=a[i++])!=null){j=w.exec(h),k="",j&&(k=j[0],h=h.replace(w,""));if(h==="hover"){a.push("mouseenter"+k,"mouseleave"+k);continue}l=h,K[h]?(a.push(K[h]+k),h=h+k):h=(K[h]||h)+k;if(c==="live")for(var p=0,q=n.length;p<q;p++)f.event.add(n[p],"live."+M(h,m),{data:d,selector:m,handler:e,origType:h,origHandler:e,preType:l});else n.unbind("live."+M(h,m),e)}return this}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.bind(b,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0)}),function(){function u(a,b,c,d,e,f){for(var g=0,h=d.length;g<h;g++){var i=d[g];if(i){var j=!1;i=i[a];while(i){if(i.sizcache===c){j=d[i.sizset];break}if(i.nodeType===1){f||(i.sizcache=c,i.sizset=g);if(typeof b!="string"){if(i===b){j=!0;break}}else if(k.filter(b,[i]).length>0){j=i;break}}i=i[a]}d[g]=j}}}function t(a,b,c,d,e,f){for(var g=0,h=d.length;g<h;g++){var i=d[g];if(i){var j=!1;i=i[a];while(i){if(i.sizcache===c){j=d[i.sizset];break}i.nodeType===1&&!f&&(i.sizcache=c,i.sizset=g);if(i.nodeName.toLowerCase()===b){j=i;break}i=i[a]}d[g]=j}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d=0,e=Object.prototype.toString,g=!1,h=!0,i=/\\/g,j=/\W/;[0,0].sort(function(){h=!1;return 0});var k=function(b,d,f,g){f=f||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return f;var i,j,n,o,q,r,s,t,u=!0,w=k.isXML(d),x=[],y=b;do{a.exec(""),i=a.exec(y);if(i){y=i[3],x.push(i[1]);if(i[2]){o=i[3];break}}}while(i);if(x.length>1&&m.exec(b))if(x.length===2&&l.relative[x[0]])j=v(x[0]+x[1],d);else{j=l.relative[x[0]]?[d]:k(x.shift(),d);while(x.length)b=x.shift(),l.relative[b]&&(b+=x.shift()),j=v(b,j)}else{!g&&x.length>1&&d.nodeType===9&&!w&&l.match.ID.test(x[0])&&!l.match.ID.test(x[x.length-1])&&(q=k.find(x.shift(),d,w),d=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]);if(d){q=g?{expr:x.pop(),set:p(g)}:k.find(x.pop(),x.length===1&&(x[0]==="~"||x[0]==="+")&&d.parentNode?d.parentNode:d,w),j=q.expr?k.filter(q.expr,q.set):q.set,x.length>0?n=p(j):u=!1;while(x.length)r=x.pop(),s=r,l.relative[r]?s=x.pop():r="",s==null&&(s=d),l.relative[r](n,s,w)}else n=x=[]}n||(n=j),n||k.error(r||b);if(e.call(n)==="[object Array]")if(!u)f.push.apply(f,n);else if(d&&d.nodeType===1)for(t=0;n[t]!=null;t++)n[t]&&(n[t]===!0||n[t].nodeType===1&&k.contains(d,n[t]))&&f.push(j[t]);else for(t=0;n[t]!=null;t++)n[t]&&n[t].nodeType===1&&f.push(j[t]);else p(n,f);o&&(k(o,h,f,g),k.uniqueSort(f));return f};k.uniqueSort=function(a){if(r){g=h,a.sort(r);if(g)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},k.matches=function(a,b){return k(a,null,null,b)},k.matchesSelector=function(a,b){return k(b,null,null,[a]).length>0},k.find=function(a,b,c){var d;if(!a)return[];for(var e=0,f=l.order.length;e<f;e++){var g,h=l.order[e];if(g=l.leftMatch[h].exec(a)){var j=g[1];g.splice(1,1);if(j.substr(j.length-1)!=="\\"){g[1]=(g[1]||"").replace(i,""),d=l.find[h](g,b,c);if(d!=null){a=a.replace(l.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},k.filter=function(a,c,d,e){var f,g,h=a,i=[],j=c,m=c&&c[0]&&k.isXML(c[0]);while(a&&c.length){for(var n in l.filter)if((f=l.leftMatch[n].exec(a))!=null&&f[2]){var o,p,q=l.filter[n],r=f[1];g=!1,f.splice(1,1);if(r.substr(r.length-1)==="\\")continue;j===i&&(i=[]);if(l.preFilter[n]){f=l.preFilter[n](f,j,d,i,e,m);if(!f)g=o=!0;else if(f===!0)continue}if(f)for(var s=0;(p=j[s])!=null;s++)if(p){o=q(p,f,s,j);var t=e^!!o;d&&o!=null?t?g=!0:j[s]=!1:t&&(i.push(p),g=!0)}if(o!==b){d||(j=i),a=a.replace(l.match[n],"");if(!g)return[];break}}if(a===h)if(g==null)k.error(a);else break;h=a}return j},k.error=function(a){throw"Syntax error, unrecognized expression: "+a};var l=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!j.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&k.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!j.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&k.filter(b,a,!0)}},"":function(a,b,c){var e,f=d++,g=u;typeof b=="string"&&!j.test(b)&&(b=b.toLowerCase(),e=b,g=t),g("parentNode",b,f,a,e,c)},"~":function(a,b,c){var e,f=d++,g=u;typeof b=="string"&&!j.test(b)&&(b=b.toLowerCase(),e=b,g=t),g("previousSibling",b,f,a,e,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(i,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(i,"")},TAG:function(a,b){return a[1].replace(i,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||k.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&k.error(a[0]);a[0]=d++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(i,"");!f&&l.attrMap[g]&&(a[1]=l.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(i,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=k(b[3],null,null,c);else{var g=k.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(l.match.POS.test(b[0])||l.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!k(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=l.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||k.getText([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}k.error(e)},CHILD:function(a,b){var c=b[1],d=a;switch(c){case"only":case"first":while(d=d.previousSibling)if(d.nodeType===1)return!1;if(c==="first")return!0;d=a;case"last":while(d=d.nextSibling)if(d.nodeType===1)return!1;return!0;case"nth":var e=b[2],f=b[3];if(e===1&&f===0)return!0;var g=b[0],h=a.parentNode;if(h&&(h.sizcache!==g||!a.nodeIndex)){var i=0;for(d=h.firstChild;d;d=d.nextSibling)d.nodeType===1&&(d.nodeIndex=++i);h.sizcache=g}var j=a.nodeIndex-f;return e===0?j===0:j%e===0&&j/e>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=l.attrHandle[c]?l.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=l.setFilters[e];if(f)return f(a,c,b,d)}}},m=l.match.POS,n=function(a,b){return"\\"+(b-0+1)};for(var o in l.match)l.match[o]=new RegExp(l.match[o].source+/(?![^\[]*\])(?![^\(]*\))/.source),l.leftMatch[o]=new RegExp(/(^(?:.|\r|\n)*?)/.source+l.match[o].source.replace(/\\(\d+)/g,n));var p=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(q){p=function(a,b){var c=0,d=b||[];if(e.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var f=a.length;c<f;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var r,s;c.documentElement.compareDocumentPosition?r=function(a,b){if(a===b){g=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(r=function(a,b){if(a===b){g=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],h=a.parentNode,i=b.parentNode,j=h;if(h===i)return s(a,b);if(!h)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return s(e[k],f[k]);return k===c?s(a,f[k],-1):s(e[k],b,1)},s=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),k.getText=function(a){var b="",c;for(var d=0;a[d];d++)c=a[d],c.nodeType===3||c.nodeType===4?b+=c.nodeValue:c.nodeType!==8&&(b+=k.getText(c.childNodes));return b},function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(l.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},l.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(l.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(l.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=k,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){k=function(b,e,f,g){e=e||c;if(!g&&!k.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return p(e.getElementsByTagName(b),f);if(h[2]&&l.find.CLASS&&e.getElementsByClassName)return p(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return p([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return p([],f);if(i.id===h[3])return p([i],f)}try{return p(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var m=e,n=e.getAttribute("id"),o=n||d,q=e.parentNode,r=/^\s*[+~]/.test(b);n?o=o.replace(/'/g,"\\$&"):e.setAttribute("id",o),r&&q&&(e=e.parentNode);try{if(!r||q)return p(e.querySelectorAll("[id='"+o+"'] "+b),f)}catch(s){}finally{n||m.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)k[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}k.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(a))try{if(e||!l.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return k(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;l.order.splice(1,0,"CLASS"),l.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?k.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?k.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:k.contains=function(){return!1},k.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var v=function(a,b){var c,d=[],e="",f=b.nodeType?[b]:b;while(c=l.match.PSEUDO.exec(a))e+=c[0],a=a.replace(l.match.PSEUDO,"");a=l.relative[a]?a+"*":a;for(var g=0,h=f.length;g<h;g++)k(a,f[g],d);return k.filter(e,d)};f.find=k,f.expr=k.selectors,f.expr[":"]=f.expr.filters,f.unique=k.uniqueSort,f.text=k.getText,f.isXMLDoc=k.isXML,f.contains=k.contains}();var N=/Until$/,O=/^(?:parents|prevUntil|prevAll)/,P=/,/,Q=/^.[^:#\[\.,]*$/,R=Array.prototype.slice,S=f.expr.match.POS,T={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(V(this,a,!1),"not",a)},filter:function(a){return this.pushStack(V(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h,i,j={},k=1;if(g&&a.length){for(d=0,e=a.length;d<e;d++)i=a[d],j[i]||(j[i]=S.test(i)?f(i,b||this.context):i);while(g&&g.ownerDocument&&g!==b){for(i in j)h=j[i],(h.jquery?h.index(g)>-1:f(g).is(h))&&c.push({selector:i,elem:g,level:k});g=g.parentNode,k++}}return c}var l=S.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(l?l.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(U(c[0])||U(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c),g=R.call(arguments);N.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!T[a]?f.unique(e):e,(this.length>1||P.test(d))&&O.test(a)&&(e=e.reverse());return this.pushStack(e,a,g.join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|object|embed|option|style)/i,bb=/checked\s*(?:[^=]|=\s*.checked.)/i,bc=/\/(java|ecma)script/i,bd=/^\s*<!(?:\[CDATA\[|\-\-)/,be={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};be.optgroup=be.option,be.tbody=be.tfoot=be.colgroup=be.caption=be.thead,be.th=be.td,f.support.htmlSerialize||(be._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!="object"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){f(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f(arguments[0]).toArray());return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!be[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName("*")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bb.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bf(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bl)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i;b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof a[0]=="string"&&a[0].length<512&&i===c&&a[0].charAt(0)==="<"&&!ba.test(a[0])&&(f.support.checkClone||!bb.test(a[0]))&&(g=!0,h=f.fragments[a[0]],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean
(a,i,e,d)),g&&(f.fragments[a[0]]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d=a.cloneNode(!0),e,g,h;if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bh(a,d),e=bi(a),g=bi(d);for(h=0;e[h];++h)g[h]&&bh(e[h],g[h])}if(b){bg(a,d);if(c){e=bi(a),g=bi(d);for(h=0;e[h];++h)bg(e[h],g[h])}}e=g=null;return d},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k=="number"&&(k+="");if(!k)continue;if(typeof k=="string")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,"<$1></$2>");var l=(Z.exec(k)||["",""])[1].toLowerCase(),m=be[l]||be._default,n=m[0],o=b.createElement("div");o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l==="table"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]==="<table>"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],"tbody")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)=="number")for(i=0;i<r;i++)bk(k[i]);else bk(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||bc.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],"script")&&(!h[j].type||h[j].type.toLowerCase()==="text/javascript"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName("script"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.expando,g=f.event.special,h=f.support.deleteExpando;for(var i=0,j;(j=a[i])!=null;i++){if(j.nodeName&&f.noData[j.nodeName.toLowerCase()])continue;c=j[f.expando];if(c){b=d[c]&&d[c][e];if(b&&b.events){for(var k in b.events)g[k]?f.event.remove(j,k):f.removeEvent(j,k,b.handle);b.handle&&(b.handle.elem=null)}h?delete j[f.expando]:j.removeAttribute&&j.removeAttribute(f.expando),delete d[c]}}}});var bm=/alpha\([^)]*\)/i,bn=/opacity=([^)]*)/,bo=/([A-Z]|^ms)/g,bp=/^-?\d+(?:px)?$/i,bq=/^-?\d/,br=/^([\-+])=([\-+.\de]+)/,bs={position:"absolute",visibility:"hidden",display:"block"},bt=["Left","Right"],bu=["Top","Bottom"],bv,bw,bx;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bv(a,"opacity","opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=br.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(bv)return bv(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return by(a,b,d);f.swap(a,bs,function(){e=by(a,b,d)});return e}},set:function(a,b){if(!bp.test(b))return b;b=parseFloat(b);if(b>=0)return b+"px"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return bn.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNaN(b)?"":"alpha(opacity="+b*100+")",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bm,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bm.test(g)?g.replace(bm,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:"inline-block"},function(){b?c=bv(a,"margin-right","marginRight"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bw=function(a,c){var d,e,g;c=c.replace(bo,"-$1").toLowerCase();if(!(e=a.ownerDocument.defaultView))return b;if(g=e.getComputedStyle(a,null))d=g.getPropertyValue(c),d===""&&!f.contains(a.ownerDocument.documentElement,a)&&(d=f.style(a,c));return d}),c.documentElement.currentStyle&&(bx=function(a,b){var c,d=a.currentStyle&&a.currentStyle[b],e=a.runtimeStyle&&a.runtimeStyle[b],f=a.style;!bp.test(d)&&bq.test(d)&&(c=f.left,e&&(a.runtimeStyle.left=a.currentStyle.left),f.left=b==="fontSize"?"1em":d||0,d=f.pixelLeft+"px",f.left=c,e&&(a.runtimeStyle.left=e));return d===""?"auto":d}),bv=bw||bx,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bz=/%20/g,bA=/\[\]$/,bB=/\r?\n/g,bC=/#.*$/,bD=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bE=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bF=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bG=/^(?:GET|HEAD)$/,bH=/^\/\//,bI=/\?/,bJ=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bK=/^(?:select|textarea)/i,bL=/\s+/,bM=/([?&])_=[^&]*/,bN=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bO=f.fn.load,bP={},bQ={},bR,bS,bT=["*/"]+["*"];try{bR=e.href}catch(bU){bR=c.createElement("a"),bR.href="",bR=bR.href}bS=bN.exec(bR.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bO)return bO.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bJ,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bK.test(this.nodeName)||bE.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bB,"\r\n")}}):{name:b.name,value:c.replace(bB,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.bind(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?bX(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),bX(a,b);return a},ajaxSettings:{url:bR,isLocal:bF.test(bS[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bT},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bV(bP),ajaxTransport:bV(bQ),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?bZ(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=b$(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.resolveWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f._Deferred(),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bD.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.done,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bC,"").replace(bH,bS[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bL),d.crossDomain==null&&(r=bN.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bS[1]&&r[2]==bS[2]&&(r[3]||(r[1]==="http:"?80:443))==(bS[3]||(bS[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),bW(bP,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bG.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bI.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bM,"$1_="+x);d.url=y+(y===d.url?(bI.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bT+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=bW(bQ,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){s<2?w(-1,z):f.error(z)}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)bY(g,a[g],c,e);return d.join("&").replace(bz,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var b_=f.now(),ca=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+b_++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=b.contentType==="application/x-www-form-urlencoded"&&typeof b.data=="string";if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(ca.test(b.url)||e&&ca.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(ca,l),b.url===j&&(e&&(k=k.replace(ca,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cb=a.ActiveXObject?function(){for(var a in cd)cd[a](0,1)}:!1,cc=0,cd;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ce()||cf()}:ce,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cb&&delete cd[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cc,cb&&(cd||(cd={},f(a).unload(cb)),cd[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var cg={},ch,ci,cj=/^(?:toggle|show|hide)$/,ck=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,cl,cm=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cn;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cq("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),e===""&&f.css(d,"display")==="none"&&f._data(d,"olddisplay",cr(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cq("hide",3),a,b,c);for(var d=0,e=this.length;d<e;d++)if(this[d].style){var g=f.css(this[d],"display");g!=="none"&&!f._data(this[d],"olddisplay")&&f._data(this[d],"olddisplay",g)}for(d=0;d<e;d++)this[d].style&&(this[d].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(cq("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return this[e.queue===!1?"each":"queue"](function(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(f.support.inlineBlockNeedsLayout?(j=cr(this.nodeName),j==="inline"?this.style.display="inline-block":(this.style.display="inline",this.style.zoom=1)):this.style.display="inline-block"))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)k=new f.fx(this,b,i),h=a[i],cj.test(h)?k[h==="toggle"?d?"show":"hide":h]():(l=ck.exec(h),m=k.cur(),l?(n=parseFloat(l[2]),o=l[3]||(f.cssNumber[i]?"":"px"),o!=="px"&&(f.style(this,i,(n||1)+o),m=(n||1)/k.cur()*m,f.style(this,i,m+o)),l[1]&&(n=(l[1]==="-="?-1:1)*n+m),k.custom(m,n,o)):k.custom(m,h,""));return!0})},stop:function(a,b){a&&this.queue([]),this.each(function(){var a=f.timers,c=a.length;b||f._unmark(!0,this);while(c--)a[c].elem===this&&(b&&a[c](!0),a.splice(c,1))}),b||this.dequeue();return this}}),f.each({slideDown:cq("show",1),slideUp:cq("hide",1),slideToggle:cq("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default,d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue!==!1?f.dequeue(this):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,b,c){function g(a){return d.step(a)}var d=this,e=f.fx;this.startTime=cn||co(),this.start=a,this.end=b,this.unit=c||this.unit||(f.cssNumber[this.prop]?"":"px"),this.now=this.start,this.pos=this.state=0,g.elem=this.elem,g()&&f.timers.push(g)&&!cl&&(cl=setInterval(e.tick,e.interval))},show:function(){this.options.orig[this.prop]=f.style(this.elem,this.prop),this.options.show=!0,this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b=cn||co(),c=!0,d=this.elem,e=this.options,g,h;if(a||b>=e.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),e.animatedProperties[this.prop]=!0;for(g in e.animatedProperties)e.animatedProperties[g]!==!0&&(c=!1);if(c){e.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){d.style["overflow"+b]=e.overflow[a]}),e.hide&&f(d).hide();if(e.hide||e.show)for(var i in e.animatedProperties)f.style(d,i,e.orig[i]);e.complete.call(d)}return!1}e.duration==Infinity?this.now=b:(h=b-this.startTime,this.state=h/e.duration,this.pos=f.easing[e.animatedProperties[this.prop]](this.state,h,0,1,e.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){for(var a=f.timers,b=0;b<a.length;++b)a[b]()||a.splice(b--,1);a.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cl),cl=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit:a.elem[a.prop]=a.now}}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cs=/^t(?:able|d|h)$/i,ct=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cu(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);f.offset.initialize();var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.offset.supportsFixedPosition&&k.position==="fixed")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.offset.doesNotAddBorder&&(!f.offset.doesAddBorderForTableAndCells||!cs.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.offset.subtractsBorderForOverflowNotVisible&&c.overflow!=="visible"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position==="relative"||k.position==="static")l+=i.offsetTop,m+=i.offsetLeft;f.offset.supportsFixedPosition&&k.position==="fixed"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={initialize:function(){var a=c.body,b=c.createElement("div"),d,e,g,h,i=parseFloat(f.css(a,"marginTop"))||0,j="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";f.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"}),b.innerHTML=j,a.insertBefore(b,a.firstChild),d=b.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,this.doesNotAddBorder=e.offsetTop!==5,this.doesAddBorderForTableAndCells=h.offsetTop===5,e.style.position="fixed",e.style.top="20px",this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top="",d.style.overflow="hidden",d.style.position="relative",this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==i,a.removeChild(b),f.offset.initialize=f.noop},bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.offset.initialize(),f.offset.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=ct.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!ct.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each(["Left","Top"],function(a,c){var d="scroll"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cu(e);return g?"pageXOffset"in g?g[a?"pageYOffset":"pageXOffset"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cu(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each(["Height","Width"],function(a,c){var d=c.toLowerCase();f.fn["inner"+c]=function(){var a=this[0];return a&&a.style?parseFloat(f.css(a,d,"padding")):null},f.fn["outer"+c]=function(a){var b=this[0];return b&&b.style?parseFloat(f.css(b,d,a?"margin":"border")):null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement["client"+c],h=e.document.body;return e.document.compatMode==="CSS1Compat"&&g||h&&h["client"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement["client"+c],e.body["scroll"+c],e.documentElement["scroll"+c],e.body["offset"+c],e.documentElement["offset"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNaN(j)?i:j}return this.css(d,typeof a=="string"?a:a+"px")}}),a.jQuery=a.$=f})(window);


/*!
 * jQuery UI 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function(c,j){function k(a,b){var d=a.nodeName.toLowerCase();if("area"===d){b=a.parentNode;d=b.name;if(!a.href||!d||b.nodeName.toLowerCase()!=="map")return false;a=c("img[usemap=#"+d+"]")[0];return!!a&&l(a)}return(/input|select|textarea|button|object/.test(d)?!a.disabled:"a"==d?a.href||b:b)&&l(a)}function l(a){return!c(a).parents().andSelf().filter(function(){return c.curCSS(this,"visibility")==="hidden"||c.expr.filters.hidden(this)}).length}c.ui=c.ui||{};if(!c.ui.version){c.extend(c.ui,{version:"1.8.15",
keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}});c.fn.extend({propAttr:c.fn.prop||c.fn.attr,_focus:c.fn.focus,focus:function(a,b){return typeof a==="number"?this.each(function(){var d=
this;setTimeout(function(){c(d).focus();b&&b.call(d)},a)}):this._focus.apply(this,arguments)},scrollParent:function(){var a;a=c.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(c.curCSS(this,"position",1))&&/(auto|scroll)/.test(c.curCSS(this,"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(c.curCSS(this,
"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0);return/fixed/.test(this.css("position"))||!a.length?c(document):a},zIndex:function(a){if(a!==j)return this.css("zIndex",a);if(this.length){a=c(this[0]);for(var b;a.length&&a[0]!==document;){b=a.css("position");if(b==="absolute"||b==="relative"||b==="fixed"){b=parseInt(a.css("zIndex"),10);if(!isNaN(b)&&b!==0)return b}a=a.parent()}}return 0},disableSelection:function(){return this.bind((c.support.selectstart?"selectstart":
"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}});c.each(["Width","Height"],function(a,b){function d(f,g,m,n){c.each(e,function(){g-=parseFloat(c.curCSS(f,"padding"+this,true))||0;if(m)g-=parseFloat(c.curCSS(f,"border"+this+"Width",true))||0;if(n)g-=parseFloat(c.curCSS(f,"margin"+this,true))||0});return g}var e=b==="Width"?["Left","Right"]:["Top","Bottom"],h=b.toLowerCase(),i={innerWidth:c.fn.innerWidth,innerHeight:c.fn.innerHeight,
outerWidth:c.fn.outerWidth,outerHeight:c.fn.outerHeight};c.fn["inner"+b]=function(f){if(f===j)return i["inner"+b].call(this);return this.each(function(){c(this).css(h,d(this,f)+"px")})};c.fn["outer"+b]=function(f,g){if(typeof f!=="number")return i["outer"+b].call(this,f);return this.each(function(){c(this).css(h,d(this,f,true,g)+"px")})}});c.extend(c.expr[":"],{data:function(a,b,d){return!!c.data(a,d[3])},focusable:function(a){return k(a,!isNaN(c.attr(a,"tabindex")))},tabbable:function(a){var b=c.attr(a,
"tabindex"),d=isNaN(b);return(d||b>=0)&&k(a,!d)}});c(function(){var a=document.body,b=a.appendChild(b=document.createElement("div"));c.extend(b.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0});c.support.minHeight=b.offsetHeight===100;c.support.selectstart="onselectstart"in b;a.removeChild(b).style.display="none"});c.extend(c.ui,{plugin:{add:function(a,b,d){a=c.ui[a].prototype;for(var e in d){a.plugins[e]=a.plugins[e]||[];a.plugins[e].push([b,d[e]])}},call:function(a,b,d){if((b=a.plugins[b])&&
a.element[0].parentNode)for(var e=0;e<b.length;e++)a.options[b[e][0]]&&b[e][1].apply(a.element,d)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(a,b){if(c(a).css("overflow")==="hidden")return false;b=b&&b==="left"?"scrollLeft":"scrollTop";var d=false;if(a[b]>0)return true;a[b]=1;d=a[b]>0;a[b]=0;return d},isOverAxis:function(a,b,d){return a>b&&a<b+d},isOver:function(a,b,d,e,h,i){return c.ui.isOverAxis(a,d,h)&&
c.ui.isOverAxis(b,e,i)}})}})(jQuery);
;/*!
 * jQuery UI Widget 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function(b,j){if(b.cleanData){var k=b.cleanData;b.cleanData=function(a){for(var c=0,d;(d=a[c])!=null;c++)b(d).triggerHandler("remove");k(a)}}else{var l=b.fn.remove;b.fn.remove=function(a,c){return this.each(function(){if(!c)if(!a||b.filter(a,[this]).length)b("*",this).add([this]).each(function(){b(this).triggerHandler("remove")});return l.call(b(this),a,c)})}}b.widget=function(a,c,d){var e=a.split(".")[0],f;a=a.split(".")[1];f=e+"-"+a;if(!d){d=c;c=b.Widget}b.expr[":"][f]=function(h){return!!b.data(h,
a)};b[e]=b[e]||{};b[e][a]=function(h,g){arguments.length&&this._createWidget(h,g)};c=new c;c.options=b.extend(true,{},c.options);b[e][a].prototype=b.extend(true,c,{namespace:e,widgetName:a,widgetEventPrefix:b[e][a].prototype.widgetEventPrefix||a,widgetBaseClass:f},d);b.widget.bridge(a,b[e][a])};b.widget.bridge=function(a,c){b.fn[a]=function(d){var e=typeof d==="string",f=Array.prototype.slice.call(arguments,1),h=this;d=!e&&f.length?b.extend.apply(null,[true,d].concat(f)):d;if(e&&d.charAt(0)==="_")return h;
e?this.each(function(){var g=b.data(this,a),i=g&&b.isFunction(g[d])?g[d].apply(g,f):g;if(i!==g&&i!==j){h=i;return false}}):this.each(function(){var g=b.data(this,a);g?g.option(d||{})._init():b.data(this,a,new c(d,this))});return h}};b.Widget=function(a,c){arguments.length&&this._createWidget(a,c)};b.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:false},_createWidget:function(a,c){b.data(c,this.widgetName,this);this.element=b(c);this.options=b.extend(true,{},this.options,
this._getCreateOptions(),a);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()});this._create();this._trigger("create");this._init()},_getCreateOptions:function(){return b.metadata&&b.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName);this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled ui-state-disabled")},
widget:function(){return this.element},option:function(a,c){var d=a;if(arguments.length===0)return b.extend({},this.options);if(typeof a==="string"){if(c===j)return this.options[a];d={};d[a]=c}this._setOptions(d);return this},_setOptions:function(a){var c=this;b.each(a,function(d,e){c._setOption(d,e)});return this},_setOption:function(a,c){this.options[a]=c;if(a==="disabled")this.widget()[c?"addClass":"removeClass"](this.widgetBaseClass+"-disabled ui-state-disabled").attr("aria-disabled",c);return this},
enable:function(){return this._setOption("disabled",false)},disable:function(){return this._setOption("disabled",true)},_trigger:function(a,c,d){var e=this.options[a];c=b.Event(c);c.type=(a===this.widgetEventPrefix?a:this.widgetEventPrefix+a).toLowerCase();d=d||{};if(c.originalEvent){a=b.event.props.length;for(var f;a;){f=b.event.props[--a];c[f]=c.originalEvent[f]}}this.element.trigger(c,d);return!(b.isFunction(e)&&e.call(this.element[0],c,d)===false||c.isDefaultPrevented())}}})(jQuery);
;/*!
 * jQuery UI Mouse 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function(b){b.widget("ui.mouse",{options:{cancel:":input,option",distance:1,delay:0},_mouseInit:function(){var a=this;this.element.bind("mousedown."+this.widgetName,function(c){return a._mouseDown(c)}).bind("click."+this.widgetName,function(c){if(true===b.data(c.target,a.widgetName+".preventClickEvent")){b.removeData(c.target,a.widgetName+".preventClickEvent");c.stopImmediatePropagation();return false}});this.started=false},_mouseDestroy:function(){this.element.unbind("."+this.widgetName)},_mouseDown:function(a){a.originalEvent=
a.originalEvent||{};if(!a.originalEvent.mouseHandled){this._mouseStarted&&this._mouseUp(a);this._mouseDownEvent=a;var c=this,e=a.which==1,f=typeof this.options.cancel=="string"?b(a.target).closest(this.options.cancel).length:false;if(!e||f||!this._mouseCapture(a))return true;this.mouseDelayMet=!this.options.delay;if(!this.mouseDelayMet)this._mouseDelayTimer=setTimeout(function(){c.mouseDelayMet=true},this.options.delay);if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a)){this._mouseStarted=this._mouseStart(a)!==
false;if(!this._mouseStarted){a.preventDefault();return true}}true===b.data(a.target,this.widgetName+".preventClickEvent")&&b.removeData(a.target,this.widgetName+".preventClickEvent");this._mouseMoveDelegate=function(d){return c._mouseMove(d)};this._mouseUpDelegate=function(d){return c._mouseUp(d)};b(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate);a.preventDefault();return a.originalEvent.mouseHandled=true}},_mouseMove:function(a){if(b.browser.msie&&
!(document.documentMode>=9)&&!a.button)return this._mouseUp(a);if(this._mouseStarted){this._mouseDrag(a);return a.preventDefault()}if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a))(this._mouseStarted=this._mouseStart(this._mouseDownEvent,a)!==false)?this._mouseDrag(a):this._mouseUp(a);return!this._mouseStarted},_mouseUp:function(a){b(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate);if(this._mouseStarted){this._mouseStarted=
false;a.target==this._mouseDownEvent.target&&b.data(a.target,this.widgetName+".preventClickEvent",true);this._mouseStop(a)}return false},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return true}})})(jQuery);
;/*
 * jQuery UI Position 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function(c){c.ui=c.ui||{};var n=/left|center|right/,o=/top|center|bottom/,t=c.fn.position,u=c.fn.offset;c.fn.position=function(b){if(!b||!b.of)return t.apply(this,arguments);b=c.extend({},b);var a=c(b.of),d=a[0],g=(b.collision||"flip").split(" "),e=b.offset?b.offset.split(" "):[0,0],h,k,j;if(d.nodeType===9){h=a.width();k=a.height();j={top:0,left:0}}else if(d.setTimeout){h=a.width();k=a.height();j={top:a.scrollTop(),left:a.scrollLeft()}}else if(d.preventDefault){b.at="left top";h=k=0;j={top:b.of.pageY,
left:b.of.pageX}}else{h=a.outerWidth();k=a.outerHeight();j=a.offset()}c.each(["my","at"],function(){var f=(b[this]||"").split(" ");if(f.length===1)f=n.test(f[0])?f.concat(["center"]):o.test(f[0])?["center"].concat(f):["center","center"];f[0]=n.test(f[0])?f[0]:"center";f[1]=o.test(f[1])?f[1]:"center";b[this]=f});if(g.length===1)g[1]=g[0];e[0]=parseInt(e[0],10)||0;if(e.length===1)e[1]=e[0];e[1]=parseInt(e[1],10)||0;if(b.at[0]==="right")j.left+=h;else if(b.at[0]==="center")j.left+=h/2;if(b.at[1]==="bottom")j.top+=
k;else if(b.at[1]==="center")j.top+=k/2;j.left+=e[0];j.top+=e[1];return this.each(function(){var f=c(this),l=f.outerWidth(),m=f.outerHeight(),p=parseInt(c.curCSS(this,"marginLeft",true))||0,q=parseInt(c.curCSS(this,"marginTop",true))||0,v=l+p+(parseInt(c.curCSS(this,"marginRight",true))||0),w=m+q+(parseInt(c.curCSS(this,"marginBottom",true))||0),i=c.extend({},j),r;if(b.my[0]==="right")i.left-=l;else if(b.my[0]==="center")i.left-=l/2;if(b.my[1]==="bottom")i.top-=m;else if(b.my[1]==="center")i.top-=
m/2;i.left=Math.round(i.left);i.top=Math.round(i.top);r={left:i.left-p,top:i.top-q};c.each(["left","top"],function(s,x){c.ui.position[g[s]]&&c.ui.position[g[s]][x](i,{targetWidth:h,targetHeight:k,elemWidth:l,elemHeight:m,collisionPosition:r,collisionWidth:v,collisionHeight:w,offset:e,my:b.my,at:b.at})});c.fn.bgiframe&&f.bgiframe();f.offset(c.extend(i,{using:b.using}))})};c.ui.position={fit:{left:function(b,a){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();b.left=
d>0?b.left-d:Math.max(b.left-a.collisionPosition.left,b.left)},top:function(b,a){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();b.top=d>0?b.top-d:Math.max(b.top-a.collisionPosition.top,b.top)}},flip:{left:function(b,a){if(a.at[0]!=="center"){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();var g=a.my[0]==="left"?-a.elemWidth:a.my[0]==="right"?a.elemWidth:0,e=a.at[0]==="left"?a.targetWidth:-a.targetWidth,h=-2*a.offset[0];b.left+=
a.collisionPosition.left<0?g+e+h:d>0?g+e+h:0}},top:function(b,a){if(a.at[1]!=="center"){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();var g=a.my[1]==="top"?-a.elemHeight:a.my[1]==="bottom"?a.elemHeight:0,e=a.at[1]==="top"?a.targetHeight:-a.targetHeight,h=-2*a.offset[1];b.top+=a.collisionPosition.top<0?g+e+h:d>0?g+e+h:0}}}};if(!c.offset.setOffset){c.offset.setOffset=function(b,a){if(/static/.test(c.curCSS(b,"position")))b.style.position="relative";var d=c(b),
g=d.offset(),e=parseInt(c.curCSS(b,"top",true),10)||0,h=parseInt(c.curCSS(b,"left",true),10)||0;g={top:a.top-g.top+e,left:a.left-g.left+h};"using"in a?a.using.call(b,g):d.css(g)};c.fn.offset=function(b){var a=this[0];if(!a||!a.ownerDocument)return null;if(b)return this.each(function(){c.offset.setOffset(this,b)});return u.call(this)}}})(jQuery);
;/*
 * jQuery UI Draggable 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.draggable",d.ui.mouse,{widgetEventPrefix:"drag",options:{addClasses:true,appendTo:"parent",axis:false,connectToSortable:false,containment:false,cursor:"auto",cursorAt:false,grid:false,handle:false,helper:"original",iframeFix:false,opacity:false,refreshPositions:false,revert:false,revertDuration:500,scope:"default",scroll:true,scrollSensitivity:20,scrollSpeed:20,snap:false,snapMode:"both",snapTolerance:20,stack:false,zIndex:false},_create:function(){if(this.options.helper==
"original"&&!/^(?:r|a|f)/.test(this.element.css("position")))this.element[0].style.position="relative";this.options.addClasses&&this.element.addClass("ui-draggable");this.options.disabled&&this.element.addClass("ui-draggable-disabled");this._mouseInit()},destroy:function(){if(this.element.data("draggable")){this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");this._mouseDestroy();return this}},_mouseCapture:function(a){var b=
this.options;if(this.helper||b.disabled||d(a.target).is(".ui-resizable-handle"))return false;this.handle=this._getHandle(a);if(!this.handle)return false;d(b.iframeFix===true?"iframe":b.iframeFix).each(function(){d('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1E3}).css(d(this).offset()).appendTo("body")});return true},_mouseStart:function(a){var b=this.options;this.helper=
this._createHelper(a);this._cacheHelperProportions();if(d.ui.ddmanager)d.ui.ddmanager.current=this;this._cacheMargins();this.cssPosition=this.helper.css("position");this.scrollParent=this.helper.scrollParent();this.offset=this.positionAbs=this.element.offset();this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left};d.extend(this.offset,{click:{left:a.pageX-this.offset.left,top:a.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()});
this.originalPosition=this.position=this._generatePosition(a);this.originalPageX=a.pageX;this.originalPageY=a.pageY;b.cursorAt&&this._adjustOffsetFromHelper(b.cursorAt);b.containment&&this._setContainment();if(this._trigger("start",a)===false){this._clear();return false}this._cacheHelperProportions();d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a);this.helper.addClass("ui-draggable-dragging");this._mouseDrag(a,true);d.ui.ddmanager&&d.ui.ddmanager.dragStart(this,a);return true},
_mouseDrag:function(a,b){this.position=this._generatePosition(a);this.positionAbs=this._convertPositionTo("absolute");if(!b){b=this._uiHash();if(this._trigger("drag",a,b)===false){this._mouseUp({});return false}this.position=b.position}if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";d.ui.ddmanager&&d.ui.ddmanager.drag(this,a);return false},_mouseStop:function(a){var b=
false;if(d.ui.ddmanager&&!this.options.dropBehaviour)b=d.ui.ddmanager.drop(this,a);if(this.dropped){b=this.dropped;this.dropped=false}if((!this.element[0]||!this.element[0].parentNode)&&this.options.helper=="original")return false;if(this.options.revert=="invalid"&&!b||this.options.revert=="valid"&&b||this.options.revert===true||d.isFunction(this.options.revert)&&this.options.revert.call(this.element,b)){var c=this;d(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,
10),function(){c._trigger("stop",a)!==false&&c._clear()})}else this._trigger("stop",a)!==false&&this._clear();return false},_mouseUp:function(a){this.options.iframeFix===true&&d("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)});d.ui.ddmanager&&d.ui.ddmanager.dragStop(this,a);return d.ui.mouse.prototype._mouseUp.call(this,a)},cancel:function(){this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear();return this},_getHandle:function(a){var b=!this.options.handle||
!d(this.options.handle,this.element).length?true:false;d(this.options.handle,this.element).find("*").andSelf().each(function(){if(this==a.target)b=true});return b},_createHelper:function(a){var b=this.options;a=d.isFunction(b.helper)?d(b.helper.apply(this.element[0],[a])):b.helper=="clone"?this.element.clone().removeAttr("id"):this.element;a.parents("body").length||a.appendTo(b.appendTo=="parent"?this.element[0].parentNode:b.appendTo);a[0]!=this.element[0]&&!/(fixed|absolute)/.test(a.css("position"))&&
a.css("position","absolute");return a},_adjustOffsetFromHelper:function(a){if(typeof a=="string")a=a.split(" ");if(d.isArray(a))a={left:+a[0],top:+a[1]||0};if("left"in a)this.offset.click.left=a.left+this.margins.left;if("right"in a)this.offset.click.left=this.helperProportions.width-a.right+this.margins.left;if("top"in a)this.offset.click.top=a.top+this.margins.top;if("bottom"in a)this.offset.click.top=this.helperProportions.height-a.bottom+this.margins.top},_getParentOffset:function(){this.offsetParent=
this.helper.offsetParent();var a=this.offsetParent.offset();if(this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0])){a.left+=this.scrollParent.scrollLeft();a.top+=this.scrollParent.scrollTop()}if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&d.browser.msie)a={top:0,left:0};return{top:a.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:a.left+(parseInt(this.offsetParent.css("borderLeftWidth"),
10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.element.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}else return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),
10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var a=this.options;if(a.containment=="parent")a.containment=this.helper[0].parentNode;if(a.containment=="document"||a.containment=="window")this.containment=[a.containment=="document"?0:d(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,a.containment=="document"?0:d(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,
(a.containment=="document"?0:d(window).scrollLeft())+d(a.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(a.containment=="document"?0:d(window).scrollTop())+(d(a.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(a.containment)&&a.containment.constructor!=Array){a=d(a.containment);var b=a[0];if(b){a.offset();var c=d(b).css("overflow")!=
"hidden";this.containment=[(parseInt(d(b).css("borderLeftWidth"),10)||0)+(parseInt(d(b).css("paddingLeft"),10)||0),(parseInt(d(b).css("borderTopWidth"),10)||0)+(parseInt(d(b).css("paddingTop"),10)||0),(c?Math.max(b.scrollWidth,b.offsetWidth):b.offsetWidth)-(parseInt(d(b).css("borderLeftWidth"),10)||0)-(parseInt(d(b).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(c?Math.max(b.scrollHeight,b.offsetHeight):b.offsetHeight)-(parseInt(d(b).css("borderTopWidth"),
10)||0)-(parseInt(d(b).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom];this.relative_container=a}}else if(a.containment.constructor==Array)this.containment=a.containment},_convertPositionTo:function(a,b){if(!b)b=this.position;a=a=="absolute"?1:-1;var c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,f=/(html|body)/i.test(c[0].tagName);return{top:b.top+
this.offset.relative.top*a+this.offset.parent.top*a-(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():f?0:c.scrollTop())*a),left:b.left+this.offset.relative.left*a+this.offset.parent.left*a-(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():f?0:c.scrollLeft())*a)}},_generatePosition:function(a){var b=this.options,c=this.cssPosition=="absolute"&&
!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,f=/(html|body)/i.test(c[0].tagName),e=a.pageX,h=a.pageY;if(this.originalPosition){var g;if(this.containment){if(this.relative_container){g=this.relative_container.offset();g=[this.containment[0]+g.left,this.containment[1]+g.top,this.containment[2]+g.left,this.containment[3]+g.top]}else g=this.containment;if(a.pageX-this.offset.click.left<g[0])e=g[0]+this.offset.click.left;
if(a.pageY-this.offset.click.top<g[1])h=g[1]+this.offset.click.top;if(a.pageX-this.offset.click.left>g[2])e=g[2]+this.offset.click.left;if(a.pageY-this.offset.click.top>g[3])h=g[3]+this.offset.click.top}if(b.grid){h=b.grid[1]?this.originalPageY+Math.round((h-this.originalPageY)/b.grid[1])*b.grid[1]:this.originalPageY;h=g?!(h-this.offset.click.top<g[1]||h-this.offset.click.top>g[3])?h:!(h-this.offset.click.top<g[1])?h-b.grid[1]:h+b.grid[1]:h;e=b.grid[0]?this.originalPageX+Math.round((e-this.originalPageX)/
b.grid[0])*b.grid[0]:this.originalPageX;e=g?!(e-this.offset.click.left<g[0]||e-this.offset.click.left>g[2])?e:!(e-this.offset.click.left<g[0])?e-b.grid[0]:e+b.grid[0]:e}}return{top:h-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():f?0:c.scrollTop()),left:e-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(d.browser.safari&&d.browser.version<
526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():f?0:c.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging");this.helper[0]!=this.element[0]&&!this.cancelHelperRemoval&&this.helper.remove();this.helper=null;this.cancelHelperRemoval=false},_trigger:function(a,b,c){c=c||this._uiHash();d.ui.plugin.call(this,a,[b,c]);if(a=="drag")this.positionAbs=this._convertPositionTo("absolute");return d.Widget.prototype._trigger.call(this,a,b,
c)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}});d.extend(d.ui.draggable,{version:"1.8.15"});d.ui.plugin.add("draggable","connectToSortable",{start:function(a,b){var c=d(this).data("draggable"),f=c.options,e=d.extend({},b,{item:c.element});c.sortables=[];d(f.connectToSortable).each(function(){var h=d.data(this,"sortable");if(h&&!h.options.disabled){c.sortables.push({instance:h,shouldRevert:h.options.revert});
h.refreshPositions();h._trigger("activate",a,e)}})},stop:function(a,b){var c=d(this).data("draggable"),f=d.extend({},b,{item:c.element});d.each(c.sortables,function(){if(this.instance.isOver){this.instance.isOver=0;c.cancelHelperRemoval=true;this.instance.cancelHelperRemoval=false;if(this.shouldRevert)this.instance.options.revert=true;this.instance._mouseStop(a);this.instance.options.helper=this.instance.options._helper;c.options.helper=="original"&&this.instance.currentItem.css({top:"auto",left:"auto"})}else{this.instance.cancelHelperRemoval=
false;this.instance._trigger("deactivate",a,f)}})},drag:function(a,b){var c=d(this).data("draggable"),f=this;d.each(c.sortables,function(){this.instance.positionAbs=c.positionAbs;this.instance.helperProportions=c.helperProportions;this.instance.offset.click=c.offset.click;if(this.instance._intersectsWith(this.instance.containerCache)){if(!this.instance.isOver){this.instance.isOver=1;this.instance.currentItem=d(f).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item",true);
this.instance.options._helper=this.instance.options.helper;this.instance.options.helper=function(){return b.helper[0]};a.target=this.instance.currentItem[0];this.instance._mouseCapture(a,true);this.instance._mouseStart(a,true,true);this.instance.offset.click.top=c.offset.click.top;this.instance.offset.click.left=c.offset.click.left;this.instance.offset.parent.left-=c.offset.parent.left-this.instance.offset.parent.left;this.instance.offset.parent.top-=c.offset.parent.top-this.instance.offset.parent.top;
c._trigger("toSortable",a);c.dropped=this.instance.element;c.currentItem=c.element;this.instance.fromOutside=c}this.instance.currentItem&&this.instance._mouseDrag(a)}else if(this.instance.isOver){this.instance.isOver=0;this.instance.cancelHelperRemoval=true;this.instance.options.revert=false;this.instance._trigger("out",a,this.instance._uiHash(this.instance));this.instance._mouseStop(a,true);this.instance.options.helper=this.instance.options._helper;this.instance.currentItem.remove();this.instance.placeholder&&
this.instance.placeholder.remove();c._trigger("fromSortable",a);c.dropped=false}})}});d.ui.plugin.add("draggable","cursor",{start:function(){var a=d("body"),b=d(this).data("draggable").options;if(a.css("cursor"))b._cursor=a.css("cursor");a.css("cursor",b.cursor)},stop:function(){var a=d(this).data("draggable").options;a._cursor&&d("body").css("cursor",a._cursor)}});d.ui.plugin.add("draggable","opacity",{start:function(a,b){a=d(b.helper);b=d(this).data("draggable").options;if(a.css("opacity"))b._opacity=
a.css("opacity");a.css("opacity",b.opacity)},stop:function(a,b){a=d(this).data("draggable").options;a._opacity&&d(b.helper).css("opacity",a._opacity)}});d.ui.plugin.add("draggable","scroll",{start:function(){var a=d(this).data("draggable");if(a.scrollParent[0]!=document&&a.scrollParent[0].tagName!="HTML")a.overflowOffset=a.scrollParent.offset()},drag:function(a){var b=d(this).data("draggable"),c=b.options,f=false;if(b.scrollParent[0]!=document&&b.scrollParent[0].tagName!="HTML"){if(!c.axis||c.axis!=
"x")if(b.overflowOffset.top+b.scrollParent[0].offsetHeight-a.pageY<c.scrollSensitivity)b.scrollParent[0].scrollTop=f=b.scrollParent[0].scrollTop+c.scrollSpeed;else if(a.pageY-b.overflowOffset.top<c.scrollSensitivity)b.scrollParent[0].scrollTop=f=b.scrollParent[0].scrollTop-c.scrollSpeed;if(!c.axis||c.axis!="y")if(b.overflowOffset.left+b.scrollParent[0].offsetWidth-a.pageX<c.scrollSensitivity)b.scrollParent[0].scrollLeft=f=b.scrollParent[0].scrollLeft+c.scrollSpeed;else if(a.pageX-b.overflowOffset.left<
c.scrollSensitivity)b.scrollParent[0].scrollLeft=f=b.scrollParent[0].scrollLeft-c.scrollSpeed}else{if(!c.axis||c.axis!="x")if(a.pageY-d(document).scrollTop()<c.scrollSensitivity)f=d(document).scrollTop(d(document).scrollTop()-c.scrollSpeed);else if(d(window).height()-(a.pageY-d(document).scrollTop())<c.scrollSensitivity)f=d(document).scrollTop(d(document).scrollTop()+c.scrollSpeed);if(!c.axis||c.axis!="y")if(a.pageX-d(document).scrollLeft()<c.scrollSensitivity)f=d(document).scrollLeft(d(document).scrollLeft()-
c.scrollSpeed);else if(d(window).width()-(a.pageX-d(document).scrollLeft())<c.scrollSensitivity)f=d(document).scrollLeft(d(document).scrollLeft()+c.scrollSpeed)}f!==false&&d.ui.ddmanager&&!c.dropBehaviour&&d.ui.ddmanager.prepareOffsets(b,a)}});d.ui.plugin.add("draggable","snap",{start:function(){var a=d(this).data("draggable"),b=a.options;a.snapElements=[];d(b.snap.constructor!=String?b.snap.items||":data(draggable)":b.snap).each(function(){var c=d(this),f=c.offset();this!=a.element[0]&&a.snapElements.push({item:this,
width:c.outerWidth(),height:c.outerHeight(),top:f.top,left:f.left})})},drag:function(a,b){for(var c=d(this).data("draggable"),f=c.options,e=f.snapTolerance,h=b.offset.left,g=h+c.helperProportions.width,n=b.offset.top,o=n+c.helperProportions.height,i=c.snapElements.length-1;i>=0;i--){var j=c.snapElements[i].left,l=j+c.snapElements[i].width,k=c.snapElements[i].top,m=k+c.snapElements[i].height;if(j-e<h&&h<l+e&&k-e<n&&n<m+e||j-e<h&&h<l+e&&k-e<o&&o<m+e||j-e<g&&g<l+e&&k-e<n&&n<m+e||j-e<g&&g<l+e&&k-e<o&&
o<m+e){if(f.snapMode!="inner"){var p=Math.abs(k-o)<=e,q=Math.abs(m-n)<=e,r=Math.abs(j-g)<=e,s=Math.abs(l-h)<=e;if(p)b.position.top=c._convertPositionTo("relative",{top:k-c.helperProportions.height,left:0}).top-c.margins.top;if(q)b.position.top=c._convertPositionTo("relative",{top:m,left:0}).top-c.margins.top;if(r)b.position.left=c._convertPositionTo("relative",{top:0,left:j-c.helperProportions.width}).left-c.margins.left;if(s)b.position.left=c._convertPositionTo("relative",{top:0,left:l}).left-c.margins.left}var t=
p||q||r||s;if(f.snapMode!="outer"){p=Math.abs(k-n)<=e;q=Math.abs(m-o)<=e;r=Math.abs(j-h)<=e;s=Math.abs(l-g)<=e;if(p)b.position.top=c._convertPositionTo("relative",{top:k,left:0}).top-c.margins.top;if(q)b.position.top=c._convertPositionTo("relative",{top:m-c.helperProportions.height,left:0}).top-c.margins.top;if(r)b.position.left=c._convertPositionTo("relative",{top:0,left:j}).left-c.margins.left;if(s)b.position.left=c._convertPositionTo("relative",{top:0,left:l-c.helperProportions.width}).left-c.margins.left}if(!c.snapElements[i].snapping&&
(p||q||r||s||t))c.options.snap.snap&&c.options.snap.snap.call(c.element,a,d.extend(c._uiHash(),{snapItem:c.snapElements[i].item}));c.snapElements[i].snapping=p||q||r||s||t}else{c.snapElements[i].snapping&&c.options.snap.release&&c.options.snap.release.call(c.element,a,d.extend(c._uiHash(),{snapItem:c.snapElements[i].item}));c.snapElements[i].snapping=false}}}});d.ui.plugin.add("draggable","stack",{start:function(){var a=d(this).data("draggable").options;a=d.makeArray(d(a.stack)).sort(function(c,f){return(parseInt(d(c).css("zIndex"),
10)||0)-(parseInt(d(f).css("zIndex"),10)||0)});if(a.length){var b=parseInt(a[0].style.zIndex)||0;d(a).each(function(c){this.style.zIndex=b+c});this[0].style.zIndex=b+a.length}}});d.ui.plugin.add("draggable","zIndex",{start:function(a,b){a=d(b.helper);b=d(this).data("draggable").options;if(a.css("zIndex"))b._zIndex=a.css("zIndex");a.css("zIndex",b.zIndex)},stop:function(a,b){a=d(this).data("draggable").options;a._zIndex&&d(b.helper).css("zIndex",a._zIndex)}})})(jQuery);
;/*
 * jQuery UI Droppable 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function(d){d.widget("ui.droppable",{widgetEventPrefix:"drop",options:{accept:"*",activeClass:false,addClasses:true,greedy:false,hoverClass:false,scope:"default",tolerance:"intersect"},_create:function(){var a=this.options,b=a.accept;this.isover=0;this.isout=1;this.accept=d.isFunction(b)?b:function(c){return c.is(b)};this.proportions={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight};d.ui.ddmanager.droppables[a.scope]=d.ui.ddmanager.droppables[a.scope]||[];d.ui.ddmanager.droppables[a.scope].push(this);
a.addClasses&&this.element.addClass("ui-droppable")},destroy:function(){for(var a=d.ui.ddmanager.droppables[this.options.scope],b=0;b<a.length;b++)a[b]==this&&a.splice(b,1);this.element.removeClass("ui-droppable ui-droppable-disabled").removeData("droppable").unbind(".droppable");return this},_setOption:function(a,b){if(a=="accept")this.accept=d.isFunction(b)?b:function(c){return c.is(b)};d.Widget.prototype._setOption.apply(this,arguments)},_activate:function(a){var b=d.ui.ddmanager.current;this.options.activeClass&&
this.element.addClass(this.options.activeClass);b&&this._trigger("activate",a,this.ui(b))},_deactivate:function(a){var b=d.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass);b&&this._trigger("deactivate",a,this.ui(b))},_over:function(a){var b=d.ui.ddmanager.current;if(!(!b||(b.currentItem||b.element)[0]==this.element[0]))if(this.accept.call(this.element[0],b.currentItem||b.element)){this.options.hoverClass&&this.element.addClass(this.options.hoverClass);
this._trigger("over",a,this.ui(b))}},_out:function(a){var b=d.ui.ddmanager.current;if(!(!b||(b.currentItem||b.element)[0]==this.element[0]))if(this.accept.call(this.element[0],b.currentItem||b.element)){this.options.hoverClass&&this.element.removeClass(this.options.hoverClass);this._trigger("out",a,this.ui(b))}},_drop:function(a,b){var c=b||d.ui.ddmanager.current;if(!c||(c.currentItem||c.element)[0]==this.element[0])return false;var e=false;this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function(){var g=
d.data(this,"droppable");if(g.options.greedy&&!g.options.disabled&&g.options.scope==c.options.scope&&g.accept.call(g.element[0],c.currentItem||c.element)&&d.ui.intersect(c,d.extend(g,{offset:g.element.offset()}),g.options.tolerance)){e=true;return false}});if(e)return false;if(this.accept.call(this.element[0],c.currentItem||c.element)){this.options.activeClass&&this.element.removeClass(this.options.activeClass);this.options.hoverClass&&this.element.removeClass(this.options.hoverClass);this._trigger("drop",
a,this.ui(c));return this.element}return false},ui:function(a){return{draggable:a.currentItem||a.element,helper:a.helper,position:a.position,offset:a.positionAbs}}});d.extend(d.ui.droppable,{version:"1.8.15"});d.ui.intersect=function(a,b,c){if(!b.offset)return false;var e=(a.positionAbs||a.position.absolute).left,g=e+a.helperProportions.width,f=(a.positionAbs||a.position.absolute).top,h=f+a.helperProportions.height,i=b.offset.left,k=i+b.proportions.width,j=b.offset.top,l=j+b.proportions.height;
switch(c){case "fit":return i<=e&&g<=k&&j<=f&&h<=l;case "intersect":return i<e+a.helperProportions.width/2&&g-a.helperProportions.width/2<k&&j<f+a.helperProportions.height/2&&h-a.helperProportions.height/2<l;case "pointer":return d.ui.isOver((a.positionAbs||a.position.absolute).top+(a.clickOffset||a.offset.click).top,(a.positionAbs||a.position.absolute).left+(a.clickOffset||a.offset.click).left,j,i,b.proportions.height,b.proportions.width);case "touch":return(f>=j&&f<=l||h>=j&&h<=l||f<j&&h>l)&&(e>=
i&&e<=k||g>=i&&g<=k||e<i&&g>k);default:return false}};d.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(a,b){var c=d.ui.ddmanager.droppables[a.options.scope]||[],e=b?b.type:null,g=(a.currentItem||a.element).find(":data(droppable)").andSelf(),f=0;a:for(;f<c.length;f++)if(!(c[f].options.disabled||a&&!c[f].accept.call(c[f].element[0],a.currentItem||a.element))){for(var h=0;h<g.length;h++)if(g[h]==c[f].element[0]){c[f].proportions.height=0;continue a}c[f].visible=c[f].element.css("display")!=
"none";if(c[f].visible){e=="mousedown"&&c[f]._activate.call(c[f],b);c[f].offset=c[f].element.offset();c[f].proportions={width:c[f].element[0].offsetWidth,height:c[f].element[0].offsetHeight}}}},drop:function(a,b){var c=false;d.each(d.ui.ddmanager.droppables[a.options.scope]||[],function(){if(this.options){if(!this.options.disabled&&this.visible&&d.ui.intersect(a,this,this.options.tolerance))c=c||this._drop.call(this,b);if(!this.options.disabled&&this.visible&&this.accept.call(this.element[0],a.currentItem||
a.element)){this.isout=1;this.isover=0;this._deactivate.call(this,b)}}});return c},dragStart:function(a,b){a.element.parentsUntil("body").bind("scroll.droppable",function(){a.options.refreshPositions||d.ui.ddmanager.prepareOffsets(a,b)})},drag:function(a,b){a.options.refreshPositions&&d.ui.ddmanager.prepareOffsets(a,b);d.each(d.ui.ddmanager.droppables[a.options.scope]||[],function(){if(!(this.options.disabled||this.greedyChild||!this.visible)){var c=d.ui.intersect(a,this,this.options.tolerance);if(c=
!c&&this.isover==1?"isout":c&&this.isover==0?"isover":null){var e;if(this.options.greedy){var g=this.element.parents(":data(droppable):eq(0)");if(g.length){e=d.data(g[0],"droppable");e.greedyChild=c=="isover"?1:0}}if(e&&c=="isover"){e.isover=0;e.isout=1;e._out.call(e,b)}this[c]=1;this[c=="isout"?"isover":"isout"]=0;this[c=="isover"?"_over":"_out"].call(this,b);if(e&&c=="isout"){e.isout=0;e.isover=1;e._over.call(e,b)}}}})},dragStop:function(a,b){a.element.parentsUntil("body").unbind("scroll.droppable");
a.options.refreshPositions||d.ui.ddmanager.prepareOffsets(a,b)}}})(jQuery);
;/*
 * jQuery UI Resizable 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(e){e.widget("ui.resizable",e.ui.mouse,{widgetEventPrefix:"resize",options:{alsoResize:false,animate:false,animateDuration:"slow",animateEasing:"swing",aspectRatio:false,autoHide:false,containment:false,ghost:false,grid:false,handles:"e,s,se",helper:false,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:1E3},_create:function(){var b=this,a=this.options;this.element.addClass("ui-resizable");e.extend(this,{_aspectRatio:!!a.aspectRatio,aspectRatio:a.aspectRatio,originalElement:this.element,
_proportionallyResizeElements:[],_helper:a.helper||a.ghost||a.animate?a.helper||"ui-resizable-helper":null});if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)){/relative/.test(this.element.css("position"))&&e.browser.opera&&this.element.css({position:"relative",top:"auto",left:"auto"});this.element.wrap(e('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),
top:this.element.css("top"),left:this.element.css("left")}));this.element=this.element.parent().data("resizable",this.element.data("resizable"));this.elementIsWrapper=true;this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")});this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0});this.originalResizeStyle=
this.originalElement.css("resize");this.originalElement.css("resize","none");this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"}));this.originalElement.css({margin:this.originalElement.css("margin")});this._proportionallyResize()}this.handles=a.handles||(!e(".ui-resizable-handle",this.element).length?"e,s,se":{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",
nw:".ui-resizable-nw"});if(this.handles.constructor==String){if(this.handles=="all")this.handles="n,e,s,w,se,sw,ne,nw";var c=this.handles.split(",");this.handles={};for(var d=0;d<c.length;d++){var f=e.trim(c[d]),g=e('<div class="ui-resizable-handle '+("ui-resizable-"+f)+'"></div>');/sw|se|ne|nw/.test(f)&&g.css({zIndex:++a.zIndex});"se"==f&&g.addClass("ui-icon ui-icon-gripsmall-diagonal-se");this.handles[f]=".ui-resizable-"+f;this.element.append(g)}}this._renderAxis=function(h){h=h||this.element;for(var i in this.handles){if(this.handles[i].constructor==
String)this.handles[i]=e(this.handles[i],this.element).show();if(this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)){var j=e(this.handles[i],this.element),l=0;l=/sw|ne|nw|se|n|s/.test(i)?j.outerHeight():j.outerWidth();j=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join("");h.css(j,l);this._proportionallyResize()}e(this.handles[i])}};this._renderAxis(this.element);this._handles=e(".ui-resizable-handle",this.element).disableSelection();
this._handles.mouseover(function(){if(!b.resizing){if(this.className)var h=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);b.axis=h&&h[1]?h[1]:"se"}});if(a.autoHide){this._handles.hide();e(this.element).addClass("ui-resizable-autohide").hover(function(){if(!a.disabled){e(this).removeClass("ui-resizable-autohide");b._handles.show()}},function(){if(!a.disabled)if(!b.resizing){e(this).addClass("ui-resizable-autohide");b._handles.hide()}})}this._mouseInit()},destroy:function(){this._mouseDestroy();
var b=function(c){e(c).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};if(this.elementIsWrapper){b(this.element);var a=this.element;a.after(this.originalElement.css({position:a.css("position"),width:a.outerWidth(),height:a.outerHeight(),top:a.css("top"),left:a.css("left")})).remove()}this.originalElement.css("resize",this.originalResizeStyle);b(this.originalElement);return this},_mouseCapture:function(b){var a=
false;for(var c in this.handles)if(e(this.handles[c])[0]==b.target)a=true;return!this.options.disabled&&a},_mouseStart:function(b){var a=this.options,c=this.element.position(),d=this.element;this.resizing=true;this.documentScroll={top:e(document).scrollTop(),left:e(document).scrollLeft()};if(d.is(".ui-draggable")||/absolute/.test(d.css("position")))d.css({position:"absolute",top:c.top,left:c.left});e.browser.opera&&/relative/.test(d.css("position"))&&d.css({position:"relative",top:"auto",left:"auto"});
this._renderProxy();c=m(this.helper.css("left"));var f=m(this.helper.css("top"));if(a.containment){c+=e(a.containment).scrollLeft()||0;f+=e(a.containment).scrollTop()||0}this.offset=this.helper.offset();this.position={left:c,top:f};this.size=this._helper?{width:d.outerWidth(),height:d.outerHeight()}:{width:d.width(),height:d.height()};this.originalSize=this._helper?{width:d.outerWidth(),height:d.outerHeight()}:{width:d.width(),height:d.height()};this.originalPosition={left:c,top:f};this.sizeDiff=
{width:d.outerWidth()-d.width(),height:d.outerHeight()-d.height()};this.originalMousePosition={left:b.pageX,top:b.pageY};this.aspectRatio=typeof a.aspectRatio=="number"?a.aspectRatio:this.originalSize.width/this.originalSize.height||1;a=e(".ui-resizable-"+this.axis).css("cursor");e("body").css("cursor",a=="auto"?this.axis+"-resize":a);d.addClass("ui-resizable-resizing");this._propagate("start",b);return true},_mouseDrag:function(b){var a=this.helper,c=this.originalMousePosition,d=this._change[this.axis];
if(!d)return false;c=d.apply(this,[b,b.pageX-c.left||0,b.pageY-c.top||0]);this._updateVirtualBoundaries(b.shiftKey);if(this._aspectRatio||b.shiftKey)c=this._updateRatio(c,b);c=this._respectSize(c,b);this._propagate("resize",b);a.css({top:this.position.top+"px",left:this.position.left+"px",width:this.size.width+"px",height:this.size.height+"px"});!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize();this._updateCache(c);this._trigger("resize",b,this.ui());return false},
_mouseStop:function(b){this.resizing=false;var a=this.options,c=this;if(this._helper){var d=this._proportionallyResizeElements,f=d.length&&/textarea/i.test(d[0].nodeName);d=f&&e.ui.hasScroll(d[0],"left")?0:c.sizeDiff.height;f=f?0:c.sizeDiff.width;f={width:c.helper.width()-f,height:c.helper.height()-d};d=parseInt(c.element.css("left"),10)+(c.position.left-c.originalPosition.left)||null;var g=parseInt(c.element.css("top"),10)+(c.position.top-c.originalPosition.top)||null;a.animate||this.element.css(e.extend(f,
{top:g,left:d}));c.helper.height(c.size.height);c.helper.width(c.size.width);this._helper&&!a.animate&&this._proportionallyResize()}e("body").css("cursor","auto");this.element.removeClass("ui-resizable-resizing");this._propagate("stop",b);this._helper&&this.helper.remove();return false},_updateVirtualBoundaries:function(b){var a=this.options,c,d,f;a={minWidth:k(a.minWidth)?a.minWidth:0,maxWidth:k(a.maxWidth)?a.maxWidth:Infinity,minHeight:k(a.minHeight)?a.minHeight:0,maxHeight:k(a.maxHeight)?a.maxHeight:
Infinity};if(this._aspectRatio||b){b=a.minHeight*this.aspectRatio;d=a.minWidth/this.aspectRatio;c=a.maxHeight*this.aspectRatio;f=a.maxWidth/this.aspectRatio;if(b>a.minWidth)a.minWidth=b;if(d>a.minHeight)a.minHeight=d;if(c<a.maxWidth)a.maxWidth=c;if(f<a.maxHeight)a.maxHeight=f}this._vBoundaries=a},_updateCache:function(b){this.offset=this.helper.offset();if(k(b.left))this.position.left=b.left;if(k(b.top))this.position.top=b.top;if(k(b.height))this.size.height=b.height;if(k(b.width))this.size.width=
b.width},_updateRatio:function(b){var a=this.position,c=this.size,d=this.axis;if(k(b.height))b.width=b.height*this.aspectRatio;else if(k(b.width))b.height=b.width/this.aspectRatio;if(d=="sw"){b.left=a.left+(c.width-b.width);b.top=null}if(d=="nw"){b.top=a.top+(c.height-b.height);b.left=a.left+(c.width-b.width)}return b},_respectSize:function(b){var a=this._vBoundaries,c=this.axis,d=k(b.width)&&a.maxWidth&&a.maxWidth<b.width,f=k(b.height)&&a.maxHeight&&a.maxHeight<b.height,g=k(b.width)&&a.minWidth&&
a.minWidth>b.width,h=k(b.height)&&a.minHeight&&a.minHeight>b.height;if(g)b.width=a.minWidth;if(h)b.height=a.minHeight;if(d)b.width=a.maxWidth;if(f)b.height=a.maxHeight;var i=this.originalPosition.left+this.originalSize.width,j=this.position.top+this.size.height,l=/sw|nw|w/.test(c);c=/nw|ne|n/.test(c);if(g&&l)b.left=i-a.minWidth;if(d&&l)b.left=i-a.maxWidth;if(h&&c)b.top=j-a.minHeight;if(f&&c)b.top=j-a.maxHeight;if((a=!b.width&&!b.height)&&!b.left&&b.top)b.top=null;else if(a&&!b.top&&b.left)b.left=
null;return b},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var b=this.helper||this.element,a=0;a<this._proportionallyResizeElements.length;a++){var c=this._proportionallyResizeElements[a];if(!this.borderDif){var d=[c.css("borderTopWidth"),c.css("borderRightWidth"),c.css("borderBottomWidth"),c.css("borderLeftWidth")],f=[c.css("paddingTop"),c.css("paddingRight"),c.css("paddingBottom"),c.css("paddingLeft")];this.borderDif=e.map(d,function(g,h){g=parseInt(g,10)||
0;h=parseInt(f[h],10)||0;return g+h})}e.browser.msie&&(e(b).is(":hidden")||e(b).parents(":hidden").length)||c.css({height:b.height()-this.borderDif[0]-this.borderDif[2]||0,width:b.width()-this.borderDif[1]-this.borderDif[3]||0})}},_renderProxy:function(){var b=this.options;this.elementOffset=this.element.offset();if(this._helper){this.helper=this.helper||e('<div style="overflow:hidden;"></div>');var a=e.browser.msie&&e.browser.version<7,c=a?1:0;a=a?2:-1;this.helper.addClass(this._helper).css({width:this.element.outerWidth()+
a,height:this.element.outerHeight()+a,position:"absolute",left:this.elementOffset.left-c+"px",top:this.elementOffset.top-c+"px",zIndex:++b.zIndex});this.helper.appendTo("body").disableSelection()}else this.helper=this.element},_change:{e:function(b,a){return{width:this.originalSize.width+a}},w:function(b,a){return{left:this.originalPosition.left+a,width:this.originalSize.width-a}},n:function(b,a,c){return{top:this.originalPosition.top+c,height:this.originalSize.height-c}},s:function(b,a,c){return{height:this.originalSize.height+
c}},se:function(b,a,c){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[b,a,c]))},sw:function(b,a,c){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[b,a,c]))},ne:function(b,a,c){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[b,a,c]))},nw:function(b,a,c){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[b,a,c]))}},_propagate:function(b,a){e.ui.plugin.call(this,b,[a,this.ui()]);
b!="resize"&&this._trigger(b,a,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}});e.extend(e.ui.resizable,{version:"1.8.15"});e.ui.plugin.add("resizable","alsoResize",{start:function(){var b=e(this).data("resizable").options,a=function(c){e(c).each(function(){var d=e(this);d.data("resizable-alsoresize",{width:parseInt(d.width(),
10),height:parseInt(d.height(),10),left:parseInt(d.css("left"),10),top:parseInt(d.css("top"),10),position:d.css("position")})})};if(typeof b.alsoResize=="object"&&!b.alsoResize.parentNode)if(b.alsoResize.length){b.alsoResize=b.alsoResize[0];a(b.alsoResize)}else e.each(b.alsoResize,function(c){a(c)});else a(b.alsoResize)},resize:function(b,a){var c=e(this).data("resizable");b=c.options;var d=c.originalSize,f=c.originalPosition,g={height:c.size.height-d.height||0,width:c.size.width-d.width||0,top:c.position.top-
f.top||0,left:c.position.left-f.left||0},h=function(i,j){e(i).each(function(){var l=e(this),q=e(this).data("resizable-alsoresize"),p={},r=j&&j.length?j:l.parents(a.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(r,function(n,o){if((n=(q[o]||0)+(g[o]||0))&&n>=0)p[o]=n||null});if(e.browser.opera&&/relative/.test(l.css("position"))){c._revertToRelativePosition=true;l.css({position:"absolute",top:"auto",left:"auto"})}l.css(p)})};typeof b.alsoResize=="object"&&!b.alsoResize.nodeType?
e.each(b.alsoResize,function(i,j){h(i,j)}):h(b.alsoResize)},stop:function(){var b=e(this).data("resizable"),a=b.options,c=function(d){e(d).each(function(){var f=e(this);f.css({position:f.data("resizable-alsoresize").position})})};if(b._revertToRelativePosition){b._revertToRelativePosition=false;typeof a.alsoResize=="object"&&!a.alsoResize.nodeType?e.each(a.alsoResize,function(d){c(d)}):c(a.alsoResize)}e(this).removeData("resizable-alsoresize")}});e.ui.plugin.add("resizable","animate",{stop:function(b){var a=
e(this).data("resizable"),c=a.options,d=a._proportionallyResizeElements,f=d.length&&/textarea/i.test(d[0].nodeName),g=f&&e.ui.hasScroll(d[0],"left")?0:a.sizeDiff.height;f={width:a.size.width-(f?0:a.sizeDiff.width),height:a.size.height-g};g=parseInt(a.element.css("left"),10)+(a.position.left-a.originalPosition.left)||null;var h=parseInt(a.element.css("top"),10)+(a.position.top-a.originalPosition.top)||null;a.element.animate(e.extend(f,h&&g?{top:h,left:g}:{}),{duration:c.animateDuration,easing:c.animateEasing,
step:function(){var i={width:parseInt(a.element.css("width"),10),height:parseInt(a.element.css("height"),10),top:parseInt(a.element.css("top"),10),left:parseInt(a.element.css("left"),10)};d&&d.length&&e(d[0]).css({width:i.width,height:i.height});a._updateCache(i);a._propagate("resize",b)}})}});e.ui.plugin.add("resizable","containment",{start:function(){var b=e(this).data("resizable"),a=b.element,c=b.options.containment;if(a=c instanceof e?c.get(0):/parent/.test(c)?a.parent().get(0):c){b.containerElement=
e(a);if(/document/.test(c)||c==document){b.containerOffset={left:0,top:0};b.containerPosition={left:0,top:0};b.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight}}else{var d=e(a),f=[];e(["Top","Right","Left","Bottom"]).each(function(i,j){f[i]=m(d.css("padding"+j))});b.containerOffset=d.offset();b.containerPosition=d.position();b.containerSize={height:d.innerHeight()-f[3],width:d.innerWidth()-f[1]};c=b.containerOffset;
var g=b.containerSize.height,h=b.containerSize.width;h=e.ui.hasScroll(a,"left")?a.scrollWidth:h;g=e.ui.hasScroll(a)?a.scrollHeight:g;b.parentData={element:a,left:c.left,top:c.top,width:h,height:g}}}},resize:function(b){var a=e(this).data("resizable"),c=a.options,d=a.containerOffset,f=a.position;b=a._aspectRatio||b.shiftKey;var g={top:0,left:0},h=a.containerElement;if(h[0]!=document&&/static/.test(h.css("position")))g=d;if(f.left<(a._helper?d.left:0)){a.size.width+=a._helper?a.position.left-d.left:
a.position.left-g.left;if(b)a.size.height=a.size.width/c.aspectRatio;a.position.left=c.helper?d.left:0}if(f.top<(a._helper?d.top:0)){a.size.height+=a._helper?a.position.top-d.top:a.position.top;if(b)a.size.width=a.size.height*c.aspectRatio;a.position.top=a._helper?d.top:0}a.offset.left=a.parentData.left+a.position.left;a.offset.top=a.parentData.top+a.position.top;c=Math.abs((a._helper?a.offset.left-g.left:a.offset.left-g.left)+a.sizeDiff.width);d=Math.abs((a._helper?a.offset.top-g.top:a.offset.top-
d.top)+a.sizeDiff.height);f=a.containerElement.get(0)==a.element.parent().get(0);g=/relative|absolute/.test(a.containerElement.css("position"));if(f&&g)c-=a.parentData.left;if(c+a.size.width>=a.parentData.width){a.size.width=a.parentData.width-c;if(b)a.size.height=a.size.width/a.aspectRatio}if(d+a.size.height>=a.parentData.height){a.size.height=a.parentData.height-d;if(b)a.size.width=a.size.height*a.aspectRatio}},stop:function(){var b=e(this).data("resizable"),a=b.options,c=b.containerOffset,d=b.containerPosition,
f=b.containerElement,g=e(b.helper),h=g.offset(),i=g.outerWidth()-b.sizeDiff.width;g=g.outerHeight()-b.sizeDiff.height;b._helper&&!a.animate&&/relative/.test(f.css("position"))&&e(this).css({left:h.left-d.left-c.left,width:i,height:g});b._helper&&!a.animate&&/static/.test(f.css("position"))&&e(this).css({left:h.left-d.left-c.left,width:i,height:g})}});e.ui.plugin.add("resizable","ghost",{start:function(){var b=e(this).data("resizable"),a=b.options,c=b.size;b.ghost=b.originalElement.clone();b.ghost.css({opacity:0.25,
display:"block",position:"relative",height:c.height,width:c.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass(typeof a.ghost=="string"?a.ghost:"");b.ghost.appendTo(b.helper)},resize:function(){var b=e(this).data("resizable");b.ghost&&b.ghost.css({position:"relative",height:b.size.height,width:b.size.width})},stop:function(){var b=e(this).data("resizable");b.ghost&&b.helper&&b.helper.get(0).removeChild(b.ghost.get(0))}});e.ui.plugin.add("resizable","grid",{resize:function(){var b=
e(this).data("resizable"),a=b.options,c=b.size,d=b.originalSize,f=b.originalPosition,g=b.axis;a.grid=typeof a.grid=="number"?[a.grid,a.grid]:a.grid;var h=Math.round((c.width-d.width)/(a.grid[0]||1))*(a.grid[0]||1);a=Math.round((c.height-d.height)/(a.grid[1]||1))*(a.grid[1]||1);if(/^(se|s|e)$/.test(g)){b.size.width=d.width+h;b.size.height=d.height+a}else if(/^(ne)$/.test(g)){b.size.width=d.width+h;b.size.height=d.height+a;b.position.top=f.top-a}else{if(/^(sw)$/.test(g)){b.size.width=d.width+h;b.size.height=
d.height+a}else{b.size.width=d.width+h;b.size.height=d.height+a;b.position.top=f.top-a}b.position.left=f.left-h}}});var m=function(b){return parseInt(b,10)||0},k=function(b){return!isNaN(parseInt(b,10))}})(jQuery);
;/*
 * jQuery UI Selectable 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Selectables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(e){e.widget("ui.selectable",e.ui.mouse,{options:{appendTo:"body",autoRefresh:true,distance:0,filter:"*",tolerance:"touch"},_create:function(){var c=this;this.element.addClass("ui-selectable");this.dragged=false;var f;this.refresh=function(){f=e(c.options.filter,c.element[0]);f.each(function(){var d=e(this),b=d.offset();e.data(this,"selectable-item",{element:this,$element:d,left:b.left,top:b.top,right:b.left+d.outerWidth(),bottom:b.top+d.outerHeight(),startselected:false,selected:d.hasClass("ui-selected"),
selecting:d.hasClass("ui-selecting"),unselecting:d.hasClass("ui-unselecting")})})};this.refresh();this.selectees=f.addClass("ui-selectee");this._mouseInit();this.helper=e("<div class='ui-selectable-helper'></div>")},destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item");this.element.removeClass("ui-selectable ui-selectable-disabled").removeData("selectable").unbind(".selectable");this._mouseDestroy();return this},_mouseStart:function(c){var f=this;this.opos=[c.pageX,
c.pageY];if(!this.options.disabled){var d=this.options;this.selectees=e(d.filter,this.element[0]);this._trigger("start",c);e(d.appendTo).append(this.helper);this.helper.css({left:c.clientX,top:c.clientY,width:0,height:0});d.autoRefresh&&this.refresh();this.selectees.filter(".ui-selected").each(function(){var b=e.data(this,"selectable-item");b.startselected=true;if(!c.metaKey){b.$element.removeClass("ui-selected");b.selected=false;b.$element.addClass("ui-unselecting");b.unselecting=true;f._trigger("unselecting",
c,{unselecting:b.element})}});e(c.target).parents().andSelf().each(function(){var b=e.data(this,"selectable-item");if(b){var g=!c.metaKey||!b.$element.hasClass("ui-selected");b.$element.removeClass(g?"ui-unselecting":"ui-selected").addClass(g?"ui-selecting":"ui-unselecting");b.unselecting=!g;b.selecting=g;(b.selected=g)?f._trigger("selecting",c,{selecting:b.element}):f._trigger("unselecting",c,{unselecting:b.element});return false}})}},_mouseDrag:function(c){var f=this;this.dragged=true;if(!this.options.disabled){var d=
this.options,b=this.opos[0],g=this.opos[1],h=c.pageX,i=c.pageY;if(b>h){var j=h;h=b;b=j}if(g>i){j=i;i=g;g=j}this.helper.css({left:b,top:g,width:h-b,height:i-g});this.selectees.each(function(){var a=e.data(this,"selectable-item");if(!(!a||a.element==f.element[0])){var k=false;if(d.tolerance=="touch")k=!(a.left>h||a.right<b||a.top>i||a.bottom<g);else if(d.tolerance=="fit")k=a.left>b&&a.right<h&&a.top>g&&a.bottom<i;if(k){if(a.selected){a.$element.removeClass("ui-selected");a.selected=false}if(a.unselecting){a.$element.removeClass("ui-unselecting");
a.unselecting=false}if(!a.selecting){a.$element.addClass("ui-selecting");a.selecting=true;f._trigger("selecting",c,{selecting:a.element})}}else{if(a.selecting)if(c.metaKey&&a.startselected){a.$element.removeClass("ui-selecting");a.selecting=false;a.$element.addClass("ui-selected");a.selected=true}else{a.$element.removeClass("ui-selecting");a.selecting=false;if(a.startselected){a.$element.addClass("ui-unselecting");a.unselecting=true}f._trigger("unselecting",c,{unselecting:a.element})}if(a.selected)if(!c.metaKey&&
!a.startselected){a.$element.removeClass("ui-selected");a.selected=false;a.$element.addClass("ui-unselecting");a.unselecting=true;f._trigger("unselecting",c,{unselecting:a.element})}}}});return false}},_mouseStop:function(c){var f=this;this.dragged=false;e(".ui-unselecting",this.element[0]).each(function(){var d=e.data(this,"selectable-item");d.$element.removeClass("ui-unselecting");d.unselecting=false;d.startselected=false;f._trigger("unselected",c,{unselected:d.element})});e(".ui-selecting",this.element[0]).each(function(){var d=
e.data(this,"selectable-item");d.$element.removeClass("ui-selecting").addClass("ui-selected");d.selecting=false;d.selected=true;d.startselected=true;f._trigger("selected",c,{selected:d.element})});this._trigger("stop",c);this.helper.remove();return false}});e.extend(e.ui.selectable,{version:"1.8.15"})})(jQuery);
;/*
 * jQuery UI Sortable 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.sortable",d.ui.mouse,{widgetEventPrefix:"sort",options:{appendTo:"parent",axis:false,connectWith:false,containment:false,cursor:"auto",cursorAt:false,dropOnEmpty:true,forcePlaceholderSize:false,forceHelperSize:false,grid:false,handle:false,helper:"original",items:"> *",opacity:false,placeholder:false,revert:false,scroll:true,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1E3},_create:function(){var a=this.options;this.containerCache={};this.element.addClass("ui-sortable");
this.refresh();this.floating=this.items.length?a.axis==="x"||/left|right/.test(this.items[0].item.css("float"))||/inline|table-cell/.test(this.items[0].item.css("display")):false;this.offset=this.element.offset();this._mouseInit()},destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").removeData("sortable").unbind(".sortable");this._mouseDestroy();for(var a=this.items.length-1;a>=0;a--)this.items[a].item.removeData("sortable-item");return this},_setOption:function(a,b){if(a===
"disabled"){this.options[a]=b;this.widget()[b?"addClass":"removeClass"]("ui-sortable-disabled")}else d.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(a,b){if(this.reverting)return false;if(this.options.disabled||this.options.type=="static")return false;this._refreshItems(a);var c=null,e=this;d(a.target).parents().each(function(){if(d.data(this,"sortable-item")==e){c=d(this);return false}});if(d.data(a.target,"sortable-item")==e)c=d(a.target);if(!c)return false;if(this.options.handle&&
!b){var f=false;d(this.options.handle,c).find("*").andSelf().each(function(){if(this==a.target)f=true});if(!f)return false}this.currentItem=c;this._removeCurrentsFromItems();return true},_mouseStart:function(a,b,c){b=this.options;var e=this;this.currentContainer=this;this.refreshPositions();this.helper=this._createHelper(a);this._cacheHelperProportions();this._cacheMargins();this.scrollParent=this.helper.scrollParent();this.offset=this.currentItem.offset();this.offset={top:this.offset.top-this.margins.top,
left:this.offset.left-this.margins.left};this.helper.css("position","absolute");this.cssPosition=this.helper.css("position");d.extend(this.offset,{click:{left:a.pageX-this.offset.left,top:a.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()});this.originalPosition=this._generatePosition(a);this.originalPageX=a.pageX;this.originalPageY=a.pageY;b.cursorAt&&this._adjustOffsetFromHelper(b.cursorAt);this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]};
this.helper[0]!=this.currentItem[0]&&this.currentItem.hide();this._createPlaceholder();b.containment&&this._setContainment();if(b.cursor){if(d("body").css("cursor"))this._storedCursor=d("body").css("cursor");d("body").css("cursor",b.cursor)}if(b.opacity){if(this.helper.css("opacity"))this._storedOpacity=this.helper.css("opacity");this.helper.css("opacity",b.opacity)}if(b.zIndex){if(this.helper.css("zIndex"))this._storedZIndex=this.helper.css("zIndex");this.helper.css("zIndex",b.zIndex)}if(this.scrollParent[0]!=
document&&this.scrollParent[0].tagName!="HTML")this.overflowOffset=this.scrollParent.offset();this._trigger("start",a,this._uiHash());this._preserveHelperProportions||this._cacheHelperProportions();if(!c)for(c=this.containers.length-1;c>=0;c--)this.containers[c]._trigger("activate",a,e._uiHash(this));if(d.ui.ddmanager)d.ui.ddmanager.current=this;d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a);this.dragging=true;this.helper.addClass("ui-sortable-helper");this._mouseDrag(a);
return true},_mouseDrag:function(a){this.position=this._generatePosition(a);this.positionAbs=this._convertPositionTo("absolute");if(!this.lastPositionAbs)this.lastPositionAbs=this.positionAbs;if(this.options.scroll){var b=this.options,c=false;if(this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"){if(this.overflowOffset.top+this.scrollParent[0].offsetHeight-a.pageY<b.scrollSensitivity)this.scrollParent[0].scrollTop=c=this.scrollParent[0].scrollTop+b.scrollSpeed;else if(a.pageY-this.overflowOffset.top<
b.scrollSensitivity)this.scrollParent[0].scrollTop=c=this.scrollParent[0].scrollTop-b.scrollSpeed;if(this.overflowOffset.left+this.scrollParent[0].offsetWidth-a.pageX<b.scrollSensitivity)this.scrollParent[0].scrollLeft=c=this.scrollParent[0].scrollLeft+b.scrollSpeed;else if(a.pageX-this.overflowOffset.left<b.scrollSensitivity)this.scrollParent[0].scrollLeft=c=this.scrollParent[0].scrollLeft-b.scrollSpeed}else{if(a.pageY-d(document).scrollTop()<b.scrollSensitivity)c=d(document).scrollTop(d(document).scrollTop()-
b.scrollSpeed);else if(d(window).height()-(a.pageY-d(document).scrollTop())<b.scrollSensitivity)c=d(document).scrollTop(d(document).scrollTop()+b.scrollSpeed);if(a.pageX-d(document).scrollLeft()<b.scrollSensitivity)c=d(document).scrollLeft(d(document).scrollLeft()-b.scrollSpeed);else if(d(window).width()-(a.pageX-d(document).scrollLeft())<b.scrollSensitivity)c=d(document).scrollLeft(d(document).scrollLeft()+b.scrollSpeed)}c!==false&&d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,
a)}this.positionAbs=this._convertPositionTo("absolute");if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";for(b=this.items.length-1;b>=0;b--){c=this.items[b];var e=c.item[0],f=this._intersectsWithPointer(c);if(f)if(e!=this.currentItem[0]&&this.placeholder[f==1?"next":"prev"]()[0]!=e&&!d.ui.contains(this.placeholder[0],e)&&(this.options.type=="semi-dynamic"?!d.ui.contains(this.element[0],
e):true)){this.direction=f==1?"down":"up";if(this.options.tolerance=="pointer"||this._intersectsWithSides(c))this._rearrange(a,c);else break;this._trigger("change",a,this._uiHash());break}}this._contactContainers(a);d.ui.ddmanager&&d.ui.ddmanager.drag(this,a);this._trigger("sort",a,this._uiHash());this.lastPositionAbs=this.positionAbs;return false},_mouseStop:function(a,b){if(a){d.ui.ddmanager&&!this.options.dropBehaviour&&d.ui.ddmanager.drop(this,a);if(this.options.revert){var c=this;b=c.placeholder.offset();
c.reverting=true;d(this.helper).animate({left:b.left-this.offset.parent.left-c.margins.left+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollLeft),top:b.top-this.offset.parent.top-c.margins.top+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollTop)},parseInt(this.options.revert,10)||500,function(){c._clear(a)})}else this._clear(a,b);return false}},cancel:function(){var a=this;if(this.dragging){this._mouseUp({target:null});this.options.helper=="original"?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):
this.currentItem.show();for(var b=this.containers.length-1;b>=0;b--){this.containers[b]._trigger("deactivate",null,a._uiHash(this));if(this.containers[b].containerCache.over){this.containers[b]._trigger("out",null,a._uiHash(this));this.containers[b].containerCache.over=0}}}if(this.placeholder){this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]);this.options.helper!="original"&&this.helper&&this.helper[0].parentNode&&this.helper.remove();d.extend(this,{helper:null,
dragging:false,reverting:false,_noFinalSort:null});this.domPosition.prev?d(this.domPosition.prev).after(this.currentItem):d(this.domPosition.parent).prepend(this.currentItem)}return this},serialize:function(a){var b=this._getItemsAsjQuery(a&&a.connected),c=[];a=a||{};d(b).each(function(){var e=(d(a.item||this).attr(a.attribute||"id")||"").match(a.expression||/(.+)[-=_](.+)/);if(e)c.push((a.key||e[1]+"[]")+"="+(a.key&&a.expression?e[1]:e[2]))});!c.length&&a.key&&c.push(a.key+"=");return c.join("&")},
toArray:function(a){var b=this._getItemsAsjQuery(a&&a.connected),c=[];a=a||{};b.each(function(){c.push(d(a.item||this).attr(a.attribute||"id")||"")});return c},_intersectsWith:function(a){var b=this.positionAbs.left,c=b+this.helperProportions.width,e=this.positionAbs.top,f=e+this.helperProportions.height,g=a.left,h=g+a.width,i=a.top,k=i+a.height,j=this.offset.click.top,l=this.offset.click.left;j=e+j>i&&e+j<k&&b+l>g&&b+l<h;return this.options.tolerance=="pointer"||this.options.forcePointerForContainers||
this.options.tolerance!="pointer"&&this.helperProportions[this.floating?"width":"height"]>a[this.floating?"width":"height"]?j:g<b+this.helperProportions.width/2&&c-this.helperProportions.width/2<h&&i<e+this.helperProportions.height/2&&f-this.helperProportions.height/2<k},_intersectsWithPointer:function(a){var b=d.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,a.top,a.height);a=d.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,a.left,a.width);b=b&&a;a=this._getDragVerticalDirection();
var c=this._getDragHorizontalDirection();if(!b)return false;return this.floating?c&&c=="right"||a=="down"?2:1:a&&(a=="down"?2:1)},_intersectsWithSides:function(a){var b=d.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,a.top+a.height/2,a.height);a=d.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,a.left+a.width/2,a.width);var c=this._getDragVerticalDirection(),e=this._getDragHorizontalDirection();return this.floating&&e?e=="right"&&a||e=="left"&&!a:c&&(c=="down"&&b||c=="up"&&!b)},
_getDragVerticalDirection:function(){var a=this.positionAbs.top-this.lastPositionAbs.top;return a!=0&&(a>0?"down":"up")},_getDragHorizontalDirection:function(){var a=this.positionAbs.left-this.lastPositionAbs.left;return a!=0&&(a>0?"right":"left")},refresh:function(a){this._refreshItems(a);this.refreshPositions();return this},_connectWith:function(){var a=this.options;return a.connectWith.constructor==String?[a.connectWith]:a.connectWith},_getItemsAsjQuery:function(a){var b=[],c=[],e=this._connectWith();
if(e&&a)for(a=e.length-1;a>=0;a--)for(var f=d(e[a]),g=f.length-1;g>=0;g--){var h=d.data(f[g],"sortable");if(h&&h!=this&&!h.options.disabled)c.push([d.isFunction(h.options.items)?h.options.items.call(h.element):d(h.options.items,h.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),h])}c.push([d.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):d(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),
this]);for(a=c.length-1;a>=0;a--)c[a][0].each(function(){b.push(this)});return d(b)},_removeCurrentsFromItems:function(){for(var a=this.currentItem.find(":data(sortable-item)"),b=0;b<this.items.length;b++)for(var c=0;c<a.length;c++)a[c]==this.items[b].item[0]&&this.items.splice(b,1)},_refreshItems:function(a){this.items=[];this.containers=[this];var b=this.items,c=[[d.isFunction(this.options.items)?this.options.items.call(this.element[0],a,{item:this.currentItem}):d(this.options.items,this.element),
this]],e=this._connectWith();if(e)for(var f=e.length-1;f>=0;f--)for(var g=d(e[f]),h=g.length-1;h>=0;h--){var i=d.data(g[h],"sortable");if(i&&i!=this&&!i.options.disabled){c.push([d.isFunction(i.options.items)?i.options.items.call(i.element[0],a,{item:this.currentItem}):d(i.options.items,i.element),i]);this.containers.push(i)}}for(f=c.length-1;f>=0;f--){a=c[f][1];e=c[f][0];h=0;for(g=e.length;h<g;h++){i=d(e[h]);i.data("sortable-item",a);b.push({item:i,instance:a,width:0,height:0,left:0,top:0})}}},refreshPositions:function(a){if(this.offsetParent&&
this.helper)this.offset.parent=this._getParentOffset();for(var b=this.items.length-1;b>=0;b--){var c=this.items[b];if(!(c.instance!=this.currentContainer&&this.currentContainer&&c.item[0]!=this.currentItem[0])){var e=this.options.toleranceElement?d(this.options.toleranceElement,c.item):c.item;if(!a){c.width=e.outerWidth();c.height=e.outerHeight()}e=e.offset();c.left=e.left;c.top=e.top}}if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(b=
this.containers.length-1;b>=0;b--){e=this.containers[b].element.offset();this.containers[b].containerCache.left=e.left;this.containers[b].containerCache.top=e.top;this.containers[b].containerCache.width=this.containers[b].element.outerWidth();this.containers[b].containerCache.height=this.containers[b].element.outerHeight()}return this},_createPlaceholder:function(a){var b=a||this,c=b.options;if(!c.placeholder||c.placeholder.constructor==String){var e=c.placeholder;c.placeholder={element:function(){var f=
d(document.createElement(b.currentItem[0].nodeName)).addClass(e||b.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];if(!e)f.style.visibility="hidden";return f},update:function(f,g){if(!(e&&!c.forcePlaceholderSize)){g.height()||g.height(b.currentItem.innerHeight()-parseInt(b.currentItem.css("paddingTop")||0,10)-parseInt(b.currentItem.css("paddingBottom")||0,10));g.width()||g.width(b.currentItem.innerWidth()-parseInt(b.currentItem.css("paddingLeft")||0,10)-parseInt(b.currentItem.css("paddingRight")||
0,10))}}}}b.placeholder=d(c.placeholder.element.call(b.element,b.currentItem));b.currentItem.after(b.placeholder);c.placeholder.update(b,b.placeholder)},_contactContainers:function(a){for(var b=null,c=null,e=this.containers.length-1;e>=0;e--)if(!d.ui.contains(this.currentItem[0],this.containers[e].element[0]))if(this._intersectsWith(this.containers[e].containerCache)){if(!(b&&d.ui.contains(this.containers[e].element[0],b.element[0]))){b=this.containers[e];c=e}}else if(this.containers[e].containerCache.over){this.containers[e]._trigger("out",
a,this._uiHash(this));this.containers[e].containerCache.over=0}if(b)if(this.containers.length===1){this.containers[c]._trigger("over",a,this._uiHash(this));this.containers[c].containerCache.over=1}else if(this.currentContainer!=this.containers[c]){b=1E4;e=null;for(var f=this.positionAbs[this.containers[c].floating?"left":"top"],g=this.items.length-1;g>=0;g--)if(d.ui.contains(this.containers[c].element[0],this.items[g].item[0])){var h=this.items[g][this.containers[c].floating?"left":"top"];if(Math.abs(h-
f)<b){b=Math.abs(h-f);e=this.items[g]}}if(e||this.options.dropOnEmpty){this.currentContainer=this.containers[c];e?this._rearrange(a,e,null,true):this._rearrange(a,null,this.containers[c].element,true);this._trigger("change",a,this._uiHash());this.containers[c]._trigger("change",a,this._uiHash(this));this.options.placeholder.update(this.currentContainer,this.placeholder);this.containers[c]._trigger("over",a,this._uiHash(this));this.containers[c].containerCache.over=1}}},_createHelper:function(a){var b=
this.options;a=d.isFunction(b.helper)?d(b.helper.apply(this.element[0],[a,this.currentItem])):b.helper=="clone"?this.currentItem.clone():this.currentItem;a.parents("body").length||d(b.appendTo!="parent"?b.appendTo:this.currentItem[0].parentNode)[0].appendChild(a[0]);if(a[0]==this.currentItem[0])this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")};if(a[0].style.width==
""||b.forceHelperSize)a.width(this.currentItem.width());if(a[0].style.height==""||b.forceHelperSize)a.height(this.currentItem.height());return a},_adjustOffsetFromHelper:function(a){if(typeof a=="string")a=a.split(" ");if(d.isArray(a))a={left:+a[0],top:+a[1]||0};if("left"in a)this.offset.click.left=a.left+this.margins.left;if("right"in a)this.offset.click.left=this.helperProportions.width-a.right+this.margins.left;if("top"in a)this.offset.click.top=a.top+this.margins.top;if("bottom"in a)this.offset.click.top=
this.helperProportions.height-a.bottom+this.margins.top},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var a=this.offsetParent.offset();if(this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0])){a.left+=this.scrollParent.scrollLeft();a.top+=this.scrollParent.scrollTop()}if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&d.browser.msie)a=
{top:0,left:0};return{top:a.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:a.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.currentItem.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}else return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),
10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var a=this.options;if(a.containment=="parent")a.containment=this.helper[0].parentNode;if(a.containment=="document"||a.containment=="window")this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,d(a.containment=="document"?
document:window).width()-this.helperProportions.width-this.margins.left,(d(a.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(a.containment)){var b=d(a.containment)[0];a=d(a.containment).offset();var c=d(b).css("overflow")!="hidden";this.containment=[a.left+(parseInt(d(b).css("borderLeftWidth"),10)||0)+(parseInt(d(b).css("paddingLeft"),10)||0)-this.margins.left,a.top+(parseInt(d(b).css("borderTopWidth"),
10)||0)+(parseInt(d(b).css("paddingTop"),10)||0)-this.margins.top,a.left+(c?Math.max(b.scrollWidth,b.offsetWidth):b.offsetWidth)-(parseInt(d(b).css("borderLeftWidth"),10)||0)-(parseInt(d(b).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,a.top+(c?Math.max(b.scrollHeight,b.offsetHeight):b.offsetHeight)-(parseInt(d(b).css("borderTopWidth"),10)||0)-(parseInt(d(b).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}},_convertPositionTo:function(a,b){if(!b)b=
this.position;a=a=="absolute"?1:-1;var c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(c[0].tagName);return{top:b.top+this.offset.relative.top*a+this.offset.parent.top*a-(d.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:c.scrollTop())*a),left:b.left+this.offset.relative.left*a+this.offset.parent.left*a-(d.browser.safari&&
this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:c.scrollLeft())*a)}},_generatePosition:function(a){var b=this.options,c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(c[0].tagName);if(this.cssPosition=="relative"&&!(this.scrollParent[0]!=document&&this.scrollParent[0]!=this.offsetParent[0]))this.offset.relative=this._getRelativeOffset();
var f=a.pageX,g=a.pageY;if(this.originalPosition){if(this.containment){if(a.pageX-this.offset.click.left<this.containment[0])f=this.containment[0]+this.offset.click.left;if(a.pageY-this.offset.click.top<this.containment[1])g=this.containment[1]+this.offset.click.top;if(a.pageX-this.offset.click.left>this.containment[2])f=this.containment[2]+this.offset.click.left;if(a.pageY-this.offset.click.top>this.containment[3])g=this.containment[3]+this.offset.click.top}if(b.grid){g=this.originalPageY+Math.round((g-
this.originalPageY)/b.grid[1])*b.grid[1];g=this.containment?!(g-this.offset.click.top<this.containment[1]||g-this.offset.click.top>this.containment[3])?g:!(g-this.offset.click.top<this.containment[1])?g-b.grid[1]:g+b.grid[1]:g;f=this.originalPageX+Math.round((f-this.originalPageX)/b.grid[0])*b.grid[0];f=this.containment?!(f-this.offset.click.left<this.containment[0]||f-this.offset.click.left>this.containment[2])?f:!(f-this.offset.click.left<this.containment[0])?f-b.grid[0]:f+b.grid[0]:f}}return{top:g-
this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(d.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:c.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(d.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:c.scrollLeft())}},_rearrange:function(a,b,c,e){c?c[0].appendChild(this.placeholder[0]):b.item[0].parentNode.insertBefore(this.placeholder[0],
this.direction=="down"?b.item[0]:b.item[0].nextSibling);this.counter=this.counter?++this.counter:1;var f=this,g=this.counter;window.setTimeout(function(){g==f.counter&&f.refreshPositions(!e)},0)},_clear:function(a,b){this.reverting=false;var c=[];!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem);this._noFinalSort=null;if(this.helper[0]==this.currentItem[0]){for(var e in this._storedCSS)if(this._storedCSS[e]=="auto"||this._storedCSS[e]=="static")this._storedCSS[e]=
"";this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();this.fromOutside&&!b&&c.push(function(f){this._trigger("receive",f,this._uiHash(this.fromOutside))});if((this.fromOutside||this.domPosition.prev!=this.currentItem.prev().not(".ui-sortable-helper")[0]||this.domPosition.parent!=this.currentItem.parent()[0])&&!b)c.push(function(f){this._trigger("update",f,this._uiHash())});if(!d.ui.contains(this.element[0],this.currentItem[0])){b||c.push(function(f){this._trigger("remove",
f,this._uiHash())});for(e=this.containers.length-1;e>=0;e--)if(d.ui.contains(this.containers[e].element[0],this.currentItem[0])&&!b){c.push(function(f){return function(g){f._trigger("receive",g,this._uiHash(this))}}.call(this,this.containers[e]));c.push(function(f){return function(g){f._trigger("update",g,this._uiHash(this))}}.call(this,this.containers[e]))}}for(e=this.containers.length-1;e>=0;e--){b||c.push(function(f){return function(g){f._trigger("deactivate",g,this._uiHash(this))}}.call(this,
this.containers[e]));if(this.containers[e].containerCache.over){c.push(function(f){return function(g){f._trigger("out",g,this._uiHash(this))}}.call(this,this.containers[e]));this.containers[e].containerCache.over=0}}this._storedCursor&&d("body").css("cursor",this._storedCursor);this._storedOpacity&&this.helper.css("opacity",this._storedOpacity);if(this._storedZIndex)this.helper.css("zIndex",this._storedZIndex=="auto"?"":this._storedZIndex);this.dragging=false;if(this.cancelHelperRemoval){if(!b){this._trigger("beforeStop",
a,this._uiHash());for(e=0;e<c.length;e++)c[e].call(this,a);this._trigger("stop",a,this._uiHash())}return false}b||this._trigger("beforeStop",a,this._uiHash());this.placeholder[0].parentNode.removeChild(this.placeholder[0]);this.helper[0]!=this.currentItem[0]&&this.helper.remove();this.helper=null;if(!b){for(e=0;e<c.length;e++)c[e].call(this,a);this._trigger("stop",a,this._uiHash())}this.fromOutside=false;return true},_trigger:function(){d.Widget.prototype._trigger.apply(this,arguments)===false&&this.cancel()},
_uiHash:function(a){var b=a||this;return{helper:b.helper,placeholder:b.placeholder||d([]),position:b.position,originalPosition:b.originalPosition,offset:b.positionAbs,item:b.currentItem,sender:a?a.element:null}}});d.extend(d.ui.sortable,{version:"1.8.15"})})(jQuery);
;/*
 * jQuery UI Accordion 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Accordion
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(c){c.widget("ui.accordion",{options:{active:0,animated:"slide",autoHeight:true,clearStyle:false,collapsible:false,event:"click",fillSpace:false,header:"> li > :first-child,> :not(li):even",icons:{header:"ui-icon-triangle-1-e",headerSelected:"ui-icon-triangle-1-s"},navigation:false,navigationFilter:function(){return this.href.toLowerCase()===location.href.toLowerCase()}},_create:function(){var a=this,b=a.options;a.running=0;a.element.addClass("ui-accordion ui-widget ui-helper-reset").children("li").addClass("ui-accordion-li-fix");
a.headers=a.element.find(b.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all").bind("mouseenter.accordion",function(){b.disabled||c(this).addClass("ui-state-hover")}).bind("mouseleave.accordion",function(){b.disabled||c(this).removeClass("ui-state-hover")}).bind("focus.accordion",function(){b.disabled||c(this).addClass("ui-state-focus")}).bind("blur.accordion",function(){b.disabled||c(this).removeClass("ui-state-focus")});a.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom");
if(b.navigation){var d=a.element.find("a").filter(b.navigationFilter).eq(0);if(d.length){var h=d.closest(".ui-accordion-header");a.active=h.length?h:d.closest(".ui-accordion-content").prev()}}a.active=a._findActive(a.active||b.active).addClass("ui-state-default ui-state-active").toggleClass("ui-corner-all").toggleClass("ui-corner-top");a.active.next().addClass("ui-accordion-content-active");a._createIcons();a.resize();a.element.attr("role","tablist");a.headers.attr("role","tab").bind("keydown.accordion",
function(f){return a._keydown(f)}).next().attr("role","tabpanel");a.headers.not(a.active||"").attr({"aria-expanded":"false","aria-selected":"false",tabIndex:-1}).next().hide();a.active.length?a.active.attr({"aria-expanded":"true","aria-selected":"true",tabIndex:0}):a.headers.eq(0).attr("tabIndex",0);c.browser.safari||a.headers.find("a").attr("tabIndex",-1);b.event&&a.headers.bind(b.event.split(" ").join(".accordion ")+".accordion",function(f){a._clickHandler.call(a,f,this);f.preventDefault()})},_createIcons:function(){var a=
this.options;if(a.icons){c("<span></span>").addClass("ui-icon "+a.icons.header).prependTo(this.headers);this.active.children(".ui-icon").toggleClass(a.icons.header).toggleClass(a.icons.headerSelected);this.element.addClass("ui-accordion-icons")}},_destroyIcons:function(){this.headers.children(".ui-icon").remove();this.element.removeClass("ui-accordion-icons")},destroy:function(){var a=this.options;this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role");this.headers.unbind(".accordion").removeClass("ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("tabIndex");
this.headers.find("a").removeAttr("tabIndex");this._destroyIcons();var b=this.headers.next().css("display","").removeAttr("role").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled");if(a.autoHeight||a.fillHeight)b.css("height","");return c.Widget.prototype.destroy.call(this)},_setOption:function(a,b){c.Widget.prototype._setOption.apply(this,arguments);a=="active"&&this.activate(b);if(a=="icons"){this._destroyIcons();
b&&this._createIcons()}if(a=="disabled")this.headers.add(this.headers.next())[b?"addClass":"removeClass"]("ui-accordion-disabled ui-state-disabled")},_keydown:function(a){if(!(this.options.disabled||a.altKey||a.ctrlKey)){var b=c.ui.keyCode,d=this.headers.length,h=this.headers.index(a.target),f=false;switch(a.keyCode){case b.RIGHT:case b.DOWN:f=this.headers[(h+1)%d];break;case b.LEFT:case b.UP:f=this.headers[(h-1+d)%d];break;case b.SPACE:case b.ENTER:this._clickHandler({target:a.target},a.target);
a.preventDefault()}if(f){c(a.target).attr("tabIndex",-1);c(f).attr("tabIndex",0);f.focus();return false}return true}},resize:function(){var a=this.options,b;if(a.fillSpace){if(c.browser.msie){var d=this.element.parent().css("overflow");this.element.parent().css("overflow","hidden")}b=this.element.parent().height();c.browser.msie&&this.element.parent().css("overflow",d);this.headers.each(function(){b-=c(this).outerHeight(true)});this.headers.next().each(function(){c(this).height(Math.max(0,b-c(this).innerHeight()+
c(this).height()))}).css("overflow","auto")}else if(a.autoHeight){b=0;this.headers.next().each(function(){b=Math.max(b,c(this).height("").height())}).height(b)}return this},activate:function(a){this.options.active=a;a=this._findActive(a)[0];this._clickHandler({target:a},a);return this},_findActive:function(a){return a?typeof a==="number"?this.headers.filter(":eq("+a+")"):this.headers.not(this.headers.not(a)):a===false?c([]):this.headers.filter(":eq(0)")},_clickHandler:function(a,b){var d=this.options;
if(!d.disabled)if(a.target){a=c(a.currentTarget||b);b=a[0]===this.active[0];d.active=d.collapsible&&b?false:this.headers.index(a);if(!(this.running||!d.collapsible&&b)){var h=this.active;j=a.next();g=this.active.next();e={options:d,newHeader:b&&d.collapsible?c([]):a,oldHeader:this.active,newContent:b&&d.collapsible?c([]):j,oldContent:g};var f=this.headers.index(this.active[0])>this.headers.index(a[0]);this.active=b?c([]):a;this._toggle(j,g,e,b,f);h.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header);
if(!b){a.removeClass("ui-state-default ui-corner-all").addClass("ui-state-active ui-corner-top").children(".ui-icon").removeClass(d.icons.header).addClass(d.icons.headerSelected);a.next().addClass("ui-accordion-content-active")}}}else if(d.collapsible){this.active.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header);this.active.next().addClass("ui-accordion-content-active");var g=this.active.next(),
e={options:d,newHeader:c([]),oldHeader:d.active,newContent:c([]),oldContent:g},j=this.active=c([]);this._toggle(j,g,e)}},_toggle:function(a,b,d,h,f){var g=this,e=g.options;g.toShow=a;g.toHide=b;g.data=d;var j=function(){if(g)return g._completed.apply(g,arguments)};g._trigger("changestart",null,g.data);g.running=b.size()===0?a.size():b.size();if(e.animated){d={};d=e.collapsible&&h?{toShow:c([]),toHide:b,complete:j,down:f,autoHeight:e.autoHeight||e.fillSpace}:{toShow:a,toHide:b,complete:j,down:f,autoHeight:e.autoHeight||
e.fillSpace};if(!e.proxied)e.proxied=e.animated;if(!e.proxiedDuration)e.proxiedDuration=e.duration;e.animated=c.isFunction(e.proxied)?e.proxied(d):e.proxied;e.duration=c.isFunction(e.proxiedDuration)?e.proxiedDuration(d):e.proxiedDuration;h=c.ui.accordion.animations;var i=e.duration,k=e.animated;if(k&&!h[k]&&!c.easing[k])k="slide";h[k]||(h[k]=function(l){this.slide(l,{easing:k,duration:i||700})});h[k](d)}else{if(e.collapsible&&h)a.toggle();else{b.hide();a.show()}j(true)}b.prev().attr({"aria-expanded":"false",
"aria-selected":"false",tabIndex:-1}).blur();a.prev().attr({"aria-expanded":"true","aria-selected":"true",tabIndex:0}).focus()},_completed:function(a){this.running=a?0:--this.running;if(!this.running){this.options.clearStyle&&this.toShow.add(this.toHide).css({height:"",overflow:""});this.toHide.removeClass("ui-accordion-content-active");if(this.toHide.length)this.toHide.parent()[0].className=this.toHide.parent()[0].className;this._trigger("change",null,this.data)}}});c.extend(c.ui.accordion,{version:"1.8.15",
animations:{slide:function(a,b){a=c.extend({easing:"swing",duration:300},a,b);if(a.toHide.size())if(a.toShow.size()){var d=a.toShow.css("overflow"),h=0,f={},g={},e;b=a.toShow;e=b[0].style.width;b.width(parseInt(b.parent().width(),10)-parseInt(b.css("paddingLeft"),10)-parseInt(b.css("paddingRight"),10)-(parseInt(b.css("borderLeftWidth"),10)||0)-(parseInt(b.css("borderRightWidth"),10)||0));c.each(["height","paddingTop","paddingBottom"],function(j,i){g[i]="hide";j=(""+c.css(a.toShow[0],i)).match(/^([\d+-.]+)(.*)$/);
f[i]={value:j[1],unit:j[2]||"px"}});a.toShow.css({height:0,overflow:"hidden"}).show();a.toHide.filter(":hidden").each(a.complete).end().filter(":visible").animate(g,{step:function(j,i){if(i.prop=="height")h=i.end-i.start===0?0:(i.now-i.start)/(i.end-i.start);a.toShow[0].style[i.prop]=h*f[i.prop].value+f[i.prop].unit},duration:a.duration,easing:a.easing,complete:function(){a.autoHeight||a.toShow.css("height","");a.toShow.css({width:e,overflow:d});a.complete()}})}else a.toHide.animate({height:"hide",
paddingTop:"hide",paddingBottom:"hide"},a);else a.toShow.animate({height:"show",paddingTop:"show",paddingBottom:"show"},a)},bounceslide:function(a){this.slide(a,{easing:a.down?"easeOutBounce":"swing",duration:a.down?1E3:200})}}})})(jQuery);
;/*
 * jQuery UI Autocomplete 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
(function(d){var e=0;d.widget("ui.autocomplete",{options:{appendTo:"body",autoFocus:false,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null},pending:0,_create:function(){var a=this,b=this.element[0].ownerDocument,g;this.element.addClass("ui-autocomplete-input").attr("autocomplete","off").attr({role:"textbox","aria-autocomplete":"list","aria-haspopup":"true"}).bind("keydown.autocomplete",function(c){if(!(a.options.disabled||a.element.propAttr("readOnly"))){g=
false;var f=d.ui.keyCode;switch(c.keyCode){case f.PAGE_UP:a._move("previousPage",c);break;case f.PAGE_DOWN:a._move("nextPage",c);break;case f.UP:a._move("previous",c);c.preventDefault();break;case f.DOWN:a._move("next",c);c.preventDefault();break;case f.ENTER:case f.NUMPAD_ENTER:if(a.menu.active){g=true;c.preventDefault()}case f.TAB:if(!a.menu.active)return;a.menu.select(c);break;case f.ESCAPE:a.element.val(a.term);a.close(c);break;default:clearTimeout(a.searching);a.searching=setTimeout(function(){if(a.term!=
a.element.val()){a.selectedItem=null;a.search(null,c)}},a.options.delay);break}}}).bind("keypress.autocomplete",function(c){if(g){g=false;c.preventDefault()}}).bind("focus.autocomplete",function(){if(!a.options.disabled){a.selectedItem=null;a.previous=a.element.val()}}).bind("blur.autocomplete",function(c){if(!a.options.disabled){clearTimeout(a.searching);a.closing=setTimeout(function(){a.close(c);a._change(c)},150)}});this._initSource();this.response=function(){return a._response.apply(a,arguments)};
this.menu=d("<ul></ul>").addClass("ui-autocomplete").appendTo(d(this.options.appendTo||"body",b)[0]).mousedown(function(c){var f=a.menu.element[0];d(c.target).closest(".ui-menu-item").length||setTimeout(function(){d(document).one("mousedown",function(h){h.target!==a.element[0]&&h.target!==f&&!d.ui.contains(f,h.target)&&a.close()})},1);setTimeout(function(){clearTimeout(a.closing)},13)}).menu({focus:function(c,f){f=f.item.data("item.autocomplete");false!==a._trigger("focus",c,{item:f})&&/^key/.test(c.originalEvent.type)&&
a.element.val(f.value)},selected:function(c,f){var h=f.item.data("item.autocomplete"),i=a.previous;if(a.element[0]!==b.activeElement){a.element.focus();a.previous=i;setTimeout(function(){a.previous=i;a.selectedItem=h},1)}false!==a._trigger("select",c,{item:h})&&a.element.val(h.value);a.term=a.element.val();a.close(c);a.selectedItem=h},blur:function(){a.menu.element.is(":visible")&&a.element.val()!==a.term&&a.element.val(a.term)}}).zIndex(this.element.zIndex()+1).css({top:0,left:0}).hide().data("menu");
d.fn.bgiframe&&this.menu.element.bgiframe()},destroy:function(){this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete").removeAttr("role").removeAttr("aria-autocomplete").removeAttr("aria-haspopup");this.menu.element.remove();d.Widget.prototype.destroy.call(this)},_setOption:function(a,b){d.Widget.prototype._setOption.apply(this,arguments);a==="source"&&this._initSource();if(a==="appendTo")this.menu.element.appendTo(d(b||"body",this.element[0].ownerDocument)[0]);a==="disabled"&&
b&&this.xhr&&this.xhr.abort()},_initSource:function(){var a=this,b,g;if(d.isArray(this.options.source)){b=this.options.source;this.source=function(c,f){f(d.ui.autocomplete.filter(b,c.term))}}else if(typeof this.options.source==="string"){g=this.options.source;this.source=function(c,f){a.xhr&&a.xhr.abort();a.xhr=d.ajax({url:g,data:c,dataType:"json",autocompleteRequest:++e,success:function(h){this.autocompleteRequest===e&&f(h)},error:function(){this.autocompleteRequest===e&&f([])}})}}else this.source=
this.options.source},search:function(a,b){a=a!=null?a:this.element.val();this.term=this.element.val();if(a.length<this.options.minLength)return this.close(b);clearTimeout(this.closing);if(this._trigger("search",b)!==false)return this._search(a)},_search:function(a){this.pending++;this.element.addClass("ui-autocomplete-loading");this.source({term:a},this.response)},_response:function(a){if(!this.options.disabled&&a&&a.length){a=this._normalize(a);this._suggest(a);this._trigger("open")}else this.close();
this.pending--;this.pending||this.element.removeClass("ui-autocomplete-loading")},close:function(a){clearTimeout(this.closing);if(this.menu.element.is(":visible")){this.menu.element.hide();this.menu.deactivate();this._trigger("close",a)}},_change:function(a){this.previous!==this.element.val()&&this._trigger("change",a,{item:this.selectedItem})},_normalize:function(a){if(a.length&&a[0].label&&a[0].value)return a;return d.map(a,function(b){if(typeof b==="string")return{label:b,value:b};return d.extend({label:b.label||
b.value,value:b.value||b.label},b)})},_suggest:function(a){var b=this.menu.element.empty().zIndex(this.element.zIndex()+1);this._renderMenu(b,a);this.menu.deactivate();this.menu.refresh();b.show();this._resizeMenu();b.position(d.extend({of:this.element},this.options.position));this.options.autoFocus&&this.menu.next(new d.Event("mouseover"))},_resizeMenu:function(){var a=this.menu.element;a.outerWidth(Math.max(a.width("").outerWidth(),this.element.outerWidth()))},_renderMenu:function(a,b){var g=this;
d.each(b,function(c,f){g._renderItem(a,f)})},_renderItem:function(a,b){return d("<li></li>").data("item.autocomplete",b).append(d("<a></a>").text(b.label)).appendTo(a)},_move:function(a,b){if(this.menu.element.is(":visible"))if(this.menu.first()&&/^previous/.test(a)||this.menu.last()&&/^next/.test(a)){this.element.val(this.term);this.menu.deactivate()}else this.menu[a](b);else this.search(null,b)},widget:function(){return this.menu.element}});d.extend(d.ui.autocomplete,{escapeRegex:function(a){return a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,
"\\$&")},filter:function(a,b){var g=new RegExp(d.ui.autocomplete.escapeRegex(b),"i");return d.grep(a,function(c){return g.test(c.label||c.value||c)})}})})(jQuery);
(function(d){d.widget("ui.menu",{_create:function(){var e=this;this.element.addClass("ui-menu ui-widget ui-widget-content ui-corner-all").attr({role:"listbox","aria-activedescendant":"ui-active-menuitem"}).click(function(a){if(d(a.target).closest(".ui-menu-item a").length){a.preventDefault();e.select(a)}});this.refresh()},refresh:function(){var e=this;this.element.children("li:not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role","menuitem").children("a").addClass("ui-corner-all").attr("tabindex",
-1).mouseenter(function(a){e.activate(a,d(this).parent())}).mouseleave(function(){e.deactivate()})},activate:function(e,a){this.deactivate();if(this.hasScroll()){var b=a.offset().top-this.element.offset().top,g=this.element.scrollTop(),c=this.element.height();if(b<0)this.element.scrollTop(g+b);else b>=c&&this.element.scrollTop(g+b-c+a.height())}this.active=a.eq(0).children("a").addClass("ui-state-hover").attr("id","ui-active-menuitem").end();this._trigger("focus",e,{item:a})},deactivate:function(){if(this.active){this.active.children("a").removeClass("ui-state-hover").removeAttr("id");
this._trigger("blur");this.active=null}},next:function(e){this.move("next",".ui-menu-item:first",e)},previous:function(e){this.move("prev",".ui-menu-item:last",e)},first:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},last:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},move:function(e,a,b){if(this.active){e=this.active[e+"All"](".ui-menu-item").eq(0);e.length?this.activate(b,e):this.activate(b,this.element.children(a))}else this.activate(b,
this.element.children(a))},nextPage:function(e){if(this.hasScroll())if(!this.active||this.last())this.activate(e,this.element.children(".ui-menu-item:first"));else{var a=this.active.offset().top,b=this.element.height(),g=this.element.children(".ui-menu-item").filter(function(){var c=d(this).offset().top-a-b+d(this).height();return c<10&&c>-10});g.length||(g=this.element.children(".ui-menu-item:last"));this.activate(e,g)}else this.activate(e,this.element.children(".ui-menu-item").filter(!this.active||
this.last()?":first":":last"))},previousPage:function(e){if(this.hasScroll())if(!this.active||this.first())this.activate(e,this.element.children(".ui-menu-item:last"));else{var a=this.active.offset().top,b=this.element.height();result=this.element.children(".ui-menu-item").filter(function(){var g=d(this).offset().top-a+b-d(this).height();return g<10&&g>-10});result.length||(result=this.element.children(".ui-menu-item:first"));this.activate(e,result)}else this.activate(e,this.element.children(".ui-menu-item").filter(!this.active||
this.first()?":last":":first"))},hasScroll:function(){return this.element.height()<this.element[d.fn.prop?"prop":"attr"]("scrollHeight")},select:function(e){this._trigger("selected",e,{item:this.active})}})})(jQuery);
;/*
 * jQuery UI Button 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(b){var h,i,j,g,l=function(){var a=b(this).find(":ui-button");setTimeout(function(){a.button("refresh")},1)},k=function(a){var c=a.name,e=a.form,f=b([]);if(c)f=e?b(e).find("[name='"+c+"']"):b("[name='"+c+"']",a.ownerDocument).filter(function(){return!this.form});return f};b.widget("ui.button",{options:{disabled:null,text:true,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset.button").bind("reset.button",l);if(typeof this.options.disabled!==
"boolean")this.options.disabled=this.element.propAttr("disabled");this._determineButtonType();this.hasTitle=!!this.buttonElement.attr("title");var a=this,c=this.options,e=this.type==="checkbox"||this.type==="radio",f="ui-state-hover"+(!e?" ui-state-active":"");if(c.label===null)c.label=this.buttonElement.html();if(this.element.is(":disabled"))c.disabled=true;this.buttonElement.addClass("ui-button ui-widget ui-state-default ui-corner-all").attr("role","button").bind("mouseenter.button",function(){if(!c.disabled){b(this).addClass("ui-state-hover");
this===h&&b(this).addClass("ui-state-active")}}).bind("mouseleave.button",function(){c.disabled||b(this).removeClass(f)}).bind("click.button",function(d){if(c.disabled){d.preventDefault();d.stopImmediatePropagation()}});this.element.bind("focus.button",function(){a.buttonElement.addClass("ui-state-focus")}).bind("blur.button",function(){a.buttonElement.removeClass("ui-state-focus")});if(e){this.element.bind("change.button",function(){g||a.refresh()});this.buttonElement.bind("mousedown.button",function(d){if(!c.disabled){g=
false;i=d.pageX;j=d.pageY}}).bind("mouseup.button",function(d){if(!c.disabled)if(i!==d.pageX||j!==d.pageY)g=true})}if(this.type==="checkbox")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).toggleClass("ui-state-active");a.buttonElement.attr("aria-pressed",a.element[0].checked)});else if(this.type==="radio")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).addClass("ui-state-active");a.buttonElement.attr("aria-pressed","true");
var d=a.element[0];k(d).not(d).map(function(){return b(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")});else{this.buttonElement.bind("mousedown.button",function(){if(c.disabled)return false;b(this).addClass("ui-state-active");h=this;b(document).one("mouseup",function(){h=null})}).bind("mouseup.button",function(){if(c.disabled)return false;b(this).removeClass("ui-state-active")}).bind("keydown.button",function(d){if(c.disabled)return false;if(d.keyCode==b.ui.keyCode.SPACE||
d.keyCode==b.ui.keyCode.ENTER)b(this).addClass("ui-state-active")}).bind("keyup.button",function(){b(this).removeClass("ui-state-active")});this.buttonElement.is("a")&&this.buttonElement.keyup(function(d){d.keyCode===b.ui.keyCode.SPACE&&b(this).click()})}this._setOption("disabled",c.disabled);this._resetButton()},_determineButtonType:function(){this.type=this.element.is(":checkbox")?"checkbox":this.element.is(":radio")?"radio":this.element.is("input")?"input":"button";if(this.type==="checkbox"||this.type===
"radio"){var a=this.element.parents().filter(":last"),c="label[for="+this.element.attr("id")+"]";this.buttonElement=a.find(c);if(!this.buttonElement.length){a=a.length?a.siblings():this.element.siblings();this.buttonElement=a.filter(c);if(!this.buttonElement.length)this.buttonElement=a.find(c)}this.element.addClass("ui-helper-hidden-accessible");(a=this.element.is(":checked"))&&this.buttonElement.addClass("ui-state-active");this.buttonElement.attr("aria-pressed",a)}else this.buttonElement=this.element},
widget:function(){return this.buttonElement},destroy:function(){this.element.removeClass("ui-helper-hidden-accessible");this.buttonElement.removeClass("ui-button ui-widget ui-state-default ui-corner-all ui-state-hover ui-state-active  ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only").removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());this.hasTitle||this.buttonElement.removeAttr("title");
b.Widget.prototype.destroy.call(this)},_setOption:function(a,c){b.Widget.prototype._setOption.apply(this,arguments);if(a==="disabled")c?this.element.propAttr("disabled",true):this.element.propAttr("disabled",false);else this._resetButton()},refresh:function(){var a=this.element.is(":disabled");a!==this.options.disabled&&this._setOption("disabled",a);if(this.type==="radio")k(this.element[0]).each(function(){b(this).is(":checked")?b(this).button("widget").addClass("ui-state-active").attr("aria-pressed",
"true"):b(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")});else if(this.type==="checkbox")this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false")},_resetButton:function(){if(this.type==="input")this.options.label&&this.element.val(this.options.label);else{var a=this.buttonElement.removeClass("ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only"),
c=b("<span></span>").addClass("ui-button-text").html(this.options.label).appendTo(a.empty()).text(),e=this.options.icons,f=e.primary&&e.secondary,d=[];if(e.primary||e.secondary){if(this.options.text)d.push("ui-button-text-icon"+(f?"s":e.primary?"-primary":"-secondary"));e.primary&&a.prepend("<span class='ui-button-icon-primary ui-icon "+e.primary+"'></span>");e.secondary&&a.append("<span class='ui-button-icon-secondary ui-icon "+e.secondary+"'></span>");if(!this.options.text){d.push(f?"ui-button-icons-only":
"ui-button-icon-only");this.hasTitle||a.attr("title",c)}}else d.push("ui-button-text-only");a.addClass(d.join(" "))}}});b.widget("ui.buttonset",{options:{items:":button, :submit, :reset, :checkbox, :radio, a, :data(button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(a,c){a==="disabled"&&this.buttons.button("option",a,c);b.Widget.prototype._setOption.apply(this,arguments)},refresh:function(){var a=this.element.css("direction")===
"ltr";this.buttons=this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(a?"ui-corner-left":"ui-corner-right").end().filter(":last").addClass(a?"ui-corner-right":"ui-corner-left").end().end()},destroy:function(){this.element.removeClass("ui-buttonset");this.buttons.map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
b.Widget.prototype.destroy.call(this)}})})(jQuery);
;/*
 * jQuery UI Dialog 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function(c,l){var m={buttons:true,height:true,maxHeight:true,maxWidth:true,minHeight:true,minWidth:true,width:true},n={maxHeight:true,maxWidth:true,minHeight:true,minWidth:true},o=c.attrFn||{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true,click:true};c.widget("ui.dialog",{options:{autoOpen:true,buttons:{},closeOnEscape:true,closeText:"close",dialogClass:"",draggable:true,hide:null,height:"auto",maxHeight:false,maxWidth:false,minHeight:150,minWidth:150,modal:false,
position:{my:"center",at:"center",collision:"fit",using:function(a){var b=c(this).css(a).offset().top;b<0&&c(this).css("top",a.top-b)}},resizable:true,show:null,stack:true,title:"",width:300,zIndex:1E3},_create:function(){this.originalTitle=this.element.attr("title");if(typeof this.originalTitle!=="string")this.originalTitle="";this.options.title=this.options.title||this.originalTitle;var a=this,b=a.options,d=b.title||"&#160;",e=c.ui.dialog.getTitleId(a.element),g=(a.uiDialog=c("<div></div>")).appendTo(document.body).hide().addClass("ui-dialog ui-widget ui-widget-content ui-corner-all "+
b.dialogClass).css({zIndex:b.zIndex}).attr("tabIndex",-1).css("outline",0).keydown(function(i){if(b.closeOnEscape&&i.keyCode&&i.keyCode===c.ui.keyCode.ESCAPE){a.close(i);i.preventDefault()}}).attr({role:"dialog","aria-labelledby":e}).mousedown(function(i){a.moveToTop(false,i)});a.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(g);var f=(a.uiDialogTitlebar=c("<div></div>")).addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(g),
h=c('<a href="#"></a>').addClass("ui-dialog-titlebar-close ui-corner-all").attr("role","button").hover(function(){h.addClass("ui-state-hover")},function(){h.removeClass("ui-state-hover")}).focus(function(){h.addClass("ui-state-focus")}).blur(function(){h.removeClass("ui-state-focus")}).click(function(i){a.close(i);return false}).appendTo(f);(a.uiDialogTitlebarCloseText=c("<span></span>")).addClass("ui-icon ui-icon-closethick").text(b.closeText).appendTo(h);c("<span></span>").addClass("ui-dialog-title").attr("id",
e).html(d).prependTo(f);if(c.isFunction(b.beforeclose)&&!c.isFunction(b.beforeClose))b.beforeClose=b.beforeclose;f.find("*").add(f).disableSelection();b.draggable&&c.fn.draggable&&a._makeDraggable();b.resizable&&c.fn.resizable&&a._makeResizable();a._createButtons(b.buttons);a._isOpen=false;c.fn.bgiframe&&g.bgiframe()},_init:function(){this.options.autoOpen&&this.open()},destroy:function(){var a=this;a.overlay&&a.overlay.destroy();a.uiDialog.hide();a.element.unbind(".dialog").removeData("dialog").removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body");
a.uiDialog.remove();a.originalTitle&&a.element.attr("title",a.originalTitle);return a},widget:function(){return this.uiDialog},close:function(a){var b=this,d,e;if(false!==b._trigger("beforeClose",a)){b.overlay&&b.overlay.destroy();b.uiDialog.unbind("keypress.ui-dialog");b._isOpen=false;if(b.options.hide)b.uiDialog.hide(b.options.hide,function(){b._trigger("close",a)});else{b.uiDialog.hide();b._trigger("close",a)}c.ui.dialog.overlay.resize();if(b.options.modal){d=0;c(".ui-dialog").each(function(){if(this!==
b.uiDialog[0]){e=c(this).css("z-index");isNaN(e)||(d=Math.max(d,e))}});c.ui.dialog.maxZ=d}return b}},isOpen:function(){return this._isOpen},moveToTop:function(a,b){var d=this,e=d.options;if(e.modal&&!a||!e.stack&&!e.modal)return d._trigger("focus",b);if(e.zIndex>c.ui.dialog.maxZ)c.ui.dialog.maxZ=e.zIndex;if(d.overlay){c.ui.dialog.maxZ+=1;d.overlay.$el.css("z-index",c.ui.dialog.overlay.maxZ=c.ui.dialog.maxZ)}a={scrollTop:d.element.scrollTop(),scrollLeft:d.element.scrollLeft()};c.ui.dialog.maxZ+=1;
d.uiDialog.css("z-index",c.ui.dialog.maxZ);d.element.attr(a);d._trigger("focus",b);return d},open:function(){if(!this._isOpen){var a=this,b=a.options,d=a.uiDialog;a.overlay=b.modal?new c.ui.dialog.overlay(a):null;a._size();a._position(b.position);d.show(b.show);a.moveToTop(true);b.modal&&d.bind("keypress.ui-dialog",function(e){if(e.keyCode===c.ui.keyCode.TAB){var g=c(":tabbable",this),f=g.filter(":first");g=g.filter(":last");if(e.target===g[0]&&!e.shiftKey){f.focus(1);return false}else if(e.target===
f[0]&&e.shiftKey){g.focus(1);return false}}});c(a.element.find(":tabbable").get().concat(d.find(".ui-dialog-buttonpane :tabbable").get().concat(d.get()))).eq(0).focus();a._isOpen=true;a._trigger("open");return a}},_createButtons:function(a){var b=this,d=false,e=c("<div></div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),g=c("<div></div>").addClass("ui-dialog-buttonset").appendTo(e);b.uiDialog.find(".ui-dialog-buttonpane").remove();typeof a==="object"&&a!==null&&c.each(a,
function(){return!(d=true)});if(d){c.each(a,function(f,h){h=c.isFunction(h)?{click:h,text:f}:h;var i=c('<button type="button"></button>').click(function(){h.click.apply(b.element[0],arguments)}).appendTo(g);c.each(h,function(j,k){if(j!=="click")j in o?i[j](k):i.attr(j,k)});c.fn.button&&i.button()});e.appendTo(b.uiDialog)}},_makeDraggable:function(){function a(f){return{position:f.position,offset:f.offset}}var b=this,d=b.options,e=c(document),g;b.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",
handle:".ui-dialog-titlebar",containment:"document",start:function(f,h){g=d.height==="auto"?"auto":c(this).height();c(this).height(c(this).height()).addClass("ui-dialog-dragging");b._trigger("dragStart",f,a(h))},drag:function(f,h){b._trigger("drag",f,a(h))},stop:function(f,h){d.position=[h.position.left-e.scrollLeft(),h.position.top-e.scrollTop()];c(this).removeClass("ui-dialog-dragging").height(g);b._trigger("dragStop",f,a(h));c.ui.dialog.overlay.resize()}})},_makeResizable:function(a){function b(f){return{originalPosition:f.originalPosition,
originalSize:f.originalSize,position:f.position,size:f.size}}a=a===l?this.options.resizable:a;var d=this,e=d.options,g=d.uiDialog.css("position");a=typeof a==="string"?a:"n,e,s,w,se,sw,ne,nw";d.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:d.element,maxWidth:e.maxWidth,maxHeight:e.maxHeight,minWidth:e.minWidth,minHeight:d._minHeight(),handles:a,start:function(f,h){c(this).addClass("ui-dialog-resizing");d._trigger("resizeStart",f,b(h))},resize:function(f,h){d._trigger("resize",
f,b(h))},stop:function(f,h){c(this).removeClass("ui-dialog-resizing");e.height=c(this).height();e.width=c(this).width();d._trigger("resizeStop",f,b(h));c.ui.dialog.overlay.resize()}}).css("position",g).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se")},_minHeight:function(){var a=this.options;return a.height==="auto"?a.minHeight:Math.min(a.minHeight,a.height)},_position:function(a){var b=[],d=[0,0],e;if(a){if(typeof a==="string"||typeof a==="object"&&"0"in a){b=a.split?a.split(" "):
[a[0],a[1]];if(b.length===1)b[1]=b[0];c.each(["left","top"],function(g,f){if(+b[g]===b[g]){d[g]=b[g];b[g]=f}});a={my:b.join(" "),at:b.join(" "),offset:d.join(" ")}}a=c.extend({},c.ui.dialog.prototype.options.position,a)}else a=c.ui.dialog.prototype.options.position;(e=this.uiDialog.is(":visible"))||this.uiDialog.show();this.uiDialog.css({top:0,left:0}).position(c.extend({of:window},a));e||this.uiDialog.hide()},_setOptions:function(a){var b=this,d={},e=false;c.each(a,function(g,f){b._setOption(g,f);
if(g in m)e=true;if(g in n)d[g]=f});e&&this._size();this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option",d)},_setOption:function(a,b){var d=this,e=d.uiDialog;switch(a){case "beforeclose":a="beforeClose";break;case "buttons":d._createButtons(b);break;case "closeText":d.uiDialogTitlebarCloseText.text(""+b);break;case "dialogClass":e.removeClass(d.options.dialogClass).addClass("ui-dialog ui-widget ui-widget-content ui-corner-all "+b);break;case "disabled":b?e.addClass("ui-dialog-disabled"):
e.removeClass("ui-dialog-disabled");break;case "draggable":var g=e.is(":data(draggable)");g&&!b&&e.draggable("destroy");!g&&b&&d._makeDraggable();break;case "position":d._position(b);break;case "resizable":(g=e.is(":data(resizable)"))&&!b&&e.resizable("destroy");g&&typeof b==="string"&&e.resizable("option","handles",b);!g&&b!==false&&d._makeResizable(b);break;case "title":c(".ui-dialog-title",d.uiDialogTitlebar).html(""+(b||"&#160;"));break}c.Widget.prototype._setOption.apply(d,arguments)},_size:function(){var a=
this.options,b,d,e=this.uiDialog.is(":visible");this.element.show().css({width:"auto",minHeight:0,height:0});if(a.minWidth>a.width)a.width=a.minWidth;b=this.uiDialog.css({height:"auto",width:a.width}).height();d=Math.max(0,a.minHeight-b);if(a.height==="auto")if(c.support.minHeight)this.element.css({minHeight:d,height:"auto"});else{this.uiDialog.show();a=this.element.css("height","auto").height();e||this.uiDialog.hide();this.element.height(Math.max(a,d))}else this.element.height(Math.max(a.height-
b,0));this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())}});c.extend(c.ui.dialog,{version:"1.8.15",uuid:0,maxZ:0,getTitleId:function(a){a=a.attr("id");if(!a){this.uuid+=1;a=this.uuid}return"ui-dialog-title-"+a},overlay:function(a){this.$el=c.ui.dialog.overlay.create(a)}});c.extend(c.ui.dialog.overlay,{instances:[],oldInstances:[],maxZ:0,events:c.map("focus,mousedown,mouseup,keydown,keypress,click".split(","),function(a){return a+".dialog-overlay"}).join(" "),
create:function(a){if(this.instances.length===0){setTimeout(function(){c.ui.dialog.overlay.instances.length&&c(document).bind(c.ui.dialog.overlay.events,function(d){if(c(d.target).zIndex()<c.ui.dialog.overlay.maxZ)return false})},1);c(document).bind("keydown.dialog-overlay",function(d){if(a.options.closeOnEscape&&d.keyCode&&d.keyCode===c.ui.keyCode.ESCAPE){a.close(d);d.preventDefault()}});c(window).bind("resize.dialog-overlay",c.ui.dialog.overlay.resize)}var b=(this.oldInstances.pop()||c("<div></div>").addClass("ui-widget-overlay")).appendTo(document.body).css({width:this.width(),
height:this.height()});c.fn.bgiframe&&b.bgiframe();this.instances.push(b);return b},destroy:function(a){var b=c.inArray(a,this.instances);b!=-1&&this.oldInstances.push(this.instances.splice(b,1)[0]);this.instances.length===0&&c([document,window]).unbind(".dialog-overlay");a.remove();var d=0;c.each(this.instances,function(){d=Math.max(d,this.css("z-index"))});this.maxZ=d},height:function(){var a,b;if(c.browser.msie&&c.browser.version<7){a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight);
b=Math.max(document.documentElement.offsetHeight,document.body.offsetHeight);return a<b?c(window).height()+"px":a+"px"}else return c(document).height()+"px"},width:function(){var a,b;if(c.browser.msie){a=Math.max(document.documentElement.scrollWidth,document.body.scrollWidth);b=Math.max(document.documentElement.offsetWidth,document.body.offsetWidth);return a<b?c(window).width()+"px":a+"px"}else return c(document).width()+"px"},resize:function(){var a=c([]);c.each(c.ui.dialog.overlay.instances,function(){a=
a.add(this)});a.css({width:0,height:0}).css({width:c.ui.dialog.overlay.width(),height:c.ui.dialog.overlay.height()})}});c.extend(c.ui.dialog.overlay.prototype,{destroy:function(){c.ui.dialog.overlay.destroy(this.$el)}})})(jQuery);
;/*
 * jQuery UI Slider 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.slider",d.ui.mouse,{widgetEventPrefix:"slide",options:{animate:false,distance:0,max:100,min:0,orientation:"horizontal",range:false,step:1,value:0,values:null},_create:function(){var a=this,b=this.options,c=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),f=b.values&&b.values.length||1,e=[];this._mouseSliding=this._keySliding=false;this._animateOff=true;this._handleIndex=null;this._detectOrientation();this._mouseInit();this.element.addClass("ui-slider ui-slider-"+
this.orientation+" ui-widget ui-widget-content ui-corner-all"+(b.disabled?" ui-slider-disabled ui-disabled":""));this.range=d([]);if(b.range){if(b.range===true){if(!b.values)b.values=[this._valueMin(),this._valueMin()];if(b.values.length&&b.values.length!==2)b.values=[b.values[0],b.values[0]]}this.range=d("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header"+(b.range==="min"||b.range==="max"?" ui-slider-range-"+b.range:""))}for(var j=c.length;j<f;j+=1)e.push("<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>");
this.handles=c.add(d(e.join("")).appendTo(a.element));this.handle=this.handles.eq(0);this.handles.add(this.range).filter("a").click(function(g){g.preventDefault()}).hover(function(){b.disabled||d(this).addClass("ui-state-hover")},function(){d(this).removeClass("ui-state-hover")}).focus(function(){if(b.disabled)d(this).blur();else{d(".ui-slider .ui-state-focus").removeClass("ui-state-focus");d(this).addClass("ui-state-focus")}}).blur(function(){d(this).removeClass("ui-state-focus")});this.handles.each(function(g){d(this).data("index.ui-slider-handle",
g)});this.handles.keydown(function(g){var k=true,l=d(this).data("index.ui-slider-handle"),i,h,m;if(!a.options.disabled){switch(g.keyCode){case d.ui.keyCode.HOME:case d.ui.keyCode.END:case d.ui.keyCode.PAGE_UP:case d.ui.keyCode.PAGE_DOWN:case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:k=false;if(!a._keySliding){a._keySliding=true;d(this).addClass("ui-state-active");i=a._start(g,l);if(i===false)return}break}m=a.options.step;i=a.options.values&&a.options.values.length?
(h=a.values(l)):(h=a.value());switch(g.keyCode){case d.ui.keyCode.HOME:h=a._valueMin();break;case d.ui.keyCode.END:h=a._valueMax();break;case d.ui.keyCode.PAGE_UP:h=a._trimAlignValue(i+(a._valueMax()-a._valueMin())/5);break;case d.ui.keyCode.PAGE_DOWN:h=a._trimAlignValue(i-(a._valueMax()-a._valueMin())/5);break;case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:if(i===a._valueMax())return;h=a._trimAlignValue(i+m);break;case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:if(i===a._valueMin())return;h=a._trimAlignValue(i-
m);break}a._slide(g,l,h);return k}}).keyup(function(g){var k=d(this).data("index.ui-slider-handle");if(a._keySliding){a._keySliding=false;a._stop(g,k);a._change(g,k);d(this).removeClass("ui-state-active")}});this._refreshValue();this._animateOff=false},destroy:function(){this.handles.remove();this.range.remove();this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider");this._mouseDestroy();
return this},_mouseCapture:function(a){var b=this.options,c,f,e,j,g;if(b.disabled)return false;this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()};this.elementOffset=this.element.offset();c=this._normValueFromMouse({x:a.pageX,y:a.pageY});f=this._valueMax()-this._valueMin()+1;j=this;this.handles.each(function(k){var l=Math.abs(c-j.values(k));if(f>l){f=l;e=d(this);g=k}});if(b.range===true&&this.values(1)===b.min){g+=1;e=d(this.handles[g])}if(this._start(a,g)===false)return false;
this._mouseSliding=true;j._handleIndex=g;e.addClass("ui-state-active").focus();b=e.offset();this._clickOffset=!d(a.target).parents().andSelf().is(".ui-slider-handle")?{left:0,top:0}:{left:a.pageX-b.left-e.width()/2,top:a.pageY-b.top-e.height()/2-(parseInt(e.css("borderTopWidth"),10)||0)-(parseInt(e.css("borderBottomWidth"),10)||0)+(parseInt(e.css("marginTop"),10)||0)};this.handles.hasClass("ui-state-hover")||this._slide(a,g,c);return this._animateOff=true},_mouseStart:function(){return true},_mouseDrag:function(a){var b=
this._normValueFromMouse({x:a.pageX,y:a.pageY});this._slide(a,this._handleIndex,b);return false},_mouseStop:function(a){this.handles.removeClass("ui-state-active");this._mouseSliding=false;this._stop(a,this._handleIndex);this._change(a,this._handleIndex);this._clickOffset=this._handleIndex=null;return this._animateOff=false},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(a){var b;if(this.orientation==="horizontal"){b=
this.elementSize.width;a=a.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)}else{b=this.elementSize.height;a=a.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)}b=a/b;if(b>1)b=1;if(b<0)b=0;if(this.orientation==="vertical")b=1-b;a=this._valueMax()-this._valueMin();return this._trimAlignValue(this._valueMin()+b*a)},_start:function(a,b){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);
c.values=this.values()}return this._trigger("start",a,c)},_slide:function(a,b,c){var f;if(this.options.values&&this.options.values.length){f=this.values(b?0:1);if(this.options.values.length===2&&this.options.range===true&&(b===0&&c>f||b===1&&c<f))c=f;if(c!==this.values(b)){f=this.values();f[b]=c;a=this._trigger("slide",a,{handle:this.handles[b],value:c,values:f});this.values(b?0:1);a!==false&&this.values(b,c,true)}}else if(c!==this.value()){a=this._trigger("slide",a,{handle:this.handles[b],value:c});
a!==false&&this.value(c)}},_stop:function(a,b){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);c.values=this.values()}this._trigger("stop",a,c)},_change:function(a,b){if(!this._keySliding&&!this._mouseSliding){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);c.values=this.values()}this._trigger("change",a,c)}},value:function(a){if(arguments.length){this.options.value=
this._trimAlignValue(a);this._refreshValue();this._change(null,0)}else return this._value()},values:function(a,b){var c,f,e;if(arguments.length>1){this.options.values[a]=this._trimAlignValue(b);this._refreshValue();this._change(null,a)}else if(arguments.length)if(d.isArray(arguments[0])){c=this.options.values;f=arguments[0];for(e=0;e<c.length;e+=1){c[e]=this._trimAlignValue(f[e]);this._change(null,e)}this._refreshValue()}else return this.options.values&&this.options.values.length?this._values(a):
this.value();else return this._values()},_setOption:function(a,b){var c,f=0;if(d.isArray(this.options.values))f=this.options.values.length;d.Widget.prototype._setOption.apply(this,arguments);switch(a){case "disabled":if(b){this.handles.filter(".ui-state-focus").blur();this.handles.removeClass("ui-state-hover");this.handles.propAttr("disabled",true);this.element.addClass("ui-disabled")}else{this.handles.propAttr("disabled",false);this.element.removeClass("ui-disabled")}break;case "orientation":this._detectOrientation();
this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation);this._refreshValue();break;case "value":this._animateOff=true;this._refreshValue();this._change(null,0);this._animateOff=false;break;case "values":this._animateOff=true;this._refreshValue();for(c=0;c<f;c+=1)this._change(null,c);this._animateOff=false;break}},_value:function(){var a=this.options.value;return a=this._trimAlignValue(a)},_values:function(a){var b,c;if(arguments.length){b=this.options.values[a];
return b=this._trimAlignValue(b)}else{b=this.options.values.slice();for(c=0;c<b.length;c+=1)b[c]=this._trimAlignValue(b[c]);return b}},_trimAlignValue:function(a){if(a<=this._valueMin())return this._valueMin();if(a>=this._valueMax())return this._valueMax();var b=this.options.step>0?this.options.step:1,c=(a-this._valueMin())%b;a=a-c;if(Math.abs(c)*2>=b)a+=c>0?b:-b;return parseFloat(a.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},_refreshValue:function(){var a=
this.options.range,b=this.options,c=this,f=!this._animateOff?b.animate:false,e,j={},g,k,l,i;if(this.options.values&&this.options.values.length)this.handles.each(function(h){e=(c.values(h)-c._valueMin())/(c._valueMax()-c._valueMin())*100;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";d(this).stop(1,1)[f?"animate":"css"](j,b.animate);if(c.options.range===true)if(c.orientation==="horizontal"){if(h===0)c.range.stop(1,1)[f?"animate":"css"]({left:e+"%"},b.animate);if(h===1)c.range[f?"animate":"css"]({width:e-
g+"%"},{queue:false,duration:b.animate})}else{if(h===0)c.range.stop(1,1)[f?"animate":"css"]({bottom:e+"%"},b.animate);if(h===1)c.range[f?"animate":"css"]({height:e-g+"%"},{queue:false,duration:b.animate})}g=e});else{k=this.value();l=this._valueMin();i=this._valueMax();e=i!==l?(k-l)/(i-l)*100:0;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";this.handle.stop(1,1)[f?"animate":"css"](j,b.animate);if(a==="min"&&this.orientation==="horizontal")this.range.stop(1,1)[f?"animate":"css"]({width:e+"%"},
b.animate);if(a==="max"&&this.orientation==="horizontal")this.range[f?"animate":"css"]({width:100-e+"%"},{queue:false,duration:b.animate});if(a==="min"&&this.orientation==="vertical")this.range.stop(1,1)[f?"animate":"css"]({height:e+"%"},b.animate);if(a==="max"&&this.orientation==="vertical")this.range[f?"animate":"css"]({height:100-e+"%"},{queue:false,duration:b.animate})}}});d.extend(d.ui.slider,{version:"1.8.15"})})(jQuery);
;/*
 * jQuery UI Tabs 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(d,p){function u(){return++v}function w(){return++x}var v=0,x=0;d.widget("ui.tabs",{options:{add:null,ajaxOptions:null,cache:false,cookie:null,collapsible:false,disable:null,disabled:[],enable:null,event:"click",fx:null,idPrefix:"ui-tabs-",load:null,panelTemplate:"<div></div>",remove:null,select:null,show:null,spinner:"<em>Loading&#8230;</em>",tabTemplate:"<li><a href='#{href}'><span>#{label}</span></a></li>"},_create:function(){this._tabify(true)},_setOption:function(b,e){if(b=="selected")this.options.collapsible&&
e==this.options.selected||this.select(e);else{this.options[b]=e;this._tabify()}},_tabId:function(b){return b.title&&b.title.replace(/\s/g,"_").replace(/[^\w\u00c0-\uFFFF-]/g,"")||this.options.idPrefix+u()},_sanitizeSelector:function(b){return b.replace(/:/g,"\\:")},_cookie:function(){var b=this.cookie||(this.cookie=this.options.cookie.name||"ui-tabs-"+w());return d.cookie.apply(null,[b].concat(d.makeArray(arguments)))},_ui:function(b,e){return{tab:b,panel:e,index:this.anchors.index(b)}},_cleanup:function(){this.lis.filter(".ui-state-processing").removeClass("ui-state-processing").find("span:data(label.tabs)").each(function(){var b=
d(this);b.html(b.data("label.tabs")).removeData("label.tabs")})},_tabify:function(b){function e(g,f){g.css("display","");!d.support.opacity&&f.opacity&&g[0].style.removeAttribute("filter")}var a=this,c=this.options,h=/^#.+/;this.list=this.element.find("ol,ul").eq(0);this.lis=d(" > li:has(a[href])",this.list);this.anchors=this.lis.map(function(){return d("a",this)[0]});this.panels=d([]);this.anchors.each(function(g,f){var i=d(f).attr("href"),l=i.split("#")[0],q;if(l&&(l===location.toString().split("#")[0]||
(q=d("base")[0])&&l===q.href)){i=f.hash;f.href=i}if(h.test(i))a.panels=a.panels.add(a.element.find(a._sanitizeSelector(i)));else if(i&&i!=="#"){d.data(f,"href.tabs",i);d.data(f,"load.tabs",i.replace(/#.*$/,""));i=a._tabId(f);f.href="#"+i;f=a.element.find("#"+i);if(!f.length){f=d(c.panelTemplate).attr("id",i).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").insertAfter(a.panels[g-1]||a.list);f.data("destroy.tabs",true)}a.panels=a.panels.add(f)}else c.disabled.push(g)});if(b){this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all");
this.list.addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.lis.addClass("ui-state-default ui-corner-top");this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom");if(c.selected===p){location.hash&&this.anchors.each(function(g,f){if(f.hash==location.hash){c.selected=g;return false}});if(typeof c.selected!=="number"&&c.cookie)c.selected=parseInt(a._cookie(),10);if(typeof c.selected!=="number"&&this.lis.filter(".ui-tabs-selected").length)c.selected=
this.lis.index(this.lis.filter(".ui-tabs-selected"));c.selected=c.selected||(this.lis.length?0:-1)}else if(c.selected===null)c.selected=-1;c.selected=c.selected>=0&&this.anchors[c.selected]||c.selected<0?c.selected:0;c.disabled=d.unique(c.disabled.concat(d.map(this.lis.filter(".ui-state-disabled"),function(g){return a.lis.index(g)}))).sort();d.inArray(c.selected,c.disabled)!=-1&&c.disabled.splice(d.inArray(c.selected,c.disabled),1);this.panels.addClass("ui-tabs-hide");this.lis.removeClass("ui-tabs-selected ui-state-active");
if(c.selected>=0&&this.anchors.length){a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash)).removeClass("ui-tabs-hide");this.lis.eq(c.selected).addClass("ui-tabs-selected ui-state-active");a.element.queue("tabs",function(){a._trigger("show",null,a._ui(a.anchors[c.selected],a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash))[0]))});this.load(c.selected)}d(window).bind("unload",function(){a.lis.add(a.anchors).unbind(".tabs");a.lis=a.anchors=a.panels=null})}else c.selected=this.lis.index(this.lis.filter(".ui-tabs-selected"));
this.element[c.collapsible?"addClass":"removeClass"]("ui-tabs-collapsible");c.cookie&&this._cookie(c.selected,c.cookie);b=0;for(var j;j=this.lis[b];b++)d(j)[d.inArray(b,c.disabled)!=-1&&!d(j).hasClass("ui-tabs-selected")?"addClass":"removeClass"]("ui-state-disabled");c.cache===false&&this.anchors.removeData("cache.tabs");this.lis.add(this.anchors).unbind(".tabs");if(c.event!=="mouseover"){var k=function(g,f){f.is(":not(.ui-state-disabled)")&&f.addClass("ui-state-"+g)},n=function(g,f){f.removeClass("ui-state-"+
g)};this.lis.bind("mouseover.tabs",function(){k("hover",d(this))});this.lis.bind("mouseout.tabs",function(){n("hover",d(this))});this.anchors.bind("focus.tabs",function(){k("focus",d(this).closest("li"))});this.anchors.bind("blur.tabs",function(){n("focus",d(this).closest("li"))})}var m,o;if(c.fx)if(d.isArray(c.fx)){m=c.fx[0];o=c.fx[1]}else m=o=c.fx;var r=o?function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.hide().removeClass("ui-tabs-hide").animate(o,o.duration||"normal",
function(){e(f,o);a._trigger("show",null,a._ui(g,f[0]))})}:function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.removeClass("ui-tabs-hide");a._trigger("show",null,a._ui(g,f[0]))},s=m?function(g,f){f.animate(m,m.duration||"normal",function(){a.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");e(f,m);a.element.dequeue("tabs")})}:function(g,f){a.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");a.element.dequeue("tabs")};
this.anchors.bind(c.event+".tabs",function(){var g=this,f=d(g).closest("li"),i=a.panels.filter(":not(.ui-tabs-hide)"),l=a.element.find(a._sanitizeSelector(g.hash));if(f.hasClass("ui-tabs-selected")&&!c.collapsible||f.hasClass("ui-state-disabled")||f.hasClass("ui-state-processing")||a.panels.filter(":animated").length||a._trigger("select",null,a._ui(this,l[0]))===false){this.blur();return false}c.selected=a.anchors.index(this);a.abort();if(c.collapsible)if(f.hasClass("ui-tabs-selected")){c.selected=
-1;c.cookie&&a._cookie(c.selected,c.cookie);a.element.queue("tabs",function(){s(g,i)}).dequeue("tabs");this.blur();return false}else if(!i.length){c.cookie&&a._cookie(c.selected,c.cookie);a.element.queue("tabs",function(){r(g,l)});a.load(a.anchors.index(this));this.blur();return false}c.cookie&&a._cookie(c.selected,c.cookie);if(l.length){i.length&&a.element.queue("tabs",function(){s(g,i)});a.element.queue("tabs",function(){r(g,l)});a.load(a.anchors.index(this))}else throw"jQuery UI Tabs: Mismatching fragment identifier.";
d.browser.msie&&this.blur()});this.anchors.bind("click.tabs",function(){return false})},_getIndex:function(b){if(typeof b=="string")b=this.anchors.index(this.anchors.filter("[href$="+b+"]"));return b},destroy:function(){var b=this.options;this.abort();this.element.unbind(".tabs").removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible").removeData("tabs");this.list.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.anchors.each(function(){var e=
d.data(this,"href.tabs");if(e)this.href=e;var a=d(this).unbind(".tabs");d.each(["href","load","cache"],function(c,h){a.removeData(h+".tabs")})});this.lis.unbind(".tabs").add(this.panels).each(function(){d.data(this,"destroy.tabs")?d(this).remove():d(this).removeClass("ui-state-default ui-corner-top ui-tabs-selected ui-state-active ui-state-hover ui-state-focus ui-state-disabled ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide")});b.cookie&&this._cookie(null,b.cookie);return this},add:function(b,
e,a){if(a===p)a=this.anchors.length;var c=this,h=this.options;e=d(h.tabTemplate.replace(/#\{href\}/g,b).replace(/#\{label\}/g,e));b=!b.indexOf("#")?b.replace("#",""):this._tabId(d("a",e)[0]);e.addClass("ui-state-default ui-corner-top").data("destroy.tabs",true);var j=c.element.find("#"+b);j.length||(j=d(h.panelTemplate).attr("id",b).data("destroy.tabs",true));j.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide");if(a>=this.lis.length){e.appendTo(this.list);j.appendTo(this.list[0].parentNode)}else{e.insertBefore(this.lis[a]);
j.insertBefore(this.panels[a])}h.disabled=d.map(h.disabled,function(k){return k>=a?++k:k});this._tabify();if(this.anchors.length==1){h.selected=0;e.addClass("ui-tabs-selected ui-state-active");j.removeClass("ui-tabs-hide");this.element.queue("tabs",function(){c._trigger("show",null,c._ui(c.anchors[0],c.panels[0]))});this.load(0)}this._trigger("add",null,this._ui(this.anchors[a],this.panels[a]));return this},remove:function(b){b=this._getIndex(b);var e=this.options,a=this.lis.eq(b).remove(),c=this.panels.eq(b).remove();
if(a.hasClass("ui-tabs-selected")&&this.anchors.length>1)this.select(b+(b+1<this.anchors.length?1:-1));e.disabled=d.map(d.grep(e.disabled,function(h){return h!=b}),function(h){return h>=b?--h:h});this._tabify();this._trigger("remove",null,this._ui(a.find("a")[0],c[0]));return this},enable:function(b){b=this._getIndex(b);var e=this.options;if(d.inArray(b,e.disabled)!=-1){this.lis.eq(b).removeClass("ui-state-disabled");e.disabled=d.grep(e.disabled,function(a){return a!=b});this._trigger("enable",null,
this._ui(this.anchors[b],this.panels[b]));return this}},disable:function(b){b=this._getIndex(b);var e=this.options;if(b!=e.selected){this.lis.eq(b).addClass("ui-state-disabled");e.disabled.push(b);e.disabled.sort();this._trigger("disable",null,this._ui(this.anchors[b],this.panels[b]))}return this},select:function(b){b=this._getIndex(b);if(b==-1)if(this.options.collapsible&&this.options.selected!=-1)b=this.options.selected;else return this;this.anchors.eq(b).trigger(this.options.event+".tabs");return this},
load:function(b){b=this._getIndex(b);var e=this,a=this.options,c=this.anchors.eq(b)[0],h=d.data(c,"load.tabs");this.abort();if(!h||this.element.queue("tabs").length!==0&&d.data(c,"cache.tabs"))this.element.dequeue("tabs");else{this.lis.eq(b).addClass("ui-state-processing");if(a.spinner){var j=d("span",c);j.data("label.tabs",j.html()).html(a.spinner)}this.xhr=d.ajax(d.extend({},a.ajaxOptions,{url:h,success:function(k,n){e.element.find(e._sanitizeSelector(c.hash)).html(k);e._cleanup();a.cache&&d.data(c,
"cache.tabs",true);e._trigger("load",null,e._ui(e.anchors[b],e.panels[b]));try{a.ajaxOptions.success(k,n)}catch(m){}},error:function(k,n){e._cleanup();e._trigger("load",null,e._ui(e.anchors[b],e.panels[b]));try{a.ajaxOptions.error(k,n,b,c)}catch(m){}}}));e.element.dequeue("tabs");return this}},abort:function(){this.element.queue([]);this.panels.stop(false,true);this.element.queue("tabs",this.element.queue("tabs").splice(-2,2));if(this.xhr){this.xhr.abort();delete this.xhr}this._cleanup();return this},
url:function(b,e){this.anchors.eq(b).removeData("cache.tabs").data("load.tabs",e);return this},length:function(){return this.anchors.length}});d.extend(d.ui.tabs,{version:"1.8.15"});d.extend(d.ui.tabs.prototype,{rotation:null,rotate:function(b,e){var a=this,c=this.options,h=a._rotate||(a._rotate=function(j){clearTimeout(a.rotation);a.rotation=setTimeout(function(){var k=c.selected;a.select(++k<a.anchors.length?k:0)},b);j&&j.stopPropagation()});e=a._unrotate||(a._unrotate=!e?function(j){j.clientX&&
a.rotate(null)}:function(){t=c.selected;h()});if(b){this.element.bind("tabsshow",h);this.anchors.bind(c.event+".tabs",e);h()}else{clearTimeout(a.rotation);this.element.unbind("tabsshow",h);this.anchors.unbind(c.event+".tabs",e);delete this._rotate;delete this._unrotate}return this}})})(jQuery);
;/*
 * jQuery UI Datepicker 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function(d,C){function M(){this.debug=false;this._curInst=null;this._keyEvent=false;this._disabledInputs=[];this._inDialog=this._datepickerShowing=false;this._mainDivId="ui-datepicker-div";this._inlineClass="ui-datepicker-inline";this._appendClass="ui-datepicker-append";this._triggerClass="ui-datepicker-trigger";this._dialogClass="ui-datepicker-dialog";this._disableClass="ui-datepicker-disabled";this._unselectableClass="ui-datepicker-unselectable";this._currentClass="ui-datepicker-current-day";this._dayOverClass=
"ui-datepicker-days-cell-over";this.regional=[];this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su",
"Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:false,showMonthAfterYear:false,yearSuffix:""};this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:false,hideIfNoPrevNext:false,navigationAsDateFormat:false,gotoCurrent:false,changeMonth:false,changeYear:false,yearRange:"c-10:c+10",showOtherMonths:false,selectOtherMonths:false,showWeek:false,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",
minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:true,showButtonPanel:false,autoSize:false,disabled:false};d.extend(this._defaults,this.regional[""]);this.dpDiv=N(d('<div id="'+this._mainDivId+'" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))}function N(a){return a.bind("mouseout",
function(b){b=d(b.target).closest("button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a");b.length&&b.removeClass("ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover")}).bind("mouseover",function(b){b=d(b.target).closest("button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a");if(!(d.datepicker._isDisabledDatepicker(J.inline?a.parent()[0]:J.input[0])||!b.length)){b.parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
b.addClass("ui-state-hover");b.hasClass("ui-datepicker-prev")&&b.addClass("ui-datepicker-prev-hover");b.hasClass("ui-datepicker-next")&&b.addClass("ui-datepicker-next-hover")}})}function H(a,b){d.extend(a,b);for(var c in b)if(b[c]==null||b[c]==C)a[c]=b[c];return a}d.extend(d.ui,{datepicker:{version:"1.8.15"}});var B=(new Date).getTime(),J;d.extend(M.prototype,{markerClassName:"hasDatepicker",maxRows:4,log:function(){this.debug&&console.log.apply("",arguments)},_widgetDatepicker:function(){return this.dpDiv},
setDefaults:function(a){H(this._defaults,a||{});return this},_attachDatepicker:function(a,b){var c=null;for(var e in this._defaults){var f=a.getAttribute("date:"+e);if(f){c=c||{};try{c[e]=eval(f)}catch(h){c[e]=f}}}e=a.nodeName.toLowerCase();f=e=="div"||e=="span";if(!a.id){this.uuid+=1;a.id="dp"+this.uuid}var i=this._newInst(d(a),f);i.settings=d.extend({},b||{},c||{});if(e=="input")this._connectDatepicker(a,i);else f&&this._inlineDatepicker(a,i)},_newInst:function(a,b){return{id:a[0].id.replace(/([^A-Za-z0-9_-])/g,
"\\\\$1"),input:a,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:b,dpDiv:!b?this.dpDiv:N(d('<div class="'+this._inlineClass+' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))}},_connectDatepicker:function(a,b){var c=d(a);b.append=d([]);b.trigger=d([]);if(!c.hasClass(this.markerClassName)){this._attachments(c,b);c.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker",
function(e,f,h){b.settings[f]=h}).bind("getData.datepicker",function(e,f){return this._get(b,f)});this._autoSize(b);d.data(a,"datepicker",b);b.settings.disabled&&this._disableDatepicker(a)}},_attachments:function(a,b){var c=this._get(b,"appendText"),e=this._get(b,"isRTL");b.append&&b.append.remove();if(c){b.append=d('<span class="'+this._appendClass+'">'+c+"</span>");a[e?"before":"after"](b.append)}a.unbind("focus",this._showDatepicker);b.trigger&&b.trigger.remove();c=this._get(b,"showOn");if(c==
"focus"||c=="both")a.focus(this._showDatepicker);if(c=="button"||c=="both"){c=this._get(b,"buttonText");var f=this._get(b,"buttonImage");b.trigger=d(this._get(b,"buttonImageOnly")?d("<img/>").addClass(this._triggerClass).attr({src:f,alt:c,title:c}):d('<button type="button"></button>').addClass(this._triggerClass).html(f==""?c:d("<img/>").attr({src:f,alt:c,title:c})));a[e?"before":"after"](b.trigger);b.trigger.click(function(){d.datepicker._datepickerShowing&&d.datepicker._lastInput==a[0]?d.datepicker._hideDatepicker():
d.datepicker._showDatepicker(a[0]);return false})}},_autoSize:function(a){if(this._get(a,"autoSize")&&!a.inline){var b=new Date(2009,11,20),c=this._get(a,"dateFormat");if(c.match(/[DM]/)){var e=function(f){for(var h=0,i=0,g=0;g<f.length;g++)if(f[g].length>h){h=f[g].length;i=g}return i};b.setMonth(e(this._get(a,c.match(/MM/)?"monthNames":"monthNamesShort")));b.setDate(e(this._get(a,c.match(/DD/)?"dayNames":"dayNamesShort"))+20-b.getDay())}a.input.attr("size",this._formatDate(a,b).length)}},_inlineDatepicker:function(a,
b){var c=d(a);if(!c.hasClass(this.markerClassName)){c.addClass(this.markerClassName).append(b.dpDiv).bind("setData.datepicker",function(e,f,h){b.settings[f]=h}).bind("getData.datepicker",function(e,f){return this._get(b,f)});d.data(a,"datepicker",b);this._setDate(b,this._getDefaultDate(b),true);this._updateDatepicker(b);this._updateAlternate(b);b.settings.disabled&&this._disableDatepicker(a);b.dpDiv.css("display","block")}},_dialogDatepicker:function(a,b,c,e,f){a=this._dialogInst;if(!a){this.uuid+=
1;this._dialogInput=d('<input type="text" id="'+("dp"+this.uuid)+'" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');this._dialogInput.keydown(this._doKeyDown);d("body").append(this._dialogInput);a=this._dialogInst=this._newInst(this._dialogInput,false);a.settings={};d.data(this._dialogInput[0],"datepicker",a)}H(a.settings,e||{});b=b&&b.constructor==Date?this._formatDate(a,b):b;this._dialogInput.val(b);this._pos=f?f.length?f:[f.pageX,f.pageY]:null;if(!this._pos)this._pos=[document.documentElement.clientWidth/
2-100+(document.documentElement.scrollLeft||document.body.scrollLeft),document.documentElement.clientHeight/2-150+(document.documentElement.scrollTop||document.body.scrollTop)];this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px");a.settings.onSelect=c;this._inDialog=true;this.dpDiv.addClass(this._dialogClass);this._showDatepicker(this._dialogInput[0]);d.blockUI&&d.blockUI(this.dpDiv);d.data(this._dialogInput[0],"datepicker",a);return this},_destroyDatepicker:function(a){var b=
d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();d.removeData(a,"datepicker");if(e=="input"){c.append.remove();c.trigger.remove();b.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)}else if(e=="div"||e=="span")b.removeClass(this.markerClassName).empty()}},_enableDatepicker:function(a){var b=d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=
a.nodeName.toLowerCase();if(e=="input"){a.disabled=false;c.trigger.filter("button").each(function(){this.disabled=false}).end().filter("img").css({opacity:"1.0",cursor:""})}else if(e=="div"||e=="span"){b=b.children("."+this._inlineClass);b.children().removeClass("ui-state-disabled");b.find("select.ui-datepicker-month, select.ui-datepicker-year").removeAttr("disabled")}this._disabledInputs=d.map(this._disabledInputs,function(f){return f==a?null:f})}},_disableDatepicker:function(a){var b=d(a),c=d.data(a,
"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();if(e=="input"){a.disabled=true;c.trigger.filter("button").each(function(){this.disabled=true}).end().filter("img").css({opacity:"0.5",cursor:"default"})}else if(e=="div"||e=="span"){b=b.children("."+this._inlineClass);b.children().addClass("ui-state-disabled");b.find("select.ui-datepicker-month, select.ui-datepicker-year").attr("disabled","disabled")}this._disabledInputs=d.map(this._disabledInputs,function(f){return f==
a?null:f});this._disabledInputs[this._disabledInputs.length]=a}},_isDisabledDatepicker:function(a){if(!a)return false;for(var b=0;b<this._disabledInputs.length;b++)if(this._disabledInputs[b]==a)return true;return false},_getInst:function(a){try{return d.data(a,"datepicker")}catch(b){throw"Missing instance data for this datepicker";}},_optionDatepicker:function(a,b,c){var e=this._getInst(a);if(arguments.length==2&&typeof b=="string")return b=="defaults"?d.extend({},d.datepicker._defaults):e?b=="all"?
d.extend({},e.settings):this._get(e,b):null;var f=b||{};if(typeof b=="string"){f={};f[b]=c}if(e){this._curInst==e&&this._hideDatepicker();var h=this._getDateDatepicker(a,true),i=this._getMinMaxDate(e,"min"),g=this._getMinMaxDate(e,"max");H(e.settings,f);if(i!==null&&f.dateFormat!==C&&f.minDate===C)e.settings.minDate=this._formatDate(e,i);if(g!==null&&f.dateFormat!==C&&f.maxDate===C)e.settings.maxDate=this._formatDate(e,g);this._attachments(d(a),e);this._autoSize(e);this._setDate(e,h);this._updateAlternate(e);
this._updateDatepicker(e)}},_changeDatepicker:function(a,b,c){this._optionDatepicker(a,b,c)},_refreshDatepicker:function(a){(a=this._getInst(a))&&this._updateDatepicker(a)},_setDateDatepicker:function(a,b){if(a=this._getInst(a)){this._setDate(a,b);this._updateDatepicker(a);this._updateAlternate(a)}},_getDateDatepicker:function(a,b){(a=this._getInst(a))&&!a.inline&&this._setDateFromField(a,b);return a?this._getDate(a):null},_doKeyDown:function(a){var b=d.datepicker._getInst(a.target),c=true,e=b.dpDiv.is(".ui-datepicker-rtl");
b._keyEvent=true;if(d.datepicker._datepickerShowing)switch(a.keyCode){case 9:d.datepicker._hideDatepicker();c=false;break;case 13:c=d("td."+d.datepicker._dayOverClass+":not(."+d.datepicker._currentClass+")",b.dpDiv);c[0]&&d.datepicker._selectDay(a.target,b.selectedMonth,b.selectedYear,c[0]);if(a=d.datepicker._get(b,"onSelect")){c=d.datepicker._formatDate(b);a.apply(b.input?b.input[0]:null,[c,b])}else d.datepicker._hideDatepicker();return false;case 27:d.datepicker._hideDatepicker();break;case 33:d.datepicker._adjustDate(a.target,
a.ctrlKey?-d.datepicker._get(b,"stepBigMonths"):-d.datepicker._get(b,"stepMonths"),"M");break;case 34:d.datepicker._adjustDate(a.target,a.ctrlKey?+d.datepicker._get(b,"stepBigMonths"):+d.datepicker._get(b,"stepMonths"),"M");break;case 35:if(a.ctrlKey||a.metaKey)d.datepicker._clearDate(a.target);c=a.ctrlKey||a.metaKey;break;case 36:if(a.ctrlKey||a.metaKey)d.datepicker._gotoToday(a.target);c=a.ctrlKey||a.metaKey;break;case 37:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,e?+1:-1,"D");c=
a.ctrlKey||a.metaKey;if(a.originalEvent.altKey)d.datepicker._adjustDate(a.target,a.ctrlKey?-d.datepicker._get(b,"stepBigMonths"):-d.datepicker._get(b,"stepMonths"),"M");break;case 38:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,-7,"D");c=a.ctrlKey||a.metaKey;break;case 39:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,e?-1:+1,"D");c=a.ctrlKey||a.metaKey;if(a.originalEvent.altKey)d.datepicker._adjustDate(a.target,a.ctrlKey?+d.datepicker._get(b,"stepBigMonths"):+d.datepicker._get(b,
"stepMonths"),"M");break;case 40:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,+7,"D");c=a.ctrlKey||a.metaKey;break;default:c=false}else if(a.keyCode==36&&a.ctrlKey)d.datepicker._showDatepicker(this);else c=false;if(c){a.preventDefault();a.stopPropagation()}},_doKeyPress:function(a){var b=d.datepicker._getInst(a.target);if(d.datepicker._get(b,"constrainInput")){b=d.datepicker._possibleChars(d.datepicker._get(b,"dateFormat"));var c=String.fromCharCode(a.charCode==C?a.keyCode:a.charCode);
return a.ctrlKey||a.metaKey||c<" "||!b||b.indexOf(c)>-1}},_doKeyUp:function(a){a=d.datepicker._getInst(a.target);if(a.input.val()!=a.lastVal)try{if(d.datepicker.parseDate(d.datepicker._get(a,"dateFormat"),a.input?a.input.val():null,d.datepicker._getFormatConfig(a))){d.datepicker._setDateFromField(a);d.datepicker._updateAlternate(a);d.datepicker._updateDatepicker(a)}}catch(b){d.datepicker.log(b)}return true},_showDatepicker:function(a){a=a.target||a;if(a.nodeName.toLowerCase()!="input")a=d("input",
a.parentNode)[0];if(!(d.datepicker._isDisabledDatepicker(a)||d.datepicker._lastInput==a)){var b=d.datepicker._getInst(a);if(d.datepicker._curInst&&d.datepicker._curInst!=b){d.datepicker._datepickerShowing&&d.datepicker._triggerOnClose(d.datepicker._curInst);d.datepicker._curInst.dpDiv.stop(true,true)}var c=d.datepicker._get(b,"beforeShow");H(b.settings,c?c.apply(a,[a,b]):{});b.lastVal=null;d.datepicker._lastInput=a;d.datepicker._setDateFromField(b);if(d.datepicker._inDialog)a.value="";if(!d.datepicker._pos){d.datepicker._pos=
d.datepicker._findPos(a);d.datepicker._pos[1]+=a.offsetHeight}var e=false;d(a).parents().each(function(){e|=d(this).css("position")=="fixed";return!e});if(e&&d.browser.opera){d.datepicker._pos[0]-=document.documentElement.scrollLeft;d.datepicker._pos[1]-=document.documentElement.scrollTop}c={left:d.datepicker._pos[0],top:d.datepicker._pos[1]};d.datepicker._pos=null;b.dpDiv.empty();b.dpDiv.css({position:"absolute",display:"block",top:"-1000px"});d.datepicker._updateDatepicker(b);c=d.datepicker._checkOffset(b,
c,e);b.dpDiv.css({position:d.datepicker._inDialog&&d.blockUI?"static":e?"fixed":"absolute",display:"none",left:c.left+"px",top:c.top+"px"});if(!b.inline){c=d.datepicker._get(b,"showAnim");var f=d.datepicker._get(b,"duration"),h=function(){var i=b.dpDiv.find("iframe.ui-datepicker-cover");if(i.length){var g=d.datepicker._getBorders(b.dpDiv);i.css({left:-g[0],top:-g[1],width:b.dpDiv.outerWidth(),height:b.dpDiv.outerHeight()})}};b.dpDiv.zIndex(d(a).zIndex()+1);d.datepicker._datepickerShowing=true;d.effects&&
d.effects[c]?b.dpDiv.show(c,d.datepicker._get(b,"showOptions"),f,h):b.dpDiv[c||"show"](c?f:null,h);if(!c||!f)h();b.input.is(":visible")&&!b.input.is(":disabled")&&b.input.focus();d.datepicker._curInst=b}}},_updateDatepicker:function(a){this.maxRows=4;var b=d.datepicker._getBorders(a.dpDiv);J=a;a.dpDiv.empty().append(this._generateHTML(a));var c=a.dpDiv.find("iframe.ui-datepicker-cover");c.length&&c.css({left:-b[0],top:-b[1],width:a.dpDiv.outerWidth(),height:a.dpDiv.outerHeight()});a.dpDiv.find("."+
this._dayOverClass+" a").mouseover();b=this._getNumberOfMonths(a);c=b[1];a.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");c>1&&a.dpDiv.addClass("ui-datepicker-multi-"+c).css("width",17*c+"em");a.dpDiv[(b[0]!=1||b[1]!=1?"add":"remove")+"Class"]("ui-datepicker-multi");a.dpDiv[(this._get(a,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl");a==d.datepicker._curInst&&d.datepicker._datepickerShowing&&a.input&&a.input.is(":visible")&&!a.input.is(":disabled")&&
a.input[0]!=document.activeElement&&a.input.focus();if(a.yearshtml){var e=a.yearshtml;setTimeout(function(){e===a.yearshtml&&a.yearshtml&&a.dpDiv.find("select.ui-datepicker-year:first").replaceWith(a.yearshtml);e=a.yearshtml=null},0)}},_getBorders:function(a){var b=function(c){return{thin:1,medium:2,thick:3}[c]||c};return[parseFloat(b(a.css("border-left-width"))),parseFloat(b(a.css("border-top-width")))]},_checkOffset:function(a,b,c){var e=a.dpDiv.outerWidth(),f=a.dpDiv.outerHeight(),h=a.input?a.input.outerWidth():
0,i=a.input?a.input.outerHeight():0,g=document.documentElement.clientWidth+d(document).scrollLeft(),j=document.documentElement.clientHeight+d(document).scrollTop();b.left-=this._get(a,"isRTL")?e-h:0;b.left-=c&&b.left==a.input.offset().left?d(document).scrollLeft():0;b.top-=c&&b.top==a.input.offset().top+i?d(document).scrollTop():0;b.left-=Math.min(b.left,b.left+e>g&&g>e?Math.abs(b.left+e-g):0);b.top-=Math.min(b.top,b.top+f>j&&j>f?Math.abs(f+i):0);return b},_findPos:function(a){for(var b=this._get(this._getInst(a),
"isRTL");a&&(a.type=="hidden"||a.nodeType!=1||d.expr.filters.hidden(a));)a=a[b?"previousSibling":"nextSibling"];a=d(a).offset();return[a.left,a.top]},_triggerOnClose:function(a){var b=this._get(a,"onClose");if(b)b.apply(a.input?a.input[0]:null,[a.input?a.input.val():"",a])},_hideDatepicker:function(a){var b=this._curInst;if(!(!b||a&&b!=d.data(a,"datepicker")))if(this._datepickerShowing){a=this._get(b,"showAnim");var c=this._get(b,"duration"),e=function(){d.datepicker._tidyDialog(b);this._curInst=
null};d.effects&&d.effects[a]?b.dpDiv.hide(a,d.datepicker._get(b,"showOptions"),c,e):b.dpDiv[a=="slideDown"?"slideUp":a=="fadeIn"?"fadeOut":"hide"](a?c:null,e);a||e();d.datepicker._triggerOnClose(b);this._datepickerShowing=false;this._lastInput=null;if(this._inDialog){this._dialogInput.css({position:"absolute",left:"0",top:"-100px"});if(d.blockUI){d.unblockUI();d("body").append(this.dpDiv)}}this._inDialog=false}},_tidyDialog:function(a){a.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},
_checkExternalClick:function(a){if(d.datepicker._curInst){a=d(a.target);a[0].id!=d.datepicker._mainDivId&&a.parents("#"+d.datepicker._mainDivId).length==0&&!a.hasClass(d.datepicker.markerClassName)&&!a.hasClass(d.datepicker._triggerClass)&&d.datepicker._datepickerShowing&&!(d.datepicker._inDialog&&d.blockUI)&&d.datepicker._hideDatepicker()}},_adjustDate:function(a,b,c){a=d(a);var e=this._getInst(a[0]);if(!this._isDisabledDatepicker(a[0])){this._adjustInstDate(e,b+(c=="M"?this._get(e,"showCurrentAtPos"):
0),c);this._updateDatepicker(e)}},_gotoToday:function(a){a=d(a);var b=this._getInst(a[0]);if(this._get(b,"gotoCurrent")&&b.currentDay){b.selectedDay=b.currentDay;b.drawMonth=b.selectedMonth=b.currentMonth;b.drawYear=b.selectedYear=b.currentYear}else{var c=new Date;b.selectedDay=c.getDate();b.drawMonth=b.selectedMonth=c.getMonth();b.drawYear=b.selectedYear=c.getFullYear()}this._notifyChange(b);this._adjustDate(a)},_selectMonthYear:function(a,b,c){a=d(a);var e=this._getInst(a[0]);e["selected"+(c=="M"?
"Month":"Year")]=e["draw"+(c=="M"?"Month":"Year")]=parseInt(b.options[b.selectedIndex].value,10);this._notifyChange(e);this._adjustDate(a)},_selectDay:function(a,b,c,e){var f=d(a);if(!(d(e).hasClass(this._unselectableClass)||this._isDisabledDatepicker(f[0]))){f=this._getInst(f[0]);f.selectedDay=f.currentDay=d("a",e).html();f.selectedMonth=f.currentMonth=b;f.selectedYear=f.currentYear=c;this._selectDate(a,this._formatDate(f,f.currentDay,f.currentMonth,f.currentYear))}},_clearDate:function(a){a=d(a);
this._getInst(a[0]);this._selectDate(a,"")},_selectDate:function(a,b){a=this._getInst(d(a)[0]);b=b!=null?b:this._formatDate(a);a.input&&a.input.val(b);this._updateAlternate(a);var c=this._get(a,"onSelect");if(c)c.apply(a.input?a.input[0]:null,[b,a]);else a.input&&a.input.trigger("change");if(a.inline)this._updateDatepicker(a);else{this._hideDatepicker();this._lastInput=a.input[0];a.input.focus();this._lastInput=null}},_updateAlternate:function(a){var b=this._get(a,"altField");if(b){var c=this._get(a,
"altFormat")||this._get(a,"dateFormat"),e=this._getDate(a),f=this.formatDate(c,e,this._getFormatConfig(a));d(b).each(function(){d(this).val(f)})}},noWeekends:function(a){a=a.getDay();return[a>0&&a<6,""]},iso8601Week:function(a){a=new Date(a.getTime());a.setDate(a.getDate()+4-(a.getDay()||7));var b=a.getTime();a.setMonth(0);a.setDate(1);return Math.floor(Math.round((b-a)/864E5)/7)+1},parseDate:function(a,b,c){if(a==null||b==null)throw"Invalid arguments";b=typeof b=="object"?b.toString():b+"";if(b==
"")return null;var e=(c?c.shortYearCutoff:null)||this._defaults.shortYearCutoff;e=typeof e!="string"?e:(new Date).getFullYear()%100+parseInt(e,10);for(var f=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,h=(c?c.dayNames:null)||this._defaults.dayNames,i=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort,g=(c?c.monthNames:null)||this._defaults.monthNames,j=c=-1,l=-1,u=-1,k=false,o=function(p){(p=A+1<a.length&&a.charAt(A+1)==p)&&A++;return p},m=function(p){var D=o(p);p=new RegExp("^\\d{1,"+
(p=="@"?14:p=="!"?20:p=="y"&&D?4:p=="o"?3:2)+"}");p=b.substring(q).match(p);if(!p)throw"Missing number at position "+q;q+=p[0].length;return parseInt(p[0],10)},n=function(p,D,K){p=d.map(o(p)?K:D,function(w,x){return[[x,w]]}).sort(function(w,x){return-(w[1].length-x[1].length)});var E=-1;d.each(p,function(w,x){w=x[1];if(b.substr(q,w.length).toLowerCase()==w.toLowerCase()){E=x[0];q+=w.length;return false}});if(E!=-1)return E+1;else throw"Unknown name at position "+q;},s=function(){if(b.charAt(q)!=a.charAt(A))throw"Unexpected literal at position "+
q;q++},q=0,A=0;A<a.length;A++)if(k)if(a.charAt(A)=="'"&&!o("'"))k=false;else s();else switch(a.charAt(A)){case "d":l=m("d");break;case "D":n("D",f,h);break;case "o":u=m("o");break;case "m":j=m("m");break;case "M":j=n("M",i,g);break;case "y":c=m("y");break;case "@":var v=new Date(m("@"));c=v.getFullYear();j=v.getMonth()+1;l=v.getDate();break;case "!":v=new Date((m("!")-this._ticksTo1970)/1E4);c=v.getFullYear();j=v.getMonth()+1;l=v.getDate();break;case "'":if(o("'"))s();else k=true;break;default:s()}if(q<
b.length)throw"Extra/unparsed characters found in date: "+b.substring(q);if(c==-1)c=(new Date).getFullYear();else if(c<100)c+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c<=e?0:-100);if(u>-1){j=1;l=u;do{e=this._getDaysInMonth(c,j-1);if(l<=e)break;j++;l-=e}while(1)}v=this._daylightSavingAdjust(new Date(c,j-1,l));if(v.getFullYear()!=c||v.getMonth()+1!=j||v.getDate()!=l)throw"Invalid date";return v},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",
RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925))*24*60*60*1E7,formatDate:function(a,b,c){if(!b)return"";var e=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,f=(c?c.dayNames:null)||this._defaults.dayNames,h=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort;c=(c?c.monthNames:null)||this._defaults.monthNames;var i=function(o){(o=k+1<a.length&&
a.charAt(k+1)==o)&&k++;return o},g=function(o,m,n){m=""+m;if(i(o))for(;m.length<n;)m="0"+m;return m},j=function(o,m,n,s){return i(o)?s[m]:n[m]},l="",u=false;if(b)for(var k=0;k<a.length;k++)if(u)if(a.charAt(k)=="'"&&!i("'"))u=false;else l+=a.charAt(k);else switch(a.charAt(k)){case "d":l+=g("d",b.getDate(),2);break;case "D":l+=j("D",b.getDay(),e,f);break;case "o":l+=g("o",Math.round(((new Date(b.getFullYear(),b.getMonth(),b.getDate())).getTime()-(new Date(b.getFullYear(),0,0)).getTime())/864E5),3);
break;case "m":l+=g("m",b.getMonth()+1,2);break;case "M":l+=j("M",b.getMonth(),h,c);break;case "y":l+=i("y")?b.getFullYear():(b.getYear()%100<10?"0":"")+b.getYear()%100;break;case "@":l+=b.getTime();break;case "!":l+=b.getTime()*1E4+this._ticksTo1970;break;case "'":if(i("'"))l+="'";else u=true;break;default:l+=a.charAt(k)}return l},_possibleChars:function(a){for(var b="",c=false,e=function(h){(h=f+1<a.length&&a.charAt(f+1)==h)&&f++;return h},f=0;f<a.length;f++)if(c)if(a.charAt(f)=="'"&&!e("'"))c=
false;else b+=a.charAt(f);else switch(a.charAt(f)){case "d":case "m":case "y":case "@":b+="0123456789";break;case "D":case "M":return null;case "'":if(e("'"))b+="'";else c=true;break;default:b+=a.charAt(f)}return b},_get:function(a,b){return a.settings[b]!==C?a.settings[b]:this._defaults[b]},_setDateFromField:function(a,b){if(a.input.val()!=a.lastVal){var c=this._get(a,"dateFormat"),e=a.lastVal=a.input?a.input.val():null,f,h;f=h=this._getDefaultDate(a);var i=this._getFormatConfig(a);try{f=this.parseDate(c,
e,i)||h}catch(g){this.log(g);e=b?"":e}a.selectedDay=f.getDate();a.drawMonth=a.selectedMonth=f.getMonth();a.drawYear=a.selectedYear=f.getFullYear();a.currentDay=e?f.getDate():0;a.currentMonth=e?f.getMonth():0;a.currentYear=e?f.getFullYear():0;this._adjustInstDate(a)}},_getDefaultDate:function(a){return this._restrictMinMax(a,this._determineDate(a,this._get(a,"defaultDate"),new Date))},_determineDate:function(a,b,c){var e=function(h){var i=new Date;i.setDate(i.getDate()+h);return i},f=function(h){try{return d.datepicker.parseDate(d.datepicker._get(a,
"dateFormat"),h,d.datepicker._getFormatConfig(a))}catch(i){}var g=(h.toLowerCase().match(/^c/)?d.datepicker._getDate(a):null)||new Date,j=g.getFullYear(),l=g.getMonth();g=g.getDate();for(var u=/([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,k=u.exec(h);k;){switch(k[2]||"d"){case "d":case "D":g+=parseInt(k[1],10);break;case "w":case "W":g+=parseInt(k[1],10)*7;break;case "m":case "M":l+=parseInt(k[1],10);g=Math.min(g,d.datepicker._getDaysInMonth(j,l));break;case "y":case "Y":j+=parseInt(k[1],10);g=Math.min(g,
d.datepicker._getDaysInMonth(j,l));break}k=u.exec(h)}return new Date(j,l,g)};if(b=(b=b==null||b===""?c:typeof b=="string"?f(b):typeof b=="number"?isNaN(b)?c:e(b):new Date(b.getTime()))&&b.toString()=="Invalid Date"?c:b){b.setHours(0);b.setMinutes(0);b.setSeconds(0);b.setMilliseconds(0)}return this._daylightSavingAdjust(b)},_daylightSavingAdjust:function(a){if(!a)return null;a.setHours(a.getHours()>12?a.getHours()+2:0);return a},_setDate:function(a,b,c){var e=!b,f=a.selectedMonth,h=a.selectedYear;
b=this._restrictMinMax(a,this._determineDate(a,b,new Date));a.selectedDay=a.currentDay=b.getDate();a.drawMonth=a.selectedMonth=a.currentMonth=b.getMonth();a.drawYear=a.selectedYear=a.currentYear=b.getFullYear();if((f!=a.selectedMonth||h!=a.selectedYear)&&!c)this._notifyChange(a);this._adjustInstDate(a);if(a.input)a.input.val(e?"":this._formatDate(a));if(c=this._get(a,"onSelect")){e=this._formatDate(a);c.apply(a.input?a.input[0]:null,[e,a])}},_getDate:function(a){return!a.currentYear||a.input&&a.input.val()==
""?null:this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay))},_generateHTML:function(a){var b=new Date;b=this._daylightSavingAdjust(new Date(b.getFullYear(),b.getMonth(),b.getDate()));var c=this._get(a,"isRTL"),e=this._get(a,"showButtonPanel"),f=this._get(a,"hideIfNoPrevNext"),h=this._get(a,"navigationAsDateFormat"),i=this._getNumberOfMonths(a),g=this._get(a,"showCurrentAtPos"),j=this._get(a,"stepMonths"),l=i[0]!=1||i[1]!=1,u=this._daylightSavingAdjust(!a.currentDay?new Date(9999,
9,9):new Date(a.currentYear,a.currentMonth,a.currentDay)),k=this._getMinMaxDate(a,"min"),o=this._getMinMaxDate(a,"max");g=a.drawMonth-g;var m=a.drawYear;if(g<0){g+=12;m--}if(o){var n=this._daylightSavingAdjust(new Date(o.getFullYear(),o.getMonth()-i[0]*i[1]+1,o.getDate()));for(n=k&&n<k?k:n;this._daylightSavingAdjust(new Date(m,g,1))>n;){g--;if(g<0){g=11;m--}}}a.drawMonth=g;a.drawYear=m;n=this._get(a,"prevText");n=!h?n:this.formatDate(n,this._daylightSavingAdjust(new Date(m,g-j,1)),this._getFormatConfig(a));
n=this._canAdjustMonth(a,-1,m,g)?'<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_'+B+".datepicker._adjustDate('#"+a.id+"', -"+j+", 'M');\" title=\""+n+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+n+"</span></a>":f?"":'<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+n+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+n+"</span></a>";var s=this._get(a,"nextText");s=!h?s:this.formatDate(s,this._daylightSavingAdjust(new Date(m,
g+j,1)),this._getFormatConfig(a));f=this._canAdjustMonth(a,+1,m,g)?'<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_'+B+".datepicker._adjustDate('#"+a.id+"', +"+j+", 'M');\" title=\""+s+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+s+"</span></a>":f?"":'<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+s+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+s+"</span></a>";j=this._get(a,"currentText");s=this._get(a,"gotoCurrent")&&
a.currentDay?u:b;j=!h?j:this.formatDate(j,s,this._getFormatConfig(a));h=!a.inline?'<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_'+B+'.datepicker._hideDatepicker();">'+this._get(a,"closeText")+"</button>":"";e=e?'<div class="ui-datepicker-buttonpane ui-widget-content">'+(c?h:"")+(this._isInRange(a,s)?'<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_'+
B+".datepicker._gotoToday('#"+a.id+"');\">"+j+"</button>":"")+(c?"":h)+"</div>":"";h=parseInt(this._get(a,"firstDay"),10);h=isNaN(h)?0:h;j=this._get(a,"showWeek");s=this._get(a,"dayNames");this._get(a,"dayNamesShort");var q=this._get(a,"dayNamesMin"),A=this._get(a,"monthNames"),v=this._get(a,"monthNamesShort"),p=this._get(a,"beforeShowDay"),D=this._get(a,"showOtherMonths"),K=this._get(a,"selectOtherMonths");this._get(a,"calculateWeek");for(var E=this._getDefaultDate(a),w="",x=0;x<i[0];x++){var O=
"";this.maxRows=4;for(var G=0;G<i[1];G++){var P=this._daylightSavingAdjust(new Date(m,g,a.selectedDay)),t=" ui-corner-all",y="";if(l){y+='<div class="ui-datepicker-group';if(i[1]>1)switch(G){case 0:y+=" ui-datepicker-group-first";t=" ui-corner-"+(c?"right":"left");break;case i[1]-1:y+=" ui-datepicker-group-last";t=" ui-corner-"+(c?"left":"right");break;default:y+=" ui-datepicker-group-middle";t="";break}y+='">'}y+='<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix'+t+'">'+(/all|left/.test(t)&&
x==0?c?f:n:"")+(/all|right/.test(t)&&x==0?c?n:f:"")+this._generateMonthYearHeader(a,g,m,k,o,x>0||G>0,A,v)+'</div><table class="ui-datepicker-calendar"><thead><tr>';var z=j?'<th class="ui-datepicker-week-col">'+this._get(a,"weekHeader")+"</th>":"";for(t=0;t<7;t++){var r=(t+h)%7;z+="<th"+((t+h+6)%7>=5?' class="ui-datepicker-week-end"':"")+'><span title="'+s[r]+'">'+q[r]+"</span></th>"}y+=z+"</tr></thead><tbody>";z=this._getDaysInMonth(m,g);if(m==a.selectedYear&&g==a.selectedMonth)a.selectedDay=Math.min(a.selectedDay,
z);t=(this._getFirstDayOfMonth(m,g)-h+7)%7;z=Math.ceil((t+z)/7);this.maxRows=z=l?this.maxRows>z?this.maxRows:z:z;r=this._daylightSavingAdjust(new Date(m,g,1-t));for(var Q=0;Q<z;Q++){y+="<tr>";var R=!j?"":'<td class="ui-datepicker-week-col">'+this._get(a,"calculateWeek")(r)+"</td>";for(t=0;t<7;t++){var I=p?p.apply(a.input?a.input[0]:null,[r]):[true,""],F=r.getMonth()!=g,L=F&&!K||!I[0]||k&&r<k||o&&r>o;R+='<td class="'+((t+h+6)%7>=5?" ui-datepicker-week-end":"")+(F?" ui-datepicker-other-month":"")+(r.getTime()==
P.getTime()&&g==a.selectedMonth&&a._keyEvent||E.getTime()==r.getTime()&&E.getTime()==P.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(F&&!D?"":" "+I[1]+(r.getTime()==u.getTime()?" "+this._currentClass:"")+(r.getTime()==b.getTime()?" ui-datepicker-today":""))+'"'+((!F||D)&&I[2]?' title="'+I[2]+'"':"")+(L?"":' onclick="DP_jQuery_'+B+".datepicker._selectDay('#"+a.id+"',"+r.getMonth()+","+r.getFullYear()+', this);return false;"')+">"+(F&&!D?"&#xa0;":L?'<span class="ui-state-default">'+
r.getDate()+"</span>":'<a class="ui-state-default'+(r.getTime()==b.getTime()?" ui-state-highlight":"")+(r.getTime()==u.getTime()?" ui-state-active":"")+(F?" ui-priority-secondary":"")+'" href="#">'+r.getDate()+"</a>")+"</td>";r.setDate(r.getDate()+1);r=this._daylightSavingAdjust(r)}y+=R+"</tr>"}g++;if(g>11){g=0;m++}y+="</tbody></table>"+(l?"</div>"+(i[0]>0&&G==i[1]-1?'<div class="ui-datepicker-row-break"></div>':""):"");O+=y}w+=O}w+=e+(d.browser.msie&&parseInt(d.browser.version,10)<7&&!a.inline?'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>':
"");a._keyEvent=false;return w},_generateMonthYearHeader:function(a,b,c,e,f,h,i,g){var j=this._get(a,"changeMonth"),l=this._get(a,"changeYear"),u=this._get(a,"showMonthAfterYear"),k='<div class="ui-datepicker-title">',o="";if(h||!j)o+='<span class="ui-datepicker-month">'+i[b]+"</span>";else{i=e&&e.getFullYear()==c;var m=f&&f.getFullYear()==c;o+='<select class="ui-datepicker-month" onchange="DP_jQuery_'+B+".datepicker._selectMonthYear('#"+a.id+"', this, 'M');\" >";for(var n=0;n<12;n++)if((!i||n>=e.getMonth())&&
(!m||n<=f.getMonth()))o+='<option value="'+n+'"'+(n==b?' selected="selected"':"")+">"+g[n]+"</option>";o+="</select>"}u||(k+=o+(h||!(j&&l)?"&#xa0;":""));if(!a.yearshtml){a.yearshtml="";if(h||!l)k+='<span class="ui-datepicker-year">'+c+"</span>";else{g=this._get(a,"yearRange").split(":");var s=(new Date).getFullYear();i=function(q){q=q.match(/c[+-].*/)?c+parseInt(q.substring(1),10):q.match(/[+-].*/)?s+parseInt(q,10):parseInt(q,10);return isNaN(q)?s:q};b=i(g[0]);g=Math.max(b,i(g[1]||""));b=e?Math.max(b,
e.getFullYear()):b;g=f?Math.min(g,f.getFullYear()):g;for(a.yearshtml+='<select class="ui-datepicker-year" onchange="DP_jQuery_'+B+".datepicker._selectMonthYear('#"+a.id+"', this, 'Y');\" >";b<=g;b++)a.yearshtml+='<option value="'+b+'"'+(b==c?' selected="selected"':"")+">"+b+"</option>";a.yearshtml+="</select>";k+=a.yearshtml;a.yearshtml=null}}k+=this._get(a,"yearSuffix");if(u)k+=(h||!(j&&l)?"&#xa0;":"")+o;k+="</div>";return k},_adjustInstDate:function(a,b,c){var e=a.drawYear+(c=="Y"?b:0),f=a.drawMonth+
(c=="M"?b:0);b=Math.min(a.selectedDay,this._getDaysInMonth(e,f))+(c=="D"?b:0);e=this._restrictMinMax(a,this._daylightSavingAdjust(new Date(e,f,b)));a.selectedDay=e.getDate();a.drawMonth=a.selectedMonth=e.getMonth();a.drawYear=a.selectedYear=e.getFullYear();if(c=="M"||c=="Y")this._notifyChange(a)},_restrictMinMax:function(a,b){var c=this._getMinMaxDate(a,"min");a=this._getMinMaxDate(a,"max");b=c&&b<c?c:b;return b=a&&b>a?a:b},_notifyChange:function(a){var b=this._get(a,"onChangeMonthYear");if(b)b.apply(a.input?
a.input[0]:null,[a.selectedYear,a.selectedMonth+1,a])},_getNumberOfMonths:function(a){a=this._get(a,"numberOfMonths");return a==null?[1,1]:typeof a=="number"?[1,a]:a},_getMinMaxDate:function(a,b){return this._determineDate(a,this._get(a,b+"Date"),null)},_getDaysInMonth:function(a,b){return 32-this._daylightSavingAdjust(new Date(a,b,32)).getDate()},_getFirstDayOfMonth:function(a,b){return(new Date(a,b,1)).getDay()},_canAdjustMonth:function(a,b,c,e){var f=this._getNumberOfMonths(a);c=this._daylightSavingAdjust(new Date(c,
e+(b<0?b:f[0]*f[1]),1));b<0&&c.setDate(this._getDaysInMonth(c.getFullYear(),c.getMonth()));return this._isInRange(a,c)},_isInRange:function(a,b){var c=this._getMinMaxDate(a,"min");a=this._getMinMaxDate(a,"max");return(!c||b.getTime()>=c.getTime())&&(!a||b.getTime()<=a.getTime())},_getFormatConfig:function(a){var b=this._get(a,"shortYearCutoff");b=typeof b!="string"?b:(new Date).getFullYear()%100+parseInt(b,10);return{shortYearCutoff:b,dayNamesShort:this._get(a,"dayNamesShort"),dayNames:this._get(a,
"dayNames"),monthNamesShort:this._get(a,"monthNamesShort"),monthNames:this._get(a,"monthNames")}},_formatDate:function(a,b,c,e){if(!b){a.currentDay=a.selectedDay;a.currentMonth=a.selectedMonth;a.currentYear=a.selectedYear}b=b?typeof b=="object"?b:this._daylightSavingAdjust(new Date(e,c,b)):this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay));return this.formatDate(this._get(a,"dateFormat"),b,this._getFormatConfig(a))}});d.fn.datepicker=function(a){if(!this.length)return this;
if(!d.datepicker.initialized){d(document).mousedown(d.datepicker._checkExternalClick).find("body").append(d.datepicker.dpDiv);d.datepicker.initialized=true}var b=Array.prototype.slice.call(arguments,1);if(typeof a=="string"&&(a=="isDisabled"||a=="getDate"||a=="widget"))return d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this[0]].concat(b));if(a=="option"&&arguments.length==2&&typeof arguments[1]=="string")return d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this[0]].concat(b));return this.each(function(){typeof a==
"string"?d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this].concat(b)):d.datepicker._attachDatepicker(this,a)})};d.datepicker=new M;d.datepicker.initialized=false;d.datepicker.uuid=(new Date).getTime();d.datepicker.version="1.8.15";window["DP_jQuery_"+B]=d})(jQuery);
;/*
 * jQuery UI Progressbar 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function(b,d){b.widget("ui.progressbar",{options:{value:0,max:100},min:0,_create:function(){this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min,"aria-valuemax":this.options.max,"aria-valuenow":this._value()});this.valueDiv=b("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);this.oldValue=this._value();this._refreshValue()},destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
this.valueDiv.remove();b.Widget.prototype.destroy.apply(this,arguments)},value:function(a){if(a===d)return this._value();this._setOption("value",a);return this},_setOption:function(a,c){if(a==="value"){this.options.value=c;this._refreshValue();this._value()===this.options.max&&this._trigger("complete")}b.Widget.prototype._setOption.apply(this,arguments)},_value:function(){var a=this.options.value;if(typeof a!=="number")a=0;return Math.min(this.options.max,Math.max(this.min,a))},_percentage:function(){return 100*
this._value()/this.options.max},_refreshValue:function(){var a=this.value(),c=this._percentage();if(this.oldValue!==a){this.oldValue=a;this._trigger("change")}this.valueDiv.toggle(a>this.min).toggleClass("ui-corner-right",a===this.options.max).width(c.toFixed(0)+"%");this.element.attr("aria-valuenow",a)}});b.extend(b.ui.progressbar,{version:"1.8.15"})})(jQuery);
;/*
 * jQuery UI Effects 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
jQuery.effects||function(f,j){function m(c){var a;if(c&&c.constructor==Array&&c.length==3)return c;if(a=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(c))return[parseInt(a[1],10),parseInt(a[2],10),parseInt(a[3],10)];if(a=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(c))return[parseFloat(a[1])*2.55,parseFloat(a[2])*2.55,parseFloat(a[3])*2.55];if(a=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(c))return[parseInt(a[1],
16),parseInt(a[2],16),parseInt(a[3],16)];if(a=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(c))return[parseInt(a[1]+a[1],16),parseInt(a[2]+a[2],16),parseInt(a[3]+a[3],16)];if(/rgba\(0, 0, 0, 0\)/.exec(c))return n.transparent;return n[f.trim(c).toLowerCase()]}function s(c,a){var b;do{b=f.curCSS(c,a);if(b!=""&&b!="transparent"||f.nodeName(c,"body"))break;a="backgroundColor"}while(c=c.parentNode);return m(b)}function o(){var c=document.defaultView?document.defaultView.getComputedStyle(this,null):this.currentStyle,
a={},b,d;if(c&&c.length&&c[0]&&c[c[0]])for(var e=c.length;e--;){b=c[e];if(typeof c[b]=="string"){d=b.replace(/\-(\w)/g,function(g,h){return h.toUpperCase()});a[d]=c[b]}}else for(b in c)if(typeof c[b]==="string")a[b]=c[b];return a}function p(c){var a,b;for(a in c){b=c[a];if(b==null||f.isFunction(b)||a in t||/scrollbar/.test(a)||!/color/i.test(a)&&isNaN(parseFloat(b)))delete c[a]}return c}function u(c,a){var b={_:0},d;for(d in a)if(c[d]!=a[d])b[d]=a[d];return b}function k(c,a,b,d){if(typeof c=="object"){d=
a;b=null;a=c;c=a.effect}if(f.isFunction(a)){d=a;b=null;a={}}if(typeof a=="number"||f.fx.speeds[a]){d=b;b=a;a={}}if(f.isFunction(b)){d=b;b=null}a=a||{};b=b||a.duration;b=f.fx.off?0:typeof b=="number"?b:b in f.fx.speeds?f.fx.speeds[b]:f.fx.speeds._default;d=d||a.complete;return[c,a,b,d]}function l(c){if(!c||typeof c==="number"||f.fx.speeds[c])return true;if(typeof c==="string"&&!f.effects[c])return true;return false}f.effects={};f.each(["backgroundColor","borderBottomColor","borderLeftColor","borderRightColor",
"borderTopColor","borderColor","color","outlineColor"],function(c,a){f.fx.step[a]=function(b){if(!b.colorInit){b.start=s(b.elem,a);b.end=m(b.end);b.colorInit=true}b.elem.style[a]="rgb("+Math.max(Math.min(parseInt(b.pos*(b.end[0]-b.start[0])+b.start[0],10),255),0)+","+Math.max(Math.min(parseInt(b.pos*(b.end[1]-b.start[1])+b.start[1],10),255),0)+","+Math.max(Math.min(parseInt(b.pos*(b.end[2]-b.start[2])+b.start[2],10),255),0)+")"}});var n={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,
0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,
211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0],transparent:[255,255,255]},q=["add","remove","toggle"],t={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};f.effects.animateClass=function(c,a,b,
d){if(f.isFunction(b)){d=b;b=null}return this.queue(function(){var e=f(this),g=e.attr("style")||" ",h=p(o.call(this)),r,v=e.attr("class");f.each(q,function(w,i){c[i]&&e[i+"Class"](c[i])});r=p(o.call(this));e.attr("class",v);e.animate(u(h,r),{queue:false,duration:a,easing:b,complete:function(){f.each(q,function(w,i){c[i]&&e[i+"Class"](c[i])});if(typeof e.attr("style")=="object"){e.attr("style").cssText="";e.attr("style").cssText=g}else e.attr("style",g);d&&d.apply(this,arguments);f.dequeue(this)}})})};
f.fn.extend({_addClass:f.fn.addClass,addClass:function(c,a,b,d){return a?f.effects.animateClass.apply(this,[{add:c},a,b,d]):this._addClass(c)},_removeClass:f.fn.removeClass,removeClass:function(c,a,b,d){return a?f.effects.animateClass.apply(this,[{remove:c},a,b,d]):this._removeClass(c)},_toggleClass:f.fn.toggleClass,toggleClass:function(c,a,b,d,e){return typeof a=="boolean"||a===j?b?f.effects.animateClass.apply(this,[a?{add:c}:{remove:c},b,d,e]):this._toggleClass(c,a):f.effects.animateClass.apply(this,
[{toggle:c},a,b,d])},switchClass:function(c,a,b,d,e){return f.effects.animateClass.apply(this,[{add:a,remove:c},b,d,e])}});f.extend(f.effects,{version:"1.8.15",save:function(c,a){for(var b=0;b<a.length;b++)a[b]!==null&&c.data("ec.storage."+a[b],c[0].style[a[b]])},restore:function(c,a){for(var b=0;b<a.length;b++)a[b]!==null&&c.css(a[b],c.data("ec.storage."+a[b]))},setMode:function(c,a){if(a=="toggle")a=c.is(":hidden")?"show":"hide";return a},getBaseline:function(c,a){var b;switch(c[0]){case "top":b=
0;break;case "middle":b=0.5;break;case "bottom":b=1;break;default:b=c[0]/a.height}switch(c[1]){case "left":c=0;break;case "center":c=0.5;break;case "right":c=1;break;default:c=c[1]/a.width}return{x:c,y:b}},createWrapper:function(c){if(c.parent().is(".ui-effects-wrapper"))return c.parent();var a={width:c.outerWidth(true),height:c.outerHeight(true),"float":c.css("float")},b=f("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0});
c.wrap(b);b=c.parent();if(c.css("position")=="static"){b.css({position:"relative"});c.css({position:"relative"})}else{f.extend(a,{position:c.css("position"),zIndex:c.css("z-index")});f.each(["top","left","bottom","right"],function(d,e){a[e]=c.css(e);if(isNaN(parseInt(a[e],10)))a[e]="auto"});c.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})}return b.css(a).show()},removeWrapper:function(c){if(c.parent().is(".ui-effects-wrapper"))return c.parent().replaceWith(c);return c},setTransition:function(c,
a,b,d){d=d||{};f.each(a,function(e,g){unit=c.cssUnit(g);if(unit[0]>0)d[g]=unit[0]*b+unit[1]});return d}});f.fn.extend({effect:function(c){var a=k.apply(this,arguments),b={options:a[1],duration:a[2],callback:a[3]};a=b.options.mode;var d=f.effects[c];if(f.fx.off||!d)return a?this[a](b.duration,b.callback):this.each(function(){b.callback&&b.callback.call(this)});return d.call(this,b)},_show:f.fn.show,show:function(c){if(l(c))return this._show.apply(this,arguments);else{var a=k.apply(this,arguments);
a[1].mode="show";return this.effect.apply(this,a)}},_hide:f.fn.hide,hide:function(c){if(l(c))return this._hide.apply(this,arguments);else{var a=k.apply(this,arguments);a[1].mode="hide";return this.effect.apply(this,a)}},__toggle:f.fn.toggle,toggle:function(c){if(l(c)||typeof c==="boolean"||f.isFunction(c))return this.__toggle.apply(this,arguments);else{var a=k.apply(this,arguments);a[1].mode="toggle";return this.effect.apply(this,a)}},cssUnit:function(c){var a=this.css(c),b=[];f.each(["em","px","%",
"pt"],function(d,e){if(a.indexOf(e)>0)b=[parseFloat(a),e]});return b}});f.easing.jswing=f.easing.swing;f.extend(f.easing,{def:"easeOutQuad",swing:function(c,a,b,d,e){return f.easing[f.easing.def](c,a,b,d,e)},easeInQuad:function(c,a,b,d,e){return d*(a/=e)*a+b},easeOutQuad:function(c,a,b,d,e){return-d*(a/=e)*(a-2)+b},easeInOutQuad:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a+b;return-d/2*(--a*(a-2)-1)+b},easeInCubic:function(c,a,b,d,e){return d*(a/=e)*a*a+b},easeOutCubic:function(c,a,b,d,e){return d*
((a=a/e-1)*a*a+1)+b},easeInOutCubic:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a+b;return d/2*((a-=2)*a*a+2)+b},easeInQuart:function(c,a,b,d,e){return d*(a/=e)*a*a*a+b},easeOutQuart:function(c,a,b,d,e){return-d*((a=a/e-1)*a*a*a-1)+b},easeInOutQuart:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a*a+b;return-d/2*((a-=2)*a*a*a-2)+b},easeInQuint:function(c,a,b,d,e){return d*(a/=e)*a*a*a*a+b},easeOutQuint:function(c,a,b,d,e){return d*((a=a/e-1)*a*a*a*a+1)+b},easeInOutQuint:function(c,a,b,d,e){if((a/=
e/2)<1)return d/2*a*a*a*a*a+b;return d/2*((a-=2)*a*a*a*a+2)+b},easeInSine:function(c,a,b,d,e){return-d*Math.cos(a/e*(Math.PI/2))+d+b},easeOutSine:function(c,a,b,d,e){return d*Math.sin(a/e*(Math.PI/2))+b},easeInOutSine:function(c,a,b,d,e){return-d/2*(Math.cos(Math.PI*a/e)-1)+b},easeInExpo:function(c,a,b,d,e){return a==0?b:d*Math.pow(2,10*(a/e-1))+b},easeOutExpo:function(c,a,b,d,e){return a==e?b+d:d*(-Math.pow(2,-10*a/e)+1)+b},easeInOutExpo:function(c,a,b,d,e){if(a==0)return b;if(a==e)return b+d;if((a/=
e/2)<1)return d/2*Math.pow(2,10*(a-1))+b;return d/2*(-Math.pow(2,-10*--a)+2)+b},easeInCirc:function(c,a,b,d,e){return-d*(Math.sqrt(1-(a/=e)*a)-1)+b},easeOutCirc:function(c,a,b,d,e){return d*Math.sqrt(1-(a=a/e-1)*a)+b},easeInOutCirc:function(c,a,b,d,e){if((a/=e/2)<1)return-d/2*(Math.sqrt(1-a*a)-1)+b;return d/2*(Math.sqrt(1-(a-=2)*a)+1)+b},easeInElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e)==1)return b+d;g||(g=e*0.3);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/
h);return-(h*Math.pow(2,10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g))+b},easeOutElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e)==1)return b+d;g||(g=e*0.3);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/h);return h*Math.pow(2,-10*a)*Math.sin((a*e-c)*2*Math.PI/g)+d+b},easeInOutElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e/2)==2)return b+d;g||(g=e*0.3*1.5);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/h);if(a<1)return-0.5*
h*Math.pow(2,10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g)+b;return h*Math.pow(2,-10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g)*0.5+d+b},easeInBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;return d*(a/=e)*a*((g+1)*a-g)+b},easeOutBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;return d*((a=a/e-1)*a*((g+1)*a+g)+1)+b},easeInOutBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;if((a/=e/2)<1)return d/2*a*a*(((g*=1.525)+1)*a-g)+b;return d/2*((a-=2)*a*(((g*=1.525)+1)*a+g)+2)+b},easeInBounce:function(c,a,b,d,e){return d-f.easing.easeOutBounce(c,
e-a,0,d,e)+b},easeOutBounce:function(c,a,b,d,e){return(a/=e)<1/2.75?d*7.5625*a*a+b:a<2/2.75?d*(7.5625*(a-=1.5/2.75)*a+0.75)+b:a<2.5/2.75?d*(7.5625*(a-=2.25/2.75)*a+0.9375)+b:d*(7.5625*(a-=2.625/2.75)*a+0.984375)+b},easeInOutBounce:function(c,a,b,d,e){if(a<e/2)return f.easing.easeInBounce(c,a*2,0,d,e)*0.5+b;return f.easing.easeOutBounce(c,a*2-e,0,d,e)*0.5+d*0.5+b}})}(jQuery);
;/*
 * jQuery UI Effects Blind 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Blind
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.blind=function(c){return this.queue(function(){var a=b(this),g=["position","top","bottom","left","right"],f=b.effects.setMode(a,c.options.mode||"hide"),d=c.options.direction||"vertical";b.effects.save(a,g);a.show();var e=b.effects.createWrapper(a).css({overflow:"hidden"}),h=d=="vertical"?"height":"width";d=d=="vertical"?e.height():e.width();f=="show"&&e.css(h,0);var i={};i[h]=f=="show"?d:0;e.animate(i,c.duration,c.options.easing,function(){f=="hide"&&a.hide();b.effects.restore(a,
g);b.effects.removeWrapper(a);c.callback&&c.callback.apply(a[0],arguments);a.dequeue()})})}})(jQuery);
;/*
 * jQuery UI Effects Bounce 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Bounce
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(e){e.effects.bounce=function(b){return this.queue(function(){var a=e(this),l=["position","top","bottom","left","right"],h=e.effects.setMode(a,b.options.mode||"effect"),d=b.options.direction||"up",c=b.options.distance||20,m=b.options.times||5,i=b.duration||250;/show|hide/.test(h)&&l.push("opacity");e.effects.save(a,l);a.show();e.effects.createWrapper(a);var f=d=="up"||d=="down"?"top":"left";d=d=="up"||d=="left"?"pos":"neg";c=b.options.distance||(f=="top"?a.outerHeight({margin:true})/3:a.outerWidth({margin:true})/
3);if(h=="show")a.css("opacity",0).css(f,d=="pos"?-c:c);if(h=="hide")c/=m*2;h!="hide"&&m--;if(h=="show"){var g={opacity:1};g[f]=(d=="pos"?"+=":"-=")+c;a.animate(g,i/2,b.options.easing);c/=2;m--}for(g=0;g<m;g++){var j={},k={};j[f]=(d=="pos"?"-=":"+=")+c;k[f]=(d=="pos"?"+=":"-=")+c;a.animate(j,i/2,b.options.easing).animate(k,i/2,b.options.easing);c=h=="hide"?c*2:c/2}if(h=="hide"){g={opacity:0};g[f]=(d=="pos"?"-=":"+=")+c;a.animate(g,i/2,b.options.easing,function(){a.hide();e.effects.restore(a,l);e.effects.removeWrapper(a);
b.callback&&b.callback.apply(this,arguments)})}else{j={};k={};j[f]=(d=="pos"?"-=":"+=")+c;k[f]=(d=="pos"?"+=":"-=")+c;a.animate(j,i/2,b.options.easing).animate(k,i/2,b.options.easing,function(){e.effects.restore(a,l);e.effects.removeWrapper(a);b.callback&&b.callback.apply(this,arguments)})}a.queue("fx",function(){a.dequeue()});a.dequeue()})}})(jQuery);
;/*
 * jQuery UI Effects Clip 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Clip
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.clip=function(e){return this.queue(function(){var a=b(this),i=["position","top","bottom","left","right","height","width"],f=b.effects.setMode(a,e.options.mode||"hide"),c=e.options.direction||"vertical";b.effects.save(a,i);a.show();var d=b.effects.createWrapper(a).css({overflow:"hidden"});d=a[0].tagName=="IMG"?d:a;var g={size:c=="vertical"?"height":"width",position:c=="vertical"?"top":"left"};c=c=="vertical"?d.height():d.width();if(f=="show"){d.css(g.size,0);d.css(g.position,
c/2)}var h={};h[g.size]=f=="show"?c:0;h[g.position]=f=="show"?0:c/2;d.animate(h,{queue:false,duration:e.duration,easing:e.options.easing,complete:function(){f=="hide"&&a.hide();b.effects.restore(a,i);b.effects.removeWrapper(a);e.callback&&e.callback.apply(a[0],arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Drop 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Drop
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.drop=function(d){return this.queue(function(){var a=c(this),h=["position","top","bottom","left","right","opacity"],e=c.effects.setMode(a,d.options.mode||"hide"),b=d.options.direction||"left";c.effects.save(a,h);a.show();c.effects.createWrapper(a);var f=b=="up"||b=="down"?"top":"left";b=b=="up"||b=="left"?"pos":"neg";var g=d.options.distance||(f=="top"?a.outerHeight({margin:true})/2:a.outerWidth({margin:true})/2);if(e=="show")a.css("opacity",0).css(f,b=="pos"?-g:g);var i={opacity:e==
"show"?1:0};i[f]=(e=="show"?b=="pos"?"+=":"-=":b=="pos"?"-=":"+=")+g;a.animate(i,{queue:false,duration:d.duration,easing:d.options.easing,complete:function(){e=="hide"&&a.hide();c.effects.restore(a,h);c.effects.removeWrapper(a);d.callback&&d.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Explode 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Explode
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(j){j.effects.explode=function(a){return this.queue(function(){var c=a.options.pieces?Math.round(Math.sqrt(a.options.pieces)):3,d=a.options.pieces?Math.round(Math.sqrt(a.options.pieces)):3;a.options.mode=a.options.mode=="toggle"?j(this).is(":visible")?"hide":"show":a.options.mode;var b=j(this).show().css("visibility","hidden"),g=b.offset();g.top-=parseInt(b.css("marginTop"),10)||0;g.left-=parseInt(b.css("marginLeft"),10)||0;for(var h=b.outerWidth(true),i=b.outerHeight(true),e=0;e<c;e++)for(var f=
0;f<d;f++)b.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-f*(h/d),top:-e*(i/c)}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:h/d,height:i/c,left:g.left+f*(h/d)+(a.options.mode=="show"?(f-Math.floor(d/2))*(h/d):0),top:g.top+e*(i/c)+(a.options.mode=="show"?(e-Math.floor(c/2))*(i/c):0),opacity:a.options.mode=="show"?0:1}).animate({left:g.left+f*(h/d)+(a.options.mode=="show"?0:(f-Math.floor(d/2))*(h/d)),top:g.top+
e*(i/c)+(a.options.mode=="show"?0:(e-Math.floor(c/2))*(i/c)),opacity:a.options.mode=="show"?1:0},a.duration||500);setTimeout(function(){a.options.mode=="show"?b.css({visibility:"visible"}):b.css({visibility:"visible"}).hide();a.callback&&a.callback.apply(b[0]);b.dequeue();j("div.ui-effects-explode").remove()},a.duration||500)})}})(jQuery);
;/*
 * jQuery UI Effects Fade 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fade
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.fade=function(a){return this.queue(function(){var c=b(this),d=b.effects.setMode(c,a.options.mode||"hide");c.animate({opacity:d},{queue:false,duration:a.duration,easing:a.options.easing,complete:function(){a.callback&&a.callback.apply(this,arguments);c.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Fold 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fold
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.fold=function(a){return this.queue(function(){var b=c(this),j=["position","top","bottom","left","right"],d=c.effects.setMode(b,a.options.mode||"hide"),g=a.options.size||15,h=!!a.options.horizFirst,k=a.duration?a.duration/2:c.fx.speeds._default/2;c.effects.save(b,j);b.show();var e=c.effects.createWrapper(b).css({overflow:"hidden"}),f=d=="show"!=h,l=f?["width","height"]:["height","width"];f=f?[e.width(),e.height()]:[e.height(),e.width()];var i=/([0-9]+)%/.exec(g);if(i)g=parseInt(i[1],
10)/100*f[d=="hide"?0:1];if(d=="show")e.css(h?{height:0,width:g}:{height:g,width:0});h={};i={};h[l[0]]=d=="show"?f[0]:g;i[l[1]]=d=="show"?f[1]:0;e.animate(h,k,a.options.easing).animate(i,k,a.options.easing,function(){d=="hide"&&b.hide();c.effects.restore(b,j);c.effects.removeWrapper(b);a.callback&&a.callback.apply(b[0],arguments);b.dequeue()})})}})(jQuery);
;/*
 * jQuery UI Effects Highlight 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Highlight
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.highlight=function(c){return this.queue(function(){var a=b(this),e=["backgroundImage","backgroundColor","opacity"],d=b.effects.setMode(a,c.options.mode||"show"),f={backgroundColor:a.css("backgroundColor")};if(d=="hide")f.opacity=0;b.effects.save(a,e);a.show().css({backgroundImage:"none",backgroundColor:c.options.color||"#ffff99"}).animate(f,{queue:false,duration:c.duration,easing:c.options.easing,complete:function(){d=="hide"&&a.hide();b.effects.restore(a,e);d=="show"&&!b.support.opacity&&
this.style.removeAttribute("filter");c.callback&&c.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Pulsate 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Pulsate
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(d){d.effects.pulsate=function(a){return this.queue(function(){var b=d(this),c=d.effects.setMode(b,a.options.mode||"show");times=(a.options.times||5)*2-1;duration=a.duration?a.duration/2:d.fx.speeds._default/2;isVisible=b.is(":visible");animateTo=0;if(!isVisible){b.css("opacity",0).show();animateTo=1}if(c=="hide"&&isVisible||c=="show"&&!isVisible)times--;for(c=0;c<times;c++){b.animate({opacity:animateTo},duration,a.options.easing);animateTo=(animateTo+1)%2}b.animate({opacity:animateTo},duration,
a.options.easing,function(){animateTo==0&&b.hide();a.callback&&a.callback.apply(this,arguments)});b.queue("fx",function(){b.dequeue()}).dequeue()})}})(jQuery);
;/*
 * jQuery UI Effects Scale 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Scale
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.puff=function(b){return this.queue(function(){var a=c(this),e=c.effects.setMode(a,b.options.mode||"hide"),g=parseInt(b.options.percent,10)||150,h=g/100,i={height:a.height(),width:a.width()};c.extend(b.options,{fade:true,mode:e,percent:e=="hide"?g:100,from:e=="hide"?i:{height:i.height*h,width:i.width*h}});a.effect("scale",b.options,b.duration,b.callback);a.dequeue()})};c.effects.scale=function(b){return this.queue(function(){var a=c(this),e=c.extend(true,{},b.options),g=c.effects.setMode(a,
b.options.mode||"effect"),h=parseInt(b.options.percent,10)||(parseInt(b.options.percent,10)==0?0:g=="hide"?0:100),i=b.options.direction||"both",f=b.options.origin;if(g!="effect"){e.origin=f||["middle","center"];e.restore=true}f={height:a.height(),width:a.width()};a.from=b.options.from||(g=="show"?{height:0,width:0}:f);h={y:i!="horizontal"?h/100:1,x:i!="vertical"?h/100:1};a.to={height:f.height*h.y,width:f.width*h.x};if(b.options.fade){if(g=="show"){a.from.opacity=0;a.to.opacity=1}if(g=="hide"){a.from.opacity=
1;a.to.opacity=0}}e.from=a.from;e.to=a.to;e.mode=g;a.effect("size",e,b.duration,b.callback);a.dequeue()})};c.effects.size=function(b){return this.queue(function(){var a=c(this),e=["position","top","bottom","left","right","width","height","overflow","opacity"],g=["position","top","bottom","left","right","overflow","opacity"],h=["width","height","overflow"],i=["fontSize"],f=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],k=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],
p=c.effects.setMode(a,b.options.mode||"effect"),n=b.options.restore||false,m=b.options.scale||"both",l=b.options.origin,j={height:a.height(),width:a.width()};a.from=b.options.from||j;a.to=b.options.to||j;if(l){l=c.effects.getBaseline(l,j);a.from.top=(j.height-a.from.height)*l.y;a.from.left=(j.width-a.from.width)*l.x;a.to.top=(j.height-a.to.height)*l.y;a.to.left=(j.width-a.to.width)*l.x}var d={from:{y:a.from.height/j.height,x:a.from.width/j.width},to:{y:a.to.height/j.height,x:a.to.width/j.width}};
if(m=="box"||m=="both"){if(d.from.y!=d.to.y){e=e.concat(f);a.from=c.effects.setTransition(a,f,d.from.y,a.from);a.to=c.effects.setTransition(a,f,d.to.y,a.to)}if(d.from.x!=d.to.x){e=e.concat(k);a.from=c.effects.setTransition(a,k,d.from.x,a.from);a.to=c.effects.setTransition(a,k,d.to.x,a.to)}}if(m=="content"||m=="both")if(d.from.y!=d.to.y){e=e.concat(i);a.from=c.effects.setTransition(a,i,d.from.y,a.from);a.to=c.effects.setTransition(a,i,d.to.y,a.to)}c.effects.save(a,n?e:g);a.show();c.effects.createWrapper(a);
a.css("overflow","hidden").css(a.from);if(m=="content"||m=="both"){f=f.concat(["marginTop","marginBottom"]).concat(i);k=k.concat(["marginLeft","marginRight"]);h=e.concat(f).concat(k);a.find("*[width]").each(function(){child=c(this);n&&c.effects.save(child,h);var o={height:child.height(),width:child.width()};child.from={height:o.height*d.from.y,width:o.width*d.from.x};child.to={height:o.height*d.to.y,width:o.width*d.to.x};if(d.from.y!=d.to.y){child.from=c.effects.setTransition(child,f,d.from.y,child.from);
child.to=c.effects.setTransition(child,f,d.to.y,child.to)}if(d.from.x!=d.to.x){child.from=c.effects.setTransition(child,k,d.from.x,child.from);child.to=c.effects.setTransition(child,k,d.to.x,child.to)}child.css(child.from);child.animate(child.to,b.duration,b.options.easing,function(){n&&c.effects.restore(child,h)})})}a.animate(a.to,{queue:false,duration:b.duration,easing:b.options.easing,complete:function(){a.to.opacity===0&&a.css("opacity",a.from.opacity);p=="hide"&&a.hide();c.effects.restore(a,
n?e:g);c.effects.removeWrapper(a);b.callback&&b.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Shake 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Shake
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(d){d.effects.shake=function(a){return this.queue(function(){var b=d(this),j=["position","top","bottom","left","right"];d.effects.setMode(b,a.options.mode||"effect");var c=a.options.direction||"left",e=a.options.distance||20,l=a.options.times||3,f=a.duration||a.options.duration||140;d.effects.save(b,j);b.show();d.effects.createWrapper(b);var g=c=="up"||c=="down"?"top":"left",h=c=="up"||c=="left"?"pos":"neg";c={};var i={},k={};c[g]=(h=="pos"?"-=":"+=")+e;i[g]=(h=="pos"?"+=":"-=")+e*2;k[g]=
(h=="pos"?"-=":"+=")+e*2;b.animate(c,f,a.options.easing);for(e=1;e<l;e++)b.animate(i,f,a.options.easing).animate(k,f,a.options.easing);b.animate(i,f,a.options.easing).animate(c,f/2,a.options.easing,function(){d.effects.restore(b,j);d.effects.removeWrapper(b);a.callback&&a.callback.apply(this,arguments)});b.queue("fx",function(){b.dequeue()});b.dequeue()})}})(jQuery);
;/*
 * jQuery UI Effects Slide 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Slide
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.slide=function(d){return this.queue(function(){var a=c(this),h=["position","top","bottom","left","right"],f=c.effects.setMode(a,d.options.mode||"show"),b=d.options.direction||"left";c.effects.save(a,h);a.show();c.effects.createWrapper(a).css({overflow:"hidden"});var g=b=="up"||b=="down"?"top":"left";b=b=="up"||b=="left"?"pos":"neg";var e=d.options.distance||(g=="top"?a.outerHeight({margin:true}):a.outerWidth({margin:true}));if(f=="show")a.css(g,b=="pos"?isNaN(e)?"-"+e:-e:e);
var i={};i[g]=(f=="show"?b=="pos"?"+=":"-=":b=="pos"?"-=":"+=")+e;a.animate(i,{queue:false,duration:d.duration,easing:d.options.easing,complete:function(){f=="hide"&&a.hide();c.effects.restore(a,h);c.effects.removeWrapper(a);d.callback&&d.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Transfer 1.8.15
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Transfer
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(e){e.effects.transfer=function(a){return this.queue(function(){var b=e(this),c=e(a.options.to),d=c.offset();c={top:d.top,left:d.left,height:c.innerHeight(),width:c.innerWidth()};d=b.offset();var f=e('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(a.options.className).css({top:d.top,left:d.left,height:b.innerHeight(),width:b.innerWidth(),position:"absolute"}).animate(c,a.duration,a.options.easing,function(){f.remove();a.callback&&a.callback.apply(b[0],arguments);
b.dequeue()})})}})(jQuery);
;


/**
 * jQuery Validation Plugin 1.8.1
 *
 * http://bassistance.de/jquery-plugins/jquery-plugin-validation/
 * http://docs.jquery.com/Plugins/Validation
 *
 * Copyright (c) 2006 - 2011 Jörn Zaefferer
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

(function($) {

$.extend($.fn, {

    removeValidator: function() {
        //this.unbind();
        this.unbind('focusin focusout keyup');
        this.unbind('click');
        this.unbind('invalid-form.validate');
        this.unbind('.validate-equalTo');
        jQuery.removeData(this[0], 'validator'); 
    },

	// http://docs.jquery.com/Plugins/Validation/validate
	validate: function( options ) {

		// if nothing is selected, return nothing; can't chain anyway
		if (!this.length) {
			options && options.debug && window.console && console.warn( "nothing selected, can't validate, returning nothing" );
			return;
		}

		// check if a validator for this form was already created
		var validator = $.data(this[0], 'validator');
		if ( validator ) {
			return validator;
		}

		validator = new $.validator( options, this[0] );
		$.data(this[0], 'validator', validator);

		if ( validator.settings.onsubmit ) {

			// allow suppresing validation by adding a cancel class to the submit button
			this.find("input, button").filter(".cancel").click(function() {
				validator.cancelSubmit = true;
			});

			// when a submitHandler is used, capture the submitting button
			if (validator.settings.submitHandler) {
				this.find("input, button").filter(":submit").click(function() {
					validator.submitButton = this;
				});
			}

			// validate the form on submit
			this.submit( function( event ) {
				if ( validator.settings.debug )
					// prevent form submit to be able to see console output
					event.preventDefault();

				function handle() {
					if ( validator.settings.submitHandler ) {
						if (validator.submitButton) {
							// insert a hidden input as a replacement for the missing submit button
							var hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val(validator.submitButton.value).appendTo(validator.currentForm);
						}
						validator.settings.submitHandler.call( validator, validator.currentForm );
						if (validator.submitButton) {
							// and clean up afterwards; thanks to no-block-scope, hidden can be referenced
							hidden.remove();
						}
						return false;
					}
					return true;
				}

				// prevent submit for invalid forms or custom submit handlers
				if ( validator.cancelSubmit ) {
					validator.cancelSubmit = false;
					return handle();
				}
				if ( validator.form() ) {
					if ( validator.pendingRequest ) {
						validator.formSubmitted = true;
						return false;
					}
					return handle();
				} else {
					validator.focusInvalid();
					return false;
				}
			});
		}

		return validator;
	},
	// http://docs.jquery.com/Plugins/Validation/valid
	valid: function() {
        if ( $(this[0]).is('form')) {
            return this.validate().form();
        } else {
            var valid = true;
            var validator = $(this[0].form).validate();
            this.each(function() {
				valid &= validator.element(this);
            });
            return valid;
        }
    },
	// attributes: space seperated list of attributes to retrieve and remove
	removeAttrs: function(attributes) {
		var result = {},
			$element = this;
		$.each(attributes.split(/\s+/), function(index, value) {
			result[value] = $element.attr(value);
			$element.removeAttr(value);
		});
		return result;
	},
	// http://docs.jquery.com/Plugins/Validation/rules
	rules: function(command, argument) {
		var element = this[0];

		if (command) {
			var settings = $.data(element.form, 'validator').settings;
			var staticRules = settings.rules;
			var existingRules = $.validator.staticRules(element);
			switch(command) {
			case "add":
				$.extend(existingRules, $.validator.normalizeRule(argument));
				staticRules[element.name] = existingRules;
				if (argument.messages)
					settings.messages[element.name] = $.extend( settings.messages[element.name], argument.messages );
				break;
			case "remove":
				if (!argument) {
					delete staticRules[element.name];
					return existingRules;
				}
				var filtered = {};
				$.each(argument.split(/\s+/), function(index, method) {
					filtered[method] = existingRules[method];
					delete existingRules[method];
				});
				return filtered;
			}
		}

		var data = $.validator.normalizeRules(
		$.extend(
			{},
			$.validator.metadataRules(element),
			$.validator.classRules(element),
			$.validator.attributeRules(element),
			$.validator.staticRules(element)
		), element);

		// make sure required is at front
		if (data.required) {
			var param = data.required;
			delete data.required;
			data = $.extend({required: param}, data);
		}

		return data;
	}
});

// Custom selectors
$.extend($.expr[":"], {
	// http://docs.jquery.com/Plugins/Validation/blank
	blank: function(a) {return !$.trim("" + a.value);},
	// http://docs.jquery.com/Plugins/Validation/filled
	filled: function(a) {return !!$.trim("" + a.value);},
	// http://docs.jquery.com/Plugins/Validation/unchecked
	unchecked: function(a) {return !a.checked;}
});

// constructor for validator
$.validator = function( options, form ) {
	this.settings = $.extend( true, {}, $.validator.defaults, options );
	this.currentForm = form;
	this.init();
};

$.validator.format = function(source, params) {
	if ( arguments.length == 1 )
		return function() {
			var args = $.makeArray(arguments);
			args.unshift(source);
			return $.validator.format.apply( this, args );
		};
	if ( arguments.length > 2 && params.constructor != Array  ) {
		params = $.makeArray(arguments).slice(1);
	}
	if ( params.constructor != Array ) {
		params = [ params ];
	}
	$.each(params, function(i, n) {
		source = source.replace(new RegExp("\\{" + i + "\\}", "g"), n);
	});
	return source;
};

$.extend($.validator, {

	defaults: {
		messages: {},
		groups: {},
		rules: {},
		errorClass: "error",
		validClass: "valid",
		errorElement: "label",
		focusInvalid: true,
		errorContainer: $( [] ),
		errorLabelContainer: $( [] ),
		onsubmit: true,
		ignore: [],
		ignoreTitle: false,
		onfocusin: function(element) {
			this.lastActive = element;

			// hide error label and remove error class on focus if enabled
			if ( this.settings.focusCleanup && !this.blockFocusCleanup ) {
				this.settings.unhighlight && this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
				this.addWrapper(this.errorsFor(element)).hide();
			}
		},
		onfocusout: function(element) {
			if ( !this.checkable(element) && (element.name in this.submitted || !this.optional(element)) ) {
				this.element(element);
			}
		},
		onkeyup: function(element) {
			if ( element.name in this.submitted || element == this.lastElement ) {
				this.element(element);
			}
		},
		onclick: function(element) {
			// click on selects, radiobuttons and checkboxes
			if ( element.name in this.submitted )
				this.element(element);
			// or option elements, check parent select in that case
			else if (element.parentNode.name in this.submitted)
				this.element(element.parentNode);
		},
		highlight: function(element, errorClass, validClass) {
			if (element.type === 'radio') {
				this.findByName(element.name).addClass(errorClass).removeClass(validClass);
			} else {
				$(element).addClass(errorClass).removeClass(validClass);
			}
		},
		unhighlight: function(element, errorClass, validClass) {
			if (element.type === 'radio') {
				this.findByName(element.name).removeClass(errorClass).addClass(validClass);
			} else {
				$(element).removeClass(errorClass).addClass(validClass);
			}
		}
	},

	// http://docs.jquery.com/Plugins/Validation/Validator/setDefaults
	setDefaults: function(settings) {
		$.extend( $.validator.defaults, settings );
	},

	messages: {
		required: "This field is required.",
		remote: "Please fix this field.",
		email: "Please enter a valid email address.",
		url: "Please enter a valid URL.",
		date: "Please enter a valid date.",
		dateISO: "Please enter a valid date (ISO).",
		number: "Please enter a valid number.",
		digits: "Please enter only digits.",
		creditcard: "Please enter a valid credit card number.",
		equalTo: "Please enter the same value again.",
		accept: "Please enter a value with a valid extension.",
		maxlength: $.validator.format("Please enter no more than {0} characters."),
		minlength: $.validator.format("Please enter at least {0} characters."),
		rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
		range: $.validator.format("Please enter a value between {0} and {1}."),
		max: $.validator.format("Please enter a value less than or equal to {0}."),
		min: $.validator.format("Please enter a value greater than or equal to {0}.")
	},

	autoCreateRanges: false,

	prototype: {

		init: function() {
			this.labelContainer = $(this.settings.errorLabelContainer);
			this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
			this.containers = $(this.settings.errorContainer).add( this.settings.errorLabelContainer );
			this.submitted = {};
			this.valueCache = {};
			this.pendingRequest = 0;
			this.pending = {};
			this.invalid = {};
			this.reset();

			var groups = (this.groups = {});
			$.each(this.settings.groups, function(key, value) {
				$.each(value.split(/\s+/), function(index, name) {
					groups[name] = key;
				});
			});
			var rules = this.settings.rules;
			$.each(rules, function(key, value) {
				rules[key] = $.validator.normalizeRule(value);
			});

			function delegate(event) {
				var validator = $.data(this[0].form, "validator"),
					eventType = "on" + event.type.replace(/^validate/, "");
				validator.settings[eventType] && validator.settings[eventType].call(validator, this[0] );
			}
			$(this.currentForm)
				.validateDelegate(":text, :password, :file, select, textarea", "focusin focusout keyup", delegate)
				.validateDelegate(":radio, :checkbox, select, option", "click", delegate);

			if (this.settings.invalidHandler)
				$(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);
		},

		// http://docs.jquery.com/Plugins/Validation/Validator/form
		form: function() {
			this.checkForm();
			$.extend(this.submitted, this.errorMap);
			this.invalid = $.extend({}, this.errorMap);
			if (!this.valid())
				$(this.currentForm).triggerHandler("invalid-form", [this]);
			this.showErrors();
			return this.valid();
		},

		checkForm: function() {
			this.prepareForm();
			for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) {
				this.check( elements[i] );
			}
			return this.valid();
		},

		// http://docs.jquery.com/Plugins/Validation/Validator/element
		element: function( element ) {
			element = this.clean( element );
			this.lastElement = element;
			this.prepareElement( element );
			this.currentElements = $(element);
			var result = this.check( element );
			if ( result ) {
				delete this.invalid[element.name];
			} else {
				this.invalid[element.name] = true;
			}
			if ( !this.numberOfInvalids() ) {
				// Hide error containers on last error
				this.toHide = this.toHide.add( this.containers );
			}
			this.showErrors();
			return result;
		},

		// http://docs.jquery.com/Plugins/Validation/Validator/showErrors
		showErrors: function(errors) {
			if(errors) {
				// add items to error list and map
				$.extend( this.errorMap, errors );
				this.errorList = [];
				for ( var name in errors ) {
					this.errorList.push({
						message: errors[name],
						element: this.findByName(name)[0]
					});
				}
				// remove items from success list
				this.successList = $.grep( this.successList, function(element) {
					return !(element.name in errors);
				});
			}
			this.settings.showErrors
				? this.settings.showErrors.call( this, this.errorMap, this.errorList )
				: this.defaultShowErrors();
		},

		// http://docs.jquery.com/Plugins/Validation/Validator/resetForm
		resetForm: function() {
			if ( $.fn.resetForm )
				$( this.currentForm ).resetForm();
			this.submitted = {};
			this.prepareForm();
			this.hideErrors();
			this.elements().removeClass( this.settings.errorClass );
		},

		numberOfInvalids: function() {
			return this.objectLength(this.invalid);
		},

		objectLength: function( obj ) {
			var count = 0;
			for ( var i in obj )
				count++;
			return count;
		},

		hideErrors: function() {
			this.addWrapper( this.toHide ).hide();
		},

		valid: function() {
			return this.size() == 0;
		},

		size: function() {
			return this.errorList.length;
		},

		focusInvalid: function() {
			if( this.settings.focusInvalid ) {
				try {
					$(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])
					.filter(":visible")
					.focus()
					// manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
					.trigger("focusin");
				} catch(e) {
					// ignore IE throwing errors when focusing hidden elements
				}
			}
		},

		findLastActive: function() {
			var lastActive = this.lastActive;
			return lastActive && $.grep(this.errorList, function(n) {
				return n.element.name == lastActive.name;
			}).length == 1 && lastActive;
		},

		elements: function() {
			var validator = this,
				rulesCache = {};

			// select all valid inputs inside the form (no submit or reset buttons)
			return $(this.currentForm)
			.find("input, select, textarea")
			.not(":submit, :reset, :image, [disabled]")
			.not( this.settings.ignore )
			.filter(function() {
				!this.name && validator.settings.debug && window.console && console.error( "%o has no name assigned", this);

				// select only the first element for each name, and only those with rules specified
				if ( this.name in rulesCache || !validator.objectLength($(this).rules()) )
					return false;

                // no sub-form elements
				if (this.form !== validator.currentForm)
				    return false;

				rulesCache[this.name] = true;
				return true;
			});
		},

		clean: function( selector ) {
			return $( selector )[0];
		},

		errors: function() {
			return $( this.settings.errorElement + "." + this.settings.errorClass, this.errorContext );
		},

		reset: function() {
			this.successList = [];
			this.errorList = [];
			this.errorMap = {};
			this.toShow = $([]);
			this.toHide = $([]);
			this.currentElements = $([]);
		},

		prepareForm: function() {
			this.reset();
			this.toHide = this.errors().add( this.containers );
		},

		prepareElement: function( element ) {
			this.reset();
			this.toHide = this.errorsFor(element);
		},

		check: function( element ) {
			element = this.clean( element );

			// if radio/checkbox, validate first element in group instead
			if (this.checkable(element)) {
				element = this.findByName( element.name ).not(this.settings.ignore)[0];
			}

			var rules = $(element).rules();
			var dependencyMismatch = false;
			for (var method in rules ) {
				var rule = { method: method, parameters: rules[method] };
				try {
					var result = $.validator.methods[method].call( this, element.value.replace(/\r/g, ""), element, rule.parameters );

					// if a method indicates that the field is optional and therefore valid,
					// don't mark it as valid when there are no other rules
					if ( result == "dependency-mismatch" ) {
						dependencyMismatch = true;
						continue;
					}
					dependencyMismatch = false;

					if ( result == "pending" ) {
						this.toHide = this.toHide.not( this.errorsFor(element) );
						return;
					}

					if( !result ) {
						this.formatAndAdd( element, rule );
						return false;
					}
				} catch(e) {
					this.settings.debug && window.console && console.log("exception occured when checking element " + element.id
						 + ", check the '" + rule.method + "' method", e);
					throw e;
				}
			}
			if (dependencyMismatch)
				return;
			if ( this.objectLength(rules) )
				this.successList.push(element);
			return true;
		},

		// return the custom message for the given element and validation method
		// specified in the element's "messages" metadata
		customMetaMessage: function(element, method) {
			if (!$.metadata)
				return;

			var meta = this.settings.meta
				? $(element).metadata()[this.settings.meta]
				: $(element).metadata();

			return meta && meta.messages && meta.messages[method];
		},

		// return the custom message for the given element name and validation method
		customMessage: function( name, method ) {
			var m = this.settings.messages[name];
			return m && (m.constructor == String
				? m
				: m[method]);
		},

		// return the first defined argument, allowing empty strings
		findDefined: function() {
			for(var i = 0; i < arguments.length; i++) {
				if (arguments[i] !== undefined)
					return arguments[i];
			}
			return undefined;
		},

		defaultMessage: function( element, method) {
			return this.findDefined(
				this.customMessage( element.name, method ),
				this.customMetaMessage( element, method ),
				// title is never undefined, so handle empty string as undefined
				!this.settings.ignoreTitle && element.title || undefined,
				$.validator.messages[method],
				"<strong>Warning: No message defined for " + element.name + "</strong>"
			);
		},

		formatAndAdd: function( element, rule ) {
			var message = this.defaultMessage( element, rule.method ),
				theregex = /\$?\{(\d+)\}/g;
			if ( typeof message == "function" ) {
				message = message.call(this, rule.parameters, element);
			} else if (theregex.test(message)) {
				message = jQuery.format(message.replace(theregex, '{$1}'), rule.parameters);
			}
			this.errorList.push({
				message: message,
				element: element
			});

			this.errorMap[element.name] = message;
			this.submitted[element.name] = message;
		},

		addWrapper: function(toToggle) {
			if ( this.settings.wrapper )
				toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
			return toToggle;
		},

		defaultShowErrors: function() {
			for ( var i = 0; this.errorList[i]; i++ ) {
				var error = this.errorList[i];
				this.settings.highlight && this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
				this.showLabel( error.element, error.message );
			}
			if( this.errorList.length ) {
				this.toShow = this.toShow.add( this.containers );
			}
			if (this.settings.success) {
				for ( var i = 0; this.successList[i]; i++ ) {
					this.showLabel( this.successList[i] );
				}
			}
			if (this.settings.unhighlight) {
				for ( var i = 0, elements = this.validElements(); elements[i]; i++ ) {
					this.settings.unhighlight.call( this, elements[i], this.settings.errorClass, this.settings.validClass );
				}
			}
			this.toHide = this.toHide.not( this.toShow );
			this.hideErrors();
			this.addWrapper( this.toShow ).show();
		},

		validElements: function() {
			return this.currentElements.not(this.invalidElements());
		},

		invalidElements: function() {
			return $(this.errorList).map(function() {
				return this.element;
			});
		},

		showLabel: function(element, message) {
			var label = this.errorsFor( element );
			if ( label.length ) {
				// refresh error/success class
				label.removeClass().addClass( this.settings.errorClass );

				// check if we have a generated label, replace the message then
				label.attr("generated") && label.html(message);
			} else {
				// create label
				label = $("<" + this.settings.errorElement + "/>")
					.attr({"for":  this.idOrName(element), generated: true})
					.addClass(this.settings.errorClass)
					.html(message || "");
				if ( this.settings.wrapper ) {
					// make sure the element is visible, even in IE
					// actually showing the wrapped element is handled elsewhere
					label = label.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
				}
				if ( !this.labelContainer.append(label).length )
					this.settings.errorPlacement
						? this.settings.errorPlacement(label, $(element) )
						: label.insertAfter(element);
			}
			if ( !message && this.settings.success ) {
				label.text("");
				typeof this.settings.success == "string"
					? label.addClass( this.settings.success )
					: this.settings.success( label );
			}
			this.toShow = this.toShow.add(label);
		},

		errorsFor: function(element) {
			var name = this.idOrName(element);
    		return this.errors().filter(function() {
				return $(this).attr('for') == name;
			});
		},

		idOrName: function(element) {
			return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
		},

		checkable: function( element ) {
			return /radio|checkbox/i.test(element.type);
		},

		findByName: function( name ) {
			// select by name and filter by form for performance over form.find("[name=...]")
			var form = this.currentForm;
			return $(document.getElementsByName(name)).map(function(index, element) {
				return element.form == form && element.name == name && element  || null;
			});
		},

		getLength: function(value, element) {
			switch( element.nodeName.toLowerCase() ) {
			case 'select':
				return $("option:selected", element).length;
			case 'input':
				if( this.checkable( element) )
					return this.findByName(element.name).filter(':checked').length;
			}
			return value.length;
		},

		depend: function(param, element) {
			return this.dependTypes[typeof param]
				? this.dependTypes[typeof param](param, element)
				: true;
		},

		dependTypes: {
			"boolean": function(param, element) {
				return param;
			},
			"string": function(param, element) {
				return !!$(param, element.form).length;
			},
			"function": function(param, element) {
				return param(element);
			}
		},

		optional: function(element) {
			return !$.validator.methods.required.call(this, $.trim(element.value), element) && "dependency-mismatch";
		},

		startRequest: function(element) {
			if (!this.pending[element.name]) {
				this.pendingRequest++;
				this.pending[element.name] = true;
			}
		},

		stopRequest: function(element, valid) {
			this.pendingRequest--;
			// sometimes synchronization fails, make sure pendingRequest is never < 0
			if (this.pendingRequest < 0)
				this.pendingRequest = 0;
			delete this.pending[element.name];
			if ( valid && this.pendingRequest == 0 && this.formSubmitted && this.form() ) {
				$(this.currentForm).submit();
				this.formSubmitted = false;
			} else if (!valid && this.pendingRequest == 0 && this.formSubmitted) {
				$(this.currentForm).triggerHandler("invalid-form", [this]);
				this.formSubmitted = false;
			}
		},

		previousValue: function(element) {
			return $.data(element, "previousValue") || $.data(element, "previousValue", {
				old: null,
				valid: true,
				message: this.defaultMessage( element, "remote" )
			});
		}

	},

	classRuleSettings: {
		required: {required: true},
		email: {email: true},
		url: {url: true},
		date: {date: true},
		dateISO: {dateISO: true},
		dateDE: {dateDE: true},
		number: {number: true},
		numberDE: {numberDE: true},
		digits: {digits: true},
		creditcard: {creditcard: true}
	},

	addClassRules: function(className, rules) {
		className.constructor == String ?
			this.classRuleSettings[className] = rules :
			$.extend(this.classRuleSettings, className);
	},

	classRules: function(element) {
		var rules = {};
		var classes = $(element).attr('class');
		classes && $.each(classes.split(' '), function() {
			if (this in $.validator.classRuleSettings) {
				$.extend(rules, $.validator.classRuleSettings[this]);
			}
		});
		return rules;
	},

	attributeRules: function(element) {
		var rules = {};
		var $element = $(element);

		for (var method in $.validator.methods) {
			var value = $element.attr(method);
			if (value) {
				rules[method] = value;
			}
		}

		// maxlength may be returned as -1, 2147483647 (IE) and 524288 (safari) for text inputs
		if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
			delete rules.maxlength;
		}

		return rules;
	},

	metadataRules: function(element) {
		if (!$.metadata) return {};

		var meta = $.data(element.form, 'validator').settings.meta;
		return meta ?
			$(element).metadata()[meta] :
			$(element).metadata();
	},

	staticRules: function(element) {
		var rules = {};
		var validator = $.data(element.form, 'validator');
		if (validator.settings.rules) {
			rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
		}
		return rules;
	},

	normalizeRules: function(rules, element) {
		// handle dependency check
		$.each(rules, function(prop, val) {
			// ignore rule when param is explicitly false, eg. required:false
			if (val === false) {
				delete rules[prop];
				return;
			}
			if (val.param || val.depends) {
				var keepRule = true;
				switch (typeof val.depends) {
					case "string":
						keepRule = !!$(val.depends, element.form).length;
						break;
					case "function":
						keepRule = val.depends.call(element, element);
						break;
				}
				if (keepRule) {
					rules[prop] = val.param !== undefined ? val.param : true;
				} else {
					delete rules[prop];
				}
			}
		});

		// evaluate parameters
		$.each(rules, function(rule, parameter) {
			rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;
		});

		// clean number parameters
		$.each(['minlength', 'maxlength', 'min', 'max'], function() {
			if (rules[this]) {
				rules[this] = Number(rules[this]);
			}
		});
		$.each(['rangelength', 'range'], function() {
			if (rules[this]) {
				rules[this] = [Number(rules[this][0]), Number(rules[this][1])];
			}
		});

		if ($.validator.autoCreateRanges) {
			// auto-create ranges
			if (rules.min && rules.max) {
				rules.range = [rules.min, rules.max];
				delete rules.min;
				delete rules.max;
			}
			if (rules.minlength && rules.maxlength) {
				rules.rangelength = [rules.minlength, rules.maxlength];
				delete rules.minlength;
				delete rules.maxlength;
			}
		}

		// To support custom messages in metadata ignore rule methods titled "messages"
		if (rules.messages) {
			delete rules.messages;
		}

		return rules;
	},

	// Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
	normalizeRule: function(data) {
		if( typeof data == "string" ) {
			var transformed = {};
			$.each(data.split(/\s+/), function() {
				transformed[this] = true;
			});
			data = transformed;
		}
		return data;
	},

	// http://docs.jquery.com/Plugins/Validation/Validator/addMethod
	addMethod: function(name, method, message) {
		$.validator.methods[name] = method;
		$.validator.messages[name] = message != undefined ? message : $.validator.messages[name];
		if (method.length < 3) {
			$.validator.addClassRules(name, $.validator.normalizeRule(name));
		}
	},

	methods: {

		// http://docs.jquery.com/Plugins/Validation/Methods/required
		required: function(value, element, param) {
			// check if dependency is met
			if ( !this.depend(param, element) )
				return "dependency-mismatch";
			switch( element.nodeName.toLowerCase() ) {
			case 'select':
				// could be an array for select-multiple or a string, both are fine this way
				var val = $(element).val();
				return val && val.length > 0;
			case 'input':
				if ( this.checkable(element) )
					return this.getLength(value, element) > 0;
			default:
				return $.trim(value).length > 0;
			}
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/remote
		remote: function(value, element, param) {
			if ( this.optional(element) )
				return "dependency-mismatch";

			var previous = this.previousValue(element);
			if (!this.settings.messages[element.name] )
				this.settings.messages[element.name] = {};
			previous.originalMessage = this.settings.messages[element.name].remote;
			this.settings.messages[element.name].remote = previous.message;

			param = typeof param == "string" && {url:param} || param;

			if ( this.pending[element.name] ) {
				return "pending";
			}
			if ( previous.old === value ) {
				return previous.valid;
			}

			previous.old = value;
			var validator = this;
			this.startRequest(element);
			var data = {};
			data[element.name] = value;
			$.ajax($.extend(true, {
				url: param,
				mode: "abort",
				port: "validate" + element.name,
				dataType: "json",
				data: data,
				success: function(response) {
					validator.settings.messages[element.name].remote = previous.originalMessage;
					var valid = response === true;
					if ( valid ) {
						var submitted = validator.formSubmitted;
						validator.prepareElement(element);
						validator.formSubmitted = submitted;
						validator.successList.push(element);
						validator.showErrors();
					} else {
						var errors = {};
						var message = response || validator.defaultMessage( element, "remote" );
						errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;
						validator.showErrors(errors);
					}
					previous.valid = valid;
					validator.stopRequest(element, valid);
				}
			}, param));
			return "pending";
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/minlength
		minlength: function(value, element, param) {
			return this.optional(element) || this.getLength($.trim(value), element) >= param;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/maxlength
		maxlength: function(value, element, param) {
			return this.optional(element) || this.getLength($.trim(value), element) <= param;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/rangelength
		rangelength: function(value, element, param) {
			var length = this.getLength($.trim(value), element);
			return this.optional(element) || ( length >= param[0] && length <= param[1] );
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/min
		min: function( value, element, param ) {
			return this.optional(element) || value >= param;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/max
		max: function( value, element, param ) {
			return this.optional(element) || value <= param;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/range
		range: function( value, element, param ) {
			return this.optional(element) || ( value >= param[0] && value <= param[1] );
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/email
		email: function(value, element) {
			// contributed by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/
			return this.optional(element) || /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/url
		url: function(value, element) {
			// contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
			return this.optional(element) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/date
		date: function(value, element) {
			return this.optional(element) || !/Invalid|NaN/.test(new Date(value));
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/dateISO
		dateISO: function(value, element) {
			return this.optional(element) || /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/number
		number: function(value, element) {
			return this.optional(element) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/digits
		digits: function(value, element) {
			return this.optional(element) || /^\d+$/.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/creditcard
		// based on http://en.wikipedia.org/wiki/Luhn
		creditcard: function(value, element) {
			if ( this.optional(element) )
				return "dependency-mismatch";
			// accept only digits and dashes
			if (/[^0-9-]+/.test(value))
				return false;
			var nCheck = 0,
				nDigit = 0,
				bEven = false;

			value = value.replace(/\D/g, "");

			for (var n = value.length - 1; n >= 0; n--) {
				var cDigit = value.charAt(n);
				var nDigit = parseInt(cDigit, 10);
				if (bEven) {
					if ((nDigit *= 2) > 9)
						nDigit -= 9;
				}
				nCheck += nDigit;
				bEven = !bEven;
			}

			return (nCheck % 10) == 0;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/accept
		accept: function(value, element, param) {
			param = typeof param == "string" ? param.replace(/,/g, '|') : "png|jpe?g|gif";
			return this.optional(element) || value.match(new RegExp(".(" + param + ")$", "i"));
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/equalTo
		equalTo: function(value, element, param) {
			// bind to the blur event of the target in order to revalidate whenever the target field is updated
			// TODO find a way to bind the event just once, avoiding the unbind-rebind overhead
			var target = $(param).unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
				$(element).valid();
			});
			return value == target.val();
		}

	}

});

// deprecated, use $.validator.format instead
$.format = $.validator.format;

})(jQuery);

// ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()
;(function($) {
	var pendingRequests = {};
	// Use a prefilter if available (1.5+)
	if ( $.ajaxPrefilter ) {
		$.ajaxPrefilter(function(settings, _, xhr) {
			var port = settings.port;
			if (settings.mode == "abort") {
				if ( pendingRequests[port] ) {
					pendingRequests[port].abort();
				}
				pendingRequests[port] = xhr;
			}
		});
	} else {
		// Proxy ajax
		var ajax = $.ajax;
		$.ajax = function(settings) {
			var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
				port = ( "port" in settings ? settings : $.ajaxSettings ).port;
			if (mode == "abort") {
				if ( pendingRequests[port] ) {
					pendingRequests[port].abort();
				}
				return (pendingRequests[port] = ajax.apply(this, arguments));
			}
			return ajax.apply(this, arguments);
		};
	}
})(jQuery);

// provides cross-browser focusin and focusout events
// IE has native support, in other browsers, use event caputuring (neither bubbles)

// provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation
// handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target
;(function($) {
	// only implement if not provided by jQuery core (since 1.4)
	// TODO verify if jQuery 1.4's implementation is compatible with older jQuery special-event APIs
	if (!jQuery.event.special.focusin && !jQuery.event.special.focusout && document.addEventListener) {
		$.each({
			focus: 'focusin',
			blur: 'focusout'
		}, function( original, fix ){
			$.event.special[fix] = {
				setup:function() {
					this.addEventListener( original, handler, true );
				},
				teardown:function() {
					this.removeEventListener( original, handler, true );
				},
				handler: function(e) {
					arguments[0] = $.event.fix(e);
					arguments[0].type = fix;
					return $.event.handle.apply(this, arguments);
				}
			};
			function handler(e) {
				e = $.event.fix(e);
				e.type = fix;
				return $.event.handle.call(this, e);
			}
		});
	};
	$.extend($.fn, {
		validateDelegate: function(delegate, type, handler) {
			return this.bind(type, function(event) {
				var target = $(event.target);
				if (target.is(delegate)) {
					return handler.apply(target, arguments);
				}
			});
		}
	});
})(jQuery);



/**
* gettext for jQuery
* 
* Copyright (c) 2008 Sabin Iacob (m0n5t3r) <iacobs@m0n5t3r.info>
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details. 
*
* @license http://www.gnu.org/licenses/gpl.html 
* @project jquery.gettext
*
* Usage:
* 
* This plugin expects its input data to be a JSON object like 
* {"": header, "string": "translation", ...} 
*
* After getting the server side set up (either as a static file - my choice - or 
* as a web service), the client side is simple:
*  * add to the head section of the page something like 
*    <link href="path/to/translation.json" lang="ro" rel="gettext"/>
*  * in your script, use $.gt.gettext(string) or _(string); for plural forms, use
*    $.gt.ngettext(sg, pl1[, pl2, ...], count) or n_(sg, pl1[, pl2, ...], count)
*  * to extract strings to a .po file, you can use standard gettext utilities like
*    xgettext and msgfmt; to generate the JSON, one could use the following Python 
*    snippet, assuming a domain.mo file exists under path/lang/LC_MESSAGES:
*
*    import simplejson as enc
* 
*    def gettext_json(domain, path, lang = [], indent = False):
*        try:
*            tr = gettext.translation(domain, path, lang)
*            return enc.dumps(tr._catalog, ensure_ascii = False, indent = indent)
*        except IOError:
*            return None
*
*    why go through the additional hassle of gettext? well, it's a matter of 
*    preference, the main advantags I see are:
*     * well known editing tools like KBabel, poEdit, gtranslator, Emacs PO mode, 
*       etc.
*     * translation memory, fuzzy matches and other features that get really 
*       helpful when your application is big and you have hundreds of strings
*/
(function ($) {

    String.format = function () {
        var s = arguments[0];
        for (var i = 0; i < arguments.length - 1; i++) {
            var reg = new RegExp("\\{" + i + "\\}", "gm");
            s = s.replace(reg, arguments[i + 1]);
        }

        return s;
    };

    $.gt = $.gt || {};

    $.extend($.gt, {
        messages: {},
        messagescurrent: {},
        lang: 'C',
        setLang: function (code) { $.gt.lang = typeof code == 'string' && code != ' ' ? code : 'C'; },
        pl_re: /^Plural-Forms:\s*nplurals\s*=\s*(\d+);\s*plural\s*=\s*([^a-zA-Z0-9\$]*([a-zA-Z0-9\$]+).+)$/m,
        plural: function (n) { return n != 1; },
        load: function () {
            $.gt.setLang($('html').attr('lang'));
            var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
            var srs = translationMode ? JsLocalizator.targetLocaleSR() : JsLocalizator.currentLocaleSR();
            if (!srs) {
                if ($('link[rel=gettext]').length > 0) {
                    $('link[rel=gettext]').each(function() {
                        $.get(this.href, function(data) {
                            if (!data.message) {
                                $.gt.loadfromjson(data);
                            }
                        });
                    });
                } else {
                   $.gt.loaded = true;
                }
            } else {
                $.gt.loadfromjson(srs, translationMode ? JsLocalizator.currentLocaleSR() : null);
            }
        },
        loadfromjson: function (jsonData, jsonDataCurrent) {
            var lang = this.lang;
            $.gt.messages[lang] = $.gt.messages[lang] || {};
            $.extend($.gt.messages[lang], jsonData);
            var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
            if (jsonDataCurrent && translationMode) {
                $.gt.messagescurrent[lang] = $.gt.messagescurrent[lang] || {};
                $.extend($.gt.messagescurrent[lang], jsonDataCurrent);
                $.gt.pl_re.exec($.gt.messagescurrent[lang]['']);
            }

            var pl = $.gt.pl_re.exec($.gt.messages[lang]['']);
            if (pl) {
                var expr = pl[2];
                var np = pl[1];
                var v = pl[3];
                try {
                    var fn = eval('(function(' + v + ') {return ' + expr + ';})');
                } catch (e) {
                    return;
                }
                $.gt.plural = fn;
            }
            $.gt.loaded = true;
        },
        formatvalue: function (key, current, target, args) {
            var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
            if (!translationMode)
                return String.format.apply((current ? current : key), args);
            if (!args || args.length == 0) {
                var res = jQuery.validator.format("|SRString|{0}_____{1}_____{2}|/SRString|", key, current ? current : key, target);
                return res;
            }
            var formatCurrent = current;
            var formatTarget = target;
            current = jQuery.validator.format(current, args);
            target = jQuery.validator.format(target, args);
            return jQuery.validator.format("|SRString|{0}_____{1}_____{2}_____{3}_____{4}|/SRString|", key, current ? current: key, target, formatCurrent, formatTarget)
        },
        gettext: function (msgstr) {
            if (!$.gt.loaded) {
                $.gt.load();
            }
            var lang = $.gt.lang;
            var argArray = [];
            if (arguments.length && arguments.length > 1) {
                argArray = $.makeArray(arguments);
                argArray = argArray.slice(1);
            }
            if (lang == 'C' || typeof $.gt.messages[lang] == 'undefined') {
                argArray.unshift(msgstr);
                return String.format.apply(this, argArray);
                //$.gt.formatvalue(msgstr, null, null, argArray);
            }
            var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
            var trans = $.gt.messages[lang][msgstr];
            if (!trans || typeof trans == 'undefined') {
                if (translationMode && $.gt.messagescurrent[lang]) {
                    trans = $.gt.messagescurrent[lang][msgstr];
                    if (typeof trans == 'undefined') {
                        argArray.unshift(msgstr);
                        //return $.gt.formatvalue(msgstr, null, null, argArray);
                        return String.format.apply(this, argArray);
                    }
                } else {
                    argArray.unshift(msgstr);
                    return  String.format.apply(this, argArray);
                }
            }
            if (typeof trans == 'string') { // regular action
                if (translationMode) {
                    var current = $.gt.messagescurrent[lang][msgstr];
                    return $.gt.formatvalue(msgstr, current, trans, argArray);
                } else {
                    argArray.unshift(trans);
                    return String.format.apply(this, argArray);
                }
            } else if (typeof trans == 'object' && trans.constructor == Array) { // the translation contains plural(s), yet gettext was called
                if (translationMode) {
                    var currentArr = $.gt.messagescurrent[lang][msgstr];
                    return $.gt.formatvalue(msgstr, currentArr[0], trans[0], argArray);
                } else {
                    argArray.unshift(trans[0]);
                    return String.format.apply(this, argArray);
                }
            }
            return msgstr;
        }
    });

    //$(document).ready($.gt.load);
})(jQuery);

if (typeof SR == 'undefined') {
    SR = {};
}
if (typeof SR.T == 'undefined') {
    SR.T = jQuery.gt.gettext;
}


/*! Copyright 2012, Ben Lin (http://dreamerslab.com/)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 1.0.16
 *
 * Requires: jQuery >= 1.2.3
 */
(function(a){a.fn.addBack=a.fn.addBack||a.fn.andSelf;
a.fn.extend({actual:function(b,l){if(!this[b]){throw'$.actual => The jQuery method "'+b+'" you called does not exist';}var f={absolute:false,clone:false,includeMargin:false};
var i=a.extend(f,l);var e=this.eq(0);var h,j;if(i.clone===true){h=function(){var m="position: absolute !important; top: -1000 !important; ";e=e.clone().attr("style",m).appendTo("body");
};j=function(){e.remove();};}else{var g=[];var d="";var c;h=function(){c=e.parents().addBack().filter(":hidden");d+="visibility: hidden !important; display: block !important; ";
if(i.absolute===true){d+="position: absolute !important; ";}c.each(function(){var m=a(this);var n=m.attr("style");g.push(n);m.attr("style",n?n+";"+d:d);
});};j=function(){c.each(function(m){var o=a(this);var n=g[m];if(n===undefined){o.removeAttr("style");}else{o.attr("style",n);}});};}h();var k=/(outer)/.test(b)?e[b](i.includeMargin):e[b]();
j();return k;}});})(jQuery);


/*!
 * jQuery BBQ: Back Button & Query Library - v1.2.1 - 2/17/2010
 * http://benalman.com/projects/jquery-bbq-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery BBQ: Back Button & Query Library
//
// *Version: 1.2.1, Last updated: 2/17/2010*
// 
// Project Home - http://benalman.com/projects/jquery-bbq-plugin/
// GitHub       - http://github.com/cowboy/jquery-bbq/
// Source       - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.js
// (Minified)   - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.min.js (4.0kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Basic AJAX     - http://benalman.com/code/projects/jquery-bbq/examples/fragment-basic/
// Advanced AJAX  - http://benalman.com/code/projects/jquery-bbq/examples/fragment-advanced/
// jQuery UI Tabs - http://benalman.com/code/projects/jquery-bbq/examples/fragment-jquery-ui-tabs/
// Deparam        - http://benalman.com/code/projects/jquery-bbq/examples/deparam/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.7, Safari 3-4,
//                   Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-bbq/unit/
// 
// About: Release History
// 
// 1.2.1 - (2/17/2010) Actually fixed the stale window.location Safari bug from
//         <jQuery hashchange event> in BBQ, which was the main reason for the
//         previous release!
// 1.2   - (2/16/2010) Integrated <jQuery hashchange event> v1.2, which fixes a
//         Safari bug, the event can now be bound before DOM ready, and IE6/7
//         page should no longer scroll when the event is first bound. Also
//         added the <jQuery.param.fragment.noEscape> method, and reworked the
//         <hashchange event (BBQ)> internal "add" method to be compatible with
//         changes made to the jQuery 1.4.2 special events API.
// 1.1.1 - (1/22/2010) Integrated <jQuery hashchange event> v1.1, which fixes an
//         obscure IE8 EmulateIE7 meta tag compatibility mode bug.
// 1.1   - (1/9/2010) Broke out the jQuery BBQ event.special <hashchange event>
//         functionality into a separate plugin for users who want just the
//         basic event & back button support, without all the extra awesomeness
//         that BBQ provides. This plugin will be included as part of jQuery BBQ,
//         but also be available separately. See <jQuery hashchange event>
//         plugin for more information. Also added the <jQuery.bbq.removeState>
//         method and added additional <jQuery.deparam> examples.
// 1.0.3 - (12/2/2009) Fixed an issue in IE 6 where location.search and
//         location.hash would report incorrectly if the hash contained the ?
//         character. Also <jQuery.param.querystring> and <jQuery.param.fragment>
//         will no longer parse params out of a URL that doesn't contain ? or #,
//         respectively.
// 1.0.2 - (10/10/2009) Fixed an issue in IE 6/7 where the hidden IFRAME caused
//         a "This page contains both secure and nonsecure items." warning when
//         used on an https:// page.
// 1.0.1 - (10/7/2009) Fixed an issue in IE 8. Since both "IE7" and "IE8
//         Compatibility View" modes erroneously report that the browser
//         supports the native window.onhashchange event, a slightly more
//         robust test needed to be added.
// 1.0   - (10/2/2009) Initial release

(function($,window){
  '$:nomunge'; // Used by YUI compressor.
  
  // Some convenient shortcuts.
  var undefined,
    aps = Array.prototype.slice,
    decode = decodeURIComponent,
    
    // Method / object references.
    jq_param = $.param,
    jq_param_fragment,
    jq_deparam,
    jq_deparam_fragment,
    jq_bbq = $.bbq = $.bbq || {},
    jq_bbq_pushState,
    jq_bbq_getState,
    jq_elemUrlAttr,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_hashchange = 'hashchange',
    str_querystring = 'querystring',
    str_fragment = 'fragment',
    str_elemUrlAttr = 'elemUrlAttr',
    str_location = 'location',
    str_href = 'href',
    str_src = 'src',
    
    // Reused RegExp.
    re_trim_querystring = /^.*\?|#.*$/g,
    re_trim_fragment = /^.*\#/,
    re_no_escape,
    
    // Used by jQuery.elemUrlAttr.
    elemUrlAttr_cache = {};
  
  // A few commonly used bits, broken out to help reduce minified file size.
  
  function is_string( arg ) {
    return typeof arg === 'string';
  };
  
  // Why write the same function twice? Let's curry! Mmmm, curry..
  
  function curry( func ) {
    var args = aps.call( arguments, 1 );
    
    return function() {
      return func.apply( this, args.concat( aps.call( arguments ) ) );
    };
  };
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Get location.search (or what you'd expect location.search to be) sans any
  // leading #. Thanks for making this necessary, IE6!
  function get_querystring( url ) {
    return url.replace( /(?:^[^?#]*\?([^#]*).*$)?.*/, '$1' );
  };
  
  // Section: Param (to string)
  // 
  // Method: jQuery.param.querystring
  // 
  // Retrieve the query string from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing query string params to be parsed. If url
  //    is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed query string, with any leading "?" removed.
  //
  
  // Method: jQuery.param.querystring (build url)
  // 
  // Merge a URL, with or without pre-existing query string params, plus any
  // object, params string or URL containing query string params into a new URL.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing query string params to
  //    be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any query string
  //         params in url.
  //    * 1: any query string params in url will override params in the params
  //         argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded query string in the format 'a=b&c=d&e=f'.
  
  // Method: jQuery.param.fragment
  // 
  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing fragment (hash) params to be parsed. If
  //    url is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed fragment (hash) string, with any leading "#" removed.
  
  // Method: jQuery.param.fragment (build url)
  // 
  // Merge a URL, with or without pre-existing fragment (hash) params, plus any
  // object, params string or URL containing fragment (hash) params into a new
  // URL.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing fragment (hash) params
  //    to be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any fragment (hash)
  //         params in url.
  //    * 1: any fragment (hash) params in url will override params in the
  //         params argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded fragment (hash) in the format 'a=b&c=d&e=f'.
  
  function jq_param_sub( is_fragment, get_func, url, params, merge_mode ) {
    var result,
      qs,
      matches,
      url_params,
      hash;
    
    if ( params !== undefined ) {
      // Build URL by merging params into url string.
      
      // matches[1] = url part that precedes params, not including trailing ?/#
      // matches[2] = params, not including leading ?/#
      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''
      matches = url.match( is_fragment ? /^([^#]*)\#?(.*)$/ : /^([^#?]*)\??([^#]*)(#?.*)/ );
      
      // Get the hash if in 'querystring' mode, and it exists.
      hash = matches[3] || '';
      
      if ( merge_mode === 2 && is_string( params ) ) {
        // If merge_mode is 2 and params is a string, merge the fragment / query
        // string into the URL wholesale, without converting it into an object.
        qs = params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' );
        
      } else {
        // Convert relevant params in url to object.
        url_params = jq_deparam( matches[2] );
        
        params = is_string( params )
          
          // Convert passed params string into object.
          ? jq_deparam[ is_fragment ? str_fragment : str_querystring ]( params )
          
          // Passed params object.
          : params;
        
        qs = merge_mode === 2 ? params                              // passed params replace url params
          : merge_mode === 1  ? $.extend( {}, params, url_params )  // url params override passed params
          : $.extend( {}, url_params, params );                     // passed params override url params
        
        // Convert params object to a string.
        qs = jq_param( qs );
        
        // Unescape characters specified via $.param.noEscape. Since only hash-
        // history users have requested this feature, it's only enabled for
        // fragment-related params strings.
        if ( is_fragment ) {
          qs = qs.replace( re_no_escape, decode );
        }
      }
      
      // Build URL from the base url, querystring and hash. In 'querystring'
      // mode, ? is only added if a query string exists. In 'fragment' mode, #
      // is always added.
      result = matches[1] + ( is_fragment ? '#' : qs || !matches[1] ? '?' : '' ) + qs + hash;
      
    } else {
      // If URL was passed in, parse params from URL string, otherwise parse
      // params from window.location.
      result = get_func( url !== undefined ? url : window[ str_location ][ str_href ] );
    }
    
    return result;
  };
  
  jq_param[ str_querystring ]                  = curry( jq_param_sub, 0, get_querystring );
  jq_param[ str_fragment ] = jq_param_fragment = curry( jq_param_sub, 1, get_fragment );
  
  // Method: jQuery.param.fragment.noEscape
  // 
  // Specify characters that will be left unescaped when fragments are created
  // or merged using <jQuery.param.fragment>, or when the fragment is modified
  // using <jQuery.bbq.pushState>. This option only applies to serialized data
  // object fragments, and not set-as-string fragments. Does not affect the
  // query string. Defaults to ",/" (comma, forward slash).
  // 
  // Note that this is considered a purely aesthetic option, and will help to
  // create URLs that "look pretty" in the address bar or bookmarks, without
  // affecting functionality in any way. That being said, be careful to not
  // unescape characters that are used as delimiters or serve a special
  // purpose, such as the "#?&=+" (octothorpe, question mark, ampersand,
  // equals, plus) characters.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment.noEscape( [ chars ] );
  // 
  // Arguments:
  // 
  //  chars - (String) The characters to not escape in the fragment. If
  //    unspecified, defaults to empty string (escape all characters).
  // 
  // Returns:
  // 
  //  Nothing.
  
  jq_param_fragment.noEscape = function( chars ) {
    chars = chars || '';
    var arr = $.map( chars.split(''), encodeURIComponent );
    re_no_escape = new RegExp( arr.join('|'), 'g' );
  };
  
  // A sensible default. These are the characters people seem to complain about
  // "uglifying up the URL" the most.
  jq_param_fragment.noEscape( ',/' );
  
  // Section: Deparam (from string)
  // 
  // Method: jQuery.deparam
  // 
  // Deserialize a params string into an object, optionally coercing numbers,
  // booleans, null and undefined values; this method is the counterpart to the
  // internal jQuery.param method.
  // 
  // Usage:
  // 
  // > jQuery.deparam( params [, coerce ] );
  // 
  // Arguments:
  // 
  //  params - (String) A params string to be parsed.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  $.deparam = jq_deparam = function( params, coerce ) {
    var obj = {},
      coerce_types = { 'true': !0, 'false': !1, 'null': null };
    
    // Iterate over all name=value pairs.
    $.each( params.replace( /\+/g, ' ' ).split( '&' ), function(j,v){
      var param = v.split( '=' ),
        key = decode( param[0] ),
        val,
        cur = obj,
        i = 0,
        
        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
        // into its component parts.
        keys = key.split( '][' ),
        keys_last = keys.length - 1;
      
      // If the first keys part contains [ and the last ends with ], then []
      // are correctly balanced.
      if ( /\[/.test( keys[0] ) && /\]$/.test( keys[ keys_last ] ) ) {
        // Remove the trailing ] from the last keys part.
        keys[ keys_last ] = keys[ keys_last ].replace( /\]$/, '' );
        
        // Split first keys part into two parts on the [ and add them back onto
        // the beginning of the keys array.
        keys = keys.shift().split('[').concat( keys );
        
        keys_last = keys.length - 1;
      } else {
        // Basic 'foo' style key.
        keys_last = 0;
      }
      
      // Are we dealing with a name=value pair, or just a name?
      if ( param.length === 2 ) {
        val = decode( param[1] );
        
        // Coerce values.
        if ( coerce ) {
          val = val && !isNaN(val)            ? +val              // number
            : val === 'undefined'             ? undefined         // undefined
            : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
            : val;                                                // string
        }
        
        if ( keys_last ) {
          // Complex key, build deep object structure based on a few rules:
          // * The 'cur' pointer starts at the object top-level.
          // * [] = array push (n is set to array length), [n] = array if n is 
          //   numeric, otherwise object.
          // * If at the last keys part, set the value.
          // * For each keys part, if the current level is undefined create an
          //   object or array based on the type of the next keys part.
          // * Move the 'cur' pointer to the next level.
          // * Rinse & repeat.
          for ( ; i <= keys_last; i++ ) {
            key = keys[i] === '' ? cur.length : keys[i];
            cur = cur[key] = i < keys_last
              ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )
              : val;
          }
          
        } else {
          // Simple key, even simpler rules, since only scalars and shallow
          // arrays are allowed.
          
          if ( $.isArray( obj[key] ) ) {
            // val is already an array, so push on the next value.
            obj[key].push( val );
            
          } else if ( obj[key] !== undefined ) {
            // val isn't an array, but since a second value has been specified,
            // convert val into an array.
            obj[key] = [ obj[key], val ];
            
          } else {
            // val is a scalar.
            obj[key] = val;
          }
        }
        
      } else if ( key ) {
        // No value was defined, so set something meaningful.
        obj[key] = coerce
          ? undefined
          : '';
      }
    });
    
    return obj;
  };
  
  // Method: jQuery.deparam.querystring
  // 
  // Parse the query string from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.querystring( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing query string
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  // Method: jQuery.deparam.fragment
  // 
  // Parse the fragment (hash) from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.fragment( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing fragment (hash)
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  function jq_deparam_sub( is_fragment, url_or_params, coerce ) {
    if ( url_or_params === undefined || typeof url_or_params === 'boolean' ) {
      // url_or_params not specified.
      coerce = url_or_params;
      url_or_params = jq_param[ is_fragment ? str_fragment : str_querystring ]();
    } else {
      url_or_params = is_string( url_or_params )
        ? url_or_params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' )
        : url_or_params;
    }
    
    return jq_deparam( url_or_params, coerce );
  };
  
  jq_deparam[ str_querystring ]                    = curry( jq_deparam_sub, 0 );
  jq_deparam[ str_fragment ] = jq_deparam_fragment = curry( jq_deparam_sub, 1 );
  
  // Section: Element manipulation
  // 
  // Method: jQuery.elemUrlAttr
  // 
  // Get the internal "Default URL attribute per tag" list, or augment the list
  // with additional tag-attribute pairs, in case the defaults are insufficient.
  // 
  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list
  // is used to determine which attribute contains the URL to be modified, if
  // an "attr" param is not specified.
  // 
  // Default Tag-Attribute List:
  // 
  //  a      - href
  //  base   - href
  //  iframe - src
  //  img    - src
  //  input  - src
  //  form   - action
  //  link   - href
  //  script - src
  // 
  // Usage:
  // 
  // > jQuery.elemUrlAttr( [ tag_attr ] );
  // 
  // Arguments:
  // 
  //  tag_attr - (Object) An object containing a list of tag names and their
  //    associated default attribute names in the format { tag: 'attr', ... } to
  //    be merged into the internal tag-attribute list.
  // 
  // Returns:
  // 
  //  (Object) An object containing all stored tag-attribute values.
  
  // Only define function and set defaults if function doesn't already exist, as
  // the urlInternal plugin will provide this method as well.
  $[ str_elemUrlAttr ] || ($[ str_elemUrlAttr ] = function( obj ) {
    return $.extend( elemUrlAttr_cache, obj );
  })({
    a: str_href,
    base: str_href,
    iframe: str_src,
    img: str_src,
    input: str_src,
    form: 'action',
    link: str_href,
    script: str_src
  });
  
  jq_elemUrlAttr = $[ str_elemUrlAttr ];
  
  // Method: jQuery.fn.querystring
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing query string params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing query string params, or params string
  //    to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any query string in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  // Method: jQuery.fn.fragment
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing fragment/hash params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing fragment (hash) params, or params
  //    string to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any fragment (hash) in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  function jq_fn_sub( mode, force_attr, params, merge_mode ) {
    if ( !is_string( params ) && typeof params !== 'object' ) {
      // force_attr not specified.
      merge_mode = params;
      params = force_attr;
      force_attr = undefined;
    }
    
    return this.each(function(){
      var that = $(this),
        
        // Get attribute specified, or default specified via $.elemUrlAttr.
        attr = force_attr || jq_elemUrlAttr()[ ( this.nodeName || '' ).toLowerCase() ] || '',
        
        // Get URL value.
        url = attr && that.attr( attr ) || '';
      
      // Update attribute with new URL.
      that.attr( attr, jq_param[ mode ]( url, params, merge_mode ) );
    });
    
  };
  
  $.fn[ str_querystring ] = curry( jq_fn_sub, str_querystring );
  $.fn[ str_fragment ]    = curry( jq_fn_sub, str_fragment );
  
  // Section: History, hashchange event
  // 
  // Method: jQuery.bbq.pushState
  // 
  // Adds a 'state' into the browser history at the current position, setting
  // location.hash and triggering any bound <hashchange event> callbacks
  // (provided the new state is different than the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );
  // 
  // Arguments:
  // 
  //  params - (String) A serialized params string or a hash string beginning
  //    with # to merge into location.hash.
  //  params - (Object) A params object to merge into location.hash.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified (unless a hash string beginning with # is specified, in which
  //    case merge behavior defaults to 2), and is as-follows:
  // 
  //    * 0: params in the params argument will override any params in the
  //         current state.
  //    * 1: any params in the current state will override params in the params
  //         argument.
  //    * 2: params argument will completely replace current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  //  * Unlike the fragment and querystring methods, if a hash string beginning
  //    with # is specified as the params agrument, merge_mode defaults to 2.
  
  jq_bbq.pushState = jq_bbq_pushState = function( params, merge_mode ) {
    if ( is_string( params ) && /^#/.test( params ) && merge_mode === undefined ) {
      // Params string begins with # and merge_mode not specified, so completely
      // overwrite window.location.hash.
      merge_mode = 2;
    }
    
    var has_args = params !== undefined,
      // Merge params into window.location using $.param.fragment.
      url = jq_param_fragment( window[ str_location ][ str_href ],
        has_args ? params : {}, has_args ? merge_mode : 2 );
    
    // Set new window.location.href. If hash is empty, use just # to prevent
    // browser from reloading the page. Note that Safari 3 & Chrome barf on
    // location.hash = '#'.
    window[ str_location ][ str_href ] = url + ( /#/.test( url ) ? '' : '#' );
  };
  
  // Method: jQuery.bbq.getState
  // 
  // Retrieves the current 'state' from the browser history, parsing
  // location.hash for a specific key or returning an object containing the
  // entire state, optionally coercing numbers, booleans, null and undefined
  // values.
  // 
  // Usage:
  // 
  // > jQuery.bbq.getState( [ key ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  key - (String) An optional state key for which to return a value.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false.
  // 
  // Returns:
  // 
  //  (Anything) If key is passed, returns the value corresponding with that key
  //    in the location.hash 'state', or undefined. If not, an object
  //    representing the entire 'state' is returned.
  
  jq_bbq.getState = jq_bbq_getState = function( key, coerce ) {
    return key === undefined || typeof key === 'boolean'
      ? jq_deparam_fragment( key ) // 'key' really means 'coerce' here
      : jq_deparam_fragment( coerce )[ key ];
  };
  
  // Method: jQuery.bbq.removeState
  // 
  // Remove one or more keys from the current browser history 'state', creating
  // a new state, setting location.hash and triggering any bound
  // <hashchange event> callbacks (provided the new state is different than
  // the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.removeState( [ key [, key ... ] ] );
  // 
  // Arguments:
  // 
  //  key - (String) One or more key values to remove from the current state,
  //    passed as individual arguments.
  //  key - (Array) A single array argument that contains a list of key values
  //    to remove from the current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  
  jq_bbq.removeState = function( arr ) {
    var state = {};
    
    // If one or more arguments is passed..
    if ( arr !== undefined ) {
      
      // Get the current state.
      state = jq_bbq_getState();
      
      // For each passed key, delete the corresponding property from the current
      // state.
      $.each( $.isArray( arr ) ? arr : arguments, function(i,v){
        delete state[ v ];
      });
    }
    
    // Set the state, completely overriding any existing state.
    jq_bbq_pushState( state, 2 );
  };
  
  // Event: hashchange event (BBQ)
  // 
  // Usage in jQuery 1.4 and newer:
  // 
  // In jQuery 1.4 and newer, the event object passed into any hashchange event
  // callback is augmented with a copy of the location.hash fragment at the time
  // the event was triggered as its event.fragment property. In addition, the
  // event.getState method operates on this property (instead of location.hash)
  // which allows this fragment-as-a-state to be referenced later, even after
  // window.location may have changed.
  // 
  // Note that event.fragment and event.getState are not defined according to
  // W3C (or any other) specification, but will still be available whether or
  // not the hashchange event exists natively in the browser, because of the
  // utility they provide.
  // 
  // The event.fragment property contains the output of <jQuery.param.fragment>
  // and the event.getState method is equivalent to the <jQuery.bbq.getState>
  // method.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = event.fragment,
  // >     param_obj = event.getState(),
  // >     param_val = event.getState( 'param_name' ),
  // >     param_val_coerced = event.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Usage in jQuery 1.3.2:
  // 
  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,
  // so the fragment state isn't bound to the event object and must instead be
  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = $.param.fragment(),
  // >     param_obj = $.bbq.getState(),
  // >     param_val = $.bbq.getState( 'param_name' ),
  // >     param_val_coerced = $.bbq.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is
  //   required to enable the augmented event object in jQuery 1.4.2 and newer.
  // * See <jQuery hashchange event> for more detailed information.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Augmenting the event object with the .fragment property and .getState
    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will
    // work, but the event won't be augmented)
    add: function( handleObj ) {
      var old_handler;
      
      function new_handler(e) {
        // e.fragment is set to the value of location.hash (with any leading #
        // removed) at the time the event is triggered.
        var hash = e[ str_fragment ] = jq_param_fragment();
        
        // e.getState() works just like $.bbq.getState(), but uses the
        // e.fragment property stored on the event object.
        e.getState = function( key, coerce ) {
          return key === undefined || typeof key === 'boolean'
            ? jq_deparam( hash, key ) // 'key' really means 'coerce' here
            : jq_deparam( hash, coerce )[ key ];
        };
        
        old_handler.apply( this, arguments );
      };
      
      // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+
      if ( $.isFunction( handleObj ) ) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
    
  });
  
})(jQuery,this);

/*!
 * jQuery hashchange event - v1.2 - 2/11/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.2, Last updated: 2/11/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (1.1kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// This working example, complete with fully commented code, illustrate one way
// in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.7, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and robust,
// there are a few unfortunate browser bugs surrounding expected hashchange
// event-based behaviors, independent of any JavaScript window.onhashchange
// abstraction. See the following examples for more information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// About: Release History
// 
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Method / object references.
  var fake_onhashchange,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_location = 'location',
    str_hashchange = 'hashchange',
    str_href = 'href',
    
    // IE6/7 specifically need some special love when it comes to back-button
    // support, so let's do a little browser sniffing..
    browser = $.browser,
    mode = document.documentMode,
    is_old_ie = browser.msie && ( mode === undefined || mode < 8 ),
    
    // Does the browser support window.onhashchange? Test for IE version, since
    // IE8 incorrectly reports this when in "IE7" or "IE8 Compatibility View"!
    supports_onhashchange = 'on' + str_hashchange in window && !is_old_ie;
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || window[ str_location ][ str_href ];
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Property: jQuery.hashchangeDelay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 100.
  
  $[ str_hashchange + 'Delay' ] = 100;
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // window.onhashchange event is used (IE8, FF3.6), otherwise a polling loop is
  // initialized, running every <jQuery.hashchangeDelay> milliseconds to see if
  // the hash has changed. In IE 6 and 7, a hidden Iframe is created to allow
  // the back button and hash-based history to work.
  // 
  // Usage:
  // 
  // > $(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one callback
  //   is actually bound to 'hashchange'.
  // * If you need the bound callback(s) to execute immediately, in cases where
  //   the page 'state' exists on page load (via bookmark or page refresh, for
  //   example) use $(window).trigger( 'hashchange' );
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a $(document).ready() callback.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      iframe,
      set_history,
      get_history;
    
    // Initialize. In IE 6/7, creates a hidden Iframe for history handling.
    function init(){
      // Most browsers don't need special methods here..
      set_history = get_history = function(val){ return val; };
      
      // But IE6/7 do!
      if ( is_old_ie ) {
        
        // Create hidden Iframe after the end of the body to prevent initial
        // page load from scrolling unnecessarily.
        iframe = $('<iframe src="javascript:0"/>').hide().insertAfter( 'body' )[0].contentWindow;
        
        // Get history by looking at the hidden Iframe's location.hash.
        get_history = function() {
          return get_fragment( iframe.document[ str_location ][ str_href ] );
        };
        
        // Set a new history item by opening and then closing the Iframe
        // document, *then* setting its location.hash.
        set_history = function( hash, history_hash ) {
          if ( hash !== history_hash ) {
            var doc = iframe.document;
            doc.open().close();
            doc[ str_location ].hash = '#' + hash;
          }
        };
        
        // Set initial history.
        set_history( get_fragment() );
      }
    };
    
    // Start the polling loop.
    self.start = function() {
      // Polling loop is already running!
      if ( timeout_id ) { return; }
      
      // Remember the initial hash so it doesn't get triggered immediately.
      var last_hash = get_fragment();
      
      // Initialize if not yet initialized.
      set_history || init();
      
      // This polling loop checks every $.hashchangeDelay milliseconds to see if
      // location.hash has changed, and triggers the 'hashchange' event on
      // window when necessary.
      (function loopy(){
        var hash = get_fragment(),
          history_hash = get_history( last_hash );
        
        if ( hash !== last_hash ) {
          set_history( last_hash = hash, history_hash );
          
          $(window).trigger( str_hashchange );
          
        } else if ( history_hash !== last_hash ) {
          window[ str_location ][ str_href ] = window[ str_location ][ str_href ].replace( /#.*/, '' ) + '#' + history_hash;
        }
        
        timeout_id = setTimeout( loopy, $[ str_hashchange + 'Delay' ] );
      })();
    };
    
    // Stop the polling loop, but only if an IE6/7 Iframe wasn't created. In
    // that case, even if there are no longer any bound event handlers, the
    // polling loop is still necessary for back/next to work at all!
    self.stop = function() {
      if ( !iframe ) {
        timeout_id && clearTimeout( timeout_id );
        timeout_id = 0;
      }
    };
    
    return self;
  })();
  
})(jQuery,this);



/**
 * Script loader plugin 1.2.1
 *
 * Copyright (c) 2009 Filatov Dmitry (alpha@zforms.ru)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function($) {

var scripts = [];

function loadScript(url, callback, context) {

	var script = scripts[url] || (scripts[url] = {
		loaded    : false,
		callbacks : []
	});

	if(script.loaded) {
		return callback.apply(context);
	}

	script.callbacks.push({
		fn      : callback,
		context : context
	});

	if(script.callbacks.length == 1) {
		$.ajax({
			type     : 'GET',
			url      : url,
			dataType : 'script',
			cache    : true,
			success  : function() {
				script.loaded = true;
				$.each(script.callbacks, function() {
					this.fn.apply(this.context);
				});
				script.callbacks.length = 0;
			}
		});
	}

}

$.requireScript = function(url, callback, context, options) {

	if(typeof options === 'undefined' && context && context.hasOwnProperty('parallel')) {
		options = context;
		context = window;
	}

	options = $.extend({ parallel : true }, options);

	if(!$.isArray(url)) {
		return loadScript(url, callback, context);
	}

	var counter = 0;

	// parallel loading
	if(options.parallel) {
		return $.each(url, function() {
			loadScript(this, function() {
				if(++counter == url.length) {
					callback.apply(context);
				}
			});
		});
	}

	// sequential loading
	(function() {
		if(counter == url.length) {
			return callback.apply(context);
		}
		loadScript(url[counter++], arguments.callee);
	})();

};

$.requireScript.registerLoaded = function(url) {
	$.each($.makeArray(url), function() {
		(scripts[url] || (scripts[url] = {})).loaded = true;
	});
};

})(jQuery);


/*!
 * jQuery Form Plugin
 * version: 2.84 (12-AUG-2011)
 * @requires jQuery v1.3.2 or later
 *
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */
;(function($) {

/*
	Usage Note:
	-----------
	Do not use both ajaxSubmit and ajaxForm on the same form.  These
	functions are intended to be exclusive.  Use ajaxSubmit if you want
	to bind your own submit handler to the form.  For example,

	$(document).ready(function() {
		$('#myForm').bind('submit', function(e) {
			e.preventDefault(); // <-- important
			$(this).ajaxSubmit({
				target: '#output'
			});
		});
	});

	Use ajaxForm when you want the plugin to manage all the event binding
	for you.  For example,

	$(document).ready(function() {
		$('#myForm').ajaxForm({
			target: '#output'
		});
	});

	When using ajaxForm, the ajaxSubmit function will be invoked for you
	at the appropriate time.
*/

/**
 * ajaxSubmit() provides a mechanism for immediately submitting
 * an HTML form using AJAX.
 */
$.fn.ajaxSubmit = function(options) {
	// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
	if (!this.length) {
		log('ajaxSubmit: skipping submit process - no element selected');
		return this;
	}
	
	var method, action, url, $form = this;

	if (typeof options == 'function') {
		options = { success: options };
	}

	method = this.attr('method');
	action = this.attr('action');
	url = (typeof action === 'string') ? $.trim(action) : '';
	url = url || window.location.href || '';
	if (url) {
		// clean url (don't include hash vaue)
		url = (url.match(/^([^#]+)/)||[])[1];
	}

	options = $.extend(true, {
		url:  url,
		success: $.ajaxSettings.success,
		type: method || 'GET',
		iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
	}, options);

	// hook for manipulating the form data before it is extracted;
	// convenient for use with rich editors like tinyMCE or FCKEditor
	var veto = {};
	this.trigger('form-pre-serialize', [this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
		return this;
	}

	// provide opportunity to alter form data before it is serialized
	if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSerialize callback');
		return this;
	}

	var n,v,a = this.formToArray(options.semantic);
	if (options.data) {
		options.extraData = options.data;
		for (n in options.data) {
			if( $.isArray(options.data[n]) ) {
				for (var k in options.data[n]) {
					a.push( { name: n, value: options.data[n][k] } );
				}
			}
			else {
				v = options.data[n];
				v = $.isFunction(v) ? v() : v; // if value is fn, invoke it
				a.push( { name: n, value: v } );
			}
		}
	}

	// give pre-submit callback an opportunity to abort the submit
	if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSubmit callback');
		return this;
	}

	// fire vetoable 'validate' event
	this.trigger('form-submit-validate', [a, this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
		return this;
	}

	var q = $.param(a);

	if (options.type.toUpperCase() == 'GET') {
		options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
		options.data = null;  // data is null for 'get'
	}
	else {
		options.data = q; // data is the query string for 'post'
	}

	var callbacks = [];
	if (options.resetForm) {
		callbacks.push(function() { $form.resetForm(); });
	}
	if (options.clearForm) {
		callbacks.push(function() { $form.clearForm(); });
	}

	// perform a load on the target only if dataType is not provided
	if (!options.dataType && options.target) {
		var oldSuccess = options.success || function(){};
		callbacks.push(function(data) {
			var fn = options.replaceTarget ? 'replaceWith' : 'html';
			$(options.target)[fn](data).each(oldSuccess, arguments);
		});
	}
	else if (options.success) {
		callbacks.push(options.success);
	}

	options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
		var context = options.context || options;   // jQuery 1.4+ supports scope context 
		for (var i=0, max=callbacks.length; i < max; i++) {
			callbacks[i].apply(context, [data, status, xhr || $form, $form]);
		}
	};

	// are there files to upload?
	var fileInputs = $('input:file', this).length > 0;
	var mp = 'multipart/form-data';
	var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);

	// options.iframe allows user to force iframe mode
	// 06-NOV-09: now defaulting to iframe mode if file input is detected
   if (options.iframe !== false && (fileInputs || options.iframe || multipart)) {
	   // hack to fix Safari hang (thanks to Tim Molendijk for this)
	   // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
	   if (options.closeKeepAlive) {
		   $.get(options.closeKeepAlive, function() { fileUpload(a); });
		}
	   else {
		   fileUpload(a);
		}
   }
   else {
		// IE7 massage (see issue 57)
		if ($.browser.msie && method == 'get') { 
			var ieMeth = $form[0].getAttribute('method');
			if (typeof ieMeth === 'string')
				options.type = ieMeth;
		}
		$.ajax(options);
   }

	// fire 'notify' event
	this.trigger('form-submit-notify', [this, options]);
	return this;


	// private function for handling file uploads (hat tip to YAHOO!)
	function fileUpload(a) {
		var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
        var useProp = !!$.fn.prop;

        if (a) {
        	// ensure that every serialized input is still enabled
          	for (i=0; i < a.length; i++) {
                el = $(form[a[i].name]);
                el[ useProp ? 'prop' : 'attr' ]('disabled', false);
          	}
        }

		if ($(':input[name=submit],:input[id=submit]', form).length) {
			// if there is an input with a name or id of 'submit' then we won't be
			// able to invoke the submit fn on the form (at least not x-browser)
			alert('Error: Form elements must not have name or id of "submit".');
			return;
		}
		
		s = $.extend(true, {}, $.ajaxSettings, options);
		s.context = s.context || s;
		id = 'jqFormIO' + (new Date().getTime());
		if (s.iframeTarget) {
			$io = $(s.iframeTarget);
			n = $io.attr('name');
			if (n == null)
			 	$io.attr('name', id);
			else
				id = n;
		}
		else {
			$io = $('<iframe name="' + id + '" src="'+ s.iframeSrc +'" />');
			$io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
		}
		io = $io[0];


		xhr = { // mock object
			aborted: 0,
			responseText: null,
			responseXML: null,
			status: 0,
			statusText: 'n/a',
			getAllResponseHeaders: function() {},
			getResponseHeader: function() {},
			setRequestHeader: function() {},
			abort: function(status) {
				var e = (status === 'timeout' ? 'timeout' : 'aborted');
				log('aborting upload... ' + e);
				this.aborted = 1;
				$io.attr('src', s.iframeSrc); // abort op in progress
				xhr.error = e;
				s.error && s.error.call(s.context, xhr, e, status);
				g && $.event.trigger("ajaxError", [xhr, s, e]);
				s.complete && s.complete.call(s.context, xhr, e);
			}
		};

		g = s.global;
		// trigger ajax global events so that activity/block indicators work like normal
		if (g && ! $.active++) {
			$.event.trigger("ajaxStart");
		}
		if (g) {
			$.event.trigger("ajaxSend", [xhr, s]);
		}

		if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
			if (s.global) {
				$.active--;
			}
			return;
		}
		if (xhr.aborted) {
			return;
		}

		// add submitting element to data if we know it
		sub = form.clk;
		if (sub) {
			n = sub.name;
			if (n && !sub.disabled) {
				s.extraData = s.extraData || {};
				s.extraData[n] = sub.value;
				if (sub.type == "image") {
					s.extraData[n+'.x'] = form.clk_x;
					s.extraData[n+'.y'] = form.clk_y;
				}
			}
		}
		
		var CLIENT_TIMEOUT_ABORT = 1;
		var SERVER_ABORT = 2;

		function getDoc(frame) {
			var doc = frame.contentWindow ? frame.contentWindow.document : frame.contentDocument ? frame.contentDocument : frame.document;
			return doc;
		}
		
		// take a breath so that pending repaints get some cpu time before the upload starts
		function doSubmit() {
			// make sure form attrs are set
			var t = $form.attr('target'), a = $form.attr('action');

			// update form attrs in IE friendly way
			form.setAttribute('target',id);
			if (!method) {
				form.setAttribute('method', 'POST');
			}
			if (a != s.url) {
				form.setAttribute('action', s.url);
			}

			// ie borks in some cases when setting encoding
			if (! s.skipEncodingOverride && (!method || /post/i.test(method))) {
				$form.attr({
					encoding: 'multipart/form-data',
					enctype:  'multipart/form-data'
				});
			}

			// support timout
			if (s.timeout) {
				timeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);
			}
			
			// look for server aborts
			function checkState() {
				try {
					var state = getDoc(io).readyState;
					log('state = ' + state);
					if (state.toLowerCase() == 'uninitialized')
						setTimeout(checkState,50);
				}
				catch(e) {
					log('Server abort: ' , e, ' (', e.name, ')');
					cb(SERVER_ABORT);
					timeoutHandle && clearTimeout(timeoutHandle);
					timeoutHandle = undefined;
				}
			}

			// add "extra" data to form if provided in options
			var extraInputs = [];
			try {
				if (s.extraData) {
					for (var n in s.extraData) {
						extraInputs.push(
							$('<input type="hidden" name="'+n+'" />').attr('value',s.extraData[n])
								.appendTo(form)[0]);
					}
				}

				if (!s.iframeTarget) {
					// add iframe to doc and submit the form
					$io.appendTo('body');
	                io.attachEvent ? io.attachEvent('onload', cb) : io.addEventListener('load', cb, false);
				}
				setTimeout(checkState,15);
				form.submit();
			}
			finally {
				// reset attrs and remove "extra" input elements
				form.setAttribute('action',a);
				if(t) {
					form.setAttribute('target', t);
				} else {
					$form.removeAttr('target');
				}
				$(extraInputs).remove();
			}
		}

		if (s.forceSync) {
			doSubmit();
		}
		else {
			setTimeout(doSubmit, 10); // this lets dom updates render
		}

		var data, doc, domCheckCount = 50, callbackProcessed;

		function cb(e) {
			if (xhr.aborted || callbackProcessed) {
				return;
			}
			try {
				doc = getDoc(io);
			}
			catch(ex) {
				log('cannot access response document: ', ex);
				e = SERVER_ABORT;
			}
			if (e === CLIENT_TIMEOUT_ABORT && xhr) {
				xhr.abort('timeout');
				return;
			}
			else if (e == SERVER_ABORT && xhr) {
				xhr.abort('server abort');
				return;
			}

			if (!doc || doc.location.href == s.iframeSrc) {
				// response not received yet
				if (!timedOut)
					return;
			}
            io.detachEvent ? io.detachEvent('onload', cb) : io.removeEventListener('load', cb, false);

			var status = 'success', errMsg;
			try {
				if (timedOut) {
					throw 'timeout';
				}

				var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
				log('isXml='+isXml);
				if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
					if (--domCheckCount) {
						// in some browsers (Opera) the iframe DOM is not always traversable when
						// the onload callback fires, so we loop a bit to accommodate
						log('requeing onLoad callback, DOM not available');
						setTimeout(cb, 250);
						return;
					}
					// let this fall through because server response could be an empty document
					//log('Could not access iframe DOM after mutiple tries.');
					//throw 'DOMException: not available';
				}

				//log('response detected');
                var docRoot = doc.body ? doc.body : doc.documentElement;
                xhr.responseText = docRoot ? docRoot.innerHTML : null;
				xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
				if (isXml)
					s.dataType = 'xml';
				xhr.getResponseHeader = function(header){
					var headers = {'content-type': s.dataType};
					return headers[header];
				};
                // support for XHR 'status' & 'statusText' emulation :
                if (docRoot) {
                    xhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;
                    xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;
                }

				var dt = s.dataType || '';
				var scr = /(json|script|text)/.test(dt.toLowerCase());
				if (scr || s.textarea) {
					// see if user embedded response in textarea
					var ta = doc.getElementsByTagName('textarea')[0];
					if (ta) {
						xhr.responseText = ta.value;
                        // support for XHR 'status' & 'statusText' emulation :
                        xhr.status = Number( ta.getAttribute('status') ) || xhr.status;
                        xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;
					}
					else if (scr) {
						// account for browsers injecting pre around json response
						var pre = doc.getElementsByTagName('pre')[0];
						var b = doc.getElementsByTagName('body')[0];
						if (pre) {
							xhr.responseText = pre.textContent ? pre.textContent : pre.innerHTML;
						}
						else if (b) {
							xhr.responseText = b.innerHTML;
						}
					}
				}
				else if (s.dataType == 'xml' && !xhr.responseXML && xhr.responseText != null) {
					xhr.responseXML = toXml(xhr.responseText);
				}

                try {
                    data = httpData(xhr, s.dataType, s);
                }
                catch (e) {
                    status = 'parsererror';
                    xhr.error = errMsg = (e || status);
                }
			}
			catch (e) {
				log('error caught: ',e);
				status = 'error';
                xhr.error = errMsg = (e || status);
			}

			if (xhr.aborted) {
				log('upload aborted');
				status = null;
			}

            if (xhr.status) { // we've set xhr.status
                status = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';
            }

			// ordering of these callbacks/triggers is odd, but that's how $.ajax does it
			if (status === 'success') {
				s.success && s.success.call(s.context, data, 'success', xhr);
				g && $.event.trigger("ajaxSuccess", [xhr, s]);
			}
            else if (status) {
				if (errMsg == undefined)
					errMsg = xhr.statusText;
				s.error && s.error.call(s.context, xhr, status, errMsg);
				g && $.event.trigger("ajaxError", [xhr, s, errMsg]);
            }

			g && $.event.trigger("ajaxComplete", [xhr, s]);

			if (g && ! --$.active) {
				$.event.trigger("ajaxStop");
			}

			s.complete && s.complete.call(s.context, xhr, status);

			callbackProcessed = true;
			if (s.timeout)
				clearTimeout(timeoutHandle);

			// clean up
			setTimeout(function() {
				if (!s.iframeTarget)
					$io.remove();
				xhr.responseXML = null;
			}, 100);
		}

		var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
			if (window.ActiveXObject) {
				doc = new ActiveXObject('Microsoft.XMLDOM');
				doc.async = 'false';
				doc.loadXML(s);
			}
			else {
				doc = (new DOMParser()).parseFromString(s, 'text/xml');
			}
			return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;
		};
		var parseJSON = $.parseJSON || function(s) {
			return window['eval']('(' + s + ')');
		};

		var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4

			var ct = xhr.getResponseHeader('content-type') || '',
				xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,
				data = xml ? xhr.responseXML : xhr.responseText;

			if (xml && data.documentElement.nodeName === 'parsererror') {
				$.error && $.error('parsererror');
			}
			if (s && s.dataFilter) {
				data = s.dataFilter(data, type);
			}
			if (typeof data === 'string') {
				if (type === 'json' || !type && ct.indexOf('json') >= 0) {
					data = parseJSON(data);
				} else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
					$.globalEval(data);
				}
			}
			return data;
		};
	}
};

/**
 * ajaxForm() provides a mechanism for fully automating form submission.
 *
 * The advantages of using this method instead of ajaxSubmit() are:
 *
 * 1: This method will include coordinates for <input type="image" /> elements (if the element
 *	is used to submit the form).
 * 2. This method will include the submit element's name/value data (for the element that was
 *	used to submit the form).
 * 3. This method binds the submit() method to the form for you.
 *
 * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
 * passes the options argument along after properly binding events for submit elements and
 * the form itself.
 */
$.fn.ajaxForm = function(options) {
	// in jQuery 1.3+ we can fix mistakes with the ready state
	if (this.length === 0) {
		var o = { s: this.selector, c: this.context };
		if (!$.isReady && o.s) {
			log('DOM not ready, queuing ajaxForm');
			$(function() {
				$(o.s,o.c).ajaxForm(options);
			});
			return this;
		}
		// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
		log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
		return this;
	}

	return this.ajaxFormUnbind().bind('submit.form-plugin', function(e) {
		if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
			e.preventDefault();
			$(this).ajaxSubmit(options);
		}
	}).bind('click.form-plugin', function(e) {
		var target = e.target;
		var $el = $(target);
		if (!($el.is(":submit,input:image"))) {
			// is this a child element of the submit el?  (ex: a span within a button)
			var t = $el.closest(':submit');
			if (t.length == 0) {
				return;
			}
			target = t[0];
		}
		var form = this;
		form.clk = target;
		if (target.type == 'image') {
			if (e.offsetX != undefined) {
				form.clk_x = e.offsetX;
				form.clk_y = e.offsetY;
			} else if (typeof $.fn.offset == 'function') { // try to use dimensions plugin
				var offset = $el.offset();
				form.clk_x = e.pageX - offset.left;
				form.clk_y = e.pageY - offset.top;
			} else {
				form.clk_x = e.pageX - target.offsetLeft;
				form.clk_y = e.pageY - target.offsetTop;
			}
		}
		// clear form vars
		setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
	});
};

// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
	return this.unbind('submit.form-plugin click.form-plugin');
};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.
 * Each object in the array has both a 'name' and 'value' property.  An example of
 * an array for a simple login form might be:
 *
 * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
 *
 * It is this array that is passed to pre-submit callback functions provided to the
 * ajaxSubmit() and ajaxForm() methods.
 */
$.fn.formToArray = function(semantic) {
	var a = [];
	if (this.length === 0) {
		return a;
	}

	var form = this[0];
	var els = semantic ? form.getElementsByTagName('*') : form.elements;
	if (!els) {
		return a;
	}

	var i,j,n,v,el,max,jmax;
	for(i=0, max=els.length; i < max; i++) {
		el = els[i];
		n = el.name;
		if (!n) {
			continue;
		}

		if (semantic && form.clk && el.type == "image") {
			// handle image inputs on the fly when semantic == true
			if(!el.disabled && form.clk == el) {
				a.push({name: n, value: $(el).val()});
				a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
			}
			continue;
		}

		v = $.fieldValue(el, true);
		if (v && v.constructor == Array) {
			for(j=0, jmax=v.length; j < jmax; j++) {
				a.push({name: n, value: v[j]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: n, value: v});
		}
	}

	if (!semantic && form.clk) {
		// input type=='image' are not found in elements array! handle it here
		var $input = $(form.clk), input = $input[0];
		n = input.name;
		if (n && !input.disabled && input.type == 'image') {
			a.push({name: n, value: $input.val()});
			a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
		}
	}
	return a;
};

/**
 * Serializes form data into a 'submittable' string. This method will return a string
 * in the format: name1=value1&amp;name2=value2
 */
$.fn.formSerialize = function(semantic) {
	//hand off to jQuery.param for proper encoding
	return $.param(this.formToArray(semantic));
};

/**
 * Serializes all field elements in the jQuery object into a query string.
 * This method will return a string in the format: name1=value1&amp;name2=value2
 */
$.fn.fieldSerialize = function(successful) {
	var a = [];
	this.each(function() {
		var n = this.name;
		if (!n) {
			return;
		}
		var v = $.fieldValue(this, successful);
		if (v && v.constructor == Array) {
			for (var i=0,max=v.length; i < max; i++) {
				a.push({name: n, value: v[i]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: this.name, value: v});
		}
	});
	//hand off to jQuery.param for proper encoding
	return $.param(a);
};

/**
 * Returns the value(s) of the element in the matched set.  For example, consider the following form:
 *
 *  <form><fieldset>
 *	  <input name="A" type="text" />
 *	  <input name="A" type="text" />
 *	  <input name="B" type="checkbox" value="B1" />
 *	  <input name="B" type="checkbox" value="B2"/>
 *	  <input name="C" type="radio" value="C1" />
 *	  <input name="C" type="radio" value="C2" />
 *  </fieldset></form>
 *
 *  var v = $(':text').fieldValue();
 *  // if no values are entered into the text inputs
 *  v == ['','']
 *  // if values entered into the text inputs are 'foo' and 'bar'
 *  v == ['foo','bar']
 *
 *  var v = $(':checkbox').fieldValue();
 *  // if neither checkbox is checked
 *  v === undefined
 *  // if both checkboxes are checked
 *  v == ['B1', 'B2']
 *
 *  var v = $(':radio').fieldValue();
 *  // if neither radio is checked
 *  v === undefined
 *  // if first radio is checked
 *  v == ['C1']
 *
 * The successful argument controls whether or not the field element must be 'successful'
 * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
 * The default value of the successful argument is true.  If this value is false the value(s)
 * for each element is returned.
 *
 * Note: This method *always* returns an array.  If no valid value can be determined the
 *	   array will be empty, otherwise it will contain one or more values.
 */
$.fn.fieldValue = function(successful) {
	for (var val=[], i=0, max=this.length; i < max; i++) {
		var el = this[i];
		var v = $.fieldValue(el, successful);
		if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
			continue;
		}
		v.constructor == Array ? $.merge(val, v) : val.push(v);
	}
	return val;
};

/**
 * Returns the value of the field element.
 */
$.fieldValue = function(el, successful) {
	var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
	if (successful === undefined) {
		successful = true;
	}

	if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
		(t == 'checkbox' || t == 'radio') && !el.checked ||
		(t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
		tag == 'select' && el.selectedIndex == -1)) {
			return null;
	}

	if (tag == 'select') {
		var index = el.selectedIndex;
		if (index < 0) {
			return null;
		}
		var a = [], ops = el.options;
		var one = (t == 'select-one');
		var max = (one ? index+1 : ops.length);
		for(var i=(one ? index : 0); i < max; i++) {
			var op = ops[i];
			if (op.selected) {
				var v = op.value;
				if (!v) { // extra pain for IE...
					v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
				}
				if (one) {
					return v;
				}
				a.push(v);
			}
		}
		return a;
	}
	return $(el).val();
};

/**
 * Clears the form data.  Takes the following actions on the form's input fields:
 *  - input text fields will have their 'value' property set to the empty string
 *  - select elements will have their 'selectedIndex' property set to -1
 *  - checkbox and radio inputs will have their 'checked' property set to false
 *  - inputs of type submit, button, reset, and hidden will *not* be effected
 *  - button elements will *not* be effected
 */
$.fn.clearForm = function() {
	return this.each(function() {
		$('input,select,textarea', this).clearFields();
	});
};

/**
 * Clears the selected form elements.
 */
$.fn.clearFields = $.fn.clearInputs = function() {
	var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list
	return this.each(function() {
		var t = this.type, tag = this.tagName.toLowerCase();
		if (re.test(t) || tag == 'textarea') {
			this.value = '';
		}
		else if (t == 'checkbox' || t == 'radio') {
			this.checked = false;
		}
		else if (tag == 'select') {
			this.selectedIndex = -1;
		}
	});
};

/**
 * Resets the form data.  Causes all form elements to be reset to their original value.
 */
$.fn.resetForm = function() {
	return this.each(function() {
		// guard against an input with the name of 'reset'
		// note that IE reports the reset function as an 'object'
		if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
			this.reset();
		}
	});
};

/**
 * Enables or disables any matching elements.
 */
$.fn.enable = function(b) {
	if (b === undefined) {
		b = true;
	}
	return this.each(function() {
		this.disabled = !b;
	});
};

/**
 * Checks/unchecks any matching checkboxes or radio buttons and
 * selects/deselects and matching option elements.
 */
$.fn.selected = function(select) {
	if (select === undefined) {
		select = true;
	}
	return this.each(function() {
		var t = this.type;
		if (t == 'checkbox' || t == 'radio') {
			this.checked = select;
		}
		else if (this.tagName.toLowerCase() == 'option') {
			var $sel = $(this).parent('select');
			if (select && $sel[0] && $sel[0].type == 'select-one') {
				// deselect all other options
				$sel.find('option').selected(false);
			}
			this.selected = select;
		}
	});
};

// helper fn for console logging
function log() {
	var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
	if (window.console && window.console.log) {
		window.console.log(msg);
	}
	else if (window.opera && window.opera.postError) {
		window.opera.postError(msg);
	}
};

})(jQuery);



/*jslint browser: true */ /*global jQuery: true */

/**
 * jQuery Cookie plugin
 *
 * Copyright (c) 2010 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

// TODO JsDoc

/**
 * Create a cookie with the given key and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String key The key of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given key.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String key The key of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function (key, value, options) {

    // key and value given, set cookie...
    if (arguments.length > 1 && (value === null || typeof value !== "object")) {
        options = jQuery.extend({}, options);

        if (value === null) {
            options.expires = -1;
        }

        if (typeof options.expires === 'number') {
            var days = options.expires, t = options.expires = (new Date()).toBrowserDateTimeFromClient();
            t.setDate(t.getDate() + days);
        }

        return (document.cookie = [
            encodeURIComponent(key), '=',
            options.raw ? String(value) : encodeURIComponent(String(value)),
            options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
            options.path ? '; path=' + options.path : '',
            options.domain ? '; domain=' + options.domain : '',
            options.secure ? '; secure' : ''
        ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || {};
    var result, decode = options.raw ? function (s) { return s; } : decodeURIComponent;
    return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? decode(result[1]) : null;
};



jQuery.fn.reverse = function () {
    return this.pushStack(this.get().reverse(), arguments);
};

function MoveFromTo(idleft, idleftvals, idright, idrightvals) {
    var leftselector = '#' + idleft;
    var rightselector = '#' + idright;
    var selectedItems = $(leftselector + ' :selected');
    $(rightselector).append(selectedItems);
    UpdateSelected(idleftvals);
    UpdateSelected(idrightvals);
}

function SelectComplexExecutor(leftDivContainer, selectedList) {
    var left = $('#' + leftDivContainer).find('select:visible :selected');
    $('#'+ selectedList).append(left);
}

function UnselectComplexExecutor(leftDivContainer, selectedList) {
    var unselected = $('#' + selectedList + ' :selected');
    unselected.each(function(i, a) {
        var val = $(a).attr('value');
        $('#' + leftDivContainer).find('select').each(function(j, s) {
            var prefix = $(s).attr('selectorPrefix');
            var isStart = val && val.length >= prefix.length && val.indexOf(prefix) == 0;
            if (isStart) {
                $(s).append($(a));
            }
        });
    });
}

function MoveUp(id, idvals) {
    var selector = '#' + id;
    $(selector + ' :selected').each(function (i, a) {
        $(a).prev().before(a);
    });
    UpdateSelected(idvals);
}

function MoveDown(id, idvals) {
    var selector = '#' + id;
    $(selector + ' :selected').reverse().each(function (i, a) {
        $(a).next().after(a);
    });
    UpdateSelected(idvals);
}

function UpdateSelected(id) {
    var idvals = '#' + id + 'Values';
    var idsel = '#' + id + 'List';
    var name = $(idsel).attr('name');
    if (name) {
        name = name.slice(0,-4);
    }
    var options = $(idsel + ' option');
    $(idvals).empty();
    options.each(function (i, a) {
        $(idvals).append('<input type="hidden" name="' + name + '[' + i + '].Value" value="' + $(a).val() + '"/>');
        $(idvals).append('<input type="hidden" name="' + name + '[' + i + '].Text" value="' + $(a).text() + '"/>');
    });
}

function initListToList(avalibleId, selectedId) {
    UpdateSelected(avalibleId);
    UpdateSelected(selectedId);
    $('#' + avalibleId + 'List').dblclick(function () { MoveFromTo(avalibleId + 'List', avalibleId, selectedId + 'List', selectedId); });
    $('#' + selectedId + 'List').dblclick(function () { MoveFromTo(selectedId + 'List', selectedId, avalibleId + 'List', avalibleId); });   
}

function ListToListPopupSelect(selectId, inputId) {

}


/**
 * Author: A.Chakkaev [1602] http://1602.habrahabr.ru/
 * Created: summer 2008
**/
/*global MenuItem, jQuery*/

(function ($, window) {

    var undefined,
        ICONS_PATH = '',
        cls_item_with_submenu = 'cmenuItemWithSub',
        cls_item = 'cmenuItem';

    function image(img, alt, style, nodefsize) {
        if (alt) {
            alt = alt.replace(/"/, '\"');
        }
        return '<img src="' + ICONS_PATH + img +
            (img.search(/\.(gif|jpg|jpeg|png)$/i) === -1 ? '.png' : '') +
            '" ' + (nodefsize ? '' : 'width="16" height="16"')
            + ' alt="' +
            (alt ? alt : 'img') + '" ' +
            (alt ? 'title="' + alt + '"' : '') +
            (style ? ' style="' + style + '"' : '') + ' />';
    };


    var eventFlg = false;
    var oldEventElement;
    var eventFunc = function (e) {
        if (e.target != oldEventElement)
            hide_all();
        return eventFlg;
    };

    /**
    * create object MenuItem
    *
    * @param string caption    displayed label, required parameter, if first symbol is "!"
    *                          then this menu item is disabled by default
    * @param string icon       name of 16x16 icon, displayed on the left side of label, optional
    * @param function execute  this will called when menu item was triggered
    * @param object submenu    subitems of current item
    **/
    window.MenuItem = function (caption, icon, execute, submenu) {
        if (caption.search(/^!/) !== -1) {
            this.disabled = true;
            caption = caption.substr(1);
        }
        this.caption = caption;
        this.icon = icon;
        this.execute = execute;
        this.submenu = submenu;
    };

    function create_cmenu_object(actions) {
        var new_cmenu_id = $.cmenu.c.length,
        cmenu_object = {
            cn: 'cmenu',
            id: new_cmenu_id,
            jq: $('<div iuid="' + new_cmenu_id + '" class="cmenu"></div>'),
            r: false
        };
        cmenu_object[$.isFunction(actions) ? 'f' : 'a'] = actions;

        $('body').append(cmenu_object.jq);

        $.cmenu.c[new_cmenu_id] = cmenu_object;
        return cmenu_object;
    }

    function get_path(el) {     /* Menu calling stack   {{{ */
        var p = [], jel;
        while (el) {
            jel = $(el);
            if (!jel.hasClass(cls_item)) {
                p.push(el);
                break;
            }
            el.cmenu = $.cmenu.get_menu(parseInt(jel.parent().attr('iuid'), 10));
            el.cmenu_item = el.cmenu.a[jel.attr('item_id')];
            p.push(el);

            // Go to parent
            el = el.cmenu.caller;
        }
        return p.reverse();
        /* }}} */
    }

    function get_offset(el, stop) {/* Offset el against stop    {{{ */
        //console.log(el.tagName,el.offsetLeft,el.offsetTop);
        if (el.offsetParent && el.offsetParent !== stop) {
            var of = get_offset(el.offsetParent, stop);
            of.x += el.offsetLeft;
            of.y += el.offsetTop;
            return of;
        } else {
            return {
                x: el.offsetLeft,
                y: el.offsetTop
            };
        }
        /* }}} */
    }

    function hide_all() {           /* Hide all displayed menus {{{ */
        eventFlg = true;
        // Если блокировано сокрытие меню - выйти
        if ($.cmenu.lockHidingForcibly || $.cmenu.lockHiding) {
            return false;
        }
        // Отбиндить сокрытие всех меню по клику
        $().unbind('click', hide_all);
        $.cmenu.hideBinded = false;
        // Скрыть менюшки
        var len = $.cmenu.c.length;
        for (var i = 0; i < len; i++) {
            $.cmenu.hide_menu($.cmenu.c[i]);
        }
        /* }}} */
    }

    function get_caller(id, event, position, paper) {/* Compile menu-caller-string (inline script attributes)    {{{ */
        var m = false;
        if (typeof id === 'object') {
            m = true;
            id = id.id;
        }
        if (typeof id !== 'number') {
            //console.error('get_caller - unexpected type of first parameter ('+(typeof id)+'), expecting number');
            return '';
        }
        switch (event) {
            case 'click':
            default:
                return 'onclick="$.cmenu.show(' + id + ',this);$.cmenu.lockHiding=true;" onmouseout="$.cmenu.lockHiding=false;"';
            case 'hovertimeout':
                return 'onmouseover="var t=this;$.cmenu.to=setTimeout(function(){$.cmenu.show(' + id + ',t,' + (position != null ? '\'' + position + '\'' : 'null') + ',' + (paper != null ? '\'' + paper + '\'' : 'null') + ');$.cmenu.lockHiding=true;},200);" onmouseout="clearTimeout($.cmenu.to);$.cmenu.lockHiding=false;"';
                // (m?'m=$.cmenu.get_menu('+id+');m&&m.sub&&$.cmenu.hide_menu(m.sub);':'')
        }

        /* }}} */
    }

    function handle_userfunc(menu) {
        if (!$.isFunction(menu.f)) {
            return true;
        }

        if (typeof menu.caller !== 'object') {
            return false;
        }

        // result of user function should be object or boolean
        var userfunc_result = menu.f(menu);
        if (typeof userfunc_result === 'object') {
            menu.a = userfunc_result;
            menu.r = false;
        } else {
            menu.r = !userfunc_result;
        }

        return true;
    }

    function handle_async(menu) {
        if (!menu.async) {
            return true;
        }
        if (!menu.a) {
            menu.done = function () {
                menu.v = false;
                $.cmenu.show(menu, menu.caller);
            };
            return false;
        }
        menu.r = false;
        return true;
    }

    function handle_rendered(menu) {
        /*if (menu.r) {
        return false;
        }*/
        //menu.r = true;
        $('div[iuid=' + menu.id + ']').remove();
        return true;
    }

    function is_invisible(item) {
        return item.visible !== undefined && !item.visible ||
            item.acid !== undefined && $.inArray(item.acid, []);
    }

    function render_item(menu, i, radio, position, paper) { /* {{{ */
        var a = menu.a[i];
        if (a === '-') {
            return '<hr' + ($.browser.msie ? ' style="width:50px;align:center;"' : '') + '/>';
            //return h += '<div class="hr"></div>';
        }

        if (a.constructor === Array) {
            a = new MenuItem(a[0], a[1], a[2], a[3]);
            menu.a[i] = a;
        }

        menu.a[i].parent = menu.parent_item;

        if (is_invisible(a)) {
            return '';
        }

        if (a.submenu && (!a.submenu.cn || a.submenu.cn !== 'cmenu')) {
            a.submenu = $.cmenu.get_menu(a.submenu);
        }

        var caption = a.caption;
        if (radio && caption === radio) { // radio
            caption = '<strong><u>' + a.caption + '</u></strong>';
        } else { // other

        }

        /*return '<li class="cmenuItem" item_id="' + i + '" ' +
        (a.disabled ?
        // Недоступный элемент
        'style="color:#808080;" ' :
        // Доступный элемент
        (a.href ? 'href="' + a.href + '"' : 'onclick="$.cmenu.exec(this);" ') +

        //'onclick="$.cmenu.exec(' + x.id + ',\'' + i + '\');" ' +
        (a.submenu ?
        // Есть подменю
        get_caller(a.submenu, 'hovertimeout') :
        // Нет подменю
        ' onmouseover="$.cmenu.to=setTimeout(function(){var m = $.cmenu.get_menu(' + menu.id + ');m && m.sub && $.cmenu.hide_menu(m.sub);},300);" onmouseout="clearTimeout($.cmenu.to);" ')
        ) +
        '><a><span class="cmenuIcon">' +
        (a.icon ? image(a.icon, ' ') : '') +
        '</span><span class="cmenuTitle"> ' + caption +
        '</span><span class="submenuBullet ' + (a.submenu ? 'hasSubmenu' : '') + '">' +
        '</span></a>';*/

        return '<div class="cmenuItem" item_id="' + i + '" ' +
            (a.disabled ?
        // Недоступный элемент
                'style="color:#808080;" ' :
        // Доступный элемент
                (!a.href ? 'onclick="$.cmenu.exec(this);" ' : '') +

        //'onclick="$.cmenu.exec(' + x.id + ',\'' + i + '\');" ' +
                (a.submenu ?
        // Есть подменю
                get_caller(a.submenu, 'hovertimeout', position, paper) :
        // Нет подменю
                ' onmouseover="$.cmenu.to=setTimeout(function(){var m = $.cmenu.get_menu(' + menu.id + ');m && m.sub && $.cmenu.hide_menu(m.sub);},300);" onmouseout="clearTimeout($.cmenu.to);" ')
            ) +
        '>' + (a.href ? '<a href="' + a.href + '">' : '') + '<span class="cmenuIcon">' +
        (a.icon ? image(a.icon, ' ') : '') +
        '</span><span class="cmenuTitle">' + caption +
        '</span><span class="submenuBullet ' + (a.submenu ? 'hasSubmenu' : '') + '">' +
        '</span>' + (a.href ? '</a>' : '') + '</div>';
        /* }}} */
    }

    function render_menu(menu, position, paper) {            /* Render menu items    {{{ */
        if (!handle_userfunc(menu) || !handle_async(menu) || !handle_rendered(menu)) {
            return false;
        }

        if (menu.type === 'radio') {
            var radio = menu.get();
        } else {
            radio = false;
        }
        var h = '';
        for (var i in menu.a) {
            if (menu.a[i]) {
                h += render_item(menu, i, radio, 'left', paper);
            }
        }
        menu.jq.html(h);
        /* }}} */
    }

    $.cmenu = {
        c: [],
        exec: function (item_element) {     /* Execute action   {{{ */
            item_element = $(item_element);
            var act = item_element.attr('item_id');
            var id = item_element.parent().attr('iuid');

            var m = $.cmenu.c[id];
            if (!m) {
                alert('Menu not found');
                return false;
            }
            if (!m.a || !m.a[act]) {
                alert('Action not found');
                return false;
            }
            if (m.type === 'radio') {
                m.set(m.a[act].caption);
                render_menu(m);
                return false;
            }
            if (m.a[act].href) {
                location.href = m.a[act].href;
            } else {
                if ($.isFunction(m.a[act].execute) && !m.a[act].disabled) {
                    m.a[act].execute.apply(window, [m.a[act].sender, m.a[act], m, m.p]);
                    hide_all();
                }
            }
            /* }}} */
        },
        /**
        * Function get_menu returns menu from
        * @param initializer mixed
        **/
        get_menu: function (initializer) {
            return (
                (typeof initializer).search(/function|object|undefined/) === -1 ?
                this.c[initializer] : create_cmenu_object(initializer)
            );
        },
        hide_menu: function (m) {       /* {{{ */
            if (!m || !m.v) {
                return;
            }
            m.v = false;
            this.hide_menu(m.sub);
            if (m.caller) {
                $(m.caller).removeClass(cls_item_with_submenu);
            }
            m.jq.hide();
            /* }}} */
        },
        hide_all: function () {
            hide_all();
        },
        show: function (menu, parentNode, position, paper) {           /* Show menu near parentNode    {{{ */
            if (typeof menu !== 'object') {
                menu = this.get_menu(menu);
            }
            if (typeof position === 'undefined') {
                position = 'left';
            }
            // return if menu already displayed near element parentNode
            if (menu.v && menu.caller === parentNode) {
                return false;
            }
            // we need to hide all displayed menus on mouse click
            if (!this.hideBinded) {
                this.hideBinded = true;
                $().bind('click', hide_all);
            }
            var prev_caller = menu.caller;
            menu.caller = parentNode;
            if (menu.sub) {
                this.hide_menu(menu.sub);
            }
            var jqp = $(parentNode);
            // Если вызвавший меню элемент - элемент меню (то есть показываем подменю)
            // то надо оставить p подсвеченным (класс cmenuItemWithSub);
            // также надо установить родительскому меню ссылку на дочернее, а дочернему - на родителя
            // и еще - если у нашего меню уже есть подменю - скрыть его
            if (jqp.hasClass(cls_item) && !jqp.hasClass(cls_item_with_submenu)) {
                jqp.addClass(cls_item_with_submenu);
                var pm = $.cmenu.get_menu(parseInt($(parentNode.parentNode).attr('iuid'), 10));
                if (pm) {
                    if (pm.sub) {
                        if (pm.sub === menu) {
                            $(prev_caller).removeClass(cls_item_with_submenu);
                        } else {
                            $.cmenu.hide_menu(pm.sub);
                            if ($.cmenu.to && clearTimeout($.cmenu.to)) {
                                delete $.cmenu.to;
                            }
                        }
                    }
                    pm.sub = menu;
                    menu.parentMenu = pm;
                }
            }

            menu.p = get_path(parentNode);
            menu.parent_item = menu.p[menu.p.length - 1].cmenu_item;
            render_menu(menu, position, paper);

            var pOffsetParent = menu.p[0].offsetParent;
            if (menu.jq[0].offsetParent !== pOffsetParent) {
                if ($(pOffsetParent).is('table')) {
                    if ($(pOffsetParent).parents('.t-grid-content').length > 0)
                        $(pOffsetParent).parent().after(menu.jq);
                    else
                        $(pOffsetParent).after(menu.jq);
                } else if ($(pOffsetParent).is('td, th')) {
                    var widget = $(pOffsetParent).parents('.t-widget.t-grid');
                    if (widget.length > 0) {
                        $(widget[0]).after(menu.jq);
                    } else {
                        $(pOffsetParent).after(menu.jq);
                    }
                } else {
                    if ($(pOffsetParent).hasClass('t-grid-header-wrap'))
                        menu.jq.appendTo($(pOffsetParent).parent());
                    else {
                        menu.jq.appendTo($(pOffsetParent));
                    }
                }
            }

            // Display menu
            if (menu.jq.css('display') === 'none') {
                menu.jq.show();
            }

            // Calculate menu parameters
            var cmenuOffParent = menu.jq[0].offsetParent;
            var cmenuWidth = menu.jq[0].offsetWidth;
            var cmenuHeight = menu.jq[0].offsetHeight;

            // Calc visible screen bounds (this code is common)
            var w = 0, h = 0;
            if (typeof (window.innerWidth) === 'number') {// не msie
                w = window.innerWidth;
                h = window.innerHeight;
            } else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {
                w = document.documentElement.clientWidth;
                h = document.documentElement.clientHeight;
            }
            if (paper != null) {
                w = $(paper)[0].clientWidth;
                h = $(paper)[0].clientHeight;
            }
            var sx = 0, sy = 0;
            if (typeof window.pageYOffset === 'number') {
                sx = window.pageXOffset;
                sy = window.pageYOffset;
            } else if (document.body && (document.body.scrollLeft || document.body.scrollTop)) {
                sx = document.body.scrollLeft;
                sy = document.body.scrollTop;
            } else if (document.documentElement && (document.documentElement.scrollLeft || document.documentElement.scrollTop)) {
                sx = document.documentElement.scrollLeft;
                sy = document.documentElement.scrollTop;
            }
            if (paper != null) {
                sx = $(paper).scrollLeft();
                sy = $(paper).scrollTop();
            }
            var winHeight = h + sy;
            var winWidth = w + sx;

            // Получаем абсолютное смещение элемента, вызвавшего меню (p)
            // относительно cmenuOffParent
            var off = get_offset(parentNode, cmenuOffParent);
            if (position == 'left') {
                // Очень важный момент - в какую сторону показывать меню (по горизонтали)
                // Задача - если есть место чтобы показать справа от объекта
                //  - показываем справа: left = off.x+p.offsetWidth
                // если места справа нет
                // - показываем слева: left = off.x-cmenuWidth
                // Наличие места вычисляем исходя из
                // - размеров блока меню (cmenuWidth)
                // - смещению (off.x) родительского элемента относительно общего offsetParent-а (cmenuOffParent)
                // - ширине экрана (winWidth)
                menu.jq.css('left',
                    cmenuOffParent.offsetLeft + off.x + parentNode.offsetWidth + cmenuWidth > winWidth ?
                    off.x - cmenuWidth : off.x + parentNode.offsetWidth);
                // Еще один очень важный момент - в какую сторону показывать меню (по вертикали)
                // Задача - если есть место чтобы показать снизу от объекта
                //  - показываем снизу: top = off.y-2
                // если места снизу нет 
                // - показываем сверху: top = off.y-cmenuHeight+p.offsetHeight+4
                // Наличие места вычисляем исходя из
                // - размеров блока меню (cmenuHeight)
                // - смещению (off.y) родительского элемента относительно общего offsetParent-а (cmenuOffParent)
                // - высоте экрана (winHeight)
                menu.jq.css('top',
                    cmenuOffParent.offsetTop + off.y + cmenuHeight > winHeight ?
                    off.y - cmenuHeight + parentNode.offsetHeight + 2 : off.y + 1);
            } else {
                menu.jq.css('left', cmenuOffParent.offsetLeft + off.x + cmenuWidth > winWidth ? off.x - cmenuWidth + parentNode.offsetWidth : off.x);
                menu.jq.css('top', cmenuOffParent.offsetTop + off.y + 1 + parentNode.offsetHeight + cmenuHeight > winHeight ? off.y - cmenuHeight - 2 : off.y + 1 + parentNode.offsetHeight);
                //menu.jq.css('top', off.y + 1 + parentNode.offsetHeight);
            }
            // Устанавливаем флаг видимости меню
            menu.v = true;
            /* }}} */

            var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
            if (translationMode)
                elma.InitTranslationContainer();
        }
    };

    $.fn.bindMenu = function (event, menu, position) {/* jQuery-plugin for menu binding {{{ */
        if (arguments.length === 1) {
            menu = event;
            event = 'mousedown';
        }
        if (!menu.jq) {
            menu = $.cmenu.get_menu(menu);
        }
        return this.each(function () {
            $(this).bind(event, function () {
                hide_all();
                $.cmenu.lockHiding = true;
                $.cmenu.show(menu, this, position);
                return false;
            })
            .bind('mouseout', function () {
                $.cmenu.lockHiding = false;
            })
            .bind('click', function () { return false; });
        });
        /* }}} */
    };

    $.fn.lockHiding = function (value) {
        $.cmenu.lockHidingForcibly = value;
        $.cmenu.lockHiding = value;
    };

    $.fn.showPopup = function (event, menu, position, paper) {
        if (arguments.length === 1) {
            menu = event;
            event = 'mousedown';
        }
        if (!menu.jq) {
            menu = $.cmenu.get_menu(menu);
        }
        return this.each(function () {
            hide_all();
            eventFlg = false;
            oldEventElement = this;
            $.cmenu.lockHiding = true;
            $.cmenu.show(menu, this, position, paper);
            $(this).bind(event, eventFunc)
                .bind('mouseout', function () {
                    $.cmenu.lockHiding = false;
                })
                .bind('click', function () { return false; });
        });
    };

    $.fn.hideAll = function() {
        hide_all();
    };

    $(document).click(function () {
        hide_all();
    });
})(jQuery, this);



(function ($) {

    $.alerts = {

        // These properties can be read/written by accessing $.alerts.propertyName from your scripts at any time

        verticalOffset: -75,                // vertical offset of the dialog from center screen, in pixels
        horizontalOffset: 0,                // horizontal offset of the dialog from center screen, in pixels/
        repositionOnResize: true,           // re-centers the dialog on window resize
        overlayOpacity: .01,                // transparency level of overlay
        overlayColor: '#FFF',               // base color of overlay
        draggable: true,                    // make the dialogs draggable (requires UI Draggables plugin)
        okButton: '&nbsp;&nbsp;&nbsp;&nbsp;' + SR.T('Да') + '&nbsp;&nbsp;&nbsp;&nbsp;',         // text for the OK button
        cancelButton: '&nbsp;&nbsp;&nbsp;&nbsp;' + SR.T('Нет') + '&nbsp;&nbsp;&nbsp;&nbsp;',    // text for the Cancel button
        alertButton: '&nbsp;' + SR.T('Закрыть') + '&nbsp;',
        dialogClass: null,                  // if specified, this class will be applied to all dialogs

        // Public methods

        alert: function (message, title, callback) {
            if (title == null) title = 'Alert';
            $.alerts._show(title, message, null, 'alert', function (result) {
                if (callback) callback(result);
            });
        },

        confirm: function (message, title, callback) {
            if (title == null) title = 'Confirm';
            $.alerts._show(title, message, null, 'confirm', function (result) {
                if (callback) callback(result);
            });
        },

        prompt: function (message, value, title, callback) {
            if (title == null) title = 'Prompt';
            $.alerts._show(title, message, value, 'prompt', function (result) {
                if (callback) callback(result);
            });
        },

        dialog: function (message, title, buttons, callback, contentClass, confirmButtonDialog) {
            if (title == null) title = 'Dialog';
            $.alerts._show(title, message, null, 'dialog', function (result) {
                if (callback) callback(result);
            }, buttons, null, contentClass, confirmButtonDialog);
        },

        // Private methods

        _show: function (title, msg, value, type, callback, buttons, body, contentClass, confirmButtonDialog) {

            $.alerts._hide();
            $.alerts._overlay('show');

            $("BODY").append(body ||
			  '<div id="popup_container">' +
    			'<div class="t-window-titlebar t-header"><span class="t-window-title" id="popup_title"></span>' +
        			'<div class="t-window-actions t-header"><a id="popup_button_close" class="t-window-action t-link" href="" onclick="return false;"><span class="t-icon t-close">Close</span></a></div>' +
                '</div>' +
			    '<div id="popup_content" class="elma-window-content">' +
			      '<div id="popup_message"></div>' +
				'</div>' +
			  '</div>');

            if ($.alerts.dialogClass) $("#popup_container").addClass($.alerts.dialogClass);

            // IE6 Fix
            var pos = ($.browser.msie && parseInt($.browser.version) <= 6) ? 'absolute' : 'fixed';

            $("#popup_container").css({
                position: pos,
                zIndex: 90000,
                padding: 0,
                margin: 0
            });

            if (contentClass) {
                $("#popup_content").addClass(contentClass);
            } else {
                $("#popup_content").addClass(type);
            }

            $("#popup_title").text(title);
            $("#popup_message").html(msg);

            switch (type) {
                case 'alert':
                    $("#popup_message").after('<div id="popup_panel" class="popup-buttons"><input type="button" class="t-button" value="' + $.alerts.alertButton + '" id="popup_ok" /></div>');
                    $("#popup_ok").click(function () {
                        $.alerts._hide();
                        callback(true);
                    });
                    $("#popup_button_close").click(function () {
                        $.alerts._hide();
                        callback(true);
                    });

                    $("#popup_ok").live('touchend', function () {
                        $.alerts._hide();
                        callback(true);
                    });
                    $("#popup_button_close").live('touchend', function () {
                        $.alerts._hide();
                        callback(true);
                    });

                    $("#popup_ok").keypress(function (e) {
                        if (e.keyCode == 13 || e.keyCode == 27) $("#popup_ok").trigger('click');
                    });
                    break;
                case 'dialog':
                    $("#popup_button_close").click(function () {
                        $.alerts._hide();
                        callback(-1);
                    });
                    var buttonHtml = '';
                    for (var i = 0; i < buttons.length; i++) {
                        var classButton = "";
                        if (confirmButtonDialog == i) {
                            classButton = " confirm";
                        }
                        buttonHtml += '<input type="button" class="t-button' + classButton + '" value="' + buttons[i] + '" id="popup_button_' + i + '" />&nbsp;';
                    }
                    $("#popup_message").after('<div id="popup_panel" class="popup-buttons" style="white-space: nowrap;">' + buttonHtml + '</div>');
                    for (var j = 0; j < buttons.length; j++) {
                        $('#popup_button_' + j).attr("buttonindex", j);
                        $('#popup_button_' + j).click(function () {
                            var ii = parseInt($(this).attr("buttonindex"));
                            $.alerts._hide();
                            if (callback) callback(ii);
                        });
                        $('#popup_button_' + j).live('touchend', function () {
                            var ii = parseInt($(this).attr("buttonindex"));
                            $.alerts._hide();
                            if (callback) callback(ii);
                        });
                    }
                    break;
                case 'confirm':
                    $("#popup_message").after('<div id="popup_panel" class="popup-buttons"><input type="button" class="t-button confirm" value="' + $.alerts.okButton + '" id="popup_ok" /> <input type="button" class="t-button" value="' + $.alerts.cancelButton + '" id="popup_cancel" /></div>');
                    $("#popup_ok").click(function () {
                        $.alerts._hide();
                        if (callback) callback(true);
                    });
                    $("#popup_cancel").click(function () {
                        $.alerts._hide();
                        if (callback) callback(false);
                    });
                    $("#popup_button_close").click(function () {
                        $.alerts._hide();
                        if (callback) callback(false);
                    });
                    
                    $("#popup_ok").live('touchend', function () {
                        $.alerts._hide();
                        if (callback) callback(true);
                    });
                    $("#popup_cancel").live('touchend', function () {
                        $.alerts._hide();
                        if (callback) callback(false);
                    });
                    $("#popup_button_close").live('touchend', function () {
                        $.alerts._hide();
                        if (callback) callback(false);
                    });
                    
                    $("#popup_ok, #popup_cancel").keypress(function (e) {
                        if (e.keyCode == 13) $("#popup_ok").trigger('click');
                        if (e.keyCode == 27) $("#popup_cancel").trigger('click');
                    });
                    break;
                case 'prompt':
                    $("#popup_message").append('<br /><input type="text" size="30" id="popup_prompt" />').after('<div id="popup_panel" class="popup-buttons"><input type="button" class="t-button" value="' + $.alerts.okButton + '" id="popup_ok" /> <input type="button" class="t-button" value="' + $.alerts.cancelButton + '" id="popup_cancel" /></div>');
                    $("#popup_prompt").width($("#popup_message").width());
                    $("#popup_ok").click(function () {
                        var val = $("#popup_prompt").val();
                        $.alerts._hide();
                        if (callback) callback(val);
                    });
                    $("#popup_cancel").click(function () {
                        $.alerts._hide();
                        if (callback) callback(null);
                    });
                    $("#popup_button_close").click(function () {
                        $.alerts._hide();
                        if (callback) callback(null);
                    });

                    $("#popup_ok").live('touchend', function () {
                        var val = $("#popup_prompt").val();
                        $.alerts._hide();
                        if (callback) callback(val);
                    });
                    $("#popup_cancel").live('touchend', function () {
                        $.alerts._hide();
                        if (callback) callback(null);
                    });
                    $("#popup_button_close").live('touchend', function () {
                        $.alerts._hide();
                        if (callback) callback(null);
                    });

                    $("#popup_prompt, #popup_ok, #popup_cancel").keypress(function (e) {
                        if (e.keyCode == 13) $("#popup_ok").trigger('click');
                        if (e.keyCode == 27) $("#popup_cancel").trigger('click');
                    });
                    if (value) $("#popup_prompt").val(value);
                    break;
            }

            $("#popup_container").css({
                minWidth: $("#popup_container").outerWidth(),
                maxWidth: $("#popup_container").outerWidth()
            });

            $.alerts._reposition();
            $.alerts._maintainPosition(true);
            bindButtons();

            if (type == 'alert' || type == 'confirm') {
                $("#popup_ok").focus();
            }
            else if (type == 'prompt') {
                $("#popup_prompt").focus().select();
            }
            else if (type == 'dialog') {
                $("#popup_content .confirm").focus().select();
            }

            // Make draggable
            if ($.alerts.draggable) {
                try {
                    $("#popup_container").draggable({ handle: $("#popup_title") });
                } catch (e) { /* requires jQuery UI draggables */ }
            }

            elma.InitTranslationContainer('popup_container');
        },

        _hide: function () {
            $("#popup_container").remove();
            $.alerts._overlay('hide');
            $.alerts._maintainPosition(false);
        },

        _overlay: function (status) {
            switch (status) {
                case 'show':
                    elma.showBlockerDiv();
                    break;
                case 'hide':
                    elma.hideBlockerDiv();
                    break;
            }
        },

        _reposition: function () {
            var top = (($(window).height() / 2) - ($("#popup_container").outerHeight() / 2)) + $.alerts.verticalOffset;
            var left = (($(window).width() / 2) - ($("#popup_container").outerWidth() / 2)) + $.alerts.horizontalOffset;
            if (top < 0) top = 0;
            if (left < 0) left = 0;

            // IE6 fix
            if ($.browser.msie && parseInt($.browser.version) <= 6) top = top + $(window).scrollTop();

            $("#popup_container").css({
                top: top + 'px',
                left: left + 'px'
            });
            $(".t-overlay").height($(document).height());
        },

        _maintainPosition: function (status) {
            if ($.alerts.repositionOnResize) {
                switch (status) {
                    case true:
                        $(window).bind('resize', $.alerts._reposition);
                        break;
                    case false:
                        $(window).unbind('resize', $.alerts._reposition);
                        break;
                }
            }
        }

    };
    // Shortuct functions
    window.jAlert = function (message, title, callback) {
        $.alerts.alert(message, title, callback);
    };
    window.jConfirm = function (message, title, callback) {
        $.alerts.confirm(message, title, callback);
    };

    window.jPrompt = function (message, value, title, callback) {
        $.alerts.prompt(message, value, title, callback);
    };

    window.jDialog = function (message, title, buttons, callback, contentClass, confirmButtonDialog) {
        $.alerts.dialog(message, title, buttons, callback, contentClass, confirmButtonDialog);
    };

})(jQuery);


/*
 * jQuery JSON Plugin
 * version: 2.1 (2009-08-14)
 *
 * This document is licensed as free software under the terms of the
 * MIT License: http://www.opensource.org/licenses/mit-license.php
 *
 * Brantley Harris wrote this plugin. It is based somewhat on the JSON.org 
 * website's http://www.json.org/json2.js, which proclaims:
 * "NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.", a sentiment that
 * I uphold.
 *
 * It is also influenced heavily by MochiKit's serializeJSON, which is 
 * copyrighted 2005 by Bob Ippolito.
 */
 
(function($) {
    /** jQuery.toJSON( json-serializble )
        Converts the given argument into a JSON respresentation.

        If an object has a "toJSON" function, that will be used to get the representation.
        Non-integer/string keys are skipped in the object, as are keys that point to a function.

        json-serializble:
            The *thing* to be converted.
     **/
    $.toJSON = function(o)
    {
        if (typeof(JSON) == 'object' && JSON.stringify)
            return JSON.stringify(o);
        
        var type = typeof(o);
    
        if (o === null)
            return "null";
    
        if (type == "undefined")
            return undefined;
        
        if (type == "number" || type == "boolean")
            return o + "";
    
        if (type == "string")
            return $.quoteString(o);
    
        if (type == 'object')
        {
            if (typeof o.toJSON == "function") 
                return $.toJSON( o.toJSON() );
            
            if (o.constructor === Date)
            {
                var month = o.getUTCMonth() + 1;
                if (month < 10) month = '0' + month;

                var day = o.getUTCDate();
                if (day < 10) day = '0' + day;

                var year = o.getUTCFullYear();
                
                var hours = o.getUTCHours();
                if (hours < 10) hours = '0' + hours;
                
                var minutes = o.getUTCMinutes();
                if (minutes < 10) minutes = '0' + minutes;
                
                var seconds = o.getUTCSeconds();
                if (seconds < 10) seconds = '0' + seconds;
                
                var milli = o.getUTCMilliseconds();
                if (milli < 100) milli = '0' + milli;
                if (milli < 10) milli = '0' + milli;

                return '"' + year + '-' + month + '-' + day + 'T' +
                             hours + ':' + minutes + ':' + seconds + 
                             '.' + milli + 'Z"'; 
            }

            if (o.constructor === Array) 
            {
                var ret = [];
                for (var i = 0; i < o.length; i++)
                    ret.push( $.toJSON(o[i]) || "null" );

                return "[" + ret.join(",") + "]";
            }
        
            var pairs = [];
            for (var k in o) {
                var name;
                var type = typeof k;

                if (type == "number")
                    name = '"' + k + '"';
                else if (type == "string")
                    name = $.quoteString(k);
                else
                    continue;  //skip non-string or number keys
            
                if (typeof o[k] == "function") 
                    continue;  //skip pairs where the value is a function.
            
                var val = $.toJSON(o[k]);
            
                pairs.push(name + ":" + val);
            }

            return "{" + pairs.join(", ") + "}";
        }
    };

    /** jQuery.evalJSON(src)
        Evaluates a given piece of json source.
     **/
    $.evalJSON = function(src)
    {
        if (typeof(JSON) == 'object' && JSON.parse)
            return JSON.parse(src);
        return eval("(" + src + ")");
    };
    
    /** jQuery.secureEvalJSON(src)
        Evals JSON in a way that is *more* secure.
    **/
    $.secureEvalJSON = function(src)
    {
        if (typeof(JSON) == 'object' && JSON.parse)
            return JSON.parse(src);
        
        var filtered = src;
        filtered = filtered.replace(/\\["\\\/bfnrtu]/g, '@');
        filtered = filtered.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
        filtered = filtered.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
        
        if (/^[\],:{}\s]*$/.test(filtered))
            return eval("(" + src + ")");
        else
            throw new SyntaxError("Error parsing JSON, source is not valid.");
    };

    /** jQuery.quoteString(string)
        Returns a string-repr of a string, escaping quotes intelligently.  
        Mostly a support function for toJSON.
    
        Examples:
            >>> jQuery.quoteString("apple")
            "apple"
        
            >>> jQuery.quoteString('"Where are we going?", she asked.')
            "\"Where are we going?\", she asked."
     **/
    $.quoteString = function(string)
    {
        if (string.match(_escapeable))
        {
            return '"' + string.replace(_escapeable, function (a) 
            {
                var c = _meta[a];
                if (typeof c === 'string') return c;
                c = a.charCodeAt();
                return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
            }) + '"';
        }
        return '"' + string + '"';
    };
    
    var _escapeable = /["\\\x00-\x1f\x7f-\x9f]/g;
    
    var _meta = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    };
})(jQuery);



/*
* qTip2 - Pretty powerful tooltips
* http://craigsworks.com/projects/qtip2/
*
* Version: nightly
* Copyright 2009-2010 Craig Michael Thompson - http://craigsworks.com
*
* Dual licensed under MIT or GPLv2 licenses
*   http://en.wikipedia.org/wiki/MIT_License
*   http://en.wikipedia.org/wiki/GNU_General_Public_License
*
* Date: Mon Aug  1 10:57:03 PDT 2011
*/

/*jslint browser: true, onevar: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true, immed: true, strict: true */
/*global window: false, jQuery: false, console: false */


(function($, window, undefined) {

	"use strict"; // Enable ECMAScript "strict" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/
	
	// Munge the primitives - Paul Irish tip
	var TRUE = true,
		FALSE = false,
		NULL = null,
		
		// Shortcut vars
		QTIP, PLUGINS, MOUSE,
		usedIDs = {},
		uitooltip = 'ui-tooltip',
		widget = 'ui-widget',
		disabled = 'ui-state-disabled',
		selector = 'div.qtip.'+uitooltip,
		defaultClass = uitooltip + '-default',
		focusClass = uitooltip + '-focus',
		hoverClass = uitooltip + '-hover',
		fluidClass = uitooltip + '-fluid',
		hideOffset = '-31000px',
		replaceSuffix = '_replacedByqTip',
		oldtitle = 'oldtitle',
		trackingBound;
		
	/* Thanks to Paul Irish for this one: http://paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/ */
	function log() {
		log.history = log.history || [];
		log.history.push(arguments);
		
		// Make sure console is present
		if('object' === typeof console) {

			// Setup console and arguments
			var c = console[ console.warn ? 'warn' : 'log' ],
			args = Array.prototype.slice.call(arguments), a;

			// Add qTip2 marker to first argument if it's a string
			if(typeof arguments[0] === 'string') { args[0] = 'qTip2: ' + args[0]; }

			// Apply console.warn or .log if not supported
			a = c.apply ? c.apply(console, args) : c(args);
		}
	}

// Option object sanitizer
function sanitizeOptions(opts)
{
	var content;

	if(!opts || 'object' !== typeof opts) { return FALSE; }

	if('object' !== typeof opts.metadata) {
		opts.metadata = {
			type: opts.metadata
		};
	}

	if('content' in opts) {
		if('object' !== typeof opts.content || opts.content.jquery) {
			opts.content = {
				text: opts.content
			};
		}

		content = opts.content.text || FALSE;
		if(!$.isFunction(content) && ((!content && !content.attr) || content.length < 1 || ('object' === typeof content && !content.jquery))) {
			opts.content.text = FALSE;
		}

		if('title' in opts.content) {
			if('object' !== typeof opts.content.title) {
				opts.content.title = {
					text: opts.content.title
				};
			}

			content = opts.content.title.text || FALSE;
			if(!$.isFunction(content) && ((!content && !content.attr) || content.length < 1 || ('object' === typeof content && !content.jquery))) {
				opts.content.title.text = FALSE;
			}
		}
	}

	if('position' in opts) {
		if('object' !== typeof opts.position) {
			opts.position = {
				my: opts.position,
				at: opts.position
			};
		}
	}

	if('show' in opts) {
		if('object' !== typeof opts.show) {
			if(opts.show.jquery) {
				opts.show = { target: opts.show };
			}
			else {
				opts.show = { event: opts.show };
			}
		}
	}

	if('hide' in opts) {
		if('object' !== typeof opts.hide) {
			if(opts.hide.jquery) {
				opts.hide = { target: opts.hide };
			}
			else {
				opts.hide = { event: opts.hide };
			}
		}
	}

	if('style' in opts) {
		if('object' !== typeof opts.style) {
			opts.style = {
				classes: opts.style
			};
		}
	}

	// Sanitize plugin options
	$.each(PLUGINS, function() {
		if(this.sanitize) { this.sanitize(opts); }
	});
	
	return opts;
}

/*
* Core plugin implementation
*/
function QTip(target, options, id, attr)
{
	// Declare this reference
	var self = this,
		docBody = document.body,
		tooltipID = uitooltip + '-' + id,
		isPositioning = 0,
		isDrawing = 0,
		tooltip = $(),
		namespace = '.qtip-' + id,
		elements, cache;

	// Setup class attributes
	self.id = id;
	self.rendered = FALSE;
	self.elements = elements = { target: target };
	self.timers = { img: {} };
	self.options = options;
	self.checks = {};
	self.plugins = {};
	self.cache = cache = {
		event: {},
		target: $(),
		disabled: FALSE,
		attr: attr
	};

	/*
	* Private core functions
	*/
	function convertNotation(notation)
	{
		var i = 0, obj, option = options, 

		// Split notation into array
		levels = notation.split('.');

		// Loop through
		while( option = option[ levels[i++] ] ) {
			if(i < levels.length) { obj = option; }
		}

		return [obj || options, levels.pop()];
	}

	function setWidget() {
		var on = options.style.widget;

		tooltip.toggleClass(widget, on).toggleClass(defaultClass, !on);
		elements.content.toggleClass(widget+'-content', on);
		
		if(elements.titlebar){
			elements.titlebar.toggleClass(widget+'-header', on);
		}
		if(elements.button){
			elements.button.toggleClass(uitooltip+'-icon', !on);
		}
	}

	function removeTitle(reposition)
	{
		if(elements.title) {
			elements.titlebar.remove();
			elements.titlebar = elements.title = elements.button = NULL;

			// Reposition if enabled
			if(reposition !== FALSE) { self.reposition(); }
		}
	}

	function createButton()
	{
		var button = options.content.title.button,
			isString = typeof button === 'string',
			close = isString ? button : 'Close tooltip';

		if(elements.button) { elements.button.remove(); }

		// Use custom button if one was supplied by user, else use default
		if(button.jquery) {
			elements.button = button;
		}
		else {
			elements.button = $('<a />', {
				'class': 'ui-state-default ' + (options.style.widget ? '' : uitooltip+'-icon'),
				'title': close,
				'aria-label': close
			})
			.prepend(
				$('<span />', {
					'class': 'ui-icon ui-icon-close',
					'html': '&times;'
				})
			);
		}

		// Create button and setup attributes
		elements.button.appendTo(elements.titlebar)
			.attr('role', 'button')
			.hover(function(event){ $(this).toggleClass('ui-state-hover', event.type === 'mouseenter'); })
			.click(function(event) {
				if(!tooltip.hasClass(disabled)) { self.hide(event); }
				return FALSE;
			})
			.bind('mousedown keydown mouseup keyup mouseout', function(event) {
				$(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');
			});

		// Redraw the tooltip when we're done
		self.redraw();
	}

	function createTitle()
	{
		var id = tooltipID+'-title';

		// Destroy previous title element, if present
		if(elements.titlebar) { removeTitle(); }

		// Create title bar and title elements
		elements.titlebar = $('<div />', {
			'class': uitooltip + '-titlebar ' + (options.style.widget ? 'ui-widget-header' : '')
		})
		.append(
			elements.title = $('<div />', {
				'id': id,
				'class': uitooltip + '-title',
				'aria-atomic': TRUE
			})
		)
		.insertBefore(elements.content);

		// Create button if enabled
		if(options.content.title.button) { createButton(); }

		// Redraw the tooltip dimensions if it's rendered
		else if(self.rendered){ self.redraw(); } 
	}

	function updateButton(button)
	{
		var elem = elements.button,
			title = elements.title;

		// Make sure tooltip is rendered and if not, return
		if(!self.rendered) { return FALSE; }

		if(!button) {
			elem.remove();
		}
		else {
			if(!title) {
				createTitle();
			}
			createButton();
		}
	}

	function updateTitle(content, reposition)
	{
		var elem = elements.title;

		// Make sure tooltip is rendered and if not, return
		if(!self.rendered || !content) { return FALSE; }

		// Use function to parse content
		if($.isFunction(content)) {
			content = content.call(target, cache.event, self);
		}

		// Remove title if callback returns false
		if(content === FALSE) { return removeTitle(FALSE); }

		// Append new content if its a DOM array and show it if hidden
		else if(content.jquery && content.length > 0) {
			elem.empty().append(content.css({ display: 'block' }));
		}

		// Content is a regular string, insert the new content
		else { elem.html(content); }

		// Redraw and reposition
		self.redraw();
		if(reposition !== FALSE && self.rendered && tooltip.is(':visible')) {
			self.reposition(cache.event);
		}
	}

	function updateContent(content, reposition)
	{
		var elem = elements.content;

		// Make sure tooltip is rendered and content is defined. If not return
		if(!self.rendered || !content) { return FALSE; }

		// Use function to parse content
		if($.isFunction(content)) {
			content = content.call(target, cache.event, self) || '';
		}

		// Append new content if its a DOM array and show it if hidden
		if(content.jquery && content.length > 0) {
			elem.empty().append(content.css({ display: 'block' }));
		}

		// Content is a regular string, insert the new content
		else { elem.html(content); }

		// Image detection
		function detectImages(next) {
			var images, srcs = {};

			function imageLoad(image) {
				// Clear src from object and any timers and events associated with the image
				if(image) {
					delete srcs[image.src];
					clearTimeout(self.timers.img[image.src]);
					$(image).unbind(namespace);
				}

				// If queue is empty after image removal, update tooltip and continue the queue
				if($.isEmptyObject(srcs)) {
					self.redraw();
					if(reposition !== FALSE) {
						self.reposition(cache.event);
					}
					
					next();
				}
			}

			// Find all content images without dimensions, and if no images were found, continue
			if((images = elem.find('img:not([height]):not([width])')).length === 0) { return imageLoad(); }

			// Apply timer to each image to poll for dimensions
			images.each(function(i, elem) {
				// Skip if the src is already present
				if(srcs[elem.src] !== undefined) { return; }

				(function timer(){
					// When the dimensions are found, remove the image from the queue
					if(elem.height || elem.width) { return imageLoad(elem); }

					// Restart timer
					self.timers.img[elem.src] = setTimeout(timer, 700);
				}());

				// Also apply regular load/error event handlers
				$(elem).bind('error'+namespace+' load'+namespace, function(){ imageLoad(this); });

				// Store the src and element in our object
				srcs[elem.src] = elem;
			});
		}

		/*
		 * If we're still rendering... insert into 'fx' queue our image dimension
		 * checker which will halt the showing of the tooltip until image dimensions
		 * can be detected properly.
		 */
		if(self.rendered < 0) { tooltip.queue('fx', detectImages); }

		// We're fully rendered, so reset isDrawing flag and proceed without queue delay
		else { isDrawing = 0; detectImages($.noop); }

		return self;
	}

	function assignEvents()
	{
		var posOptions = options.position,
			targets = {
				show: options.show.target,
				hide: options.hide.target,
				viewport: $(posOptions.viewport),
				document: $(document),
				window: $(window)
			},
			events = {
				show: $.trim('' + options.show.event).split(' '),
				hide: $.trim('' + options.hide.event).split(' ')
			},
			IE6 = $.browser.msie && parseInt($.browser.version, 10) === 6;

		// Define show event method
		function showMethod(event)
		{
			if(tooltip.hasClass(disabled)) { return FALSE; }

			// If set, hide tooltip when inactive for delay period
			targets.show.trigger('qtip-'+id+'-inactive');

			// Clear hide timers
			clearTimeout(self.timers.show);
			clearTimeout(self.timers.hide);

			// Start show timer
			var callback = function(){ self.toggle(TRUE, event); };
			if(options.show.delay > 0) {
				self.timers.show = setTimeout(callback, options.show.delay);
			}
			else{ callback(); }
		}

		// Define hide method
		function hideMethod(event)
		{
			if(tooltip.hasClass(disabled) || isPositioning || isDrawing) { return FALSE; }

			// Check if new target was actually the tooltip element
			var relatedTarget = $(event.relatedTarget || event.target),
				ontoTooltip = relatedTarget.closest(selector)[0] === tooltip[0],
				ontoTarget = relatedTarget[0] === targets.show[0];

			// Clear timers and stop animation queue
			clearTimeout(self.timers.show);
			clearTimeout(self.timers.hide);

			// Prevent hiding if tooltip is fixed and event target is the tooltip. Or if mouse positioning is enabled and cursor momentarily overlaps
			if((posOptions.target === 'mouse' && ontoTooltip) || (options.hide.fixed && ((/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget)))) {
				event.preventDefault(); event.stopImmediatePropagation(); return;
			}

			// If tooltip has displayed, start hide timer
			if(options.hide.delay > 0) {
				self.timers.hide = setTimeout(function(){ self.hide(event); }, options.hide.delay);
			}
			else{ self.hide(event); }
		}

		// Define inactive method
		function inactiveMethod(event)
		{
			if(tooltip.hasClass(disabled)) { return FALSE; }

			// Clear timer
			clearTimeout(self.timers.inactive);
			self.timers.inactive = setTimeout(function(){ self.hide(event); }, options.hide.inactive);
		}

		function repositionMethod(event) {
			if(tooltip.is(':visible')) { self.reposition(event); }
		}

		// On mouseenter/mouseleave...
		tooltip.bind('mouseenter'+namespace+' mouseleave'+namespace, function(event) {
			var state = event.type === 'mouseenter';

			// Focus the tooltip on mouseenter (z-index stacking)
			if(state) { self.focus(event); }

			// Add hover class
			tooltip.toggleClass(hoverClass, state);
		});

		// Enable hide.fixed
		if(options.hide.fixed) {
			// Add tooltip as a hide target
			targets.hide = targets.hide.add(tooltip);

			// Clear hide timer on tooltip hover to prevent it from closing
			tooltip.bind('mouseover'+namespace, function() {
				if(!tooltip.hasClass(disabled)) { clearTimeout(self.timers.hide); }
			});
		}

		// If using mouseout/mouseleave as a hide event...
		if(/mouse(out|leave)/i.test(options.hide.event)) {
			// Hide tooltips when leaving current window/frame (but not select/option elements)
			if(options.hide.leave === 'window') {
				targets.window.bind('mouseout' + namespace, function(event) {
					if(/select|option/.test(event.target) && !event.relatedTarget) { self.hide(event); }
				});
			}
		}

		/*
		 * Make sure hoverIntent functions properly by using mouseleave to clear show timer if
		 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
		 */
		else if(/mouse(over|enter)/i.test(options.show.event)) {
			targets.hide.bind('mouseleave'+namespace, function(event) {
				clearTimeout(self.timers.show);
			});
		}

		// Hide tooltip on document mousedown if unfocus events are enabled
		if(('' + options.hide.event).indexOf('unfocus') > -1) {
			targets.document.bind('mousedown'+namespace, function(event) {
				var $target = $(event.target),
					enabled = !tooltip.hasClass(disabled) && tooltip.is(':visible');

				if($target[0] !== tooltip[0] && $target.parents(selector).length === 0 && $target.add(target).length > 1) {
					self.hide(event);
				}
			});
		}

		// Check if the tooltip hides when inactive
		if('number' === typeof options.hide.inactive) {
			// Bind inactive method to target as a custom event
			targets.show.bind('qtip-'+id+'-inactive', inactiveMethod);
			
			// Define events which reset the 'inactive' event handler
			$.each(QTIP.inactiveEvents, function(index, type){
				targets.hide.add(elements.tooltip).bind(type+namespace+'-inactive', inactiveMethod);
			});
		}

		// Apply hide events
		$.each(events.hide, function(index, type) {
			var showIndex = $.inArray(type, events.show),
					targetHide = $(targets.hide);

			// Both events and targets are identical, apply events using a toggle
			if((showIndex > -1 && targetHide.add(targets.show).length === targetHide.length) || type === 'unfocus')
			{
				targets.show.bind(type+namespace, function(event) {
					if(tooltip.is(':visible')) { hideMethod(event); }
					else { showMethod(event); }
				});

				// Don't bind the event again
				delete events.show[ showIndex ];
			}

			// Events are not identical, bind normally
			else { targets.hide.bind(type+namespace, hideMethod); }
		});

		// Apply show events
		$.each(events.show, function(index, type) {
			targets.show.bind(type+namespace, showMethod);
		});

		// Check if the tooltip hides when mouse is moved a certain distance
		if('number' === typeof options.hide.distance) {
			// Bind mousemove to target to detect distance difference
			targets.show.add(tooltip).bind('mousemove'+namespace, function(event) {
				var origin = cache.origin || {},
					limit = options.hide.distance,
					abs = Math.abs;

				// Check if the movement has gone beyond the limit, and hide it if so
				if(abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {
					self.hide(event);
				}
			});
		}

		// Mouse positioning events
		if(posOptions.target === 'mouse') {
			// Cache mousemove coords on show targets
			targets.show.bind('mousemove'+namespace, function(event) {
				MOUSE = { pageX: event.pageX, pageY: event.pageY, type: 'mousemove' };
			});

			// If mouse adjustment is on...
			if(posOptions.adjust.mouse) {
				// Apply a mouseleave event so we don't get problems with overlapping
				if(options.hide.event) {
					tooltip.bind('mouseleave'+namespace, function(event) {
						if((event.relatedTarget || event.target) !== targets.show[0]) { self.hide(event); }
					});
				}

				// Update tooltip position on mousemove
				targets.document.bind('mousemove'+namespace, function(event) {
					// Update the tooltip position only if the tooltip is visible and adjustment is enabled
					if(!tooltip.hasClass(disabled) && tooltip.is(':visible')) {
						self.reposition(event || MOUSE);
					}
				});
			}
		}

		// Adjust positions of the tooltip on window resize if enabled
		if(posOptions.adjust.resize || targets.viewport.length) {
			($.event.special.resize ? targets.viewport : targets.window).bind('resize'+namespace, repositionMethod);
		}

		// Adjust tooltip position on scroll if screen adjustment is enabled
		if(targets.viewport.length || (IE6 && tooltip.css('position') === 'fixed')) {
			targets.viewport.bind('scroll'+namespace, repositionMethod);
		}
	}

	function unassignEvents()
	{
		var targets = [
				options.show.target[0],
				options.hide.target[0],
				self.rendered && elements.tooltip[0],
				options.position.container[0],
				options.position.viewport[0],
				window,
				document
			];

		// Check if tooltip is rendered
		if(self.rendered) {
			$([]).pushStack( $.grep(targets, function(i){ return typeof i === 'object'; }) ).unbind(namespace);
		}

		// Tooltip isn't yet rendered, remove render event
		else { options.show.target.unbind(namespace+'-create'); }
	}

	// Setup builtin .set() option checks
	self.checks.builtin = {
		// Core checks
		'^id$': function(obj, o, v) {
			var id = v === TRUE ? QTIP.nextid : v,
				tooltipID = uitooltip + '-' + id;

			if(id !== FALSE && id.length > 0 && !$('#'+tooltipID).length) {
				tooltip[0].id = tooltipID;
				elements.content[0].id = tooltipID + '-content';
				elements.title[0].id = tooltipID + '-title';
			}
		},

		// Content checks
		'^content.text$': function(obj, o, v){ updateContent(v); },
		'^content.title.text$': function(obj, o, v) {
			// Remove title if content is null
			if(!v) { return removeTitle(); }

			// If title isn't already created, create it now and update
			if(!elements.title && v) { createTitle(); }
			updateTitle(v);
		},
		'^content.title.button$': function(obj, o, v){ updateButton(v); },

		// Position checks
		'^position.(my|at)$': function(obj, o, v){
			// Parse new corner value into Corner objecct
			if('string' === typeof v) {
				obj[o] = new PLUGINS.Corner(v);
			}
		},
		'^position.container$': function(obj, o, v){
			if(self.rendered) { tooltip.appendTo(v); }
		},

		// Show checks
		'^show.ready$': function() {
			if(!self.rendered) { self.render(1); }
			else { self.toggle(TRUE); }
		},

		// Style checks
		'^style.classes$': function(obj, o, v) { 
			tooltip.attr('class', uitooltip + ' qtip ui-helper-reset ' + v);
		},
		'^style.widget|content.title': setWidget,

		// Events check
		'^events.(render|show|move|hide|focus|blur)$': function(obj, o, v) {
			tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip'+o, v);
		},

		// Properties which require event reassignment
		'^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function() {
			var posOptions = options.position;

			// Set tracking flag
			tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);

			// Reassign events
			unassignEvents(); assignEvents();
		}
	};

	/*
	* Public API methods
	*/
	$.extend(self, {
		render: function(show)
		{
			if(self.rendered) { return self; } // If tooltip has already been rendered, exit

			var title = options.content.title.text,
				posOptions = options.position,
				callback = $.Event('tooltiprender');

			// Add ARIA attributes to target
			$.attr(target[0], 'aria-describedby', tooltipID);

			// Create tooltip element
			tooltip = elements.tooltip = $('<div/>', {
					'id': tooltipID,
					'class': uitooltip + ' qtip ui-helper-reset ' + defaultClass + ' ' + options.style.classes,
					'width': options.style.width || '',
					'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,

					/* ARIA specific attributes */
					'role': 'alert',
					'aria-live': 'polite',
					'aria-atomic': FALSE,
					'aria-describedby': tooltipID + '-content',
					'aria-hidden': TRUE
				})
				.toggleClass(disabled, cache.disabled)
				.data('qtip', self)
				.appendTo(options.position.container)
				.append(
					// Create content element
					elements.content = $('<div />', {
						'class': uitooltip + '-content',
						'id': tooltipID + '-content',
						'aria-atomic': TRUE
					})
				);

			// Set rendered flag and prevent redundant redraw/reposition calls for now
			self.rendered = -1;
			isDrawing = 1; isPositioning = 1;

			// Update title
			if(title) { 
				createTitle();
				updateTitle(title, FALSE);
			}

			// Set proper rendered flag and update content
			updateContent(options.content.text, FALSE);
			self.rendered = TRUE;

			// Setup widget classes
			setWidget();

			// Assign passed event callbacks (before plugins!)
			$.each(options.events, function(name, callback) {
				if($.isFunction(callback)) {
					tooltip.bind(name === 'toggle' ? 'tooltipshow tooltiphide' : 'tooltip'+name, callback);
				}
			});

			// Initialize 'render' plugins
			$.each(PLUGINS, function() {
				if(this.initialize === 'render') { this(self); }
			});

			// Assign events
			assignEvents();

			/* Queue this part of the render process in our fx queue so we can
			 * load images before the tooltip renders fully.
			 *
			 * See: updateContent method
			*/
			tooltip.queue('fx', function(next) {
				// Trigger tooltiprender event and pass original triggering event as original
				callback.originalEvent = cache.event;
				tooltip.trigger(callback, [self]);

				// Reset flags
				isDrawing = 0; isPositioning = 0;

				// Redraw the tooltip manually now we're fully rendered
				self.redraw();

				var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
				if (translationMode) {
				    elma.ProcessTranslationHtmlElement(tooltip);
				}

				// Show tooltip if needed
				if(options.show.ready || show) {
					self.toggle(TRUE, cache.event);
				}

				next(); // Move on to next method in queue
			});

			return self;
		},

		get: function(notation)
		{
			var result, o;

			switch(notation.toLowerCase())
			{
				case 'dimensions':
					result = {
						height: tooltip.outerHeight(), width: tooltip.outerWidth()
					};
				break;

				case 'offset':
					result = PLUGINS.offset(tooltip, options.position.container);
				break;

				default:
					o = convertNotation(notation.toLowerCase());
					result = o[0][ o[1] ];
					result = result.precedance ? result.string() : result;
				break;
			}

			return result;
		},

		set: function(option, value)
		{
			var rmove = /^position\.(my|at|adjust|target|container)|style|content|show\.ready/i,
				rdraw = /^content\.(title|attr)|style/i,
				reposition = FALSE,
				redraw = FALSE,
				checks = self.checks,
				name;

			function callback(notation, args) {
				var category, rule, match;

				for(category in checks) {
					for(rule in checks[category]) {
						if(match = (new RegExp(rule, 'i')).exec(notation)) {
							args.push(match);
							checks[category][rule].apply(self, args);
						}
					}
				}
			}

			// Convert singular option/value pair into object form
			if('string' === typeof option) {
				name = option; option = {}; option[name] = value;
			}
			else { option = $.extend(TRUE, {}, option); }

			// Set all of the defined options to their new values
			$.each(option, function(notation, value) {
				var obj = convertNotation( notation.toLowerCase() ), previous;

				// Set new obj value
				previous = obj[0][ obj[1] ];
				obj[0][ obj[1] ] = 'object' === typeof value && value.nodeType ? $(value) : value;

				// Set the new params for the callback
				option[notation] = [obj[0], obj[1], value, previous];

				// Also check if we need to reposition / redraw
				reposition = rmove.test(notation) || reposition;
				redraw = rdraw.test(notation) || redraw;
			});

			// Re-sanitize options
			sanitizeOptions(options);

			/*
			 * Execute any valid callbacks for the set options
			 * Also set isPositioning/isDrawing so we don't get loads of redundant repositioning
			 * and redraw calls.
			 */
			isPositioning = isDrawing = 1; $.each(option, callback); isPositioning = isDrawing = 0;

			// Update position / redraw if needed
			if(tooltip.is(':visible') && self.rendered) {
				if(reposition) {
					self.reposition( options.position.target === 'mouse' ? NULL : cache.event );
				}
				if(redraw) { self.redraw(); }
			}

			return self;
		},

		toggle: function(state, event)
		{
			// Make sure tooltip is rendered
			if(!self.rendered) {
				if(state) { self.render(1); } // Render the tooltip if showing and it isn't already
				else { return self; }
			}

			var type = state ? 'show' : 'hide',
				opts = options[type],
				visible = tooltip.is(':visible'),
				sameTarget = !event || options[type].target.length < 2 || cache.target[0] === event.target,
				posOptions = options.position,
				contentOptions = options.content,
				delay,
				callback;

			// Detect state if valid one isn't provided
			if((typeof state).search('boolean|number')) { state = !visible; }

			// Return if element is already in correct state
			if(!tooltip.is(':animated') && visible === state && sameTarget) { return self; }

			// Try to prevent flickering when tooltip overlaps show element
			if(event) {
				if((/over|enter/).test(event.type) && (/out|leave/).test(cache.event.type) &&
					event.target === options.show.target[0] && tooltip.has(event.relatedTarget).length) {
					return self;
				}

				// Cache event
				cache.event = $.extend({}, event);
			}

			// Call API methods
			callback = $.Event('tooltip'+type);
			callback.originalEvent = event ? cache.event : NULL;
			tooltip.trigger(callback, [self, 90]);
			if(callback.isDefaultPrevented()){ return self; }

			// Set ARIA hidden status attribute
			$.attr(tooltip[0], 'aria-hidden', !!!state);

			// Execute state specific properties
			if(state) {
				// Store show origin coordinates
				cache.origin = $.extend({}, MOUSE);

				// Focus the tooltip
				self.focus(event);

				// Update tooltip content & title if it's a dynamic function
				if($.isFunction(contentOptions.text)) { updateContent(contentOptions.text, FALSE); }
				if($.isFunction(contentOptions.title.text)) { updateTitle(contentOptions.title.text, FALSE); }

				// Cache mousemove events for positioning purposes (if not already tracking)
				if(!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {
					$(document).bind('mousemove.qtip', function(event) {
						MOUSE = { pageX: event.pageX, pageY: event.pageY, type: 'mousemove' };
					});
					trackingBound = TRUE;
				}

				// Update the tooltip position
				self.reposition(event);

				// Hide other tooltips if tooltip is solo, using it as the context
				if(opts.solo) { $(selector, opts.solo).not(tooltip).qtip('hide', callback); }
			}
			else {
				// Clear show timer if we're hiding 
				clearTimeout(self.timers.show);

				// Remove cached origin on hide
				delete cache.origin;

				// Remove mouse tracking event if not needed (all tracking qTips are hidden)
				if(trackingBound && !$(selector+'[tracking="true"]:visible', opts.solo).not(tooltip).length) {
					$(document).unbind('mousemove.qtip');
					trackingBound = FALSE;
				}
				
				// Blur the tooltip
				self.blur(event);
			}

			// Define post-animation state specific properties
			function after() {
				if(!state) {
					// Reset CSS states
					tooltip.css({
						display: '',
						visibility: '',
						opacity: '',
						left: '',
						top: ''
					});

					// Autofocus elements if enabled
					if('string' === typeof opts.autofocus) {
						$(opts.autofocus, tooltip).focus();
					}
				}
				else {
					// Prevent antialias from disappearing in IE by removing filter
					if($.browser.msie) { tooltip[0].style.removeAttribute('filter'); }

					// Remove overflow setting to prevent tip bugs
					tooltip.css('overflow', '');
				}
			}

			// Clear animation queue if same target
			if(sameTarget) { tooltip.stop(0, 1); }

			// If no effect type is supplied, use a simple toggle
			if(opts.effect === FALSE) {
				tooltip[ type ]();
				after.call(tooltip);
			}

			// Use custom function if provided
			else if($.isFunction(opts.effect)) {
				opts.effect.call(tooltip, self);
				tooltip.queue('fx', function(n){ after(); n(); });
			}

			// Use basic fade function by default
			else { tooltip.fadeTo(90, state ? 1 : 0, after); }

			// If inactive hide method is set, active it
			if(state) { opts.target.trigger('qtip-'+id+'-inactive'); }

			return self;
		},

		show: function(event){ return self.toggle(TRUE, event); },

		hide: function(event){ return self.toggle(FALSE, event); },

		focus: function(event)
		{
			if(!self.rendered) { return self; }

			var qtips = $(selector),
				curIndex = parseInt(tooltip[0].style.zIndex, 10),
				newIndex = QTIP.zindex + qtips.length,
				cachedEvent = $.extend({}, event),
				focusedElem, callback;

			// Only update the z-index if it has changed and tooltip is not already focused
			if(!tooltip.hasClass(focusClass))
			{
				// Call API method
				callback = $.Event('tooltipfocus');
				callback.originalEvent = cachedEvent;
				tooltip.trigger(callback, [self, newIndex]);

				// If default action wasn't prevented...
				if(!callback.isDefaultPrevented()) {
					// Only update z-index's if they've changed
					if(curIndex !== newIndex) {
						// Reduce our z-index's and keep them properly ordered
						qtips.each(function() {
							if(this.style.zIndex > curIndex) {
								this.style.zIndex = this.style.zIndex - 1;
							}
						});
						
						// Fire blur event for focused tooltip
						qtips.filter('.' + focusClass).qtip('blur', cachedEvent);
					}

					// Set the new z-index
					tooltip.addClass(focusClass)[0].style.zIndex = newIndex;
				}
			}

			return self;
		},

		blur: function(event) {
			var cachedEvent = $.extend({}, event),
				callback;

			// Set focused status to FALSE
			tooltip.removeClass(focusClass);

			// Trigger blur event
			callback = $.Event('tooltipblur');
			callback.originalEvent = cachedEvent;
			tooltip.trigger(callback, [self]);

			return self;
		},

		reposition: function(event, effect)
		{
			if(!self.rendered || isPositioning) { return self; }

			// Set positioning flag
			isPositioning = 1;
	
			var target = options.position.target,
				posOptions = options.position,
				my = posOptions.my, 
				at = posOptions.at,
				adjust = posOptions.adjust,
				method = adjust.method.split(' '),
				elemWidth = tooltip.outerWidth(),
				elemHeight = tooltip.outerHeight(),
				targetWidth = 0,
				targetHeight = 0,
				callback = $.Event('tooltipmove'),
				fixed = tooltip.css('position') === 'fixed',
				viewport = posOptions.viewport,
				position = { left: 0, top: 0 },
				tip = self.plugins.tip,
				readjust = {
					// Repositioning method and axis detection
					horizontal: method[0],
					vertical: method[1] || method[0],

					// Reposition methods
					left: function(posLeft) {
						var isShift = readjust.horizontal === 'shift',
							viewportScroll = viewport.offset.left + viewport.scrollLeft,
							myWidth = my.x === 'left' ? elemWidth : my.x === 'right' ? -elemWidth : -elemWidth / 2,
							atWidth = at.x === 'left' ? targetWidth : at.x === 'right' ? -targetWidth : -targetWidth / 2,
							tipWidth = tip && tip.size ? tip.size.width || 0 : 0,
							tipAdjust = tip && tip.corner && tip.corner.precedance === 'x' && !isShift ? tipWidth : 0,
							overflowLeft = viewportScroll - posLeft + tipAdjust,
							overflowRight = posLeft + elemWidth - viewport.width - viewportScroll + tipAdjust,
							offset = myWidth - (my.precedance === 'x' || my.x === my.y ? atWidth : 0),
							isCenter = my.x === 'center';

						// Optional 'shift' style repositioning
						if(isShift) {
							tipAdjust = tip && tip.corner && tip.corner.precedance === 'y' ? tipWidth : 0;
							offset = (my.x === 'left' ? 1 : -1) * myWidth - tipAdjust;

							// Adjust position but keep it within viewport dimensions
							position.left += overflowLeft > 0 ? overflowLeft : overflowRight > 0 ? -overflowRight : 0;
							position.left = Math.max(
								viewport.offset.left + (tipAdjust && tip.corner.x === 'center' ? tip.offset : 0),
								posLeft - offset,
								Math.min(
									Math.max(viewport.offset.left + viewport.width, posLeft + offset),
									position.left
								)
							);
						}

						// Default 'flip' repositioning
						else {
							if(overflowLeft > 0 && (my.x !== 'left' || overflowRight > 0)) {
								position.left -= offset + (isCenter ? 0 : 2 * adjust.x);
							}
							else if(overflowRight > 0 && (my.x !== 'right' || overflowLeft > 0)  ) {
								position.left -= isCenter ? -offset : offset + (2 * adjust.x);
							}
							if(position.left !== posLeft && isCenter) { position.left -= adjust.x; }
							
							// Make sure we haven't made things worse with the adjustment and return the adjusted difference
							if(position.left < viewportScroll && -position.left > overflowRight) { position.left = posLeft; }
						}

						return position.left - posLeft;
					},
					top: function(posTop) {
						var isShift = readjust.vertical === 'shift',
							viewportScroll = viewport.offset.top + viewport.scrollTop,
							myHeight = my.y === 'top' ? elemHeight : my.y === 'bottom' ? -elemHeight : -elemHeight / 2,
							atHeight = at.y === 'top' ? targetHeight : at.y === 'bottom' ? -targetHeight : -targetHeight / 2,
							tipHeight = tip && tip.size ? tip.size.height || 0 : 0,
							tipAdjust = tip && tip.corner && tip.corner.precedance === 'y' && !isShift ? tipHeight : 0,
							overflowTop = viewportScroll - posTop + tipAdjust,
							overflowBottom = posTop + elemHeight - viewport.height - viewportScroll + tipAdjust,
							offset = myHeight - (my.precedance === 'y' || my.x === my.y ? atHeight : 0),
							isCenter = my.y === 'center';
							
						// Optional 'shift' style repositioning
						if(isShift) {
							tipAdjust = tip && tip.corner && tip.corner.precedance === 'x' ? tipHeight : 0;
							offset = (my.y === 'top' ? 1 : -1) * myHeight - tipAdjust;

							// Adjust position but keep it within viewport dimensions
							position.top += overflowTop > 0 ? overflowTop : overflowBottom > 0 ? -overflowBottom : 0;
							position.top = Math.max(
								viewport.offset.top + (tipAdjust && tip.corner.x === 'center' ? tip.offset : 0),
								posTop - offset,
								Math.min(
									Math.max(viewport.offset.top + viewport.height, posTop + offset),
									position.top
								)
							);
						}

						// Default 'flip' repositioning
						else {
							if(overflowTop > 0 && (my.y !== 'top' || overflowBottom > 0)) {
								position.top -= offset + (isCenter ? 0 : 2 * adjust.y);
							}
							else if(overflowBottom > 0 && (my.y !== 'bottom' || overflowTop > 0)  ) {
								position.top -= isCenter ? -offset : offset + (2 * adjust.y);
							}
							if(position.top !== posTop && isCenter) { position.top -= adjust.y; }

							// Make sure we haven't made things worse with the adjustment and return the adjusted difference
							if(position.top < 0 && -position.top > overflowBottom) { position.top = posTop; }
						}

						return position.top - posTop;
					}
				};

			// Check if absolute position was passed
			if($.isArray(target) && target.length === 2) {
				// Force left top and set position
				at = { x: 'left', y: 'top' };
				position = { left: target[0], top: target[1] };
			}

			// Check if mouse was the target
			else if(target === 'mouse' && ((event && event.pageX) || cache.event.pageX)) {
				// Force left top to allow flipping
				at = { x: 'left', y: 'top' };

				// Use cached event if one isn't available for positioning
				event = (event && (event.type === 'resize' || event.type === 'scroll') ? cache.event :
					event && event.pageX && event.type === 'mousemove' ? event :
					MOUSE && MOUSE.pageX && (adjust.mouse || !event || !event.pageX) ? { pageX: MOUSE.pageX, pageY: MOUSE.pageY } :
					!adjust.mouse && cache.origin && cache.origin.pageX ? cache.origin :
					event) || event || cache.event || MOUSE || {};

				// Use event coordinates for position
				position = { top: event.pageY, left: event.pageX };
			}

			// Target wasn't mouse or absolute...
			else {
				// Check if event targetting is being used
				if(target === 'event') {
					if(event && event.target && event.type !== 'scroll' && event.type !== 'resize') {
						target = cache.target = $(event.target);
					}
					else {
						target = cache.target;
					}
				}
				else { cache.target = $(target); }

				// Parse the target into a jQuery object and make sure there's an element present
				target = $(target).eq(0);
				if(target.length === 0) { return self; }

				// Check if window or document is the target
				else if(target[0] === document || target[0] === window) {
					targetWidth = PLUGINS.iOS ? window.innerWidth : target.width();
					targetHeight = PLUGINS.iOS ? window.innerHeight : target.height();

					if(target[0] === window) {
						position = {
							top: !fixed || PLUGINS.iOS ? (viewport || target).scrollTop() : 0,
							left: !fixed || PLUGINS.iOS ? (viewport || target).scrollLeft() : 0
						};
					}
				}

				// Use Imagemap/SVG plugins if needed
				else if(target.is('area') && PLUGINS.imagemap) {
					position = PLUGINS.imagemap(target, at);
				}
				else if(target[0].namespaceURI === 'http://www.w3.org/2000/svg' && PLUGINS.svg) {
					position = PLUGINS.svg(target, at);
				}

				else {
					targetWidth = target.outerWidth();
					targetHeight = target.outerHeight();

					position = PLUGINS.offset(target, posOptions.container, fixed);
				}

				// Parse returned plugin values into proper variables
				if(position.offset) {
					targetWidth = position.width;
					targetHeight = position.height;
					position = position.offset;
				}

				// Adjust position relative to target
				position.left += at.x === 'right' ? targetWidth : at.x === 'center' ? targetWidth / 2 : 0;
				position.top += at.y === 'bottom' ? targetHeight : at.y === 'center' ? targetHeight / 2 : 0;
			}

			// Adjust position relative to tooltip
			position.left += adjust.x + (my.x === 'right' ? -elemWidth : my.x === 'center' ? -elemWidth / 2 : 0);
			position.top += adjust.y + (my.y === 'bottom' ? -elemHeight : my.y === 'center' ? -elemHeight / 2 : 0);

			// Calculate collision offset values if viewport positioning is enabled
			if(viewport.jquery && target[0] !== window && target[0] !== docBody &&
				readjust.vertical+readjust.horizontal !== 'nonenone')
			{
				// Cache our viewport details
				viewport = {
					elem: viewport,
					height: viewport[ (viewport[0] === window ? 'h' : 'outerH') + 'eight' ](),
					width: viewport[ (viewport[0] === window ? 'w' : 'outerW') + 'idth' ](),
					scrollLeft: fixed ? 0 : viewport.scrollLeft(),
					scrollTop: fixed ? 0 : viewport.scrollTop(),
					offset: viewport.offset() || { left: 0, top: 0 }
				};

				// Adjust position based onviewport and adjustment options
				position.adjusted = {
					left: readjust.horizontal !== 'none' ? readjust.left(position.left) : 0,
					top: readjust.vertical !== 'none' ? readjust.top(position.top) : 0
				};
			}

			//Viewport adjustment is disabled, set values to zero
			else { position.adjusted = { left: 0, top: 0 }; }

			// Set tooltip position class
			tooltip.attr('class', function(i, val) {
				return $.attr(this, 'class').replace(/ui-tooltip-pos-\w+/i, '');
			})
			.addClass(uitooltip + '-pos-' + my.abbreviation());

			// Call API method
			callback.originalEvent = $.extend({}, event);
			tooltip.trigger(callback, [self, position, viewport.elem || viewport]);
			if(callback.isDefaultPrevented()){ return self; }
			delete position.adjusted;

			// If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly
			if(effect === FALSE || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {
				tooltip.css(position);
			}
			
			// Use custom function if provided
			else if($.isFunction(posOptions.effect)) {
				posOptions.effect.call(tooltip, self, $.extend({}, position));
				tooltip.queue(function(next) {
					// Reset attributes to avoid cross-browser rendering bugs
					$(this).css({ opacity: '', height: '' });
					if($.browser.msie) { this.style.removeAttribute('filter'); }

					next();
				});
			}

			// Set positioning flag
			isPositioning = 0;

			return self;
		},

		// Max/min width simulator function for all browsers.. yeaaah!
		redraw: function()
		{
			if(self.rendered < 1 || isDrawing) { return self; }

			var container = options.position.container,
				perc, width, max, min;

			// Set drawing flag
			isDrawing = 1;

			// If tooltip has a set width, just set it... like a boss!
			if(options.style.width) { tooltip.css('width', options.style.width); }

			// Otherwise simualte max/min width...
			else {
				// Reset width and add fluid class
				tooltip.css('width', '').addClass(fluidClass);

				// Grab our tooltip width (add 1 so we don't get wrapping problems.. huzzah!)
				width = tooltip.width() + 1;

				// Grab our max/min properties
				max = tooltip.css('max-width') || '';
				min = tooltip.css('min-width') || '';

				// Parse into proper pixel values
				perc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;
				max = ((max.indexOf('%') > -1 ? perc : 1) * parseInt(max, 10)) || width;
				min = ((min.indexOf('%') > -1 ? perc : 1) * parseInt(min, 10)) || 0;

				// Determine new dimension size based on max/min/current values
				width = max + min ? Math.min(Math.max(width, min), max) : width;

				// Set the newly calculated width and remvoe fluid class
				tooltip.css('width', Math.round(width)).removeClass(fluidClass);
			}

			// Set drawing flag
			isDrawing = 0;

			return self;
		},

		disable: function(state)
		{
			if('boolean' !== typeof state) {
				state = !(tooltip.hasClass(disabled) || cache.disabled);
			}
			 
			if(self.rendered) {
				tooltip.toggleClass(disabled, state);
				$.attr(tooltip[0], 'aria-disabled', state);
			}
			else {
				cache.disabled = !!state;
			}

			return self;
		},
		
		enable: function() { return self.disable(FALSE); },

		destroy: function()
		{
			var t = target[0],
				title = $.attr(t, oldtitle);

			// Destroy tooltip and  any associated plugins if rendered
			if(self.rendered) {
				tooltip.remove();
				
				$.each(self.plugins, function() {
					if(this.destroy) { this.destroy(); }
				});
			}

			// Clear timers and remove bound events
			clearTimeout(self.timers.show);
			clearTimeout(self.timers.hide);
			unassignEvents();

			// Remove api object
			$.removeData(t, 'qtip');

			// Reset old title attribute if removed 
			if(title) {
				$.attr(t, 'title', title);
				target.removeAttr(oldtitle);
			}

			// Remove ARIA attributes and bound qtip events
			target.removeAttr('aria-describedby').unbind('.qtip');

			// Remove ID from sued id object
			delete usedIDs[self.id];

			return target;
		}
	});
}

// Initialization method
function init(id, opts)
{
	var obj, posOptions, attr, config, title,

	// Setup element references
	elem = $(this),
	docBody = $(document.body),

	// Use document body instead of document element if needed
	newTarget = this === document ? docBody : elem,

	// Grab metadata from element if plugin is present
	metadata = (elem.metadata) ? elem.metadata(opts.metadata) : NULL,

	// If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise
	metadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,

	// Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,
	html5 = elem.data(opts.metadata.name || 'qtipopts');

	// If we don't get an object returned attempt to parse it manualyl without parseJSON
	try { html5 = typeof html5 === 'string' ? (new Function("return " + html5))() : html5; }
	catch(e) { log('Unable to parse HTML5 attribute data: ' + html5); }

	// Merge in and sanitize metadata
	config = $.extend(TRUE, {}, QTIP.defaults, opts, 
		typeof html5 === 'object' ? sanitizeOptions(html5) : NULL,
		sanitizeOptions(metadata5 || metadata));

	// Re-grab our positioning options now we've merged our metadata and set id to passed value
	posOptions = config.position;
	config.id = id;
	
	// Setup missing content if none is detected
	if('boolean' === typeof config.content.text) {
		attr = elem.attr(config.content.attr);

		// Grab from supplied attribute if available
		if(config.content.attr !== FALSE && attr) { config.content.text = attr; }

		// No valid content was found, abort render
		else {
			log('Unable to locate content for tooltip! Aborting render of tooltip on element: ', elem);
			return FALSE;
		}
	}

	// Setup target options
	if(posOptions.container === FALSE) { posOptions.container = docBody; }
	if(posOptions.target === FALSE) { posOptions.target = newTarget; }
	if(config.show.target === FALSE) { config.show.target = newTarget; }
	if(config.show.solo === TRUE) { config.show.solo = docBody; }
	if(config.hide.target === FALSE) { config.hide.target = newTarget; }
	if(config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }

	// Convert position corner values into x and y strings
	posOptions.at = new PLUGINS.Corner(posOptions.at);
	posOptions.my = new PLUGINS.Corner(posOptions.my);

	// Destroy previous tooltip if overwrite is enabled, or skip element if not
	if($.data(this, 'qtip')) {
		if(config.overwrite) {
			elem.qtip('destroy');
		}
		else if(config.overwrite === FALSE) {
			return FALSE;
		}
	}

	// Remove title attribute and store it if present
	if(title = $.attr(this, 'title')) {
		$(this).removeAttr('title').attr(oldtitle, title);
	}

	// Initialize the tooltip and add API reference
	obj = new QTip(elem, config, id, !!attr);
	$.data(this, 'qtip', obj);

	// Catch remove events on target element to destroy redundant tooltip
	elem.bind('remove.qtip', function(){ obj.destroy(); });

	return obj;
}

// jQuery $.fn extension method
QTIP = $.fn.qtip = function(options, notation, newValue)
{
	var command = ('' + options).toLowerCase(), // Parse command
		returned = NULL,
		args = command === 'disable' ? [TRUE] : $.makeArray(arguments).slice(1),
		event = args[args.length - 1],
		opts = this[0] ? $.data(this[0], 'qtip') : NULL;

	// Check for API request
	if((!arguments.length && opts) || command === 'api') {
		return opts;
	}

	// Execute API command if present
	else if('string' === typeof options)
	{
		this.each(function()
		{
			var api = $.data(this, 'qtip');
			if(!api) { return TRUE; }

			// Cache the event if possible
			if(event && event.timeStamp) { api.cache.event = event; }

			// Check for specific API commands
			if((command === 'option' || command === 'options') && notation) {
				if($.isPlainObject(notation) || newValue !== undefined) {
					api.set(notation, newValue);
				}
				else {
					returned = api.get(notation);
					return FALSE;
				}
			}

			// Execute API command
			else if(api[command]) {
				api[command].apply(api[command], args);
			}
		});

		return returned !== NULL ? returned : this;
	}

	// No API commands. validate provided options and setup qTips
	else if('object' === typeof options || !arguments.length)
	{
		opts = sanitizeOptions($.extend(TRUE, {}, options));

		// Bind the qTips
		return QTIP.bind.call(this, opts, event);
	}
};

// $.fn.qtip Bind method
QTIP.bind = function(opts, event)
{
	return this.each(function(i) {
		var options, targets, events, namespace, api, id;

		// Find next available ID, or use custom ID if provided
		id = $.isArray(opts.id) ? opts.id[i] : opts.id;
		id = !id || id === FALSE || id.length < 1 || usedIDs[id] ? QTIP.nextid++ : (usedIDs[id] = id);

		// Setup events namespace
		namespace = '.qtip-'+id+'-create';

		// Initialize the qTip and re-grab newly sanitized options
		api = init.call(this, id, opts);
		if(api === FALSE) { return TRUE; }
		options = api.options;

		// Initialize plugins
		$.each(PLUGINS, function() {
			if(this.initialize === 'initialize') { this(api); }
		});

		// Determine hide and show targets
		targets = { show: options.show.target, hide: options.hide.target };
		events = {
			show: $.trim('' + options.show.event).replace(/ /g, namespace+' ') + namespace,
			hide: $.trim('' + options.hide.event).replace(/ /g, namespace+' ') + namespace
		};

		/*
		 * Make sure hoverIntent functions properly by using mouseleave as a hide event if
		 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
		 */
		if(/mouse(over|enter)/i.test(events.show) && !/mouse(out|leave)/i.test(events.hide)) {
			events.hide += ' mouseleave' + namespace;
		}

		// Define hoverIntent function
		function hoverIntent(event) {
			function render() {
				// Cache mouse coords,render and render the tooltip
				api.render(typeof event === 'object' || options.show.ready);

				// Unbind show and hide events
				targets.show.add(targets.hide).unbind(namespace);
			}

			// Only continue if tooltip isn't disabled
			if(api.cache.disabled) { return FALSE; }

			// Cache the event data
			api.cache.event = $.extend({}, event);
			api.cache.target = event ? $(event.target) : [undefined];

			// Start the event sequence
			if(options.show.delay > 0) {
				clearTimeout(api.timers.show);
				api.timers.show = setTimeout(render, options.show.delay);
				if(events.show !== events.hide) {
					targets.hide.bind(events.hide, function() { clearTimeout(api.timers.show); });
				}
			}
			else { render(); }
		}

		// Bind show events to target
		targets.show.bind(events.show, hoverIntent);

		// Prerendering is enabled, create tooltip now
		if(options.show.ready || options.prerender) { hoverIntent(event); }
	});
};

// Setup base plugins
PLUGINS = QTIP.plugins = {
	// Corner object parser
	Corner: function(corner) {
		corner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, 'center').toLowerCase();
		this.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();
		this.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();

		this.precedance = (corner.charAt(0).search(/^(t|b)/) > -1) ? 'y' : 'x';
		this.string = function() { return this.precedance === 'y' ? this.y+this.x : this.x+this.y; };
		this.abbreviation = function() { 
			var x = this.x.substr(0,1), y = this.y.substr(0,1);
			return x === y ? x : (x === 'c' || (x !== 'c' && y !== 'c')) ? y + x : x + y;
		};
	},

	// Custom (more correct for qTip!) offset calculator
	offset: function(elem, container, fixed) {
		var pos = elem.offset(),
			parent = container,
			deep = 0,
			docBody = document.body,
			coffset;

		function scroll(e, i) {
			pos.left += i * e.scrollLeft();
			pos.top += i * e.scrollTop();
		}

		if(parent) {
			// Compensate for non-static containers offset
			do {
				if(parent.css('position') !== 'static') {
					coffset = parent[0] === docBody ?
						{ left: parseInt(parent.css('left'), 10) || 0, top: parseInt(parent.css('top'), 10) || 0 } :
						parent.position();

					pos.left -= coffset.left + (parseInt(parent.css('borderLeftWidth'), 10) || 0);
					pos.top -= coffset.top + (parseInt(parent.css('borderTopWidth'), 10) || 0);

					deep++;
				}
				if(parent[0] === docBody) { break; }
			}
			while(parent = parent.offsetParent());

			// Compensate for containers scroll if it also has an offsetParent
			if(container[0] !== docBody && deep > 1) { scroll( container, 1 ); }

			// Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2 - v4.0)
			if((PLUGINS.iOS < 4.1 && PLUGINS.iOS > 3.1) || (!PLUGINS.iOS && fixed)) { scroll( $(window), -1 ); }
		}

		return pos;
	},
	
	/*
	 * iOS 3.2 - 4.0 scroll fix detection used in offset() function.
	 */
	iOS: parseFloat(
		('' + (/CPU.*OS ([0-9_]{1,3})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0,''])[1])
			.replace('undefined', '3_2').replace('_','.')
	) || FALSE,
	
	/*
	 * jQuery-secpfic $.fn overrides 
	 */
	fn: {
		/* Allow other plugins to successfully retrieve the title of an element with a qTip applied */
		attr: function(attr, val) {
			if(!this.length) { return; }
			
			var self = this[0],
			title = 'title',
			api = $.data(self, 'qtip');
			
			if(attr === title) {
				if(arguments.length < 2) {
					return $.attr(self, oldtitle);
				}
				else if(typeof api === 'object') {
					// If qTip is rendered and title was originally used as content, update it
					if(api && api.rendered && api.options.content.attr === title && api.cache.attr) {
						api.set('content.text', val);
					}
					
					// Use the regular attr method to set, then cache the result
					$.fn['attr'+replaceSuffix].apply(this, arguments);
					$.attr(self, oldtitle, $.attr(self, title));
					return this.removeAttr(title);
				}
			}
		},
		
		/* Allow clone to correctly retrieve cached title attributes */
		clone: function(keepData) {
			var titles = $([]), title = 'title', elem;

			// Clone our element using the real clone method
			elem = $.fn['clone'+replaceSuffix].apply(this, arguments)
			
			// Grab all elements with an oldtitle set, and change it to regular title attribute
			.filter('[oldtitle]').each(function() {
				$.attr(this, title, $.attr(this, oldtitle));
				this.removeAttribute(oldtitle);
			})
			.end();

			return elem;
		},
		
		/* 
		 * Taken directly from jQuery 1.8.2 widget source code
		 * Trigger 'remove' event on all elements on removal if jQuery UI isn't present 
		 */
		remove: $.ui ? NULL : function( selector, keepData ) {
			$(this).each(function() {
				if (!keepData) {
					if (!selector || $.filter( selector, [ this ] ).length) {
						$('*', this).add(this).each(function() {
							$(this).triggerHandler('remove');
						});
					}
				}
			});
		}
	}
};

// Apply the fn overrides above
$.each(PLUGINS.fn, function(name, func) {
	if(!func) { return TRUE; }
	
	var old = $.fn[name+replaceSuffix] = $.fn[name];
	$.fn[name] = function() {
		return func.apply(this, arguments) || old.apply(this, arguments);
	};
});

// Set global qTip properties
QTIP.version = 'nightly';
QTIP.nextid = 0;
QTIP.inactiveEvents = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' ');
QTIP.zindex = 95000;

// Define configuration defaults
QTIP.defaults = {
	prerender: FALSE,
	id: FALSE,
	overwrite: TRUE,
	content: {
		text: TRUE,
		attr: 'title',
		title: {
			text: FALSE,
			button: FALSE
		}
	},
	position: {
		my: 'top left',
		at: 'bottom right',
		target: FALSE,
		container: FALSE,
		viewport: FALSE,
		adjust: {
			x: 0, y: 0,
			mouse: TRUE,
			resize: TRUE,
			method: 'flip flip'
		},
		effect: function(api, pos, viewport) {
			$(this).animate(pos, {
				duration: 200,
				queue: FALSE
			});
		}
	},
	show: {
		target: FALSE,
		event: 'mouseenter',
		effect: TRUE,
		delay: 90,
		solo: FALSE,
		ready: FALSE,
		autofocus: FALSE
	},
	hide: {
		target: FALSE,
		event: 'mouseleave',
		effect: TRUE,
		delay: 0,
		fixed: FALSE,
		inactive: FALSE,
		leave: 'window',
		distance: FALSE
	},
	style: {
		classes: '',
		widget: FALSE,
		width: FALSE
	},
	events: {
		render: NULL,
		move: NULL,
		show: NULL,
		hide: NULL,
		toggle: NULL,
		focus: NULL,
		blur: NULL
	}
};

function Ajax(api)
{
	var self = this,
		tooltip = api.elements.tooltip,
		opts = api.options.content.ajax,
		namespace = '.qtip-ajax',
		rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
		first = TRUE;

	api.checks.ajax = {
		'^content.ajax': function(obj, name, v) {
			// If content.ajax object was reset, set our local var
			if(name === 'ajax') { opts = v; }

			if(name === 'once') {
				self.init();
			}
			else if(opts && opts.url) {
				self.load();
			}
			else {
				tooltip.unbind(namespace);
			}
		}
	};

	$.extend(self, {
		init: function()
		{
			// Make sure ajax options are enabled and bind event
			if(opts && opts.url) {
				tooltip.unbind(namespace)[ opts.once ? 'one' : 'bind' ]('tooltipshow'+namespace, self.load);
			}

			return self;
		},

		load: function(event, first)
		{
			// Make sure default event hasn't been prevented
			if(event && event.isDefaultPrevented()) { return self; }
			
			var hasSelector = opts.url.indexOf(' '),
				url = opts.url,
				selector,
				hideFirst = opts.once && !opts.loading && first;

			// If loading option is disabled, hide the tooltip until content is retrieved (first time only)
			if(hideFirst) { tooltip.css('visibility', 'hidden'); }

			// Check if user delcared a content selector like in .load()
			if(hasSelector > -1) {
				selector = url.substr(hasSelector);
				url = url.substr(0, hasSelector);
			}

			// Define common after callback for both success/error handlers
			function after() {
				// Re-display tip if loading and first time, and reset first flag
				if(hideFirst) { tooltip.css('visibility', ''); first = FALSE; }

				// Call users complete if it was defined
				if($.isFunction(opts.complete)) { opts.complete.apply(this, arguments); }
			}

			// Define success handler
			function successHandler(content) {
				if(selector) {
					// Create a dummy div to hold the results and grab the selector element
					content = $('<div/>')
						// inject the contents of the document in, removing the scripts
						// to avoid any 'Permission Denied' errors in IE
						.append(content.replace(rscript, ""))
						
						// Locate the specified elements
						.find(selector);
				}

				// Set the content
				api.set('content.text', content);
			}

			// Error handler
			function errorHandler(xh, status, error){ api.set('content.text', status + ': ' + error); }

			// Setup $.ajax option object and process the request
			$.ajax( $.extend({ success: successHandler, error: errorHandler, context: api }, opts, { url: url, complete: after }) );
			
			return self;
		}
	});

	self.init();
}


PLUGINS.ajax = function(api)
{
	var self = api.plugins.ajax;
	
	return 'object' === typeof self ? self : (api.plugins.ajax = new Ajax(api));
};

PLUGINS.ajax.initialize = 'render';

// Setup plugin sanitization
PLUGINS.ajax.sanitize = function(options)
{
	var content = options.content, opts;
	if(content && 'ajax' in content) {
		opts = content.ajax;
		if(typeof opts !== 'object') { opts = options.content.ajax = { url: opts }; }
		if('boolean' !== typeof opts.once && opts.once) { opts.once = !!opts.once; }
	}
};

// Extend original api defaults
$.extend(TRUE, QTIP.defaults, {
	content: {
		ajax: {
			loading: TRUE,
			once: TRUE
		}
	}
});

PLUGINS.imagemap = function(area, corner)
{
	if(!area.jquery) { area = $(area); }

	var shape = area.attr('shape').toLowerCase(),
		baseCoords = area.attr('coords').split(','),
		coords = [],
		image = $('img[usemap="#'+area.parent('map').attr('name')+'"]'),
		imageOffset = image.offset(),
		result = {
			width: 0, height: 0,
			offset: { top: 1e10, right: 0, bottom: 0, left: 1e10 }
		},
		i = 0, next = 0;

	// POLY area coordinate calculator
	//	Special thanks to Ed Cradock for helping out with this.
	//	Uses a binary search algorithm to find suitable coordinates.
	function polyCoordinates(result, coords)
	{
		var i = 0,
			compareX = 1, compareY = 1,
			realX = 0, realY = 0,
			newWidth = result.width,
			newHeight = result.height;

		// Use a binary search algorithm to locate most suitable coordinate (hopefully)
		while(newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0)
		{
			newWidth = Math.floor(newWidth / 2);
			newHeight = Math.floor(newHeight / 2);

			if(corner.x === 'left'){ compareX = newWidth; }
			else if(corner.x === 'right'){ compareX = result.width - newWidth; }
			else{ compareX += Math.floor(newWidth / 2); }

			if(corner.y === 'top'){ compareY = newHeight; }
			else if(corner.y === 'bottom'){ compareY = result.height - newHeight; }
			else{ compareY += Math.floor(newHeight / 2); }

			i = coords.length; while(i--)
			{
				if(coords.length < 2){ break; }

				realX = coords[i][0] - result.offset.left;
				realY = coords[i][1] - result.offset.top;

				if((corner.x === 'left' && realX >= compareX) ||
				(corner.x === 'right' && realX <= compareX) ||
				(corner.x === 'center' && (realX < compareX || realX > (result.width - compareX))) ||
				(corner.y === 'top' && realY >= compareY) ||
				(corner.y === 'bottom' && realY <= compareY) ||
				(corner.y === 'center' && (realY < compareY || realY > (result.height - compareY)))) {
					coords.splice(i, 1);
				}
			}
		}

		return { left: coords[0][0], top: coords[0][1] };
	}

	// Make sure we account for padding and borders on the image
	imageOffset.left += Math.ceil((image.outerWidth() - image.width()) / 2);
	imageOffset.top += Math.ceil((image.outerHeight() - image.height()) / 2);

	// Parse coordinates into proper array
	if(shape === 'poly') {
		i = baseCoords.length; while(i--)
		{
			next = [ parseInt(baseCoords[--i], 10), parseInt(baseCoords[i+1], 10) ];

			if(next[0] > result.offset.right){ result.offset.right = next[0]; }
			if(next[0] < result.offset.left){ result.offset.left = next[0]; }
			if(next[1] > result.offset.bottom){ result.offset.bottom = next[1]; }
			if(next[1] < result.offset.top){ result.offset.top = next[1]; }

			coords.push(next);
		}
	}
	else {
		coords = $.map(baseCoords, function(coord){ return parseInt(coord, 10); });
	}

	// Calculate details
	switch(shape)
	{
		case 'rect':
			result = {
				width: Math.abs(coords[2] - coords[0]),
				height: Math.abs(coords[3] - coords[1]),
				offset: { left: coords[0], top: coords[1] }
			};
		break;

		case 'circle':
			result = {
				width: coords[2] + 2,
				height: coords[2] + 2,
				offset: { left: coords[0], top: coords[1] }
			};
		break;

		case 'poly':
			$.extend(result, {
				width: Math.abs(result.offset.right - result.offset.left),
				height: Math.abs(result.offset.bottom - result.offset.top)
			});

			if(corner.string() === 'centercenter') {
				result.offset = {
					left: result.offset.left + (result.width / 2),
					top: result.offset.top + (result.height / 2)
				};
			}
			else {
				result.offset = polyCoordinates(result, coords.slice());
			}

			result.width = result.height = 0;
		break;
	}

	// Add image position to offset coordinates
	result.offset.left += imageOffset.left;
	result.offset.top += imageOffset.top;

	return result;
};

// Tip coordinates calculator
function calculateTip(corner, width, height)
{	
	var width2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2),

	// Define tip coordinates in terms of height and width values
	tips = {
		bottomright:	[[0,0],				[width,height],		[width,0]],
		bottomleft:		[[0,0],				[width,0],				[0,height]],
		topright:		[[0,height],		[width,0],				[width,height]],
		topleft:			[[0,0],				[0,height],				[width,height]],
		topcenter:		[[0,height],		[width2,0],				[width,height]],
		bottomcenter:	[[0,0],				[width,0],				[width2,height]],
		rightcenter:	[[0,0],				[width,height2],		[0,height]],
		leftcenter:		[[width,0],			[width,height],		[0,height2]]
	};

	// Set common side shapes
	tips.lefttop = tips.bottomright; tips.righttop = tips.bottomleft;
	tips.leftbottom = tips.topright; tips.rightbottom = tips.topleft;

	return tips[ corner.string() ];
}


function Tip(qTip, command)
{
	var self = this,
		opts = qTip.options.style.tip,
		elems = qTip.elements,
		tooltip = elems.tooltip,
		cache = { 
			top: 0, 
			left: 0, 
			corner: ''
		},
		size = {
			width: opts.width,
			height: opts.height
		},
		color = { },
		border = opts.border || 0,
		namespace = '.qtip-tip',
		hasCanvas = !!($('<canvas />')[0] || {}).getContext;

	self.corner = NULL;
	self.mimic = NULL;
	self.border = border;
	self.offset = opts.offset;
	self.size = size;

	// Add new option checks for the plugin
	qTip.checks.tip = {
		'^position.my|style.tip.(corner|mimic|border)$': function() {
			// Make sure a tip can be drawn
			if(!self.init()) {
				self.destroy();
			}

			// Reposition the tooltip
			qTip.reposition();
		},
		'^style.tip.(height|width)$': function() {
			// Re-set dimensions and redraw the tip
			size = {
				width: opts.width,
				height: opts.height
			};
			self.create();
			self.update();

			// Reposition the tooltip
			qTip.reposition();
		},
		'^content.title.text|style.(classes|widget)$': function() {
			if(elems.tip) {
				self.update();
			}
		}
	};

	function reposition(event, api, pos, viewport) {
		if(!elems.tip) { return; }

		var newCorner = $.extend({}, self.corner),
			adjust = pos.adjusted,
			method = qTip.options.position.adjust.method.split(' '),
			horizontal = method[0],
			vertical = method[1] || method[0],
			shift = { left: FALSE, top: FALSE, x: 0, y: 0 },
			offset, css = {}, props;

		// Make sure our tip position isn't fixed e.g. doesn't adjust with viewport
		if(self.corner.fixed !== TRUE) {
			// Horizontal - Shift or flip method
			if(horizontal === 'shift' && newCorner.precedance === 'x' && adjust.left && newCorner.y !== 'center') {
				newCorner.precedance = newCorner.precedance === 'x' ? 'y' : 'x';
			}
			else if(horizontal === 'flip' && adjust.left){
				newCorner.x = newCorner.x === 'center' ? (adjust.left > 0 ? 'left' : 'right') : (newCorner.x === 'left' ? 'right' : 'left');
			}

			// Vertical - Shift or flip method
			if(vertical === 'shift' && newCorner.precedance === 'y' && adjust.top && newCorner.x !== 'center') {
				newCorner.precedance = newCorner.precedance === 'y' ? 'x' : 'y';
			}
			else if(vertical === 'flip' && adjust.top) {
				newCorner.y = newCorner.y === 'center' ? (adjust.top > 0 ? 'top' : 'bottom') : (newCorner.y === 'top' ? 'bottom' : 'top');
			}

			// Update and redraw the tip if needed (check cached details of last drawn tip)
			if(newCorner.string() !== cache.corner && (cache.top !== adjust.top || cache.left !== adjust.left)) {
				self.update(newCorner, FALSE);
			}
		}

		// Setup tip offset properties
		offset = self.position(newCorner, adjust);
		if(offset.right !== undefined) { offset.left = -offset.right; }
		if(offset.bottom !== undefined) { offset.top = -offset.bottom; }
		offset.user = Math.max(0, opts.offset);

		// Viewport "shift" specific adjustments
		if(shift.left = (horizontal === 'shift' && !!adjust.left)) {
			if(newCorner.x === 'center') {
				css['margin-left'] = shift.x = offset['margin-left'] - adjust.left;
			}
			else {
				props = offset.right !== undefined ?
					[ adjust.left, -offset.left ] : [ -adjust.left, offset.left ];

				if( (shift.x = Math.max(props[0], props[1])) > props[0] ) {
					pos.left -= adjust.left;
					shift.left = FALSE;
				}
				
				css[ offset.right !== undefined ? 'right' : 'left' ] = shift.x;
			}
		}
		if(shift.top = (vertical === 'shift' && !!adjust.top)) {
			if(newCorner.y === 'center') {
				css['margin-top'] = shift.y = offset['margin-top'] - adjust.top;
			}
			else {
				props = offset.bottom !== undefined ?
					[ adjust.top, -offset.top ] : [ -adjust.top, offset.top ];

				if( (shift.y = Math.max(props[0], props[1])) > props[0] ) {
					pos.top -= adjust.top;
					shift.top = FALSE;
				}

				css[ offset.bottom !== undefined ? 'bottom' : 'top' ] = shift.y;
			}
		}

		/*
		 * If the tip is adjusted in both dimensions, or in a
		 * direction that would cause it to be anywhere but the
		 * outer border, hide it!
		 */
		elems.tip.css(css).toggle(
			!((shift.x && shift.y) || (newCorner.x === 'center' && shift.y) || (newCorner.y === 'center' && shift.x))
		);

		// Adjust position to accomodate tip dimensions
		pos.left -= offset.left.charAt ? offset.user : horizontal !== 'shift' || shift.top || !shift.left && !shift.top ? offset.left : 0;
		pos.top -= offset.top.charAt ? offset.user : vertical !== 'shift' || shift.left || !shift.left && !shift.top ? offset.top : 0;

		// Cache details
		cache.left = adjust.left; cache.top = adjust.top;
		cache.corner = newCorner.string();
	}

	/* border width calculator */
	function borderWidth(corner, side, backup) {
		side = !side ? corner[corner.precedance] : side;
		
		var isFluid = tooltip.hasClass(fluidClass),
			isTitleTop = elems.titlebar && corner.y === 'top',
			elem = isTitleTop ? elems.titlebar : elems.content,
			css = 'border-' + side + '-width',
			val;

		// Grab the border-width value (add fluid class if needed)
		tooltip.addClass(fluidClass);
		val = parseInt(elem.css(css), 10);
		val = (backup ? val || parseInt(tooltip.css(css), 10) : val) || 0;
		tooltip.toggleClass(fluidClass, isFluid);

		return val;
	}

	function borderRadius(corner) {
		var isTitleTop = elems.titlebar && corner.y === 'top',
			elem = isTitleTop ? elems.titlebar : elems.content,
			moz = $.browser.mozilla,
			prefix = moz ? '-moz-' : $.browser.webkit ? '-webkit-' : '',
			side = corner.y + (moz ? '' : '-') + corner.x,
			css = prefix + (moz ? 'border-radius-' + side : 'border-' + side + '-radius');

		return parseInt(elem.css(css), 10) || parseInt(tooltip.css(css), 10) || 0;
	}

	function calculateSize(corner) {
		var y = corner.precedance === 'y',
			width = size [ y ? 'width' : 'height' ],
			height = size [ y ? 'height' : 'width' ],
			isCenter = corner.string().indexOf('center') > -1,
			base = width * (isCenter ? 0.5 : 1),
			pow = Math.pow,
			round = Math.round,
			bigHyp, ratio, result,

		smallHyp = Math.sqrt( pow(base, 2) + pow(height, 2) ),
		
		hyp = [
			(border / base) * smallHyp, (border / height) * smallHyp
		];
		hyp[2] = Math.sqrt( pow(hyp[0], 2) - pow(border, 2) );
		hyp[3] = Math.sqrt( pow(hyp[1], 2) - pow(border, 2) );

		bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);
		ratio = bigHyp / smallHyp;

		result = [ round(ratio * height), round(ratio * width) ];
		return { height: result[ y ? 0 : 1 ], width: result[ y ? 1 : 0 ] };
	}

	$.extend(self, {
		init: function()
		{
			var enabled = self.detectCorner() && (hasCanvas || $.browser.msie);

			// Determine tip corner and type
			if(enabled) {
				// Create a new tip and draw it
				self.create();
				self.update();

				// Bind update events
				tooltip.unbind(namespace).bind('tooltipmove'+namespace, reposition);
			}
			
			return enabled;
		},

		detectCorner: function()
		{
			var corner = opts.corner,
				posOptions = qTip.options.position,
				at = posOptions.at,
				my = posOptions.my.string ? posOptions.my.string() : posOptions.my;

			// Detect corner and mimic properties
			if(corner === FALSE || (my === FALSE && at === FALSE)) {
				return FALSE;
			}
			else {
				if(corner === TRUE) {
					self.corner = new PLUGINS.Corner(my);
				}
				else if(!corner.string) {
					self.corner = new PLUGINS.Corner(corner);
					self.corner.fixed = TRUE;
				}
			}

			return self.corner.string() !== 'centercenter';
		},

		detectColours: function() {
			var i, fill, border,
				tip = elems.tip.css({ backgroundColor: '', border: '' }),
				corner = self.corner,
				precedance = corner[ corner.precedance ],

				borderSide = 'border-' + precedance + '-color',
				borderSideCamel = 'border' + precedance.charAt(0) + precedance.substr(1) + 'Color',

				invalid = /rgba?\(0, 0, 0(, 0)?\)|transparent/i,
				backgroundColor = 'background-color',
				transparent = 'transparent',

				bodyBorder = $(document.body).css('color'),
				contentColour = qTip.elements.content.css('color'),

				useTitle = elems.titlebar && (corner.y === 'top' || (corner.y === 'center' && tip.position().top + (size.height / 2) + opts.offset < elems.titlebar.outerHeight(1))),
				colorElem = useTitle ? elems.titlebar : elems.content;

			// Apply the fluid class so we can see our CSS values properly
			tooltip.addClass(fluidClass);

			// Detect tip colours from CSS styles
			color.fill = fill = tip.css(backgroundColor);
			color.border = border = tip[0].style[ borderSideCamel ] || tooltip.css(borderSide);

			// Make sure colours are valid
			if(!fill || invalid.test(fill)) {
				color.fill = colorElem.css(backgroundColor) || transparent;
				if(invalid.test(color.fill)) {
					color.fill = tooltip.css(backgroundColor) || fill;
				}
			}
			if(!border || invalid.test(border) || border === bodyBorder) {
				color.border = colorElem.css(borderSide) || transparent;
				if(invalid.test(color.border) || color.border === contentColour) {
					color.border = border;
				}
			}

			// Reset background and border colours
			$('*', tip).add(tip).css(backgroundColor, transparent).css('border', '');

			// Remove fluid class
			tooltip.removeClass(fluidClass);
		},

		create: function()
		{
			var width = size.width,
				height = size.height,
				vml;

			// Remove previous tip element if present
			if(elems.tip) { elems.tip.remove(); }

			// Create tip element and prepend to the tooltip
			elems.tip = $('<div />', { 'class': 'ui-tooltip-tip' }).css({ width: width, height: height }).prependTo(tooltip);

			// Create tip drawing element(s)
			if(hasCanvas) {
				// save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!
				$('<canvas />').appendTo(elems.tip)[0].getContext('2d').save();
			}
			else {
				vml = '<vml:shape coordorigin="0,0" style="display:inline-block; position:absolute; behavior:url(#default#VML);"></vml:shape>';
				elems.tip.html(vml + vml);
			}
		},

		update: function(corner, position) {
			var tip = elems.tip,
				inner = tip.children(),
				width = size.width,
				height = size.height,
				regular = 'px solid ',
				transparent = 'px dashed transparent', // Dashed IE6 border-transparency hack. Awesome!
				mimic = opts.mimic,
				round = Math.round,
				precedance, context, coords, translate, newSize;

			// Re-determine tip if not already set
			if(!corner) { corner = self.corner; }

			// Use corner property if we detect an invalid mimic value
			if(mimic === FALSE) { mimic = corner; }

			// Otherwise inherit mimic properties from the corner object as necessary
			else {
				mimic = new PLUGINS.Corner(mimic);
				mimic.precedance = corner.precedance;

				if(mimic.x === 'inherit') { mimic.x = corner.x; }
				else if(mimic.y === 'inherit') { mimic.y = corner.y; }
				else if(mimic.x === mimic.y) {
					mimic[ corner.precedance ] = corner[ corner.precedance ];
				}
			}
			precedance = mimic.precedance;

			// Update our colours
			self.detectColours();

			// Detect border width, taking into account colours
			if(color.border !== 'transparent' && color.border !== '#123456') {
				// Grab border width
				border = borderWidth(corner, NULL, TRUE);

				// If border width isn't zero, use border color as fill (1.0 style tips)
				if(opts.border === 0 && border > 0) { color.fill = color.border; }

				// Set border width (use detected border width if opts.border is true)
				self.border = border = opts.border !== TRUE ? opts.border : border;
			}

			// Border colour was invalid, set border to zero
			else { self.border = border = 0; }

			// Calculate coordinates
			coords = calculateTip(mimic, width , height);

			// Determine tip size
			self.size = newSize = calculateSize(corner);
			tip.css(newSize);

			// Calculate tip translation
			if(corner.precedance === 'y') {
				translate = [
					round(mimic.x === 'left' ? border : mimic.x === 'right' ? newSize.width - width - border : (newSize.width - width) / 2),
					round(mimic.y === 'top' ?  newSize.height - height : 0)
				];
			}
			else {
				translate = [
					round(mimic.x === 'left' ? newSize.width - width : 0),
					round(mimic.y === 'top' ? border : mimic.y === 'bottom' ? newSize.height - height - border : (newSize.height - height) / 2)
				];
			}

			// Canvas drawing implementation
			if(hasCanvas) {
				// Set the canvas size using calculated size
				inner.attr(newSize);
				
				// Grab canvas context and clear/save it
				context = inner[0].getContext('2d');
				context.restore(); context.save();
				context.clearRect(0,0,3000,3000);
				
				// Translate origin
				context.translate(translate[0], translate[1]);
				
				// Draw the tip
				context.beginPath();
				context.moveTo(coords[0][0], coords[0][1]);
				context.lineTo(coords[1][0], coords[1][1]);
				context.lineTo(coords[2][0], coords[2][1]);
				context.closePath();
				context.fillStyle = color.fill;
				context.strokeStyle = color.border;
				context.lineWidth = border * 2;
				context.lineJoin = 'miter';
				context.miterLimit = 100;
				if(border) { context.stroke(); }
				context.fill();
			}

			// VML (IE Proprietary implementation)
			else {
				// Setup coordinates string
				coords = 'm' + coords[0][0] + ',' + coords[0][1] + ' l' + coords[1][0] +
					',' + coords[1][1] + ' ' + coords[2][0] + ',' + coords[2][1] + ' xe';

				// Setup VML-specific offset for pixel-perfection
				translate[2] = border && /^(r|b)/i.test(corner.string()) ?
					parseFloat($.browser.version, 10) === 8 ? 2 : 1 : 0;

				// Set initial CSS
				inner.css({
					antialias: ''+(mimic.string().indexOf('center') > -1),
					left: translate[0] - (translate[2] * Number(precedance === 'x')),
					top: translate[1] - (translate[2] * Number(precedance === 'y')),
					width: width + border,
					height: height + border
				})
				.each(function(i) {
					var $this = $(this);

					// Set shape specific attributes
					$this[ $this.prop ? 'prop' : 'attr' ]({
						coordsize: (width+border) + ' ' + (height+border),
						path: coords,
						fillcolor: color.fill,
						filled: !!i,
						stroked: !!!i
					})
					.css({ display: border || i ? 'block' : 'none' });

					// Check if border is enabled and add stroke element
					if(!i && $this.html() === '') {
						$this.html(
							'<vml:stroke weight="'+(border*2)+'px" color="'+color.border+'" miterlimit="1000" joinstyle="miter" ' +
							' style="behavior:url(#default#VML); display:inline-block;" />'
						);
					}
				});
			}

			// Position if needed
			if(position !== FALSE) { self.position(corner); }
		},

		// Tip positioning method
		position: function(corner)
		{
			var tip = elems.tip,
				position = {},
				userOffset = Math.max(0, opts.offset),
				precedance, dimensions, corners;

			// Return if tips are disabled or tip is not yet rendered
			if(opts.corner === FALSE || !tip) { return FALSE; }

			// Inherit corner if not provided
			corner = corner || self.corner;
			precedance = corner.precedance;

			// Determine which tip dimension to use for adjustment
			dimensions = calculateSize(corner);

			// Setup corners and offset array
			corners = [ corner.x, corner.y ];
			if(precedance === 'x') { corners.reverse(); }

			// Calculate tip position
			$.each(corners, function(i, side) {
				var b, br;

				if(side === 'center') {
					b = precedance === 'y' ? 'left' : 'top';
					position[ b ] = '50%';
					position['margin-' + b] = -Math.round(dimensions[ precedance === 'y' ? 'width' : 'height' ] / 2) + userOffset;
				}
				else {
					b = borderWidth(corner, side, TRUE);
					br = borderRadius(corner);
					
					position[ side ] = i ?
						border ? borderWidth(corner, side) : 0 : 
						userOffset + (br > b ? br : 0);
				}
			});

			// Adjust for tip dimensions
			position[ corner[precedance] ] -= dimensions[ precedance === 'x' ? 'width' : 'height' ];

			// Set and return new position
			tip.css({ top: '', bottom: '', left: '', right: '', margin: '' }).css(position);
			return position;
		},
		
		destroy: function()
		{
			// Remov tip and bound events
			if(elems.tip) { elems.tip.remove(); }
			tooltip.unbind(namespace);
		}
	});
	
	self.init();
}

PLUGINS.tip = function(api)
{
	var self = api.plugins.tip;
	
	return 'object' === typeof self ? self : (api.plugins.tip = new Tip(api));
};

// Initialize tip on render
PLUGINS.tip.initialize = 'render';

// Setup plugin sanitization options
PLUGINS.tip.sanitize = function(options)
{
	var style = options.style, opts;
	if(style && 'tip' in style) {
		opts = options.style.tip;
		if(typeof opts !== 'object'){ options.style.tip = { corner: opts }; }
		if(!(/string|boolean/i).test(typeof opts.corner)) { opts.corner = TRUE; }
		if(typeof opts.width !== 'number'){ delete opts.width; }
		if(typeof opts.height !== 'number'){ delete opts.height; }
		if(typeof opts.border !== 'number' && opts.border !== TRUE){ delete opts.border; }
		if(typeof opts.offset !== 'number'){ delete opts.offset; }
	}
};

// Extend original qTip defaults
$.extend(TRUE, QTIP.defaults, {
	style: {
		tip: {
			corner: TRUE,
			mimic: FALSE,
			width: 6,
			height: 6,
			border: TRUE,
			offset: 0
		}
	}
});

PLUGINS.svg = function(svg, corner)
{
	var doc = $(document),
		elem = svg[0],
		result = {
			width: 0, height: 0,
			offset: { top: 1e10, left: 1e10 }
		},
		box, mtx, root, point, tPoint;

	if (elem.getBBox && elem.parentNode) {
		box = elem.getBBox();
		mtx = elem.getScreenCTM();
		root = elem.farthestViewportElement || elem;

		// Return if no method is found
		if(!root.createSVGPoint) { return result; }

		// Create our point var
		point = root.createSVGPoint();

		// Adjust top and left
		point.x = box.x;
		point.y = box.y;
		tPoint = point.matrixTransform(mtx);
		result.offset.left = tPoint.x;
		result.offset.top = tPoint.y;

		// Adjust width and height
		point.x += box.width;
		point.y += box.height;
		tPoint = point.matrixTransform(mtx);
		result.width = tPoint.x - result.offset.left;
		result.height = tPoint.y - result.offset.top;

		// Adjust by scroll offset
		result.offset.left += doc.scrollLeft();
		result.offset.top += doc.scrollTop();
	}

	return result;
};

function Modal(api)
{
	var self = this,
		options = api.options.show.modal,
		elems = api.elements,
		tooltip = elems.tooltip,
		overlaySelector = '#qtip-overlay',
		globalNamespace = '.qtipmodal',
		namespace = globalNamespace + api.id,
		attr = 'is-modal-qtip',
		docBody = $(document.body),
		overlay;

	// Setup option set checks
	api.checks.modal = {
		'^show.modal.(on|blur)$': function() {
			// Initialise
			self.init();
			
			// Show the modal if not visible already and tooltip is visible
			elems.overlay.toggle( tooltip.is(':visible') );
		}
	};

	$.extend(self, {
		init: function()
		{
			// If modal is disabled... return
			if(!options.on) { return self; }

			// Create the overlay if needed
			overlay = self.create();

			// Add unique attribute so we can grab modal tooltips easily via a selector
			tooltip.attr(attr, TRUE)

			// Remove previous bound events in globalNamespace
			.unbind(globalNamespace).unbind(namespace)

			// Apply our show/hide/focus modal events
			.bind('tooltipshow'+globalNamespace+' tooltiphide'+globalNamespace, function(event, api, duration) {
				var oEvent = event.originalEvent;
				
				// Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop
				if(oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(overlay[0]).length) {
					event.preventDefault();
				}
				else {
					self[ event.type.replace('tooltip', '') ](event, duration);
				}
			})

			// Adjust modal z-index on tooltip focus
			.bind('tooltipfocus'+globalNamespace, function(event, api, zIndex) {
				overlay[0].style.zIndex = zIndex - 1;
			})

			// Focus any other visible modals when this one blurs
			.bind('tooltipblur'+globalNamespace, function(event) {
				$('[' + attr + ']:visible').not(tooltip).last().qtip('focus', event);
			});

			// Apply keyboard "Escape key" close handler
			if(options.escape) {
				$(window).unbind(namespace).bind('keydown'+namespace, function(event) {
					if(event.keyCode === 27 && tooltip.hasClass(focusClass)) {
						api.hide(event);
					}
				});
			}

			// Apply click handler for blur option
			if(options.blur) {
				elems.overlay.unbind(namespace).bind('click'+namespace, function(event) {
					if(tooltip.hasClass(focusClass)) { api.hide(event); }
				});
			}

			return self;
		},

		create: function()
		{
			var elem = $(overlaySelector);

			// Return if overlay is already rendered
			if(elem.length) { elems.overlay = elem; return elem; }

			// Create document overlay
			overlay = elems.overlay = $('<div />', {
				id: overlaySelector.substr(1),
				html: '<div></div>',
				mousedown: function() { return FALSE; }
			})
			.insertBefore( $(selector).last() );

			// Update position on window resize or scroll
			$(window).unbind(globalNamespace).bind('resize'+globalNamespace, function() {
				overlay.css({
					height: $(window).height(),
					width: $(window).width()
				});
			})
			.triggerHandler('resize');

			return overlay;
		},

		toggle: function(event, state, duration)
		{
			// Make sure default event hasn't been prevented
			if(event && event.isDefaultPrevented()) { return self; }

			var effect = options.effect,
				type = state ? 'show': 'hide',
				visible = overlay.is(':visible'),
				modals = $('[' + attr + ']:visible').not(tooltip),
				zindex;

			// Create our overlay if it isn't present already
			if(!overlay) { overlay = self.create(); }

			// Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible
			if((overlay.is(':animated') && visible === state) || (!state && modals.length)) { return self; }

			// State specific...
			if(state) {
				// Set position
				overlay.css({ left: 0, top: 0 });

				// Toggle backdrop cursor style on show
				overlay.toggleClass('blurs', options.blur);

				// Make sure we can't focus anything outside the tooltip
				docBody.delegate('*', 'focusin'+namespace, function(event) {
					if($(event.target).closest(selector)[0] !== tooltip[0]) {
						$('a, :input, img', tooltip).add(tooltip).focus();
					}
				});
			}
			else {
				// Undelegate focus handler
				docBody.undelegate('*', 'focusin'+namespace);
			}

			// Stop all animations
			overlay.stop(TRUE, FALSE);

			// Use custom function if provided
			if($.isFunction(effect)) {
				effect.call(overlay, state);
			}

			// If no effect type is supplied, use a simple toggle
			else if(effect === FALSE) {
				overlay[ type ]();
			}

			// Use basic fade function
			else {
				overlay.fadeTo( parseInt(duration, 10) || 90, state ? 1 : 0, function() {
					if(!state) { $(this).hide(); }
				});
			}

			// Reset position on hide
			if(!state) {
				overlay.queue(function(next) {
					overlay.css({ left: '', top: '' });
					next();
				});
			}

			return self;
		},

		show: function(event, duration) { return self.toggle(event, TRUE, duration); },
		hide: function(event, duration) { return self.toggle(event, FALSE, duration); },

		destroy: function()
		{
			var delBlanket = overlay;

			if(delBlanket) {
				// Check if any other modal tooltips are present
				delBlanket = $('[' + attr + ']').not(tooltip).length < 1;

				// Remove overlay if needed
				if(delBlanket) {
					elems.overlay.remove();
					$(window).unbind(globalNamespace);
				}
				else {
					elems.overlay.unbind(globalNamespace+api.id);
				}

				// Undelegate focus handler
				docBody.undelegate('*', 'focusin'+namespace);
			}

			// Remove bound events
			return tooltip.removeAttr(attr).unbind(globalNamespace);
		}
	});

	self.init();
}

PLUGINS.modal = function(api) {
	var self = api.plugins.modal;

	return 'object' === typeof self ? self : (api.plugins.modal = new Modal(api));
};

// Plugin needs to be initialized on render
PLUGINS.modal.initialize = 'render';

// Setup sanitiztion rules
PLUGINS.modal.sanitize = function(opts) {
	if(opts.show) { 
		if(typeof opts.show.modal !== 'object') { opts.show.modal = { on: !!opts.show.modal }; }
		else if(typeof opts.show.modal.on === 'undefined') { opts.show.modal.on = TRUE; }
	}
};

// Extend original api defaults
$.extend(TRUE, QTIP.defaults, {
	show: {
		modal: {
			on: FALSE,
			effect: TRUE,
			blur: TRUE,
			escape: TRUE
		}
	}
});

/* 
 * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)
 * Special thanks to Brandon Aaron
 */
function BGIFrame(api)
{
	var self = this,
		elems = api.elements,
		tooltip = elems.tooltip,
		namespace = '.bgiframe-' + api.id;

	$.extend(self, {
		init: function()
		{
			// Create the BGIFrame element
			elems.bgiframe = $('<iframe class="ui-tooltip-bgiframe" frameborder="0" tabindex="-1" src="javascript:\'\';" ' +
				' style="display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' +
					'-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";"></iframe>');

			// Append the new element to the tooltip
			elems.bgiframe.appendTo(tooltip);

			// Update BGIFrame on tooltip move
			tooltip.bind('tooltipmove'+namespace, self.adjust);
		},

		adjust: function()
		{
			var dimensions = api.get('dimensions'), // Determine current tooltip dimensions
				plugin = api.plugins.tip,
				tip = elems.tip,
				tipAdjust, offset;

			// Adjust border offset
			offset = parseInt(tooltip.css('border-left-width'), 10) || 0;
			offset = { left: -offset, top: -offset };

			// Adjust for tips plugin
			if(plugin && tip) {
				tipAdjust = (plugin.corner.precedance === 'x') ? ['width', 'left'] : ['height', 'top'];
				offset[ tipAdjust[1] ] -= tip[ tipAdjust[0] ]();
			}

			// Update bgiframe
			elems.bgiframe.css(offset).css(dimensions);
		},

		destroy: function()
		{
			// Remove iframe
			elems.bgiframe.remove();

			// Remove bound events
			tooltip.unbind(namespace);
		}
	});

	self.init();
}

PLUGINS.bgiframe = function(api)
{
	var browser = $.browser,
		self = api.plugins.bgiframe;
	
		// Proceed only if the browser is IE6 and offending elements are present
		if($('select, object').length < 1 || !(browser.msie && browser.version.charAt(0) === '6')) {
		return FALSE;
	}

	return 'object' === typeof self ? self : (api.plugins.bgiframe = new BGIFrame(api));
};

// Plugin needs to be initialized on render
PLUGINS.bgiframe.initialize = 'render';


}(jQuery, window));


/*
	Masked Input plugin for jQuery
	Copyright (c) 2007-2011 Josh Bush (digitalbush.com)
	Licensed under the MIT license (http://digitalbush.com/projects/masked-input-plugin/#license) 
	Version: 1.3
*/
(function($) {
	var pasteEventName = ($.browser.msie ? 'paste' : 'input') + ".mask";
	var iPhone = (window.orientation != undefined);

	$.mask = {
		//Predefined character definitions
		definitions: {
			'9': "[0-9]",
			'a': "[A-Za-z]",
			'*': "[A-Za-z0-9]",
			'r': "[А-Яа-яЁё]"
		},
		dataName:"rawMaskFn"
	};

	$.fn.extend({
		//Helper Function for Caret positioning
		caret: function(begin, end) {
			if (this.length == 0) return;
			if (typeof begin == 'number') {
				end = (typeof end == 'number') ? end : begin;
				return this.each(function() {
					if (this.setSelectionRange) {
						this.setSelectionRange(begin, end);
					} else if (this.createTextRange) {
						var range = this.createTextRange();
						range.collapse(true);
						range.moveEnd('character', end);
						range.moveStart('character', begin);
						range.select();
					}
				});
			} else {
				if (this[0].setSelectionRange) {
					begin = this[0].selectionStart;
					end = this[0].selectionEnd;
				} else if (document.selection && document.selection.createRange) {
					var range = document.selection.createRange();
					begin = 0 - range.duplicate().moveStart('character', -100000);
					end = begin + range.text.length;
				}
				return { begin: begin, end: end };
			}
		},
		unmask: function() { return this.trigger("unmask"); },
		mask: function(mask, settings) {
			if (!mask && this.length > 0) {
				var input = $(this[0]);
				return input.data($.mask.dataName)();
			}
			settings = $.extend({
				placeholder: "_",
				completed: null
			}, settings);

			var defs = $.mask.definitions;
			var tests = [];
			var partialPosition = mask.length;
			var firstNonMaskPos = null;
			var len = mask.length;

			$.each(mask.split(""), function(i, c) {
				if (c == '?') {
					len--;
					partialPosition = i;
				} else if (defs[c]) {
					tests.push(new RegExp(defs[c]));
					if(firstNonMaskPos==null)
						firstNonMaskPos =  tests.length - 1;
				} else {
					tests.push(null);
				}
			});

			return this.trigger("unmask").each(function() {
				var input = $(this);
				var buffer = $.map(mask.split(""), function(c, i) { if (c != '?') return defs[c] ? settings.placeholder : c });
				var focusText = input.val();

				function seekNext(pos) {
					while (++pos <= len && !tests[pos]);
					return pos;
				};
				function seekPrev(pos) {
					while (--pos >= 0 && !tests[pos]);
					return pos;
				};

				function shiftL(begin,end) {
					if(begin<0)
					   return;
					for (var i = begin,j = seekNext(end); i < len; i++) {
						if (tests[i]) {
							if (j < len && tests[i].test(buffer[j])) {
								buffer[i] = buffer[j];
								buffer[j] = settings.placeholder;
							} else
								break;
							j = seekNext(j);
						}
					}
					writeBuffer();
					input.caret(Math.max(firstNonMaskPos, begin));
				};

				function shiftR(pos) {
					for (var i = pos, c = settings.placeholder; i < len; i++) {
						if (tests[i]) {
							var j = seekNext(i);
							var t = buffer[i];
							buffer[i] = c;
							if (j < len && tests[j].test(t))
								c = t;
							else
								break;
						}
					}
				};

				function keydownEvent(e) {
					var k=e.which;

					//backspace, delete, and escape get special treatment
					if(k == 8 || k == 46 || (iPhone && k == 127)){
						var pos = input.caret(),
							begin = pos.begin,
							end = pos.end;
						
						if(end-begin==0){
							begin=k!=46?seekPrev(begin):(end=seekNext(begin-1));
							end=k==46?seekNext(end):end;
						}
						clearBuffer(begin, end);
						shiftL(begin,end-1);

						return false;
					} else if (k == 27) {//escape
						input.val(focusText);
						input.caret(0, checkVal());
						return false;
					}
				};

				function keypressEvent(e) {
					var k = e.which,
						pos = input.caret();
					if (e.ctrlKey || e.altKey || e.metaKey || k<32) {//Ignore
						return true;
					} else if (k) {
						if(pos.end-pos.begin!=0){
							clearBuffer(pos.begin, pos.end);
							shiftL(pos.begin, pos.end-1);
						}

						var p = seekNext(pos.begin - 1);
						if (p < len) {
							var c = String.fromCharCode(k);
							if (tests[p].test(c)) {
								shiftR(p);
								buffer[p] = c;
								writeBuffer();
								var next = seekNext(p);
								input.caret(next);
								if (settings.completed && next >= len)
									settings.completed.call(input);
							}
						}
						return false;
					}
				};

				function clearBuffer(start, end) {
					for (var i = start; i < end && i < len; i++) {
						if (tests[i])
							buffer[i] = settings.placeholder;
					}
				};

				function writeBuffer() { return input.val(buffer.join('')).val(); };

				function checkVal(allow) {
					//try to place characters where they belong
					var test = input.val();
					var lastMatch = -1;
					for (var i = 0, pos = 0; i < len; i++) {
						if (tests[i]) {
							buffer[i] = settings.placeholder;
							while (pos++ < test.length) {
								var c = test.charAt(pos - 1);
								if (tests[i].test(c)) {
									buffer[i] = c;
									lastMatch = i;
									break;
								}
							}
							if (pos > test.length)
								break;
						} else if (buffer[i] == test.charAt(pos) && i!=partialPosition) {
							pos++;
							lastMatch = i;
						}
					}
					if (!allow && lastMatch + 1 < partialPosition) {
						input.val("");
						clearBuffer(0, len);
					} else if (allow || lastMatch + 1 >= partialPosition) {
						writeBuffer();
						if (!allow) input.val(input.val().substring(0, lastMatch + 1));
					}
					return (partialPosition ? i : firstNonMaskPos);
				};

				input.data($.mask.dataName,function(){
					return $.map(buffer, function(c, i) {
						return tests[i]&&c!=settings.placeholder ? c : null;
					}).join('');
				})

				if (!input.attr("readonly"))
					input
					.one("unmask", function() {
						input
							.unbind(".mask")
							.removeData($.mask.dataName);
					})
					.bind("focus.mask", function() {
						focusText = input.val();
						var pos = checkVal();
						writeBuffer();
						var moveCaret=function(){
							if (pos == mask.length)
								input.caret(0, pos);
							else
								input.caret(pos);
						};
						($.browser.msie ? moveCaret:function(){setTimeout(moveCaret,0)})();
					})
					.bind("blur.mask", function() {
						checkVal();
						if (input.val() != focusText)
							input.change();
					})
					.bind("keydown.mask", keydownEvent)
					.bind("keypress.mask", keypressEvent)
					.bind(pasteEventName, function() {
						setTimeout(function() { input.caret(checkVal(true)); }, 0);
					});

				checkVal(); //Perform initial check for existing values
			});
		}
	});
})(jQuery);



//(c) 2009 Michael Manning (actingthemaggot.com)
jQuery.getAttributes = function (F, C) {
    var F = ((typeof F === "string") ? jQuery(F)[0] : F[0]),
        D = 0,
        F = F.attributes,
        B = F.length,
        E = ["abort", "blur", "change", "click", "dblclick", "error", "focus", "keydown", "keypress", "keyup", "load", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "reset", "resize", "select", "submit", "unload"],
        A = {};
    for (D; D < B; D++) {
        if (C || !C && jQuery.inArray(F[D].nodeName.replace(/^on/, ""), E) == -1) {
            A[F[D].nodeName] = F[D].nodeValue;
        }
    }
    return A;
};


/*!
 * jQuery BBQ: Back Button & Query Library - v1.2.1 - 2/17/2010
 * http://benalman.com/projects/jquery-bbq-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery BBQ: Back Button & Query Library
//
// *Version: 1.2.1, Last updated: 2/17/2010*
// 
// Project Home - http://benalman.com/projects/jquery-bbq-plugin/
// GitHub       - http://github.com/cowboy/jquery-bbq/
// Source       - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.js
// (Minified)   - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.min.js (4.0kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Basic AJAX     - http://benalman.com/code/projects/jquery-bbq/examples/fragment-basic/
// Advanced AJAX  - http://benalman.com/code/projects/jquery-bbq/examples/fragment-advanced/
// jQuery UI Tabs - http://benalman.com/code/projects/jquery-bbq/examples/fragment-jquery-ui-tabs/
// Deparam        - http://benalman.com/code/projects/jquery-bbq/examples/deparam/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.7, Safari 3-4,
//                   Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-bbq/unit/
// 
// About: Release History
// 
// 1.2.1 - (2/17/2010) Actually fixed the stale window.location Safari bug from
//         <jQuery hashchange event> in BBQ, which was the main reason for the
//         previous release!
// 1.2   - (2/16/2010) Integrated <jQuery hashchange event> v1.2, which fixes a
//         Safari bug, the event can now be bound before DOM ready, and IE6/7
//         page should no longer scroll when the event is first bound. Also
//         added the <jQuery.param.fragment.noEscape> method, and reworked the
//         <hashchange event (BBQ)> internal "add" method to be compatible with
//         changes made to the jQuery 1.4.2 special events API.
// 1.1.1 - (1/22/2010) Integrated <jQuery hashchange event> v1.1, which fixes an
//         obscure IE8 EmulateIE7 meta tag compatibility mode bug.
// 1.1   - (1/9/2010) Broke out the jQuery BBQ event.special <hashchange event>
//         functionality into a separate plugin for users who want just the
//         basic event & back button support, without all the extra awesomeness
//         that BBQ provides. This plugin will be included as part of jQuery BBQ,
//         but also be available separately. See <jQuery hashchange event>
//         plugin for more information. Also added the <jQuery.bbq.removeState>
//         method and added additional <jQuery.deparam> examples.
// 1.0.3 - (12/2/2009) Fixed an issue in IE 6 where location.search and
//         location.hash would report incorrectly if the hash contained the ?
//         character. Also <jQuery.param.querystring> and <jQuery.param.fragment>
//         will no longer parse params out of a URL that doesn't contain ? or #,
//         respectively.
// 1.0.2 - (10/10/2009) Fixed an issue in IE 6/7 where the hidden IFRAME caused
//         a "This page contains both secure and nonsecure items." warning when
//         used on an https:// page.
// 1.0.1 - (10/7/2009) Fixed an issue in IE 8. Since both "IE7" and "IE8
//         Compatibility View" modes erroneously report that the browser
//         supports the native window.onhashchange event, a slightly more
//         robust test needed to be added.
// 1.0   - (10/2/2009) Initial release

(function($,window){
  '$:nomunge'; // Used by YUI compressor.
  
  // Some convenient shortcuts.
  var undefined,
    aps = Array.prototype.slice,
    decode = decodeURIComponent,
    
    // Method / object references.
    jq_param = $.param,
    jq_param_fragment,
    jq_deparam,
    jq_deparam_fragment,
    jq_bbq = $.bbq = $.bbq || {},
    jq_bbq_pushState,
    jq_bbq_getState,
    jq_elemUrlAttr,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_hashchange = 'hashchange',
    str_querystring = 'querystring',
    str_fragment = 'fragment',
    str_elemUrlAttr = 'elemUrlAttr',
    str_location = 'location',
    str_href = 'href',
    str_src = 'src',
    
    // Reused RegExp.
    re_trim_querystring = /^.*\?|#.*$/g,
    re_trim_fragment = /^.*\#/,
    re_no_escape,
    
    // Used by jQuery.elemUrlAttr.
    elemUrlAttr_cache = {};
  
  // A few commonly used bits, broken out to help reduce minified file size.
  
  function is_string( arg ) {
    return typeof arg === 'string';
  };
  
  // Why write the same function twice? Let's curry! Mmmm, curry..
  
  function curry( func ) {
    var args = aps.call( arguments, 1 );
    
    return function() {
      return func.apply( this, args.concat( aps.call( arguments ) ) );
    };
  };
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Get location.search (or what you'd expect location.search to be) sans any
  // leading #. Thanks for making this necessary, IE6!
  function get_querystring( url ) {
    return url.replace( /(?:^[^?#]*\?([^#]*).*$)?.*/, '$1' );
  };
  
  // Section: Param (to string)
  // 
  // Method: jQuery.param.querystring
  // 
  // Retrieve the query string from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing query string params to be parsed. If url
  //    is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed query string, with any leading "?" removed.
  //
  
  // Method: jQuery.param.querystring (build url)
  // 
  // Merge a URL, with or without pre-existing query string params, plus any
  // object, params string or URL containing query string params into a new URL.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing query string params to
  //    be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any query string
  //         params in url.
  //    * 1: any query string params in url will override params in the params
  //         argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded query string in the format 'a=b&c=d&e=f'.
  
  // Method: jQuery.param.fragment
  // 
  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing fragment (hash) params to be parsed. If
  //    url is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed fragment (hash) string, with any leading "#" removed.
  
  // Method: jQuery.param.fragment (build url)
  // 
  // Merge a URL, with or without pre-existing fragment (hash) params, plus any
  // object, params string or URL containing fragment (hash) params into a new
  // URL.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing fragment (hash) params
  //    to be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any fragment (hash)
  //         params in url.
  //    * 1: any fragment (hash) params in url will override params in the
  //         params argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded fragment (hash) in the format 'a=b&c=d&e=f'.
  
  function jq_param_sub( is_fragment, get_func, url, params, merge_mode ) {
    var result,
      qs,
      matches,
      url_params,
      hash;
    
    if ( params !== undefined ) {
      // Build URL by merging params into url string.
      
      // matches[1] = url part that precedes params, not including trailing ?/#
      // matches[2] = params, not including leading ?/#
      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''
      matches = url.match( is_fragment ? /^([^#]*)\#?(.*)$/ : /^([^#?]*)\??([^#]*)(#?.*)/ );
      
      // Get the hash if in 'querystring' mode, and it exists.
      hash = matches[3] || '';
      
      if ( merge_mode === 2 && is_string( params ) ) {
        // If merge_mode is 2 and params is a string, merge the fragment / query
        // string into the URL wholesale, without converting it into an object.
        qs = params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' );
        
      } else {
        // Convert relevant params in url to object.
        url_params = jq_deparam( matches[2] );
        
        params = is_string( params )
          
          // Convert passed params string into object.
          ? jq_deparam[ is_fragment ? str_fragment : str_querystring ]( params )
          
          // Passed params object.
          : params;
        
        qs = merge_mode === 2 ? params                              // passed params replace url params
          : merge_mode === 1  ? $.extend( {}, params, url_params )  // url params override passed params
          : $.extend( {}, url_params, params );                     // passed params override url params
        
        // Convert params object to a string.
        qs = jq_param( qs );
        
        // Unescape characters specified via $.param.noEscape. Since only hash-
        // history users have requested this feature, it's only enabled for
        // fragment-related params strings.
        if ( is_fragment ) {
          qs = qs.replace( re_no_escape, decode );
        }
      }
      
      // Build URL from the base url, querystring and hash. In 'querystring'
      // mode, ? is only added if a query string exists. In 'fragment' mode, #
      // is always added.
      result = matches[1] + ( is_fragment ? '#' : qs || !matches[1] ? '?' : '' ) + qs + hash;
      
    } else {
      // If URL was passed in, parse params from URL string, otherwise parse
      // params from window.location.
      result = get_func( url !== undefined ? url : window[ str_location ][ str_href ] );
    }
    
    return result;
  };
  
  jq_param[ str_querystring ]                  = curry( jq_param_sub, 0, get_querystring );
  jq_param[ str_fragment ] = jq_param_fragment = curry( jq_param_sub, 1, get_fragment );
  
  // Method: jQuery.param.fragment.noEscape
  // 
  // Specify characters that will be left unescaped when fragments are created
  // or merged using <jQuery.param.fragment>, or when the fragment is modified
  // using <jQuery.bbq.pushState>. This option only applies to serialized data
  // object fragments, and not set-as-string fragments. Does not affect the
  // query string. Defaults to ",/" (comma, forward slash).
  // 
  // Note that this is considered a purely aesthetic option, and will help to
  // create URLs that "look pretty" in the address bar or bookmarks, without
  // affecting functionality in any way. That being said, be careful to not
  // unescape characters that are used as delimiters or serve a special
  // purpose, such as the "#?&=+" (octothorpe, question mark, ampersand,
  // equals, plus) characters.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment.noEscape( [ chars ] );
  // 
  // Arguments:
  // 
  //  chars - (String) The characters to not escape in the fragment. If
  //    unspecified, defaults to empty string (escape all characters).
  // 
  // Returns:
  // 
  //  Nothing.
  
  jq_param_fragment.noEscape = function( chars ) {
    chars = chars || '';
    var arr = $.map( chars.split(''), encodeURIComponent );
    re_no_escape = new RegExp( arr.join('|'), 'g' );
  };
  
  // A sensible default. These are the characters people seem to complain about
  // "uglifying up the URL" the most.
  jq_param_fragment.noEscape( ',/' );
  
  // Section: Deparam (from string)
  // 
  // Method: jQuery.deparam
  // 
  // Deserialize a params string into an object, optionally coercing numbers,
  // booleans, null and undefined values; this method is the counterpart to the
  // internal jQuery.param method.
  // 
  // Usage:
  // 
  // > jQuery.deparam( params [, coerce ] );
  // 
  // Arguments:
  // 
  //  params - (String) A params string to be parsed.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  $.deparam = jq_deparam = function( params, coerce ) {
    var obj = {},
      coerce_types = { 'true': !0, 'false': !1, 'null': null };
    
    // Iterate over all name=value pairs.
    $.each( params.replace( /\+/g, ' ' ).split( '&' ), function(j,v){
      var param = v.split( '=' ),
        key = decode( param[0] ),
        val,
        cur = obj,
        i = 0,
        
        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
        // into its component parts.
        keys = key.split( '][' ),
        keys_last = keys.length - 1;
      
      // If the first keys part contains [ and the last ends with ], then []
      // are correctly balanced.
      if ( /\[/.test( keys[0] ) && /\]$/.test( keys[ keys_last ] ) ) {
        // Remove the trailing ] from the last keys part.
        keys[ keys_last ] = keys[ keys_last ].replace( /\]$/, '' );
        
        // Split first keys part into two parts on the [ and add them back onto
        // the beginning of the keys array.
        keys = keys.shift().split('[').concat( keys );
        
        keys_last = keys.length - 1;
      } else {
        // Basic 'foo' style key.
        keys_last = 0;
      }
      
      // Are we dealing with a name=value pair, or just a name?
      if ( param.length === 2 ) {
        val = decode( param[1] );
        
        // Coerce values.
        if ( coerce ) {
          val = val && !isNaN(val)            ? +val              // number
            : val === 'undefined'             ? undefined         // undefined
            : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
            : val;                                                // string
        }
        
        if ( keys_last ) {
          // Complex key, build deep object structure based on a few rules:
          // * The 'cur' pointer starts at the object top-level.
          // * [] = array push (n is set to array length), [n] = array if n is 
          //   numeric, otherwise object.
          // * If at the last keys part, set the value.
          // * For each keys part, if the current level is undefined create an
          //   object or array based on the type of the next keys part.
          // * Move the 'cur' pointer to the next level.
          // * Rinse & repeat.
          for ( ; i <= keys_last; i++ ) {
            key = keys[i] === '' ? cur.length : keys[i];
            cur = cur[key] = i < keys_last
              ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )
              : val;
          }
          
        } else {
          // Simple key, even simpler rules, since only scalars and shallow
          // arrays are allowed.
          
          if ( $.isArray( obj[key] ) ) {
            // val is already an array, so push on the next value.
            obj[key].push( val );
            
          } else if ( obj[key] !== undefined ) {
            // val isn't an array, but since a second value has been specified,
            // convert val into an array.
            obj[key] = [ obj[key], val ];
            
          } else {
            // val is a scalar.
            obj[key] = val;
          }
        }
        
      } else if ( key ) {
        // No value was defined, so set something meaningful.
        obj[key] = coerce
          ? undefined
          : '';
      }
    });
    
    return obj;
  };
  
  // Method: jQuery.deparam.querystring
  // 
  // Parse the query string from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.querystring( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing query string
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  // Method: jQuery.deparam.fragment
  // 
  // Parse the fragment (hash) from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.fragment( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing fragment (hash)
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  function jq_deparam_sub( is_fragment, url_or_params, coerce ) {
    if ( url_or_params === undefined || typeof url_or_params === 'boolean' ) {
      // url_or_params not specified.
      coerce = url_or_params;
      url_or_params = jq_param[ is_fragment ? str_fragment : str_querystring ]();
    } else {
      url_or_params = is_string( url_or_params )
        ? url_or_params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' )
        : url_or_params;
    }
    
    return jq_deparam( url_or_params, coerce );
  };
  
  jq_deparam[ str_querystring ]                    = curry( jq_deparam_sub, 0 );
  jq_deparam[ str_fragment ] = jq_deparam_fragment = curry( jq_deparam_sub, 1 );
  
  // Section: Element manipulation
  // 
  // Method: jQuery.elemUrlAttr
  // 
  // Get the internal "Default URL attribute per tag" list, or augment the list
  // with additional tag-attribute pairs, in case the defaults are insufficient.
  // 
  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list
  // is used to determine which attribute contains the URL to be modified, if
  // an "attr" param is not specified.
  // 
  // Default Tag-Attribute List:
  // 
  //  a      - href
  //  base   - href
  //  iframe - src
  //  img    - src
  //  input  - src
  //  form   - action
  //  link   - href
  //  script - src
  // 
  // Usage:
  // 
  // > jQuery.elemUrlAttr( [ tag_attr ] );
  // 
  // Arguments:
  // 
  //  tag_attr - (Object) An object containing a list of tag names and their
  //    associated default attribute names in the format { tag: 'attr', ... } to
  //    be merged into the internal tag-attribute list.
  // 
  // Returns:
  // 
  //  (Object) An object containing all stored tag-attribute values.
  
  // Only define function and set defaults if function doesn't already exist, as
  // the urlInternal plugin will provide this method as well.
  $[ str_elemUrlAttr ] || ($[ str_elemUrlAttr ] = function( obj ) {
    return $.extend( elemUrlAttr_cache, obj );
  })({
    a: str_href,
    base: str_href,
    iframe: str_src,
    img: str_src,
    input: str_src,
    form: 'action',
    link: str_href,
    script: str_src
  });
  
  jq_elemUrlAttr = $[ str_elemUrlAttr ];
  
  // Method: jQuery.fn.querystring
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing query string params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing query string params, or params string
  //    to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any query string in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  // Method: jQuery.fn.fragment
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing fragment/hash params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing fragment (hash) params, or params
  //    string to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any fragment (hash) in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  function jq_fn_sub( mode, force_attr, params, merge_mode ) {
    if ( !is_string( params ) && typeof params !== 'object' ) {
      // force_attr not specified.
      merge_mode = params;
      params = force_attr;
      force_attr = undefined;
    }
    
    return this.each(function(){
      var that = $(this),
        
        // Get attribute specified, or default specified via $.elemUrlAttr.
        attr = force_attr || jq_elemUrlAttr()[ ( this.nodeName || '' ).toLowerCase() ] || '',
        
        // Get URL value.
        url = attr && that.attr( attr ) || '';
      
      // Update attribute with new URL.
      that.attr( attr, jq_param[ mode ]( url, params, merge_mode ) );
    });
    
  };
  
  $.fn[ str_querystring ] = curry( jq_fn_sub, str_querystring );
  $.fn[ str_fragment ]    = curry( jq_fn_sub, str_fragment );
  
  // Section: History, hashchange event
  // 
  // Method: jQuery.bbq.pushState
  // 
  // Adds a 'state' into the browser history at the current position, setting
  // location.hash and triggering any bound <hashchange event> callbacks
  // (provided the new state is different than the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );
  // 
  // Arguments:
  // 
  //  params - (String) A serialized params string or a hash string beginning
  //    with # to merge into location.hash.
  //  params - (Object) A params object to merge into location.hash.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified (unless a hash string beginning with # is specified, in which
  //    case merge behavior defaults to 2), and is as-follows:
  // 
  //    * 0: params in the params argument will override any params in the
  //         current state.
  //    * 1: any params in the current state will override params in the params
  //         argument.
  //    * 2: params argument will completely replace current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  //  * Unlike the fragment and querystring methods, if a hash string beginning
  //    with # is specified as the params agrument, merge_mode defaults to 2.
  
  jq_bbq.pushState = jq_bbq_pushState = function( params, merge_mode ) {
    if ( is_string( params ) && /^#/.test( params ) && merge_mode === undefined ) {
      // Params string begins with # and merge_mode not specified, so completely
      // overwrite window.location.hash.
      merge_mode = 2;
    }
    
    var has_args = params !== undefined,
      // Merge params into window.location using $.param.fragment.
      url = jq_param_fragment( window[ str_location ][ str_href ],
        has_args ? params : {}, has_args ? merge_mode : 2 );
    
    // Set new window.location.href. If hash is empty, use just # to prevent
    // browser from reloading the page. Note that Safari 3 & Chrome barf on
    // location.hash = '#'.
    window[ str_location ][ str_href ] = url + ( /#/.test( url ) ? '' : '#' );
  };
  
  // Method: jQuery.bbq.getState
  // 
  // Retrieves the current 'state' from the browser history, parsing
  // location.hash for a specific key or returning an object containing the
  // entire state, optionally coercing numbers, booleans, null and undefined
  // values.
  // 
  // Usage:
  // 
  // > jQuery.bbq.getState( [ key ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  key - (String) An optional state key for which to return a value.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false.
  // 
  // Returns:
  // 
  //  (Anything) If key is passed, returns the value corresponding with that key
  //    in the location.hash 'state', or undefined. If not, an object
  //    representing the entire 'state' is returned.
  
  jq_bbq.getState = jq_bbq_getState = function( key, coerce ) {
    return key === undefined || typeof key === 'boolean'
      ? jq_deparam_fragment( key ) // 'key' really means 'coerce' here
      : jq_deparam_fragment( coerce )[ key ];
  };
  
  // Method: jQuery.bbq.removeState
  // 
  // Remove one or more keys from the current browser history 'state', creating
  // a new state, setting location.hash and triggering any bound
  // <hashchange event> callbacks (provided the new state is different than
  // the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.removeState( [ key [, key ... ] ] );
  // 
  // Arguments:
  // 
  //  key - (String) One or more key values to remove from the current state,
  //    passed as individual arguments.
  //  key - (Array) A single array argument that contains a list of key values
  //    to remove from the current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  
  jq_bbq.removeState = function( arr ) {
    var state = {};
    
    // If one or more arguments is passed..
    if ( arr !== undefined ) {
      
      // Get the current state.
      state = jq_bbq_getState();
      
      // For each passed key, delete the corresponding property from the current
      // state.
      $.each( $.isArray( arr ) ? arr : arguments, function(i,v){
        delete state[ v ];
      });
    }
    
    // Set the state, completely overriding any existing state.
    jq_bbq_pushState( state, 2 );
  };
  
  // Event: hashchange event (BBQ)
  // 
  // Usage in jQuery 1.4 and newer:
  // 
  // In jQuery 1.4 and newer, the event object passed into any hashchange event
  // callback is augmented with a copy of the location.hash fragment at the time
  // the event was triggered as its event.fragment property. In addition, the
  // event.getState method operates on this property (instead of location.hash)
  // which allows this fragment-as-a-state to be referenced later, even after
  // window.location may have changed.
  // 
  // Note that event.fragment and event.getState are not defined according to
  // W3C (or any other) specification, but will still be available whether or
  // not the hashchange event exists natively in the browser, because of the
  // utility they provide.
  // 
  // The event.fragment property contains the output of <jQuery.param.fragment>
  // and the event.getState method is equivalent to the <jQuery.bbq.getState>
  // method.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = event.fragment,
  // >     param_obj = event.getState(),
  // >     param_val = event.getState( 'param_name' ),
  // >     param_val_coerced = event.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Usage in jQuery 1.3.2:
  // 
  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,
  // so the fragment state isn't bound to the event object and must instead be
  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = $.param.fragment(),
  // >     param_obj = $.bbq.getState(),
  // >     param_val = $.bbq.getState( 'param_name' ),
  // >     param_val_coerced = $.bbq.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is
  //   required to enable the augmented event object in jQuery 1.4.2 and newer.
  // * See <jQuery hashchange event> for more detailed information.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Augmenting the event object with the .fragment property and .getState
    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will
    // work, but the event won't be augmented)
    add: function( handleObj ) {
      var old_handler;
      
      function new_handler(e) {
        // e.fragment is set to the value of location.hash (with any leading #
        // removed) at the time the event is triggered.
        var hash = e[ str_fragment ] = jq_param_fragment();
        
        // e.getState() works just like $.bbq.getState(), but uses the
        // e.fragment property stored on the event object.
        e.getState = function( key, coerce ) {
          return key === undefined || typeof key === 'boolean'
            ? jq_deparam( hash, key ) // 'key' really means 'coerce' here
            : jq_deparam( hash, coerce )[ key ];
        };
        
        old_handler.apply( this, arguments );
      };
      
      // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+
      if ( $.isFunction( handleObj ) ) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
    
  });
  
})(jQuery,this);

/*!
 * jQuery hashchange event - v1.2 - 2/11/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.2, Last updated: 2/11/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (1.1kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// This working example, complete with fully commented code, illustrate one way
// in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.7, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and robust,
// there are a few unfortunate browser bugs surrounding expected hashchange
// event-based behaviors, independent of any JavaScript window.onhashchange
// abstraction. See the following examples for more information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// About: Release History
// 
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Method / object references.
  var fake_onhashchange,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_location = 'location',
    str_hashchange = 'hashchange',
    str_href = 'href',
    
    // IE6/7 specifically need some special love when it comes to back-button
    // support, so let's do a little browser sniffing..
    browser = $.browser,
    mode = document.documentMode,
    is_old_ie = browser.msie && ( mode === undefined || mode < 8 ),
    
    // Does the browser support window.onhashchange? Test for IE version, since
    // IE8 incorrectly reports this when in "IE7" or "IE8 Compatibility View"!
    supports_onhashchange = 'on' + str_hashchange in window && !is_old_ie;
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || window[ str_location ][ str_href ];
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Property: jQuery.hashchangeDelay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 100.
  
  $[ str_hashchange + 'Delay' ] = 100;
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // window.onhashchange event is used (IE8, FF3.6), otherwise a polling loop is
  // initialized, running every <jQuery.hashchangeDelay> milliseconds to see if
  // the hash has changed. In IE 6 and 7, a hidden Iframe is created to allow
  // the back button and hash-based history to work.
  // 
  // Usage:
  // 
  // > $(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one callback
  //   is actually bound to 'hashchange'.
  // * If you need the bound callback(s) to execute immediately, in cases where
  //   the page 'state' exists on page load (via bookmark or page refresh, for
  //   example) use $(window).trigger( 'hashchange' );
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a $(document).ready() callback.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      iframe,
      set_history,
      get_history;
    
    // Initialize. In IE 6/7, creates a hidden Iframe for history handling.
    function init(){
      // Most browsers don't need special methods here..
      set_history = get_history = function(val){ return val; };
      
      // But IE6/7 do!
      if ( is_old_ie ) {
        
        // Create hidden Iframe after the end of the body to prevent initial
        // page load from scrolling unnecessarily.
        iframe = $('<iframe src="javascript:0"/>').hide().insertAfter( 'body' )[0].contentWindow;
        
        // Get history by looking at the hidden Iframe's location.hash.
        get_history = function() {
          return get_fragment( iframe.document[ str_location ][ str_href ] );
        };
        
        // Set a new history item by opening and then closing the Iframe
        // document, *then* setting its location.hash.
        set_history = function( hash, history_hash ) {
          if ( hash !== history_hash ) {
            var doc = iframe.document;
            doc.open().close();
            doc[ str_location ].hash = '#' + hash;
          }
        };
        
        // Set initial history.
        set_history( get_fragment() );
      }
    };
    
    // Start the polling loop.
    self.start = function() {
      // Polling loop is already running!
      if ( timeout_id ) { return; }
      
      // Remember the initial hash so it doesn't get triggered immediately.
      var last_hash = get_fragment();
      
      // Initialize if not yet initialized.
      set_history || init();
      
      // This polling loop checks every $.hashchangeDelay milliseconds to see if
      // location.hash has changed, and triggers the 'hashchange' event on
      // window when necessary.
      (function loopy(){
        var hash = get_fragment(),
          history_hash = get_history( last_hash );
        
        if ( hash !== last_hash ) {
          set_history( last_hash = hash, history_hash );
          
          $(window).trigger( str_hashchange );
          
        } else if ( history_hash !== last_hash ) {
          window[ str_location ][ str_href ] = window[ str_location ][ str_href ].replace( /#.*/, '' ) + '#' + history_hash;
        }
        
        timeout_id = setTimeout( loopy, $[ str_hashchange + 'Delay' ] );
      })();
    };
    
    // Stop the polling loop, but only if an IE6/7 Iframe wasn't created. In
    // that case, even if there are no longer any bound event handlers, the
    // polling loop is still necessary for back/next to work at all!
    self.stop = function() {
      if ( !iframe ) {
        timeout_id && clearTimeout( timeout_id );
        timeout_id = 0;
      }
    };
    
    return self;
  })();
  
})(jQuery,this);




/*
 * jQuery wizard plug-in 3.0.5
 *
 *
 * Copyright (c) 2011 Jan Sundman (jan.sundman[at]aland.net)
 *
 * http://www.thecodemine.org
 *
 * Licensed under the MIT licens:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 */


(function ($) {
    $.widget("ui.formwizard", {

        _init: function () {

            var wizard = this;
            var formOptionsSuccess = this.options.formOptions.success;
            var formOptionsComplete = this.options.formOptions.complete;
            var formOptionsBeforeSend = this.options.formOptions.beforeSend;
            var formOptionsBeforeSubmit = this.options.formOptions.beforeSubmit;
            var formOptionsBeforeSerialize = this.options.formOptions.beforeSerialize;
            this.options.formOptions = $.extend(this.options.formOptions, {
                success: function (responseText, textStatus, xhr) {
                    if (formOptionsSuccess) {
                        formOptionsSuccess(responseText, textStatus, xhr);
                    }
                    if (wizard.options.formOptions && wizard.options.formOptions.resetForm || !wizard.options.formOptions) {
                        wizard._reset();
                    }
                },
                complete: function (xhr, textStatus) {
                    if (formOptionsComplete) {
                        formOptionsComplete(xhr, textStatus);
                    }
                    wizard._enableNavigation();
                },
                beforeSubmit: function (arr, theForm, options) {
                    if (formOptionsBeforeSubmit) {
                        var shouldSubmit = formOptionsBeforeSubmit(arr, theForm, options);
                        if (!shouldSubmit)
                            wizard._enableNavigation();
                        return shouldSubmit;
                    }
                },
                beforeSend: function (xhr) {
                    if (formOptionsBeforeSend) {
                        var shouldSubmit = formOptionsBeforeSend(xhr);
                        if (!shouldSubmit)
                            wizard._enableNavigation();
                        return shouldSubmit;
                    }
                },
                beforeSerialize: function (form, options) {
                    if (formOptionsBeforeSerialize) {
                        var shouldSubmit = formOptionsBeforeSerialize(form, options);
                        if (!shouldSubmit)
                            wizard._enableNavigation();
                        return shouldSubmit;
                    }
                }
            });

            this.steps = this.element.find(".step").hide();

            this.firstStep = this.steps.eq(0).attr("id");
            this.activatedSteps = new Array();
            this.isLastStep = false;
            this.previousStep = undefined;
            this.currentStep = this.steps.eq(0).attr("id");
            this.nextButton = this.element.find(this.options.next)
					.click(function () {
					    return wizard._next();
					});

            this.nextButtonInitinalValue = this.nextButton.val();
            this.nextButton.val(this.options.textNext);

            this.backButton = this.element.find(this.options.back)
					.click(function () {
					    wizard._back(); return false;
					});

            this.backButtonInitinalValue = this.backButton.val();
            this.backButton.val(this.options.textBack);

            if (this.options.validationEnabled && jQuery().validate == undefined) {
                this.options.validationEnabled = false;
                if ((window['console'] !== undefined)) {
                    console.log("%s", "validationEnabled option set, but the validation plugin is not included");
                }
            } else if (this.options.validationEnabled) {
                this.element.validate(this.options.validationOptions);
            }
            if (this.options.formPluginEnabled && jQuery().ajaxSubmit == undefined) {
                this.options.formPluginEnabled = false;
                if ((window['console'] !== undefined)) {
                    console.log("%s", "formPluginEnabled option set but the form plugin is not included");
                }
            }

            if (this.options.disableInputFields == true) {
                $(this.steps).find(":input:not('.wizard-ignore')").attr("disabled", "disabled");
            }

            if (this.options.historyEnabled) {
                $(window).bind('hashchange', undefined, function (event) {
                    var hashStep = event.getState("_" + $(wizard.element).attr('id')) || wizard.firstStep;
                    if (hashStep !== wizard.currentStep) {
                        if (wizard.options.validationEnabled && hashStep === wizard._navigate(wizard.currentStep)) {
                            if (!wizard.element.valid()) {
                                wizard._updateHistory(wizard.currentStep);
                                wizard.element.validate().focusInvalid();

                                return false;
                            }
                        }
                        if (hashStep !== wizard.currentStep)
                            wizard._show(hashStep);
                    }
                });
            }

            this.element.addClass("ui-formwizard");
            this.element.find(":input").addClass("ui-wizard-content");
            this.steps.addClass("ui-formwizard-content");
            this.backButton.addClass("ui-formwizard-button ui-wizard-content");
            this.nextButton.addClass("ui-formwizard-button ui-wizard-content");

            if (!this.options.disableUIStyles) {
                this.element.addClass("ui-helper-reset ui-widget ui-widget-content ui-helper-reset ui-corner-all");
                this.element.find(":input").addClass("ui-helper-reset ui-state-default");
                this.steps.addClass("ui-helper-reset ui-corner-all");
                this.backButton.addClass("ui-helper-reset ui-state-default");
                this.nextButton.addClass("ui-helper-reset ui-state-default");
            }
            this._show(undefined);
            return $(this);
        },

        _next: function () {
            if (this.options.validationEnabled) {
                if (!this.element.valid()) {
                    this.element.validate().focusInvalid();
                    return false;
                }
            }

            if (this.options.remoteAjax != undefined) {
                var options = this.options.remoteAjax[this.currentStep];
                var wizard = this;
                if (options !== undefined) {
                    var success = options.success;
                    var beforeSend = options.beforeSend;
                    var complete = options.complete;

                    options = $.extend({}, options, {
                        success: function (data, statusText) {
                            if ((success !== undefined && success(data, statusText)) || (success == undefined)) {
                                wizard._continueToNextStep();
                            }
                        },
                        beforeSend: function (xhr) {
                            wizard._disableNavigation();
                            if (beforeSend !== undefined)
                                beforeSend(xhr);
                            $(wizard.element).trigger('before_remote_ajax', { "currentStep": wizard.currentStep });
                        },
                        complete: function (xhr, statusText) {
                            if (complete !== undefined)
                                complete(xhr, statusText);
                            $(wizard.element).trigger('after_remote_ajax', { "currentStep": wizard.currentStep });
                            wizard._enableNavigation();
                        }
                    })
                    this.element.ajaxSubmit(options);
                    return false;
                }
            }

            return this._continueToNextStep();
        },

        _back: function () {
            if (this.activatedSteps.length > 0) {
                if (this.options.historyEnabled) {
                    this._updateHistory(this.activatedSteps[this.activatedSteps.length - 2]);
                } else {
                    this._show(this.activatedSteps[this.activatedSteps.length - 2], true);
                }
            }
            return false;
        },

        _continueToNextStep: function () {
            if (this.isLastStep) {
                for (var i = 0; i < this.activatedSteps.length; i++) {
                    this.steps.filter("#" + this.activatedSteps[i]).find(":input").not(".wizard-ignore").removeAttr("disabled");
                }
                if (!this.options.formPluginEnabled) {
                    return true;
                } else {
                    this._disableNavigation();
                    this.element.ajaxSubmit(this.options.formOptions);
                    return false;
                }
            }

            var step = this._navigate(this.currentStep);
            if (step == this.currentStep) {
                return false;
            }
            if (this.options.historyEnabled) {
                this._updateHistory(step);
            } else {
                this._show(step, true);
            }
            return false;
        },

        _updateHistory: function (step) {
            var state = {};
            state["_" + $(this.element).attr('id')] = step;
            $.bbq.pushState(state);
        },

        _disableNavigation: function () {
            this.nextButton.attr("disabled", "disabled");
            this.backButton.attr("disabled", "disabled");
            if (!this.options.disableUIStyles) {
                this.nextButton.removeClass("ui-state-active").addClass("ui-state-disabled");
                this.backButton.removeClass("ui-state-active").addClass("ui-state-disabled");
            }
        },

        _enableNavigation: function () {
            if (this.isLastStep) {
                this.nextButton.val(this.options.textSubmit);
            } else {
                this.nextButton.val(this.options.textNext);
            }

            if ($.trim(this.currentStep) !== this.steps.eq(0).attr("id")) {
                this.backButton.removeAttr("disabled");
                if (!this.options.disableUIStyles) {
                    this.backButton.removeClass("ui-state-disabled").addClass("ui-state-active");
                }
            }

            this.nextButton.removeAttr("disabled");
            if (!this.options.disableUIStyles) {
                this.nextButton.removeClass("ui-state-disabled").addClass("ui-state-active");
            }
        },

        _animate: function (oldStep, newStep, stepShownCallback) {
            this._disableNavigation();
            var old = this.steps.filter("#" + oldStep);
            var current = this.steps.filter("#" + newStep);
            //old.find(":input").not(".wizard-ignore").attr("disabled", "disabled");
            //current.find(":input").not(".wizard-ignore").removeAttr("disabled");
            var wizard = this;

            $(old).hide();
            $(current).show();
            if (wizard.options.focusFirstInput)
                current.find(":input:first").focus();
            wizard._enableNavigation();

            stepShownCallback.apply(wizard);

            /*old.animate(wizard.options.outAnimation, wizard.options.outDuration, wizard.options.easing, function () {
                current.animate(wizard.options.inAnimation, wizard.options.inDuration, wizard.options.easing, function () {
                    if (wizard.options.focusFirstInput)
                        current.find(":input:first").focus();
                    wizard._enableNavigation();

                    stepShownCallback.apply(wizard);
                });
                return;
            });*/
        },

        _checkIflastStep: function (step) {
            this.isLastStep = false;
            if ($("#" + step).hasClass(this.options.submitStepClass) || this.steps.filter(":last").attr("id") == step) {
                this.isLastStep = true;
            }
        },

        _getLink: function (step) {
            var link = undefined;
            var links = this.steps.filter("#" + step).find(this.options.linkClass);

            if (links != undefined) {
                if (links.filter(":radio,:checkbox").size() > 0) {
                    link = links.filter(this.options.linkClass + ":checked").val();
                } else {
                    link = $(links).val();
                }
            }
            return link;
        },

        _navigate: function (step) {
            var link = this._getLink(step);
            if (link != undefined) {
                if ((link != "" && link != null && link != undefined) && this.steps.filter("#" + link).attr("id") != undefined) {
                    return link;
                }
                return this.currentStep;
            } else if (link == undefined && !this.isLastStep) {
                var step1 = this.steps.filter("#" + step).next().attr("id");
                return step1;
            }
        },

        _show: function (step) {
            var backwards = false;
            var triggerStepShown = step !== undefined;
            if (step == undefined || step == "") {
                this.activatedSteps.pop();
                step = this.firstStep;
                this.activatedSteps.push(step);
            } else {
                var index = $.inArray(step, this.activatedSteps);
                if (index > -1) {
                    backwards = true;
                    this.activatedSteps.splice(index + 1, this.activatedSteps.length);
                } else {
                    this.activatedSteps.push(step);
                }
            }

            if (this.currentStep !== step || step === this.firstStep) {
                this.previousStep = this.currentStep;
                this._checkIflastStep(step);
                this.currentStep = step;
                var stepShownCallback = function () { if (triggerStepShown) $(this.element).trigger('step_shown', $.extend({ "isBackNavigation": backwards }, this._state())); };
                this._animate(this.previousStep, step, stepShownCallback);
            };


        },

        _reset: function () {
            this.element.resetForm()
            $("label,:input,textarea", this).removeClass("error");
            for (var i = 0; i < this.activatedSteps.length; i++) {
                this.steps.filter("#" + this.activatedSteps[i]).hide();
                //.find(":input").attr("disabled", "disabled");
            }
            this.activatedSteps = new Array();
            this.previousStep = undefined;
            this.isLastStep = false;
            if (this.options.historyEnabled) {
                this._updateHistory(this.firstStep);
            } else {
                this._show(this.firstStep);
            }

        },

        _state: function (state) {
            var currentState = { "settings": this.options,
                "activatedSteps": this.activatedSteps,
                "isLastStep": this.isLastStep,
                "isFirstStep": this.currentStep === this.firstStep,
                "previousStep": this.previousStep,
                "currentStep": this.currentStep,
                "backButton": this.backButton,
                "nextButton": this.nextButton,
                "steps": this.steps,
                "firstStep": this.firstStep
            }

            if (state !== undefined)
                return currentState[state];

            return currentState;
        },

        /*Methods*/

        show: function (step) {
            if (this.options.historyEnabled) {
                this._updateHistory(step);
            } else {
                this._show(step);
            }
        },

        state: function (state) {
            return this._state(state);
        },

        reset: function () {
            this._reset();
        },

        next: function () {
            this._next();
        },

        back: function () {
            this._back();
        },

        destroy: function () {
            this.element.find("*").removeAttr("disabled").show();
            this.nextButton.unbind("click").val(this.nextButtonInitinalValue).removeClass("ui-state-disabled").addClass("ui-state-active");
            this.backButton.unbind("click").val(this.backButtonInitinalValue).removeClass("ui-state-disabled").addClass("ui-state-active");
            this.backButtonInitinalValue = undefined;
            this.nextButtonInitinalValue = undefined;
            this.activatedSteps = undefined;
            this.previousStep = undefined;
            this.currentStep = undefined;
            this.isLastStep = undefined;
            this.options = undefined;
            this.nextButton = undefined;
            this.backButton = undefined;
            this.formwizard = undefined;
            this.element = undefined;
            this.steps = undefined;
            this.firstStep = undefined;
        },

        update_steps: function () {
            this.steps = this.element.find(".step").addClass("ui-formwizard-content");
            this.steps.not("#" + this.currentStep).hide();
            //.find(":input").addClass("ui-wizard-content").attr("disabled", "disabled");
            this._checkIflastStep(this.currentStep);
            this._enableNavigation();
            if (!this.options.disableUIStyles) {
                this.steps.addClass("ui-helper-reset ui-corner-all");
                this.steps.find(":input").addClass("ui-helper-reset ui-state-default");
            }
        },

        options: {
            historyEnabled: false,
            validationEnabled: false,
            validationOptions: undefined,
            formPluginEnabled: false,
            linkClass: ".link",
            submitStepClass: "submit_step",
            back: ":reset",
            next: ":submit",
            textSubmit: 'Submit',
            textNext: 'Next',
            textBack: 'Back',
            remoteAjax: undefined,
            inAnimation: { opacity: 'show' },
            outAnimation: { opacity: 'hide' },
            inDuration: 400,
            outDuration: 400,
            easing: 'swing',
            focusFirstInput: false,
            disableInputFields: true,
            formOptions: { reset: true, success: function (data) { if ((window['console'] !== undefined)) { console.log("%s", "form submit successful"); } },
                disableUIStyles: false
            }
        }
    });
})(jQuery);



(function() {
	
	var BrowserDetect = {
		init: function () {
			this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
			this.version = this.searchVersion(navigator.userAgent)
				|| this.searchVersion(navigator.appVersion)
				|| "an unknown version";
			this.OS = this.searchString(this.dataOS) || "an unknown OS";
		},
		searchString: function (data) {
			for (var i=0;i<data.length;i++)	{
				var dataString = data[i].string;
				var dataProp = data[i].prop;
				this.versionSearchString = data[i].versionSearch || data[i].identity;
				if (dataString) {
					if (dataString.indexOf(data[i].subString) != -1)
						return data[i].identity;
				}
				else if (dataProp)
					return data[i].identity;
			}
		},
		searchVersion: function (dataString) {
			var index = dataString.indexOf(this.versionSearchString);
			if (index == -1) return;
			return parseFloat(dataString.substring(index+this.versionSearchString.length+1));
		},
		dataBrowser: [
			{
				string: navigator.userAgent,
				subString: "Chrome",
				identity: "Chrome"
			},
			{ 	string: navigator.userAgent,
				subString: "OmniWeb",
				versionSearch: "OmniWeb/",
				identity: "OmniWeb"
			},
			{
				string: navigator.vendor,
				subString: "Apple",
				identity: "Safari",
				versionSearch: "Version"
			},
			{
				prop: window.opera,
				identity: "Opera"
			},
			{
				string: navigator.vendor,
				subString: "iCab",
				identity: "iCab"
			},
			{
				string: navigator.vendor,
				subString: "KDE",
				identity: "Konqueror"
			},
			{
				string: navigator.userAgent,
				subString: "Firefox",
				identity: "Firefox"
			},
			{
				string: navigator.vendor,
				subString: "Camino",
				identity: "Camino"
			},
			{		// for newer Netscapes (6+)
				string: navigator.userAgent,
				subString: "Netscape",
				identity: "Netscape"
			},
			{
				string: navigator.userAgent,
				subString: "MSIE",
				identity: "Explorer",
				versionSearch: "MSIE"
			},
			{
				string: navigator.userAgent,
				subString: "Gecko",
				identity: "Mozilla",
				versionSearch: "rv"
			},
			{ 		// for older Netscapes (4-)
				string: navigator.userAgent,
				subString: "Mozilla",
				identity: "Netscape",
				versionSearch: "Mozilla"
			}
		],
		dataOS : [
			{
				string: navigator.platform,
				subString: "Win",
				identity: "Windows"
			},
			{
				string: navigator.platform,
				subString: "Mac",
				identity: "Mac"
			},
			{
				string: navigator.userAgent,
				subString: "iPhone",
				identity: "iPhone/iPod"
		    },
			{
				string: navigator.platform,
				subString: "Linux",
				identity: "Linux"
			}
		]
	
	};
	
	BrowserDetect.init();
	
	window.$.client = { os : BrowserDetect.OS, browser : BrowserDetect.browser };
	
})();


var base = 1024;

function getReadableSpeedString(speedInKBytesPerSec)
{
	var speed = speedInKBytesPerSec;
	speed = Math.round(speed * 10) / 10;
	if (speed < base) {
		return speed + "KB/s";
	}

	speed /= base;
	speed = Math.round(speed * 10) / 10;
	if (speed < base) {
		return speed + "MB/s";
	}

	return speedInBytesPerSec + "B/s";				
}

function getReadableFileSizeString(fileSizeInBytes)
{
	var fileSize = fileSizeInBytes;
	if (fileSize < base) {
		return fileSize + "B";
	}

	fileSize /= base;
	fileSize = Math.round(fileSize);
	if (fileSize < base) {
		return fileSize + "KB";
	}
	
	fileSize /= base;
	fileSize = Math.round(fileSize * 10) / 10;
	if (fileSize < base) {
		return fileSize + "MB";
	}

	return fileSizeInBytes + "B";
}

function getReadableDurationString(duration)
{
	var elapsed = duration;

	var minutes, seconds;

	seconds = Math.floor(elapsed / 1000);
	minutes = Math.floor((seconds / 60));
	seconds = seconds - (minutes * 60);

	var str = "";
	if (minutes>0)
		str += minutes + "m";

	str += seconds + "s";
	return str;
}


/// <reference path="..\JQuery\jquery-1.6.4.js" />
/// <reference path="..\JQuery\jquery.validate.js" />

// register custom jQuery methods

jQuery.validator.addMethod("regex", function(value, element, params) {
    if (this.optional(element)) {
        return true;
    }

    var match = new RegExp(params).exec(value);
    return (match && (match.index == 0) && (match[0].length == value.length));
});

// glue

function __MVC_ApplyValidator_Range(object, min, max) {
    object["range"] = [min, max];
}

function __MVC_ApplyValidator_RegularExpression(object, pattern) {
    object["regex"] = pattern;
}

function __MVC_ApplyValidator_Required(object) {
    object["required"] = true;
}

function __MVC_ApplyValidator_StringLength(object, maxLength) {
    object["maxlength"] = maxLength;
}

function __MVC_ApplyValidator_Unknown(object, validationType, validationParameters) {
    object[validationType] = validationParameters;
}

function __MVC_CreateFieldToValidationMessageMapping(validationFields) {
    var mapping = {};

    for (var i = 0; i < validationFields.length; i++) {
        var thisField = validationFields[i];
        mapping[thisField.FieldName] = "#" + thisField.ValidationMessageId;
    }

    return mapping;
}

function __MVC_CreateErrorMessagesObject(validationFields) {
    var messagesObj = {};

    for (var i = 0; i < validationFields.length; i++) {
        var thisField = validationFields[i];
        var thisFieldMessages = {};
        messagesObj[thisField.FieldName] = thisFieldMessages;
        var validationRules = thisField.ValidationRules;

        for (var j = 0; j < validationRules.length; j++) {
            var thisRule = validationRules[j];
            if (thisRule.ErrorMessage) {
                var jQueryValidationType = thisRule.ValidationType;
                switch (thisRule.ValidationType) {
                    case "regularExpression":
                        jQueryValidationType = "regex";
                        break;
                    case "stringLength":
                        jQueryValidationType = "maxlength";
                        break;
                }

                thisFieldMessages[jQueryValidationType] = thisRule.ErrorMessage;
            }
        }
    }

    return messagesObj;
}

function __MVC_CreateRulesForField(validationField) {
    var validationRules = validationField.ValidationRules;

    // hook each rule into jquery
    var rulesObj = {};
    for (var i = 0; i < validationRules.length; i++) {
        var thisRule = validationRules[i];
        switch (thisRule.ValidationType) {
            case "range":
                __MVC_ApplyValidator_Range(rulesObj,
                    thisRule.ValidationParameters["minimum"], thisRule.ValidationParameters["maximum"]);
                break;

            case "regularExpression":
                __MVC_ApplyValidator_RegularExpression(rulesObj,
                    thisRule.ValidationParameters["pattern"]);
                break;

            case "required":
                __MVC_ApplyValidator_Required(rulesObj);
                break;

            case "stringLength":
                __MVC_ApplyValidator_StringLength(rulesObj,
                    thisRule.ValidationParameters["maximumLength"]);
                break;

            default:
                __MVC_ApplyValidator_Unknown(rulesObj,
                    thisRule.ValidationType, thisRule.ValidationParameters);
                break;
        }
    }

    return rulesObj;
}

function __MVC_CreateValidationOptions(validationFields) {
    var rulesObj = {};
    for (var i = 0; i < validationFields.length; i++) {
        var validationField = validationFields[i];
        var fieldName = validationField.FieldName;
        rulesObj[fieldName] = __MVC_CreateRulesForField(validationField);
    }

    return rulesObj;
}

function __MVC_EnableClientValidation(validationContext) {
    // this represents the form containing elements to be validated
    var theForm = $("#" + validationContext.FormId);

    var fields = validationContext.Fields;
    for (var i = 0; i < fields.length; i++) {
        if (document.getElementsByName(fields[i].FieldName)[0] == undefined) {
            var idField = document.getElementsByName(fields[i].FieldName + ".Id");
            if (idField && idField.length > 0) {
                fields[i].FieldName = idField[0].name;
            }
        }
    }
    var rulesObj = __MVC_CreateValidationOptions(fields);
    var fieldToMessageMappings = __MVC_CreateFieldToValidationMessageMapping(fields);
    var errorMessagesObj = __MVC_CreateErrorMessagesObject(fields);

    var options = {
        errorClass: "input-validation-error",
        errorElement: "span",
        errorPlacement: function (error, element) {
            var messageSpan = !isEmpty(fieldToMessageMappings[element.attr("name")]) ? fieldToMessageMappings[element.attr("name")] : '#' + (!isEmpty(element.attr('id')) ? element.attr('id').replace(new RegExp("\\[", "g"), "\\[").replace(new RegExp("\\]", "g"), "\\]") : element.attr('name')) + '_validationMessage';
            $(messageSpan).empty();
            $(messageSpan).removeClass("field-validation-valid");
            $(messageSpan).addClass("field-validation-error");
            error.removeClass("input-validation-error");
            error.attr("_for_validation_message", messageSpan);
            error.appendTo(messageSpan);
        },
        messages: errorMessagesObj,
        rules: rulesObj,
        success: function (label) {
            var messageSpan = $(label.attr("_for_validation_message"));
            $(messageSpan).empty();
            $(messageSpan).addClass("field-validation-valid");
            $(messageSpan).removeClass("field-validation-error");
        }
    };

    // register callbacks with our AJAX system
    var formElement = document.getElementById(validationContext.FormId);
    if (formElement != null) {
        var registeredValidatorCallbacks = formElement.validationCallbacks;
        if (!registeredValidatorCallbacks) {
            registeredValidatorCallbacks = [];
            formElement.validationCallbacks = registeredValidatorCallbacks;
        }
        registeredValidatorCallbacks.push(function () {
            theForm.validate();
            return theForm.valid();
        });
    }  

    if (theForm) {
        theForm.validate(options);
    }
}

function chargeValidation() {
    var allFormOptions = window.mvcClientValidationMetadata;
    if (allFormOptions) {
        while (allFormOptions.length > 0) {
            var thisFormOptions = allFormOptions.pop();
            __MVC_EnableClientValidation(thisFormOptions);
            window.elma.ValidationRulesManager.pushStartupValidation(thisFormOptions);
        }
    }
    window.elma.ValidationRulesManager.executeMove();
}

// need to wait for the document to signal that it is ready
$(document).ready(function () {
    chargeValidation();    
});







/**
 * @preserve
 * FullCalendar v1.5.2
 * http://arshaw.com/fullcalendar/
 *
 * Use fullcalendar.css for basic styling.
 * For event drag & drop, requires jQuery UI draggable.
 * For event resizing, requires jQuery UI resizable.
 *
 * Copyright (c) 2011 Adam Shaw
 * Dual licensed under the MIT and GPL licenses, located in
 * MIT-LICENSE.txt and GPL-LICENSE.txt respectively.
 *
 * Date: Sun Aug 21 22:06:09 2011 -0700
 *
 * !!  Обратить внимание на ревизию 609, 1007
 */
 
(function ($, undefined) {


    var defaults = {

        // display
        defaultView: 'month',
        aspectRatio: 1.35,
        header: {
            left: 'title',
            center: '',
            right: 'today prev,next'
        },
        weekends: true,

        // editing
        //editable: false,
        //disableDragging: false,
        //disableResizing: false,

        allDayDefault: true,
        ignoreTimezone: true,

        // event ajax
        lazyFetching: true,
        startParam: 'start',
        endParam: 'end',

        // time formats
        titleFormat: {
            month: 'MMMM yyyy',
            week: "MMM d[ yyyy]{ '&#8212;'[ MMM] d yyyy}",
            day: 'dddd, MMM d, yyyy'
        },
        columnFormat: {
            month: 'ddd',
            week: 'ddd M/d',
            day: 'dddd M/d'
        },
        timeFormat: { // for event elements
            '': 'HH:mm{ - HH:mm}' // default
        },

        // locale
        isRTL: false,
        firstDay: 0,
        monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        buttonText: {
            prev: '&nbsp;&#9668;&nbsp;',
            next: '&nbsp;&#9658;&nbsp;',
            prevYear: '&nbsp;&lt;&lt;&nbsp;',
            nextYear: '&nbsp;&gt;&gt;&nbsp;',
            today: 'today',
            month: 'month',
            week: 'week',
            day: 'day'
        },

        // jquery-ui theming
        theme: false,
        buttonIcons: {
            prev: 'circle-triangle-w',
            next: 'circle-triangle-e'
        },

        //selectable: false,
        unselectAuto: true,

        dropAccept: '*'

    };

    // right-to-left defaults
    var rtlDefaults = {
        header: {
            left: 'next,prev today',
            center: '',
            right: 'title'
        },
        buttonText: {
            prev: '&nbsp;&#9658;&nbsp;',
            next: '&nbsp;&#9668;&nbsp;',
            prevYear: '&nbsp;&gt;&gt;&nbsp;',
            nextYear: '&nbsp;&lt;&lt;&nbsp;'
        },
        buttonIcons: {
            prev: 'circle-triangle-e',
            next: 'circle-triangle-w'
        }
    };



    var fc = $.fullCalendar = { version: "1.5.2" };
    var fcViews = fc.views = {};


    $.fn.fullCalendar = function (options) {


        // method calling
        if (typeof options == 'string') {
            var args = Array.prototype.slice.call(arguments, 1);
            var res;
            this.each(function () {
                var calendar = $.data(this, 'fullCalendar');
                if (calendar && $.isFunction(calendar[options])) {
                    var r = calendar[options].apply(calendar, args);
                    if (res === undefined) {
                        res = r;
                    }
                    if (options == 'destroy') {
                        $.removeData(this, 'fullCalendar');
                    }
                }
            });
            if (res !== undefined) {
                return res;
            }
            return this;
        }


        // would like to have this logic in EventManager, but needs to happen before options are recursively extended
        var eventSources = options.eventSources || [];
        delete options.eventSources;
        if (options.events) {
            eventSources.push(options.events);
            delete options.events;
        }


        options = $.extend(true, {},
		defaults,
		(options.isRTL || options.isRTL === undefined && defaults.isRTL) ? rtlDefaults : {},
		options
	);


        this.each(function (i, _element) {
            var element = $(_element);
            var calendar = new Calendar(element, options, eventSources);
            element.data('fullCalendar', calendar); // TODO: look into memory leak implications
            calendar.render();
        });


        return this;

    };


    // function for adding/overriding defaults
    function setDefaults(d) {
        $.extend(true, defaults, d);
    }




    function Calendar(element, options, eventSources) {
        var t = this;


        // exports
        t.options = options;
        t.render = render;
        t.destroy = destroy;
        t.refetchEvents = refetchEvents;
        t.reportEvents = reportEvents;
        t.reportEventChange = reportEventChange;
        t.rerenderEvents = rerenderEvents;
        t.changeView = changeView;
        t.select = select;
        t.unselect = unselect;
        t.prev = prev;
        t.next = next;
        t.prevYear = prevYear;
        t.nextYear = nextYear;
        t.today = today;
        t.gotoDate = gotoDate;
        t.incrementDate = incrementDate;
        t.formatDate = function (format, date) { return format.dateTimePickerTitleFormatDate(date) };
        t.formatDates = function (format, date1, date2) { return Date.dateTimePickerTitleFormatDates(format, date1, date2) };
        t.getDate = getDate;
        t.getView = getView;
        t.option = option;
        t.trigger = trigger;


        // imports
        EventManager.call(t, options, eventSources);
        var isFetchNeeded = t.isFetchNeeded;
        var fetchEvents = t.fetchEvents;


        // locals
        var _element = element[0];
        var header;
        var headerElement;
        var content;
        var tm; // for making theme classes
        var currentView;
        var viewInstances = {};
        var elementOuterWidth;
        var suggestedViewHeight;
        var absoluteViewElement;
        var resizeUID = 0;
        var ignoreWindowResize = 0;
        var date = new Date();
        var events = [];
        var _dragElement;



        /* Main Rendering
        -----------------------------------------------------------------------------*/


        setYMD(date, options.year, options.month, options.date);


        function render(inc) {
            if (!content) {
                initialRender();
            } else {
                calcSize();
                markSizesDirty();
                markEventsDirty();
                renderView(inc);
            }
        }


        function initialRender() {
            tm = options.theme ? 'ui' : 'fc';
            element.addClass('fc');
            if (options.isRTL) {
                element.addClass('fc-rtl');
            }
            if (options.theme) {
                element.addClass('ui-widget');
            }
            content = $("<div class='fc-content' style='position:relative'/>")
			.prependTo(element);
            header = new Header(t, options);
            headerElement = header.render();
            if (headerElement) {
                element.prepend(headerElement);
            }
            changeView(options.defaultView);
            $(window).resize(windowResize);
            // needed for IE in a 0x0 iframe, b/c when it is resized, never triggers a windowResize
            if (!bodyVisible()) {
                lateRender();
            }
        }


        // called when we know the calendar couldn't be rendered when it was initialized,
        // but we think it's ready now
        function lateRender() {
            setTimeout(function () { // IE7 needs this so dimensions are calculated correctly
                if (!currentView.start && bodyVisible()) { // !currentView.start makes sure this never happens more than once
                    renderView();
                }
            }, 0);
        }


        function destroy() {
            $(window).unbind('resize', windowResize);
            header.destroy();
            content.remove();
            element.removeClass('fc fc-rtl ui-widget');
        }



        function elementVisible() {
            return _element.offsetWidth !== 0;
        }


        function bodyVisible() {
            return $('body')[0].offsetWidth !== 0;
        }



        /* View Rendering
        -----------------------------------------------------------------------------*/

        // TODO: improve view switching (still weird transition in IE, and FF has whiteout problem)

        function changeView(newViewName) {
            if (!currentView || newViewName != currentView.name) {
                ignoreWindowResize++; // because setMinHeight might change the height before render (and subsequently setSize) is reached

                unselect();

                var oldView = currentView;
                var newViewElement;

                if (oldView) {
                    (oldView.beforeHide || noop)(); // called before changing min-height. if called after, scroll state is reset (in Opera)
                    setMinHeight(content, content.height());
                    oldView.element.hide();
                } else {
                    setMinHeight(content, 1); // needs to be 1 (not 0) for IE7, or else view dimensions miscalculated
                }
                content.css('overflow', 'hidden');

                currentView = viewInstances[newViewName];
                if (currentView) {
                    currentView.element.show();
                } else {
                    currentView = viewInstances[newViewName] = new fcViews[newViewName](
					newViewElement = absoluteViewElement =
						$("<div class='fc-view fc-view-" + newViewName + "' style='position:absolute'/>")
							.appendTo(content),
					t // the calendar object
				);
                }

                if (oldView) {
                    header.deactivateButton(oldView.name);
                }
                header.activateButton(newViewName);

                renderView(); // after height has been set, will make absoluteViewElement's position=relative, then set to null

                content.css('overflow', '');
                if (oldView) {
                    setMinHeight(content, 1);
                }

                if (!newViewElement) {
                    (currentView.afterShow || noop)(); // called after setting min-height/overflow, so in final scroll state (for Opera)
                }

                ignoreWindowResize--;
            }
        }



        function renderView(inc) {
            if (elementVisible()) {
                ignoreWindowResize++; // because renderEvents might temporarily change the height before setSize is reached

                unselect();

                if (suggestedViewHeight === undefined) {
                    calcSize();
                }

                var forceEventRender = false;
                if (!currentView.start || inc || date < currentView.start || date >= currentView.end) {
                    // view must render an entire new date range (and refetch/render events)
                    currentView.render(date, inc || 0); // responsible for clearing events
                    setSize(true);
                    forceEventRender = true;
                }
                else if (currentView.sizeDirty) {
                    // view must resize (and rerender events)
                    currentView.clearEvents();
                    setSize();
                    forceEventRender = true;
                }
                else if (currentView.eventsDirty) {
                    currentView.clearEvents();
                    forceEventRender = true;
                }
                currentView.sizeDirty = false;
                currentView.eventsDirty = false;
                updateEvents(forceEventRender);

                elementOuterWidth = element.outerWidth();

                var title = getTitle();
                header.updateTitle(title);
                var today = new Date();
                if (today >= currentView.start && today < currentView.end) {
                    header.disableButton('today');
                } else {
                    header.enableButton('today');
                }

                ignoreWindowResize--;
                currentView.trigger('viewDisplay', _element);
            }
        }

        function getTitle() {
            var title = currentView.title;
            if (elma.ShowCalendarWeekNumber && (options.firstDay == 1 || options.firstDay == 0)) {
                if (currentView.name == "agendaWeek" || currentView.name == "workWeek") {
                    title += SR.T(" Неделя №{0}", currentView.visStart.getWeekNum());
                }
            }
            return title;
        }


        /* Resizing
        -----------------------------------------------------------------------------*/


        function updateSize() {
            markSizesDirty();
            if (elementVisible()) {
                calcSize();
                setSize();
                unselect();
                currentView.clearEvents();
                currentView.renderEvents(events);
                currentView.sizeDirty = false;
            }
        }


        function markSizesDirty() {
            $.each(viewInstances, function (i, inst) {
                inst.sizeDirty = true;
            });
        }


        function calcSize() {
            if (options.contentHeight) {
                suggestedViewHeight = options.contentHeight;
            }
            else if (options.height) {
                suggestedViewHeight = options.height - (headerElement ? headerElement.height() : 0) - vsides(content);
            }
            else {
                suggestedViewHeight = Math.round(content.width() / Math.max(options.aspectRatio, .5));
            }
        }


        function setSize(dateChanged) { // todo: dateChanged?
            ignoreWindowResize++;
            currentView.setHeight(suggestedViewHeight, dateChanged);
            if (absoluteViewElement) {
                absoluteViewElement.css('position', 'relative');
                absoluteViewElement = null;
            }
            currentView.setWidth(content.width(), dateChanged);
            ignoreWindowResize--;
        }


        function windowResize() {
            if (!ignoreWindowResize) {
                if (currentView.start) { // view has already been rendered
                    var uid = ++resizeUID;
                    setTimeout(function () { // add a delay
                        if (uid == resizeUID && !ignoreWindowResize && elementVisible()) {
                            if (elementOuterWidth != (elementOuterWidth = element.outerWidth())) {
                                ignoreWindowResize++; // in case the windowResize callback changes the height
                                updateSize();
                                currentView.trigger('windowResize', _element);
                                ignoreWindowResize--;
                            }
                        }
                    }, 200);
                } else {
                    // calendar must have been initialized in a 0x0 iframe that has just been resized
                    lateRender();
                }
            }
        }



        /* Event Fetching/Rendering
        -----------------------------------------------------------------------------*/


        // fetches events if necessary, rerenders events if necessary (or if forced)
        function updateEvents(forceRender) {
            if (!options.lazyFetching || isFetchNeeded(currentView.visStart, currentView.visEnd)) {
                refetchEvents();
            }
            else if (forceRender) {
                rerenderEvents();
            }
        }


        function refetchEvents() {
            fetchEvents(currentView.visStart, currentView.visEnd); // will call reportEvents
        }


        // called when event data arrives
        function reportEvents(_events) {
            events = _events;
            rerenderEvents();
        }


        // called when a single event's data has been changed
        function reportEventChange(eventId, eventUid) {
            rerenderEvents(eventId, eventUid);
        }


        // attempts to rerenderEvents
        function rerenderEvents(modifiedEventId, modifiedEventUid) {
            markEventsDirty();
            if (elementVisible()) {
                currentView.clearEvents();
                currentView.renderEvents(events, modifiedEventId, modifiedEventUid);
                currentView.eventsDirty = false;
            }
        }


        function markEventsDirty() {
            $.each(viewInstances, function (i, inst) {
                inst.eventsDirty = true;
            });
        }



        /* Selection
        -----------------------------------------------------------------------------*/


        function select(start, end, allDay) {
            currentView.select(start, end, allDay === undefined ? true : allDay);
        }


        function unselect() { // safe to be called before renderView
            if (currentView) {
                currentView.unselect();
            }
        }



        /* Date
        -----------------------------------------------------------------------------*/


        function prev() {
            renderView(-1);
        }


        function next() {
            renderView(1);
        }


        function prevYear() {
            addYears(date, -1);
            renderView();
        }


        function nextYear() {
            addYears(date, 1);
            renderView();
        }


        function today() {
            date = new Date();
            renderView();
        }


        function gotoDate(year, month, dateOfMonth) {
            if (year instanceof Date) {
                date = cloneDate(year); // provided 1 argument, a Date
            } else {
                setYMD(date, year, month, dateOfMonth);
            }
            renderView();
        }


        function incrementDate(years, months, days) {
            if (years !== undefined) {
                addYears(date, years);
            }
            if (months !== undefined) {
                addMonths(date, months);
            }
            if (days !== undefined) {
                addDays(date, days);
            }
            renderView();
        }


        function getDate() {
            return cloneDate(date);
        }



        /* Misc
        -----------------------------------------------------------------------------*/


        function getView() {
            return currentView;
        }


        function option(name, value) {
            if (value === undefined) {
                return options[name];
            }
            if (name == 'height' || name == 'contentHeight' || name == 'aspectRatio') {
                options[name] = value;
                updateSize();
            }
        }


        function trigger(name, thisObj) {
            if (options[name]) {
                return options[name].apply(
				thisObj || _element,
				Array.prototype.slice.call(arguments, 2)
			);
            }
        }



        /* External Dragging
        ------------------------------------------------------------------------*/

        if (options.droppable) {
            $(document)
			.bind('dragstart', function (ev, ui) {
			    var _e = ev.target;
			    var e = $(_e);
			    if (!e.parents('.fc').length) { // not already inside a calendar
			        var accept = options.dropAccept;
			        if ($.isFunction(accept) ? accept.call(_e, e) : e.is(accept)) {
			            _dragElement = _e;
			            currentView.dragStart(_dragElement, ev, ui);
			        }
			    }
			})
			.bind('dragstop', function (ev, ui) {
			    if (_dragElement) {
			        currentView.dragStop(_dragElement, ev, ui);
			        _dragElement = null;
			    }
			});
        }


    }

    function Header(calendar, options) {
        var t = this;


        // exports
        t.render = render;
        t.destroy = destroy;
        t.updateTitle = updateTitle;
        t.activateButton = activateButton;
        t.deactivateButton = deactivateButton;
        t.disableButton = disableButton;
        t.enableButton = enableButton;


        // locals
        var element = $([]);
        var tm;



        function render() {
            tm = options.theme ? 'ui' : 'fc';
            var sections = options.header;
            if (sections) {
                element = $("<table class='fc-header' style='width:100%'/>")
				.append(
					$("<tr/>")
						.append(renderSection('left'))
						.append(renderSection('center'))
						.append(renderSection('right'))
				);
                return element;
            }
        }


        function destroy() {
            element.remove();
        }


        function renderSection(position) {
            var e = $("<td class='fc-header-" + position + "'/>");
            var buttonStr = options.header[position];
            if (buttonStr) {
                $.each(buttonStr.split(' '), function (i) {
                    if (i > 0) {
                        e.append("<span class='fc-header-space'/>");
                    }
                    var prevButton;
                    $.each(this.split(','), function (j, buttonName) {
                        if (buttonName == 'title') {
                            e.append("<span class='fc-header-title'>&nbsp;</span>");
                            if (prevButton) {
                                prevButton.addClass(tm + '-corner-right');
                            }
                            prevButton = null;
                        } else if (buttonName == 'calendarName' && options["calendarName"]) {
                            e.append("<span class='fc-header-name'" + (options["calendarNameClick"] ? " style='cursor: pointer;'" : "") + " onclick='" + options["calendarNameClick"] + "'>" + options["calendarName"] + "</span>");
                            var isFavorite = options["isFavorite"];
                            if (isFavorite != undefined && isFavorite != null) {
                                e.append("<span><img class='favorite-button' alt='" + options["favoriteButtonText"] + "' title='" + options["favoriteButtonText"] + "' src='" + options["favoriteIcon"] + "' onclick='setFavorite(" + (isFavorite ? "true" : "false") + ")' /></span>");
                            }
                            prevButton = null;
                        } else {
                            var buttonClick;
                            if (calendar[buttonName]) {
                                buttonClick = calendar[buttonName]; // calendar method
                            }
                            else if (fcViews[buttonName]) {
                                buttonClick = function () {
                                    button.removeClass(tm + '-state-hover'); // forget why
                                    calendar.changeView(buttonName);
                                };
                            }
                            if (buttonClick) {
                                var icon = options.theme ? smartProperty(options.buttonIcons, buttonName) : null; // why are we using smartProperty here?
                                var text = smartProperty(options.buttonText, buttonName); // why are we using smartProperty here?
                                var button = $(
								"<span class='fc-button fc-button-" + buttonName + " " + tm + "-state-default'>" +
									"<span class='fc-button-inner'>" +
										"<span class='fc-button-content'>" +
											(icon ?
												"<span class='fc-icon-wrap'>" +
													"<span class='ui-icon ui-icon-" + icon + "'/>" +
												"</span>" :
												text
												) +
										"</span>" +
										"<span class='fc-button-effect'><span></span></span>" +
									"</span>" +
								"</span>"
							);
                                if (button) {
                                    button
									.click(function () {
									    if (!button.hasClass(tm + '-state-disabled')) {
									        buttonClick();
									    }
									})
									.mousedown(function () {
									    button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-down');
									})
									.mouseup(function () {
									    button.removeClass(tm + '-state-down');
									})
									.hover(
										function () {
										    button
												.not('.' + tm + '-state-active')
												.not('.' + tm + '-state-disabled')
												.addClass(tm + '-state-hover');
										},
										function () {
										    button
												.removeClass(tm + '-state-hover')
												.removeClass(tm + '-state-down');
										}
									)
									.appendTo(e);
                                    if (!prevButton) {
                                        button.addClass(tm + '-corner-left');
                                    }
                                    prevButton = button;
                                }
                            }
                        }
                    });
                    if (prevButton) {
                        prevButton.addClass(tm + '-corner-right');
                    }
                });
            }
            return e;
        }


        function updateTitle(html) {
            element.find('.fc-header-title')
			.html(html);
        }


        function activateButton(buttonName) {
            element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-active');
        }


        function deactivateButton(buttonName) {
            element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-active');
        }


        function disableButton(buttonName) {
            element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-disabled');
        }


        function enableButton(buttonName) {
            element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-disabled');
        }


    }

    fc.sourceNormalizers = [];
    fc.sourceFetchers = [];

    var ajaxDefaults = {
        dataType: 'json',
        cache: false
    };

    var eventGUID = 1;


    function EventManager(options, _sources) {
        var t = this;


        // exports
        t.isFetchNeeded = isFetchNeeded;
        t.fetchEvents = fetchEvents;
        t.addEventSource = addEventSource;
        t.removeEventSource = removeEventSource;
        t.updateEvent = updateEvent;
        t.renderEvent = renderEvent;
        t.removeEvents = removeEvents;
        t.clientEvents = clientEvents;
        t.normalizeEvent = normalizeEvent;


        // imports
        var trigger = t.trigger;
        var getView = t.getView;
        var reportEvents = t.reportEvents;


        // locals
        var stickySource = { events: [] };
        var sources = [stickySource];
        var rangeStart, rangeEnd;
        var currentFetchID = 0;
        var pendingSourceCnt = 0;
        var loadingLevel = 0;
        var cache = [];


        for (var i = 0; i < _sources.length; i++) {
            _addEventSource(_sources[i]);
        }



        /* Fetching
        -----------------------------------------------------------------------------*/


        function isFetchNeeded(start, end) {
            return !rangeStart || start < rangeStart || end > rangeEnd;
        }


        function fetchEvents(start, end) {
            rangeStart = start;
            rangeEnd = end;
            cache = [];
            var fetchID = ++currentFetchID;
            var len = sources.length;
            pendingSourceCnt = len;
            for (var i = 0; i < len; i++) {
                fetchEventSource(sources[i], fetchID);
            }
        }


        function fetchEventSource(source, fetchID) {
            _fetchEventSource(source, function (events) {
                if (fetchID == currentFetchID) {
                    if (events) {
                        for (var i = 0; i < events.length; i++) {
                            events[i].source = source;
                            normalizeEvent(events[i]);
                        }
                        cache = cache.concat(events);
                    }
                    pendingSourceCnt--;
                    if (!pendingSourceCnt) {
                        reportEvents(cache);
                    }
                }
            });
        }


        function _fetchEventSource(source, callback) {
            var i;
            var fetchers = fc.sourceFetchers;
            var res;
            for (i = 0; i < fetchers.length; i++) {
                res = fetchers[i](source, rangeStart, rangeEnd, callback);
                if (res === true) {
                    // the fetcher is in charge. made its own async request
                    return;
                }
                else if (typeof res == 'object') {
                    // the fetcher returned a new source. process it
                    _fetchEventSource(res, callback);
                    return;
                }
            }
            var events = source.events;
            if (events) {
                if ($.isFunction(events)) {
                    pushLoading();
                    events(cloneDate(rangeStart), cloneDate(rangeEnd), function (events) {
                        callback(events);
                        popLoading();
                    });
                }
                else if ($.isArray(events)) {
                    callback(events);
                }
                else {
                    callback();
                }
            } else {
                var url = source.url;
                if (url) {
                    var success = source.success;
                    var error = source.error;
                    var complete = source.complete;
                    var data = $.extend({}, source.data || {});
                    var startParam = firstDefined(source.startParam, options.startParam);
                    var endParam = firstDefined(source.endParam, options.endParam);
                    if (startParam) {
                        data[startParam] = Math.round(+rangeStart / 1000);
                    }
                    if (endParam) {
                        data[endParam] = Math.round(+rangeEnd / 1000);
                    }
                    pushLoading();
                    $.ajax($.extend({}, ajaxDefaults, source, {
                        data: data,
                        success: function (events) {
                            events = events || [];
                            var res = applyAll(success, this, arguments);
                            if ($.isArray(res)) {
                                events = res;
                            }
                            callback(events);
                        },
                        error: function () {
                            applyAll(error, this, arguments);
                            callback();
                        },
                        complete: function () {
                            applyAll(complete, this, arguments);
                            popLoading();
                        }
                    }));
                } else {
                    callback();
                }
            }
        }



        /* Sources
        -----------------------------------------------------------------------------*/


        function addEventSource(source) {
            source = _addEventSource(source);
            if (source) {
                pendingSourceCnt++;
                fetchEventSource(source, currentFetchID); // will eventually call reportEvents
            }
        }


        function _addEventSource(source) {
            if ($.isFunction(source) || $.isArray(source)) {
                source = { events: source };
            }
            else if (typeof source == 'string') {
                source = { url: source };
            }
            if (typeof source == 'object') {
                normalizeSource(source);
                sources.push(source);
                return source;
            }
        }


        function removeEventSource(source) {
            sources = $.grep(sources, function (src) {
                return !isSourcesEqual(src, source);
            });
            // remove all client events from that source
            cache = $.grep(cache, function (e) {
                return !isSourcesEqual(e.source, source);
            });
            reportEvents(cache);
        }



        /* Manipulation
        -----------------------------------------------------------------------------*/


        function updateEvent(event) { // update an existing event
            var i, len = cache.length, e,
			defaultEventEnd = getView().defaultEventEnd, // getView???
			startDelta = event.start - event._start,
			endDelta = event.end ?
				(event.end - (event._end || defaultEventEnd(event))) // event._end would be null if event.end
				: 0;                                                      // was null and event was just resized
            for (i = 0; i < len; i++) {
                e = cache[i];
                if (e._id == event._id && e != event) {
                    e.start = new Date(+e.start + startDelta);
                    if (event.end) {
                        if (e.end) {
                            e.end = new Date(+e.end + endDelta);
                        } else {
                            e.end = new Date(+defaultEventEnd(e) + endDelta);
                        }
                    } else {
                        e.end = null;
                    }
                    e.title = event.title;
                    e.url = event.url;
                    e.allDay = event.allDay;
                    e.className = event.className;
                    e.editable = event.editable;
                    e.color = event.color;
                    e.backgroudColor = event.backgroudColor;
                    e.borderColor = event.borderColor;
                    e.textColor = event.textColor;
                    normalizeEvent(e);
                }
            }
            normalizeEvent(event);
            reportEvents(cache);
        }


        function renderEvent(event, stick) {
            normalizeEvent(event);
            if (!event.source) {
                if (stick) {
                    stickySource.events.push(event);
                    event.source = stickySource;
                }
                cache.push(event);
            }
            reportEvents(cache);
        }


        function removeEvents(filter) {
            if (!filter) { // remove all
                cache = [];
                // clear all array sources
                for (var i = 0; i < sources.length; i++) {
                    if ($.isArray(sources[i].events)) {
                        sources[i].events = [];
                    }
                }
            } else {
                if (!$.isFunction(filter)) { // an event ID
                    var id = filter + '';
                    filter = function (e) {
                        return e._id == id;
                    };
                }
                cache = $.grep(cache, filter, true);
                // remove events from array sources
                for (var i = 0; i < sources.length; i++) {
                    if ($.isArray(sources[i].events)) {
                        sources[i].events = $.grep(sources[i].events, filter, true);
                    }
                }
            }
            reportEvents(cache);
        }


        function clientEvents(filter) {
            if ($.isFunction(filter)) {
                return $.grep(cache, filter);
            }
            else if (filter) { // an event ID
                filter += '';
                return $.grep(cache, function (e) {
                    return e._id == filter;
                });
            }
            return cache; // else, return all
        }



        /* Loading State
        -----------------------------------------------------------------------------*/


        function pushLoading() {
            if (!loadingLevel++) {
                trigger('loading', null, true);
            }
        }


        function popLoading() {
            if (! --loadingLevel) {
                trigger('loading', null, false);
            }
        }



        /* Event Normalization
        -----------------------------------------------------------------------------*/


        function normalizeEvent(event) {
            var source = event.source || {};
            var ignoreTimezone = firstDefined(source.ignoreTimezone, options.ignoreTimezone);
            event._id = event._id || (event.id === undefined ? '_fc' + eventGUID++ : event.id + '');
            if (event.date) {
                if (!event.start) {
                    event.start = event.date;
                }
                delete event.date;
            }
            event._start = cloneDate(event.start = parseDate(event.start, ignoreTimezone));
            event.end = parseDate(event.end, ignoreTimezone);
            if (event.end && event.end <= event.start) {
                event.end = null;
            }
            event._end = event.end ? cloneDate(event.end) : null;
            if (event.allDay === undefined) {
                event.allDay = firstDefined(source.allDayDefault, options.allDayDefault);
            }
            if (event.className) {
                if (typeof event.className == 'string') {
                    event.className = event.className.split(/\s+/);
                }
            } else {
                event.className = [];
            }
            // TODO: if there is no start date, return false to indicate an invalid event
        }



        /* Utils
        ------------------------------------------------------------------------------*/


        function normalizeSource(source) {
            if (source.className) {
                // TODO: repeat code, same code for event classNames
                if (typeof source.className == 'string') {
                    source.className = source.className.split(/\s+/);
                }
            } else {
                source.className = [];
            }
            var normalizers = fc.sourceNormalizers;
            for (var i = 0; i < normalizers.length; i++) {
                normalizers[i](source);
            }
        }


        function isSourcesEqual(source1, source2) {
            return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
        }


        function getSourcePrimitive(source) {
            return ((typeof source == 'object') ? (source.events || source.url) : '') || source;
        }


    }


    fc.addDays = addDays;
    fc.cloneDate = cloneDate;
    fc.parseDate = parseDate;
    fc.parseISO8601 = parseISO8601;
    fc.parseTime = parseTime;
    fc.formatDate = Date.dateTimePickerTitleFormatDate;
    fc.formatDates = Date.dateTimePickerTitleFormatDates;



    /* Date Math
    -----------------------------------------------------------------------------*/

    var dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'],
	DAY_MS = 86400000,
	HOUR_MS = 3600000,
	MINUTE_MS = 60000;


    function addYears(d, n, keepTime) {
        d.setFullYear(d.getFullYear() + n);
        if (!keepTime) {
            clearTime(d);
        }
        return d;
    }


    function addMonths(d, n, keepTime) { // prevents day overflow/underflow
        if (+d) { // prevent infinite looping on invalid dates
            var m = d.getMonth() + n,
			check = cloneDate(d);
            check.setDate(1);
            check.setMonth(m);
            d.setMonth(m);
            if (!keepTime) {
                clearTime(d);
            }
            while (d.getMonth() != check.getMonth()) {
                d.setDate(d.getDate() + (d < check ? 1 : -1));
            }
        }
        return d;
    }


    function addDays(d, n, keepTime) { // deals with daylight savings
        if (+d) {
            var dd = d.getDate() + n,
			check = cloneDate(d);
            check.setHours(9); // set to middle of day
            check.setDate(dd);
            d.setDate(dd);
            if (!keepTime) {
                clearTime(d);
            }
            fixDate(d, check);
        }
        return d;
    }


    function fixDate(d, check) { // force d to be on check's YMD, for daylight savings purposes
        if (+d) { // prevent infinite looping on invalid dates
            while (d.getDate() != check.getDate()) {
                d.setTime(+d + (d < check ? 1 : -1) * HOUR_MS);
            }
        }
    }


    function addMinutes(d, n) {
        d.setMinutes(d.getMinutes() + n);
        return d;
    }


    function clearTime(d) {
        d.setHours(0);
        d.setMinutes(0);
        d.setSeconds(0);
        d.setMilliseconds(0);
        return d;
    }


    function cloneDate(d, dontKeepTime) {
        if (dontKeepTime) {
            return clearTime(new Date(+d));
        }
        return new Date(+d);
    }


    function zeroDate() { // returns a Date with time 00:00:00 and dateOfMonth=1
        var i = 0, d;
        do {
            d = new Date(1970, i++, 1);
        } while (d.getHours()); // != 0
        return d;
    }


    function skipWeekend(date, inc, excl) {
        inc = inc || 1;
        while (!date.getDay() || (excl && date.getDay() == 1 || !excl && date.getDay() == 6)) {
            addDays(date, inc);
        }
        return date;
    }


    function dayDiff(d1, d2) { // d1 - d2
        return Math.round((cloneDate(d1, true) - cloneDate(d2, true)) / DAY_MS);
    }


    function setYMD(date, y, m, d) {
        if (y !== undefined && y != date.getFullYear()) {
            date.setDate(1);
            date.setMonth(0);
            date.setFullYear(y);
        }
        if (m !== undefined && m != date.getMonth()) {
            date.setDate(1);
            date.setMonth(m);
        }
        if (d !== undefined) {
            date.setDate(d);
        }
    }



    /* Date Parsing
    -----------------------------------------------------------------------------*/


    function parseDate(s, ignoreTimezone) { // ignoreTimezone defaults to true
        if (typeof s == 'object') { // already a Date object
            return s;
        }
        if (typeof s == 'number') { // a UNIX timestamp
            return new Date(s * 1000);
        }
        if (typeof s == 'string') {
            if (s.match(/^\d+(\.\d+)?$/)) { // a UNIX timestamp
                return new Date(parseFloat(s) * 1000);
            }
            if (ignoreTimezone === undefined) {
                ignoreTimezone = true;
            }
            return parseISO8601(s, ignoreTimezone) || (s ? new Date(s) : null);
        }
        // TODO: never return invalid dates (like from new Date(<string>)), return null instead
        return null;
    }


    function parseISO8601(s, ignoreTimezone) { // ignoreTimezone defaults to false
        // derived from http://delete.me.uk/2005/03/iso8601.html
        // TODO: for a know glitch/feature, read tests/issue_206_parseDate_dst.html
        var m = s.match(/^([0-9]{4})(-([0-9]{2})(-([0-9]{2})([T ]([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2})(:?([0-9]{2}))?))?)?)?)?$/);
        if (!m) {
            return null;
        }
        var date = new Date(m[1], 0, 1);
        if (ignoreTimezone || !m[13]) {
            var check = new Date(m[1], 0, 1, 9, 0);
            if (m[3]) {
                date.setMonth(m[3] - 1);
                check.setMonth(m[3] - 1);
            }
            if (m[5]) {
                date.setDate(m[5]);
                check.setDate(m[5]);
            }
            fixDate(date, check);
            if (m[7]) {
                date.setHours(m[7]);
            }
            if (m[8]) {
                date.setMinutes(m[8]);
            }
            if (m[10]) {
                date.setSeconds(m[10]);
            }
            if (m[12]) {
                date.setMilliseconds(Number("0." + m[12]) * 1000);
            }
            fixDate(date, check);
        } else {
            date.setUTCFullYear(
			m[1],
			m[3] ? m[3] - 1 : 0,
			m[5] || 1
		);
            date.setUTCHours(
			m[7] || 0,
			m[8] || 0,
			m[10] || 0,
			m[12] ? Number("0." + m[12]) * 1000 : 0
		);
            if (m[14]) {
                var offset = Number(m[16]) * 60 + (m[18] ? Number(m[18]) : 0);
                offset *= m[15] == '-' ? 1 : -1;
                date = new Date(+date + (offset * 60 * 1000));
            }
        }
        return date;
    }


    function parseTime(s) { // returns minutes since start of day
        if (typeof s == 'number') { // an hour
            return s * 60;
        }
        if (typeof s == 'object') { // a Date object
            return s.getHours() * 60 + s.getMinutes();
        }
        var m = s.match(/(\d+)(?::(\d+))?\s*(\w+)?/);
        if (m) {
            var h = parseInt(m[1], 10);
            if (m[3]) {
                h %= 12;
                if (m[3].toLowerCase().charAt(0) == 'p') {
                    h += 12;
                }
            }
            return h * 60 + (m[2] ? parseInt(m[2], 10) : 0);
        }
    }

    fc.applyAll = applyAll;


    /* Event Date Math
    -----------------------------------------------------------------------------*/


    function exclEndDay(event) {
        if (event.end) {
            return _exclEndDay(event.end, event.allDay);
        } else {
            return addDays(cloneDate(event.start), 1);
        }
    }


    function _exclEndDay(end, allDay) {
        end = cloneDate(end);
        return allDay || end.getHours() || end.getMinutes() ? addDays(end, 1) : clearTime(end);
    }


    function segCmp(a, b) {
        return (b.msLength - a.msLength) * 100 + (a.event.start - b.event.start);
    }


    function segsCollide(seg1, seg2) {
        return seg1.end > seg2.start && seg1.start < seg2.end;
    }



    /* Event Sorting
    -----------------------------------------------------------------------------*/


    // event rendering utilities
    function sliceSegs(events, visEventEnds, start, end) {
        var segs = [],
		i, len = events.length, event,
		eventStart, eventEnd,
		segStart, segEnd,
		isStart, isEnd;
        for (i = 0; i < len; i++) {
            event = events[i];
            eventStart = event.start;
            eventEnd = visEventEnds[i];
            if (eventEnd > start && eventStart < end) {
                if (eventStart < start) {
                    segStart = cloneDate(start);
                    isStart = false;
                } else {
                    segStart = eventStart;
                    isStart = true;
                }
                if (eventEnd > end) {
                    segEnd = cloneDate(end);
                    isEnd = false;
                } else {
                    segEnd = eventEnd;
                    isEnd = true;
                }
                segs.push({
                    event: event,
                    start: segStart,
                    end: segEnd,
                    isStart: isStart,
                    isEnd: isEnd,
                    msLength: segEnd - segStart
                });
            }
        }
        return segs.sort(segCmp);
    }


    // event rendering calculation utilities
    function stackSegs(segs) {
        var levels = [],
		i, len = segs.length, seg,
		j, collide, k;
        for (i = 0; i < len; i++) {
            seg = segs[i];
            j = 0; // the level index where seg should belong
            while (true) {
                collide = false;
                if (levels[j]) {
                    for (k = 0; k < levels[j].length; k++) {
                        if (segsCollide(levels[j][k], seg)) {
                            collide = true;
                            break;
                        }
                    }
                }
                if (collide) {
                    j++;
                } else {
                    break;
                }
            }
            if (levels[j]) {
                levels[j].push(seg);
            } else {
                levels[j] = [seg];
            }
        }
        return levels;
    }



    /* Event Element Binding
    -----------------------------------------------------------------------------*/


    function lazySegBind(container, segs, bindHandlers) {
        container.unbind('mouseover').mouseover(function (ev) {
            var parent = ev.target, e,
			i, seg;
            while (parent != this) {
                e = parent;
                parent = parent.parentNode;
            }
            if ((i = e._fci) !== undefined) {
                e._fci = undefined;
                seg = segs[i];
                bindHandlers(seg.event, seg.element, seg);
                $(ev.target).trigger(ev);
            }
            ev.stopPropagation();
        });
    }



    /* Element Dimensions
    -----------------------------------------------------------------------------*/


    function setOuterWidth(element, width, includeMargins) {
        for (var i = 0, e; i < element.length; i++) {
            e = $(element[i]);
            e.width(Math.max(0, width - hsides(e, includeMargins)));
        }
    }


    function setOuterHeight(element, height, includeMargins) {
        for (var i = 0, e; i < element.length; i++) {
            e = $(element[i]);
            e.height(Math.max(0, height - vsides(e, includeMargins)));
        }
    }


    // TODO: curCSS has been deprecated (jQuery 1.4.3 - 10/16/2010)


    function hsides(element, includeMargins) {
        return hpadding(element) + hborders(element) + (includeMargins ? hmargins(element) : 0);
    }


    function hpadding(element) {
        return (parseFloat($.curCSS(element[0], 'paddingLeft', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'paddingRight', true)) || 0);
    }


    function hmargins(element) {
        return (parseFloat($.curCSS(element[0], 'marginLeft', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'marginRight', true)) || 0);
    }


    function hborders(element) {
        return (parseFloat($.curCSS(element[0], 'borderLeftWidth', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'borderRightWidth', true)) || 0);
    }


    function vsides(element, includeMargins) {
        return vpadding(element) + vborders(element) + (includeMargins ? vmargins(element) : 0);
    }


    function vpadding(element) {
        return (parseFloat($.curCSS(element[0], 'paddingTop', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'paddingBottom', true)) || 0);
    }


    function vmargins(element) {
        return (parseFloat($.curCSS(element[0], 'marginTop', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'marginBottom', true)) || 0);
    }


    function vborders(element) {
        return (parseFloat($.curCSS(element[0], 'borderTopWidth', true)) || 0) +
	       (parseFloat($.curCSS(element[0], 'borderBottomWidth', true)) || 0);
    }


    function setMinHeight(element, height) {
        height = (typeof height == 'number' ? height + 'px' : height);
        element.each(function (i, _element) {
            _element.style.cssText += ';min-height:' + height + ';_height:' + height;
            // why can't we just use .css() ? i forget
        });
    }



    /* Misc Utils
    -----------------------------------------------------------------------------*/


    //TODO: arraySlice
    //TODO: isFunction, grep ?


    function noop() { }


    function cmp(a, b) {
        return a - b;
    }


    function arrayMax(a) {
        return Math.max.apply(Math, a);
    }


    function zeroPad(n) {
        return (n < 10 ? '0' : '') + n;
    }


    function smartProperty(obj, name) { // get a camel-cased/namespaced property of an object
        if (obj[name] !== undefined) {
            return obj[name];
        }
        var parts = name.split(/(?=[A-Z])/),
		i = parts.length - 1, res;
        for (; i >= 0; i--) {
            res = obj[parts[i].toLowerCase()];
            if (res !== undefined) {
                return res;
            }
        }
        return obj[''];
    }


    function htmlEscape(s) {
        return s.replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;')
		.replace(/\n/g, '<br />');
    }


    function cssKey(_element) {
        return _element.id + '/' + _element.className + '/' + _element.style.cssText.replace(/(^|;)\s*(top|left|width|height)\s*:[^;]*/ig, '');
    }


    function disableTextSelection(element) {
        element
		.attr('unselectable', 'on')
		.css('MozUserSelect', 'none')
		.bind('selectstart.ui', function () { return false; });
    }


    /*
    function enableTextSelection(element) {
    element
    .attr('unselectable', 'off')
    .css('MozUserSelect', '')
    .unbind('selectstart.ui');
    }
    */


    function markFirstLast(e) {
        e.children()
		.removeClass('fc-first fc-last')
		.filter(':first-child')
			.addClass('fc-first')
		.end()
		.filter(':last-child')
			.addClass('fc-last');
    }


    function setDayID(cell, date) {
        cell.each(function (i, _cell) {
            _cell.className = _cell.className.replace(/^fc-\w*/, 'fc-' + dayIDs[date.getDay()]);
            // TODO: make a way that doesn't rely on order of classes
        });
    }


    function getSkinCss(event, opt) {
        var source = event.source || {};
        var eventColor = event.color;
        var sourceColor = source.color;
        var optionColor = opt('eventColor');
        var backgroundColor =
		event.backgroundColor ||
		eventColor ||
		source.backgroundColor ||
		sourceColor ||
		opt('eventBackgroundColor') ||
		optionColor;
        var borderColor =
		event.borderColor ||
		eventColor ||
		source.borderColor ||
		sourceColor ||
		opt('eventBorderColor') ||
		optionColor;
        var textColor =
		event.textColor ||
		source.textColor ||
		opt('eventTextColor');
        var statements = [];
        if (backgroundColor) {
            statements.push('background-color:' + backgroundColor);
        }
        if (borderColor) {
            statements.push('border-color:' + borderColor);
        }
        if (textColor) {
            statements.push('color:' + textColor);
        }
        return statements.join(';');
    }


    function applyAll(functions, thisObj, args) {
        if ($.isFunction(functions)) {
            functions = [functions];
        }
        if (functions) {
            var i;
            var ret;
            for (i = 0; i < functions.length; i++) {
                ret = functions[i].apply(thisObj, args) || ret;
            }
            return ret;
        }
    }


    function firstDefined() {
        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] !== undefined) {
                return arguments[i];
            }
        }
    }



    fcViews.month = MonthView;

    function MonthView(element, calendar) {
        var t = this;


        // exports
        t.render = render;


        // imports
        BasicView.call(t, element, calendar, 'month');
        var opt = t.opt;
        var renderBasic = t.renderBasic;
        var formatDate = calendar.formatDate;



        function render(date, delta) {
            if (delta) {
                addMonths(date, delta);
                date.setDate(1);
            }
            var start = cloneDate(date, true);
            start.setDate(1);
            var end = addMonths(cloneDate(start), 1);
            var visStart = cloneDate(start);
            var visEnd = cloneDate(end);
            var firstDay = opt('firstDay');
            var nwe = opt('weekends') ? 0 : 1;
            if (nwe) {
                skipWeekend(visStart);
                skipWeekend(visEnd, -1, true);
            }
            addDays(visStart, -((visStart.getDay() - Math.max(firstDay, nwe) + 7) % 7));
            addDays(visEnd, (7 - visEnd.getDay() + Math.max(firstDay, nwe)) % 7);
            var rowCnt = Math.round((visEnd - visStart) / (DAY_MS * 7));
            if (opt('weekMode') == 'fixed') {
                addDays(visEnd, (6 - rowCnt) * 7);
                rowCnt = 6;
            }
            t.title = start.dateTimePickerTitleFormatDate(opt('titleFormat'));
            t.start = start;
            t.end = end;
            t.visStart = visStart;
            t.visEnd = visEnd;
            renderBasic(6, rowCnt, nwe ? 5 : 7, true);
        }


    }

    fcViews.basicWeek = BasicWeekView;

    function BasicWeekView(element, calendar) {
        var t = this;


        // exports
        t.render = render;


        // imports
        BasicView.call(t, element, calendar, 'basicWeek');
        var opt = t.opt;
        var renderBasic = t.renderBasic;
        var formatDates = calendar.formatDates;



        function render(date, delta) {
            if (delta) {
                addDays(date, delta * 7);
            }
            var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
            var end = addDays(cloneDate(start), 7);
            var visStart = cloneDate(start);
            var visEnd = cloneDate(end);
            var weekends = opt('weekends');
            if (!weekends) {
                skipWeekend(visStart);
                skipWeekend(visEnd, -1, true);
            }            
            var tt = Date.dateTimePickerTitleFormatDates(visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);
            var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
            t.title = !translationMode ? tt : elma.ProcessTranslationHtmlElement(null, opt('titleFormat'), tt);
            t.start = start;
            t.end = end;
            t.visStart = visStart;
            t.visEnd = visEnd;
            renderBasic(1, 1, weekends ? 7 : 5, false);
        }


    }

    fcViews.basicDay = BasicDayView;

    //TODO: when calendar's date starts out on a weekend, shouldn't happen


    function BasicDayView(element, calendar) {
        var t = this;


        // exports
        t.render = render;


        // imports
        BasicView.call(t, element, calendar, 'basicDay');
        var opt = t.opt;
        var renderBasic = t.renderBasic;
        var formatDate = calendar.formatDate;



        function render(date, delta) {
            if (delta) {
                addDays(date, delta);
                if (!opt('weekends')) {
                    skipWeekend(date, delta < 0 ? -1 : 1);
                }
            }
            t.title = date.dateTimePickerTitleFormatDate(opt('titleFormat'));
            t.start = t.visStart = cloneDate(date, true);
            t.end = t.visEnd = addDays(cloneDate(t.start), 1);
            renderBasic(1, 1, 1, false);
        }


    }

    setDefaults({
        weekMode: 'fixed'
    });


    function BasicView(element, calendar, viewName) {
        var t = this;


        // exports
        t.renderBasic = renderBasic;
        t.setHeight = setHeight;
        t.setWidth = setWidth;
        t.renderDayOverlay = renderDayOverlay;
        t.defaultSelectionEnd = defaultSelectionEnd;
        t.renderSelection = renderSelection;
        t.clearSelection = clearSelection;
        t.reportDayClick = reportDayClick; // for selection (kinda hacky)
        t.dragStart = dragStart;
        t.dragStop = dragStop;
        t.defaultEventEnd = defaultEventEnd;
        t.getHoverListener = function () { return hoverListener };
        t.colContentLeft = colContentLeft;
        t.colContentRight = colContentRight;
        t.dayOfWeekCol = dayOfWeekCol;
        t.dateCell = dateCell;
        t.cellDate = cellDate;
        t.cellIsAllDay = function () { return true };
        t.allDayRow = allDayRow;
        t.allDayBounds = allDayBounds;
        t.getRowCnt = function () { return rowCnt };
        t.getColCnt = function () { return colCnt };
        t.getColWidth = function () { return colWidth };
        t.getDaySegmentContainer = function () { return daySegmentContainer };


        // imports
        View.call(t, element, calendar, viewName);
        OverlayManager.call(t);
        SelectionManager.call(t);
        BasicEventRenderer.call(t);
        var opt = t.opt;
        var trigger = t.trigger;
        var clearEvents = t.clearEvents;
        var renderOverlay = t.renderOverlay;
        var clearOverlays = t.clearOverlays;
        var daySelectionMousedown = t.daySelectionMousedown;
        var formatDate = calendar.formatDate;


        // locals

        var head;
        var headCells;
        var body;
        var bodyRows;
        var bodyCells;
        var bodyCellsWeekNumber;
        var bodyFirstCells;
        var bodyCellTopInners;
        var daySegmentContainer;

        var viewWidth;
        var viewHeight;
        var colWidth;

        var rowCnt, colCnt;
        var coordinateGrid;
        var hoverListener;
        var colContentPositions;

        var rtl, dis, dit;
        var firstDay;
        var nwe;
        var tm;
        var colFormat;



        /* Rendering
        ------------------------------------------------------------*/


        disableTextSelection(element.addClass('fc-grid'));


        function renderBasic(maxr, r, c, showNumbers) {
            rowCnt = r;
            colCnt = c;
            updateOptions();
            var firstTime = !body;
            if (firstTime) {
                buildSkeleton(maxr, showNumbers);
            } else {
                clearEvents();
            }
            updateCells(firstTime);
        }



        function updateOptions() {
            rtl = opt('isRTL');
            if (rtl) {
                dis = -1;
                dit = colCnt - 1;
            } else {
                dis = 1;
                dit = 0;
            }
            firstDay = opt('firstDay');
            nwe = opt('weekends') ? 0 : 1;
            tm = opt('theme') ? 'ui' : 'fc';
            colFormat = opt('columnFormat');
        }



        function buildSkeleton(maxRowCnt, showNumbers) {
            var s;
            var headerClass = tm + "-widget-header";
            var contentClass = tm + "-widget-content";
            var i, j;
            var table;
            var startElement = 0;

            s =
			"<table class='fc-border-separate' style='width:100%' cellspacing='0'>" +
			"<thead>" +
			"<tr>";
            if (elma.ShowCalendarWeekNumber && (opt('firstDay') == 0 || opt('firstDay') == 1)) {
                s += "<th  class='fc- " + headerClass + " fc-WeekNumber'>#</th>";
                startElement = -1;
            }
            for (i = 0; i < colCnt; i++) {
                s +=
				"<th class='fc- " + headerClass + "'/>"; // need fc- for setDayID
            }
            s +=
			"</tr>" +
			"</thead>" +
			"<tbody>";
            for (i = 0; i < maxRowCnt; i++) {
                s +=
				"<tr class='fc-week" + i + "'>";
                for (j = startElement; j < colCnt; j++) {
                    if (j == -1) {
                        s += "<td class='fc- " + contentClass + " fc-day" + (i * colCnt + j + 1) + " fc-WeekNumber'>" +
                            "<div>" +
                            (showNumbers ?
                                    "<div class='fc-week-number'/>" :
                                    ''
                            ) +
                            "<div class='fc-day-content'>" +
                            "<div style='position:relative'>&nbsp;</div>" +
                            "</div>" +
                            "</div>" +
                            "</td>";
                    } else {
                        s +=
                        "<td class='fc- " + contentClass + " fc-day" + (i * colCnt + j) + "'>" + // need fc- for setDayID
                        "<div>" +
                        (showNumbers ?
                            "<div class='fc-day-number'/>" :
                            ''
                            ) +
                        "<div class='fc-day-content'>" +
                        "<div style='position:relative'>&nbsp;</div>" +
                        "</div>" +
                        "</div>" +
                        "</td>";
                    }
                }
                s +=
				"</tr>";
            }
            s +=
			"</tbody>" +
			"</table>";
            table = $(s).appendTo(element);

            head = table.find('thead');
            headCells = head.find('th:not(.fc-WeekNumber)');
            body = table.find('tbody');
            bodyRows = body.find('tr');
            bodyCells = body.find('td:not(.fc-WeekNumber)');
            bodyCellsWeekNumber = body.find('td.fc-WeekNumber');
            bodyFirstCells = body.find('td').filter(':first-child');
            bodyCellTopInners = bodyRows.eq(0).find('div.fc-day-content div');

            markFirstLast(head.add(head.find('tr'))); // marks first+last tr/th's
            markFirstLast(bodyRows); // marks first+last td's
            bodyRows.eq(1).addClass('fc-first'); // fc-last is done in updateCells

            dayBind(bodyCells);
            weekBind(bodyCellsWeekNumber);

            daySegmentContainer =
			$("<div style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(element);
        }



        function updateCells(firstTime) {
            var dowDirty = firstTime || rowCnt == 1; // could the cells' day-of-weeks need updating?
            var month = t.start.getMonth();
            var today = clearTime(new Date());
            var cell;
            var date;
            var row;

            if (dowDirty) {
                headCells.each(function (i, _cell) {
                    cell = $(_cell);
                    date = indexDate(i);
                    cell.html(date.dateTimePickerTitleFormatDate(colFormat));
                    setDayID(cell, date);
                });
            }

            bodyCells.each(function (i, _cell) {
                cell = $(_cell);
                date = indexDate(i);
                if (date.getMonth() == month) {
                    cell.removeClass('fc-other-month');
                } else {
                    cell.addClass('fc-other-month');
                }
                if (+date == +today) {
                    cell.addClass(tm + '-state-highlight fc-today');
                } else {
                    cell.removeClass(tm + '-state-highlight fc-today');
                    if (isHoliday(date, date.getDay())) {
                        cell.addClass('fc-day-holiday').removeClass('fc-day-exception');
                    }
                    else if (isException(date, date.getDay())) {
                        cell.addClass('fc-day-exception').removeClass('fc-day-holiday');
                    }
                    else {
                        cell.removeClass('fc-day-holiday fc-day-exception');
                    }
                }
                cell.find('div.fc-day-number').text(date.getDate());
                if (dowDirty) {
                    setDayID(cell, date);
                }
            });

            bodyRows.each(function (i, _row) {
                row = $(_row);
                if (i < rowCnt) {
                    row.show();
                    if (i == rowCnt - 1) {
                        row.addClass('fc-last');
                    } else {
                        row.removeClass('fc-last');
                    }
                } else {
                    row.hide();
                }
            });
            if (elma.ShowCalendarWeekNumber && (opt('firstDay') == 0 || opt('firstDay') == 1)) {
                var weekNumber = new Date(t.visStart.getFullYear(), t.visStart.getMonth(), t.visStart.getDate() + 1);
                bodyCellsWeekNumber.each(function (i, _cell) {
                    cell = $(_cell);
                    date = indexDate(i);
                    if (cell.hasClass('fc-WeekNumber')) {
                        if (date.getMonth() == month) {
                            cell.removeClass('fc-other-month');
                        } else {
                            cell.addClass('fc-other-month');
                        }
                        if (+date == +today) {
                            cell.addClass(tm + '-state-highlight fc-today');
                        } else {
                            cell.removeClass(tm + '-state-highlight fc-today');
                        }
                        cell.find('div.fc-week-number').each(function () {
                            $(this).text(weekNumber.getWeekNum());
                        });
                        weekNumber = new Date(weekNumber.getFullYear(), weekNumber.getMonth(), weekNumber.getDate() + 7);
                    }
                });
            }
        }

        function isHoliday(date, index) {
            if (!t || !t.calendar || !t.calendar.options)
                return false;
            var i, eDate;
            var exceptionDays = t.calendar.options.exceptionDays;
            if (exceptionDays) {
                for (i = 0; i < exceptionDays.length; i++) {
                    eDate = clearTime(convertJSONDate(exceptionDays[i].date));
                    if (+date == +eDate) {
                        return exceptionDays[i].dayType == 1;
                    }
                }

            }
            var days = t.calendar.options.days;
            if (days) {
                for (i = 0; i < days.length; i++) {
                    if (index == days[i].dayOfWeek % 7) {
                        return days[i].state == 1;
                    }
                }
            }
            return false;
        }

        function isException(date, index) {
            if (!t || !t.calendar || !t.calendar.options)
                return false;
            var i, eDate;
            var exceptionDays = t.calendar.options.exceptionDays;
            if (exceptionDays) {
                for (i = 0; i < exceptionDays.length; i++) {
                    eDate = clearTime(convertJSONDate(exceptionDays[i].date));
                    if (+date == +eDate) {
                        return exceptionDays[i].dayType == 0;
                    }
                }

            }
            var days = t.calendar.options.days;
            if (days) {
                for (i = 0; i < days.length; i++) {
                    if (index == days[i].dayOfWeek % 7) {
                        return days[i].state == 2;
                    }
                }
            }
            return false;
        }

        function setHeight(height) {
            viewHeight = height;

            var bodyHeight = viewHeight - head.height();
            var rowHeight;
            var rowHeightLast;
            var cell;

            if (opt('weekMode') == 'variable') {
                rowHeight = rowHeightLast = Math.floor(bodyHeight / (rowCnt == 1 ? 2 : 6));
            } else {
                rowHeight = Math.floor(bodyHeight / rowCnt);
                rowHeightLast = bodyHeight - rowHeight * (rowCnt - 1);
            }

            bodyFirstCells.each(function (i, _cell) {
                if (i < rowCnt) {
                    cell = $(_cell);
                    setMinHeight(
					cell.find('> div'),
					(i == rowCnt - 1 ? rowHeightLast : rowHeight) - vsides(cell)
				);
                }
            });

        }


        function setWidth(width) {
            viewWidth = width;
            colContentPositions.clear();
            colWidth = Math.floor(viewWidth / colCnt);
            setOuterWidth(headCells.slice(0, -1), colWidth);
        }



        /* Day clicking and binding
        -----------------------------------------------------------*/

        function weekBind(days) {
            days.each(function () {
                $(this).click(dayClick)
                .mousedown(function (ev) {
                    if (ev.which == 1) {
                        var startYear = t.start.getFullYear();
                        var weekNum = $(this).find('div.fc-week-number').text();
                        if (t.start.getMonth() == 11 && (weekNum == 1 || weekNum == 2)) {//calculate choosing year
                            startYear++;
                        }
                        if (t.start.getMonth() == 0 && (weekNum == 52 || weekNum == 53)) {
                            startYear--;
                        }
                        var targetDate = new Date(startYear, 0, 1);
                        var weekNumTarget = (weekNum - 1) * 7;
                        var weekDay = targetDate.getDay();
                        if ((targetDate.getDay() > 4 || targetDate.getDay() == 0) && opt('firstDay') == 1) {
                            weekNumTarget = (weekNum) * 7;
                        }
                        targetDate.addDays(weekNumTarget);
                        t.calendar.gotoDate(targetDate);
                        t.calendar.changeView('agendaWeek');
                    }
                })
            });
        }

        function dayBind(days) {
            days.click(dayClick)
                .mousedown(daySelectionMousedown);
        }


        function dayClick(ev) {
            if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
                var index = parseInt(this.className.match(/fc\-day(\d+)/)[1]); // TODO: maybe use .data
                var date = indexDate(index);
                trigger('dayClick', this, date, true, ev);
            }
        }



        /* Semi-transparent Overlay Helpers
        ------------------------------------------------------*/


        function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid) { // overlayEnd is exclusive
            if (refreshCoordinateGrid) {
                coordinateGrid.build();
            }
            var rowStart = cloneDate(t.visStart);
            var rowEnd = addDays(cloneDate(rowStart), colCnt);
            for (var i = 0; i < rowCnt; i++) {
                var stretchStart = new Date(Math.max(rowStart, overlayStart));
                var stretchEnd = new Date(Math.min(rowEnd, overlayEnd));
                if (stretchStart < stretchEnd) {
                    var colStart, colEnd;
                    if (rtl) {
                        colStart = dayDiff(stretchEnd, rowStart) * dis + dit + 1;
                        colEnd = dayDiff(stretchStart, rowStart) * dis + dit + 1;
                    } else {
                        colStart = dayDiff(stretchStart, rowStart);
                        colEnd = dayDiff(stretchEnd, rowStart);
                    }
                    dayBind(
					renderCellOverlay(i, colStart, i, colEnd - 1)
				);
                }
                addDays(rowStart, 7);
                addDays(rowEnd, 7);
            }
        }


        function renderCellOverlay(row0, col0, row1, col1) { // row1,col1 is inclusive
            var rect = coordinateGrid.rect(row0, col0, row1, col1, element);
            return renderOverlay(rect, element);
        }



        /* Selection
        -----------------------------------------------------------------------*/


        function defaultSelectionEnd(startDate, allDay) {
            return cloneDate(startDate);
        }


        function renderSelection(startDate, endDate, allDay) {
            renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true); // rebuild every time???
        }


        function clearSelection() {
            clearOverlays();
        }


        function reportDayClick(date, allDay, ev) {
            var cell = dateCell(date);
            var _element = bodyCells[cell.row * colCnt + cell.col];
            trigger('dayClick', _element, date, allDay, ev);
        }



        /* External Dragging
        -----------------------------------------------------------------------*/


        function dragStart(_dragElement, ev, ui) {
            hoverListener.start(function (cell) {
                clearOverlays();
                if (cell) {
                    renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
                }
            }, ev);
        }


        function dragStop(_dragElement, ev, ui) {
            var cell = hoverListener.stop();
            clearOverlays();
            if (cell) {
                var d = cellDate(cell);
                trigger('drop', _dragElement, d, true, ev, ui);
            }
        }



        /* Utilities
        --------------------------------------------------------*/


        function defaultEventEnd(event) {
            return cloneDate(event.start);
        }


        coordinateGrid = new CoordinateGrid(function (rows, cols) {
            var e, n, p;
            headCells.each(function (i, _e) {
                e = $(_e);
                n = e.offset().left;
                if (i) {
                    p[1] = n;
                }
                p = [n];
                cols[i] = p;
            });
            p[1] = n + e.outerWidth();
            bodyRows.each(function (i, _e) {
                if (i < rowCnt) {
                    e = $(_e);
                    n = e.offset().top;
                    if (i) {
                        p[1] = n;
                    }
                    p = [n];
                    rows[i] = p;
                }
            });
            p[1] = n + e.outerHeight();
        });


        hoverListener = new HoverListener(coordinateGrid);


        colContentPositions = new HorizontalPositionCache(function (col) {
            return bodyCellTopInners.eq(col);
        });


        function colContentLeft(col) {
            return colContentPositions.left(col);
        }


        function colContentRight(col) {
            return colContentPositions.right(col);
        }




        function dateCell(date) {
            return {
                row: Math.floor(dayDiff(date, t.visStart) / 7),
                col: dayOfWeekCol(date.getDay())
            };
        }


        function cellDate(cell) {
            return _cellDate(cell.row, cell.col);
        }


        function _cellDate(row, col) {
            return addDays(cloneDate(t.visStart), row * 7 + col * dis + dit);
            // what about weekends in middle of week?
        }


        function indexDate(index) {
            return _cellDate(Math.floor(index / colCnt), index % colCnt);
        }


        function dayOfWeekCol(dayOfWeek) {
            var dayOfWeekColumn = ((dayOfWeek - Math.max(firstDay, nwe) + colCnt) % colCnt) * dis + dit;
            if (elma.ShowCalendarWeekNumber && (opt('firstDay') == 0 || opt('firstDay') == 1))
                dayOfWeekColumn = dayOfWeekColumn + 1;
            return dayOfWeekColumn;
        }




        function allDayRow(i) {
            return bodyRows.eq(i);
        }


        function allDayBounds(i) {
            return {
                left: 0,
                right: viewWidth
            };
        }


    }

    function BasicEventRenderer() {
        var t = this;


        // exports
        t.renderEvents = renderEvents;
        t.compileDaySegs = compileSegs; // for DayEventRenderer
        t.clearEvents = clearEvents;
        t.bindDaySeg = bindDaySeg;


        // imports
        DayEventRenderer.call(t);
        var opt = t.opt;
        var trigger = t.trigger;
        //var setOverflowHidden = t.setOverflowHidden;
        var isEventDraggable = t.isEventDraggable;
        var isEventResizable = t.isEventResizable;
        var reportEvents = t.reportEvents;
        var reportEventClear = t.reportEventClear;
        var eventElementHandlers = t.eventElementHandlers;
        var showEvents = t.showEvents;
        var hideEvents = t.hideEvents;
        var eventDrop = t.eventDrop;
        var getDaySegmentContainer = t.getDaySegmentContainer;
        var getHoverListener = t.getHoverListener;
        var renderDayOverlay = t.renderDayOverlay;
        var clearOverlays = t.clearOverlays;
        var getRowCnt = t.getRowCnt;
        var getColCnt = t.getColCnt;
        var renderDaySegs = t.renderDaySegs;
        var resizableDayEvent = t.resizableDayEvent;



        /* Rendering
        --------------------------------------------------------------------*/


        function renderEvents(events, modifiedEventId, modifiedEventUid) {
            reportEvents(events);
            renderDaySegs(compileSegs(events), modifiedEventId, modifiedEventUid);
        }


        function clearEvents() {
            reportEventClear();
            getDaySegmentContainer().empty();
        }


        function compileSegs(events) {
            var rowCnt = getRowCnt(),
			colCnt = getColCnt(),
			d1 = cloneDate(t.visStart),
			d2 = addDays(cloneDate(d1), colCnt),
			visEventsEnds = $.map(events, exclEndDay),
			i, row,
			j, level,
			k, seg,
			segs = [];
            for (i = 0; i < rowCnt; i++) {
                row = stackSegs(sliceSegs(events, visEventsEnds, d1, d2));
                for (j = 0; j < row.length; j++) {
                    level = row[j];
                    for (k = 0; k < level.length; k++) {
                        seg = level[k];
                        seg.row = i;
                        seg.level = j; // not needed anymore
                        segs.push(seg);
                    }
                }
                addDays(d1, 7);
                addDays(d2, 7);
            }
            return segs;
        }


        function bindDaySeg(event, eventElement, seg) {
            if (isEventDraggable(event)) {
                draggableDayEvent(event, eventElement);
            }
            if (seg.isEnd && isEventResizable(event)) {
                resizableDayEvent(event, eventElement, seg);
            }
            eventElementHandlers(event, eventElement);
            // needs to be after, because resizableDayEvent might stopImmediatePropagation on click
        }



        /* Dragging
        ----------------------------------------------------------------------------*/


        function draggableDayEvent(event, eventElement) {
            var hoverListener = getHoverListener();
            var dayDelta;
            eventElement.draggable({
                zIndex: 9,
                delay: 50,
                opacity: opt('dragOpacity'),
                revertDuration: opt('dragRevertDuration'),
                start: function (ev, ui) {
                    trigger('eventDragStart', eventElement, event, ev, ui);
                    hideEvents(event, eventElement);
                    hoverListener.start(function (cell, origCell, rowDelta, colDelta) {
                        eventElement.draggable('option', 'revert', !cell || !rowDelta && !colDelta);
                        clearOverlays();
                        if (cell) {
                            //setOverflowHidden(true);
                            dayDelta = rowDelta * 7 + colDelta * (opt('isRTL') ? -1 : 1);
                            renderDayOverlay(
							addDays(cloneDate(event.start), dayDelta),
							addDays(exclEndDay(event), dayDelta)
						);
                        } else {
                            //setOverflowHidden(false);
                            dayDelta = 0;
                        }
                    }, ev, 'drag');
                },
                stop: function (ev, ui) {
                    hoverListener.stop();
                    clearOverlays();
                    trigger('eventDragStop', eventElement, event, ev, ui);
                    if (dayDelta) {
                        eventDrop(this, event, dayDelta, 0, event.allDay, ev, ui);
                    } else {
                        eventElement.css('filter', ''); // clear IE opacity side-effects
                        showEvents(event, eventElement);
                    }
                    //setOverflowHidden(false);
                }
            });
        }


    }

    fcViews.agendaWeek = AgendaWeekView;

    function AgendaWeekView(element, calendar) {
        var t = this;


        // exports
        t.render = render;


        // imports
        AgendaView.call(t, element, calendar, 'agendaWeek');
        var opt = t.opt;
        var renderAgenda = t.renderAgenda;
        var formatDates = calendar.formatDates;



        function render(date, delta) {
            if (delta) {
                addDays(date, delta * 7);
            }
            var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
            var end = addDays(cloneDate(start), 7);
            var visStart = cloneDate(start);
            var visEnd = cloneDate(end);
            var weekends = opt('weekends');
            if (!weekends) {
                skipWeekend(visStart);
                skipWeekend(visEnd, -1, true);
            }
            var tt = Date.dateTimePickerTitleFormatDates(visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);
            var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
            t.title = !translationMode ? tt : elma.ProcessTranslationHtmlElement(null, opt('titleFormat'), tt);
            t.start = start;
            t.end = end;
            t.visStart = visStart;
            t.visEnd = visEnd;
            renderAgenda(weekends ? 7 : 5);
        }


    }

    fcViews.workWeek = WorkWeekView;

    function WorkWeekView(element, calendar) {
        var t = this;


        // exports
        t.render = render;


        // imports
        AgendaView.call(t, element, calendar, 'workWeek');
        var opt = t.opt;
        var renderAgenda = t.renderAgenda;
        var formatDates = calendar.formatDates;



        function render(date, delta) {
            if (delta) {
                addDays(date, delta * 7);
            }
            var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
            var end = addDays(cloneDate(start), 7);
            var visStart = cloneDate(start);
            var visEnd = cloneDate(end);
            skipWeekend(visStart);
            skipWeekend(visEnd, -1, true);
            
            var tt = Date.dateTimePickerTitleFormatDates(visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);
            var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
            t.title = !translationMode ? tt : elma.ProcessTranslationHtmlElement(null, opt('titleFormat'), tt);
            t.start = start;
            t.end = end;
            t.visStart = visStart;
            t.visEnd = visEnd;
            var days = t.calendar.options.days;
            var renderDays = 5;
            var i;
            for (i = 0; i < days.length; i++) {
                if (days[i].dayOfWeek == 6 && days[i].state == 0) {
                    renderDays = 6;
                }
            }
            renderAgenda(renderDays);
        }
    }


    fcViews.agendaDay = AgendaDayView;

    function AgendaDayView(element, calendar) {
        var t = this;


        // exports
        t.render = render;


        // imports
        AgendaView.call(t, element, calendar, 'agendaDay');
        var opt = t.opt;
        var renderAgenda = t.renderAgenda;
        var formatDate = calendar.formatDate;



        function render(date, delta) {
            if (delta) {
                addDays(date, delta);
                if (!opt('weekends')) {
                    skipWeekend(date, delta < 0 ? -1 : 1);
                }
            }
            var start = cloneDate(date, true);
            var end = addDays(cloneDate(start), 1);
            t.title = date.dateTimePickerTitleFormatDate(opt('titleFormat'));
            t.start = t.visStart = start;
            t.end = t.visEnd = end;
            renderAgenda(1);
        }


    }

    setDefaults({
        allDaySlot: true,
        allDayText: 'all-day',
        firstHour: 9,
        slotMinutes: 30,
        defaultEventMinutes: 120,
        axisFormat: 'HH:mm',
        timeFormat: {
            agenda: 'HH:mm{ - HH:mm}'
        },
        dragOpacity: {
            agenda: .5
        },
        minTime: 0,
        maxTime: 24,
        startWorkDay: 0,
        endWorkDay: 24
    });


    // TODO: make it work in quirks mode (event corners, all-day height)
    // TODO: test liquid width, especially in IE6


    function AgendaView(element, calendar, viewName) {
        var t = this;


        // exports
        t.renderAgenda = renderAgenda;
        t.setWidth = setWidth;
        t.setHeight = setHeight;
        t.beforeHide = beforeHide;
        t.afterShow = afterShow;
        t.defaultEventEnd = defaultEventEnd;
        t.timePosition = timePosition;
        t.dayOfWeekCol = dayOfWeekCol;
        t.dateCell = dateCell;
        t.cellDate = cellDate;
        t.cellIsAllDay = cellIsAllDay;
        t.allDayRow = getAllDayRow;
        t.allDayBounds = allDayBounds;
        t.getHoverListener = function () { return hoverListener };
        t.colContentLeft = colContentLeft;
        t.colContentRight = colContentRight;
        t.getDaySegmentContainer = function () { return daySegmentContainer };
        t.getSlotSegmentContainer = function () { return slotSegmentContainer };
        t.getMinMinute = function () { return minMinute };
        t.getMaxMinute = function () { return maxMinute };
        t.getBodyContent = function () { return slotContent }; // !!??
        t.getRowCnt = function () { return 1 };
        t.getColCnt = function () { return colCnt };
        t.getColWidth = function () { return colWidth };
        t.getSlotHeight = function () { return slotHeight };
        t.defaultSelectionEnd = defaultSelectionEnd;
        t.renderDayOverlay = renderDayOverlay;
        t.renderSelection = renderSelection;
        t.clearSelection = clearSelection;
        t.reportDayClick = reportDayClick; // selection mousedown hack
        t.dragStart = dragStart;
        t.dragStop = dragStop;


        // imports
        View.call(t, element, calendar, viewName);
        OverlayManager.call(t);
        SelectionManager.call(t);
        AgendaEventRenderer.call(t);
        var opt = t.opt;
        var trigger = t.trigger;
        var clearEvents = t.clearEvents;
        var renderOverlay = t.renderOverlay;
        var clearOverlays = t.clearOverlays;
        var reportSelection = t.reportSelection;
        var unselect = t.unselect;
        var daySelectionMousedown = t.daySelectionMousedown;
        var slotSegHtml = t.slotSegHtml;
        var formatDate = calendar.formatDate;


        // locals

        var dayTable;
        var dayHead;
        var dayHeadCells;
        var dayBody;
        var dayBodyCells;
        var dayBodyCellInners;
        var dayBodyFirstCell;
        var dayBodyFirstCellStretcher;
        var slotLayer;
        var daySlotScroller;
        var daySlotContent;
        var daySegmentContainer;
        var allDayTable;
        var allDayRow;
        var slotScroller;
        var slotContent;
        var slotSegmentContainer;
        var slotTable;
        var slotTableFirstInner;
        var axisFirstCells;
        var gutterCells;
        var selectionHelper;

        var viewWidth;
        var viewHeight;
        var axisWidth;
        var colWidth;
        var gutterWidth;
        var slotHeight; // TODO: what if slotHeight changes? (see issue 650)
        var savedScrollTop;

        var colCnt;
        var slotCnt;
        var coordinateGrid;
        var hoverListener;
        var colContentPositions;
        var slotTopCache = {};

        var tm;
        var firstDay;
        var nwe;            // no weekends (int)
        var rtl, dis, dit;  // day index sign / translate
        var minMinute, maxMinute;
        var colFormat;



        /* Rendering
        -----------------------------------------------------------------------------*/


        disableTextSelection(element.addClass('fc-agenda'));


        function renderAgenda(c) {
            colCnt = c;
            updateOptions();
            if (!dayTable) {
                buildSkeleton();
            } else {
                clearEvents();
            }
            updateCells();
        }



        function updateOptions() {
            tm = opt('theme') ? 'ui' : 'fc';
            nwe = opt('weekends') ? 0 : 1;
            firstDay = opt('firstDay');
            if (rtl = opt('isRTL')) {
                dis = -1;
                dit = colCnt - 1;
            } else {
                dis = 1;
                dit = 0;
            }
            minMinute = parseTime(opt('minTime'));
            maxMinute = parseTime(opt('maxTime'));
            colFormat = opt('columnFormat');
        }



        function buildSkeleton() {
            var headerClass = tm + "-widget-header";
            var contentClass = tm + "-widget-content";
            var s;
            var i;
            var d;
            var maxd;
            var minutes;
            var slotNormal = opt('slotMinutes') % 15 == 0;

            s =
			"<table style='width:100%' class='fc-agenda-days fc-border-separate' cellspacing='0'>" +
			"<thead>" +
			"<tr>" +
			"<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
            for (i = 0; i < colCnt; i++) {
                s +=
				"<th class='fc- fc-col" + i + ' ' + headerClass + "'/>"; // fc- needed for setDayID
            }
            s +=
			"<th class='fc-agenda-gutter " + headerClass + "'>&nbsp;</th>" +
			"</tr>" +
			"</thead>" +
			"<tbody>" +
			"<tr>" +
			"<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
            for (i = 0; i < colCnt; i++) {
                s +=
				"<td class='fc- fc-col" + i + ' ' + contentClass + "'>" + // fc- needed for setDayID
				"<div>" +
				"<div class='fc-day-content'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</div>" +
				"</div>" +
				"</td>";
            }
            s +=
			"<td class='fc-agenda-gutter " + contentClass + "'>&nbsp;</td>" +
			"</tr>" +
			"</tbody>" +
			"</table>";
            dayTable = $(s).appendTo(element);
            dayHead = dayTable.find('thead');
            dayHeadCells = dayHead.find('th').slice(1, -1);
            dayBody = dayTable.find('tbody');
            dayBodyCells = dayBody.find('td').slice(0, -1);
            dayBodyCellInners = dayBodyCells.find('div.fc-day-content div');
            dayBodyFirstCell = dayBodyCells.eq(0);
            dayBodyFirstCellStretcher = dayBodyFirstCell.find('> div');

            markFirstLast(dayHead.add(dayHead.find('tr')));
            markFirstLast(dayBody.add(dayBody.find('tr')));

            axisFirstCells = dayHead.find('th:first');
            gutterCells = dayTable.find('.fc-agenda-gutter');

            slotLayer =
			$("<div style='position:absolute;z-index:2;left:0;width:100%'/>")
				.appendTo(element);

            if (opt('allDaySlot')) {

                daySlotScroller =
                $("<div class='day-slot-scroller' style='overflow-x:hidden;overflow-y:auto;max-height:100px;'/>")
                    .appendTo(slotLayer);

                daySlotContent =
                $("<div style='position:relative;width:100%;overflow:hidden'/>")
                    .appendTo(daySlotScroller);

                daySegmentContainer =
				$("<div style='position:absolute;z-index:8;top:0;left:0'/>")
					.appendTo(daySlotContent);

                s =
				"<table style='width:100%' class='fc-agenda-allday' cellspacing='0'>" +
				"<tr>" +
				"<th class='" + headerClass + " fc-agenda-axis'>" + opt('allDayText') + "</th>" +
				"<td>" +
				"<div class='fc-day-content'><div style='position:relative'/></div>" +
				"</td>" +
				"<th class='" + headerClass + " fc-agenda-gutter'>&nbsp;</th>" +
				"</tr>" +
				"</table>";
                allDayTable = $(s).appendTo(daySlotContent);
                allDayRow = allDayTable.find('tr');

                dayBind(allDayRow.find('td'));

                axisFirstCells = axisFirstCells.add(allDayTable.find('th:first'));
                gutterCells = gutterCells.add(allDayTable.find('th.fc-agenda-gutter'));

                slotLayer.append(
				"<div class='fc-agenda-allday-sep fc-agenda-divider " + headerClass + "'>" +
				"<div class='fc-agenda-divider-inner'/>" +
				"</div>"
			);

            } else {

                daySegmentContainer = $([]); // in jQuery 1.4, we can just do $()

            }

            slotScroller =
			$("<div style='position:absolute;width:100%;overflow-x:hidden;overflow-y:auto'/>")
				.appendTo(slotLayer);

            slotContent =
			$("<div style='position:relative;width:100%;overflow:hidden'/>")
				.appendTo(slotScroller);

            slotSegmentContainer =
			$("<div style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(slotContent);

            s =
			"<table class='fc-agenda-slots' style='width:100%' cellspacing='0'>" +
			"<tbody>";
            d = zeroDate();
            maxd = addMinutes(cloneDate(d), maxMinute);
            addMinutes(d, minMinute);
            slotCnt = 0;

            var startWorkTime = parseTime(opt('startWorkDay'));
            var endWorkTime = parseTime(opt('endWorkDay'));

            for (i = 0; d < maxd; i++) {
                minutes = d.getMinutes();
                s +=
				"<tr class='fc-slot" + i + ' ' + (!minutes ? '' : 'fc-minor') + "'>";
                if (!minutes) {
                    s += "<th rowspan='2' class='fc-agenda-axis " + headerClass + "'>" +
				        ((!slotNormal || !minutes) ? formatDate(d, opt('axisFormat')) : '&nbsp;') +
				        "</th>";
                }
                s += "<td class='" + contentClass + (parseTime(d) < startWorkTime || parseTime(d) >= endWorkTime ? " fc-state-not-work" : "") + "'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</td>" +
				"</tr>";
                addMinutes(d, opt('slotMinutes'));
                slotCnt++;
            }
            s +=
			"</tbody>" +
			"</table>";
            slotTable = $(s).appendTo(slotContent);
            slotTableFirstInner = slotTable.find('div:first');

            slotBind(slotTable.find('td'));

            axisFirstCells = axisFirstCells.add(slotTable.find('th:first'));
        }



        function updateCells() {
            var i;
            var headCell;
            var bodyCell;
            var date;
            var today = clearTime(new Date());
            for (i = 0; i < colCnt; i++) {
                date = colDate(i);
                headCell = dayHeadCells.eq(i);
                headCell.html(formatDate(date, colFormat));
                bodyCell = dayBodyCells.eq(i);
                if (+date == +today) {
                    bodyCell.addClass(tm + '-state-highlight fc-today');
                } else {
                    bodyCell.removeClass(tm + '-state-highlight fc-today');
                    if (isHoliday(date, date.getDay())) {
                        bodyCell.addClass('fc-holiday').removeClass('fc-exception');
                    }
                    else if (isException(date, date.getDay())) {
                        bodyCell.addClass('fc-exception').removeClass('fc-holiday');
                    }
                    else {
                        bodyCell.removeClass('fc-holiday fc-exception');
                    }
                }
                setDayID(headCell.add(bodyCell), date);
            }
        }

        function isHoliday(date, index) {
            if (!t || !t.calendar || !t.calendar.options)
                return false;
            var i, eDate;
            var exceptionDays = t.calendar.options.exceptionDays;
            if (exceptionDays) {
                for (i = 0; i < exceptionDays.length; i++) {
                    eDate = clearTime(convertJSONDate(exceptionDays[i].date));
                    if (+date == +eDate) {
                        return exceptionDays[i].dayType == 1;
                    }
                }

            }
            var days = t.calendar.options.days;
            if (days) {
                for (i = 0; i < days.length; i++) {
                    if (index == days[i].dayOfWeek % 7) {
                        return days[i].state == 1;
                    }
                }
            }
            return false;
        }

        function isException(date, index) {
            if (!t || !t.calendar || !t.calendar.options)
                return false;
            var i, eDate;
            var exceptionDays = t.calendar.options.exceptionDays;
            if (exceptionDays) {
                for (i = 0; i < exceptionDays.length; i++) {
                    eDate = clearTime(convertJSONDate(exceptionDays[i].date));
                    if (+date == +eDate) {
                        return exceptionDays[i].dayType == 0;
                    }
                }

            }
            var days = t.calendar.options.days;
            if (days) {
                for (i = 0; i < days.length; i++) {
                    if (index == days[i].dayOfWeek % 7) {
                        return days[i].state == 2;
                    }
                }
            }
            return false;
        }



        function setHeight(height, dateChanged) {
            if (height === undefined) {
                height = viewHeight;
            }
            viewHeight = height;
            slotTopCache = {};

            var headHeight = dayBody.position().top;
            var allDayHeight = slotScroller.position().top; // including divider
            var bodyHeight = Math.min( // total body height, including borders
			height - headHeight,   // when scrollbars
			slotTable.height() + allDayHeight + 1 // when no scrollbars. +1 for bottom border
		);

            dayBodyFirstCellStretcher
			.height(bodyHeight - vsides(dayBodyFirstCell));

            slotLayer.css('top', headHeight);

            slotScroller.height(bodyHeight - allDayHeight - 1);

            slotHeight = slotTableFirstInner.height() + 1; // +1 for border

            if (dateChanged) {
                resetScroll();
            }
        }



        function setWidth(width) {
            viewWidth = width;
            colContentPositions.clear();

            axisWidth = 0;
            setOuterWidth(
			axisFirstCells
				.width('')
				.each(function (i, _cell) {
				    axisWidth = Math.max(axisWidth, $(_cell).outerWidth());
				}),
			axisWidth
		);

            var slotTableWidth = slotScroller[0].clientWidth; // needs to be done after axisWidth (for IE7)
            //slotTable.width(slotTableWidth);

            gutterWidth = slotScroller.width() - slotTableWidth;
            if (gutterWidth) {
                setOuterWidth(gutterCells, gutterWidth);
                gutterCells
				.show()
				.prev()
				.removeClass('fc-last');
            } else {
                gutterCells
				.hide()
				.prev()
				.addClass('fc-last');
            }

            colWidth = Math.floor((slotTableWidth - axisWidth) / colCnt);
            setOuterWidth(dayHeadCells.slice(0, -1), colWidth);
        }



        function resetScroll() {
            var d0 = zeroDate();
            var scrollDate = cloneDate(d0);
            scrollDate.setHours(opt('firstHour'));
            var top = timePosition(d0, scrollDate) + 1; // +1 for the border
            function scroll() {
                slotScroller.scrollTop(top);
            }
            scroll();
            setTimeout(scroll, 0); // overrides any previous scroll state made by the browser
        }


        function beforeHide() {
            savedScrollTop = slotScroller.scrollTop();
        }


        function afterShow() {
            slotScroller.scrollTop(savedScrollTop);
        }



        /* Slot/Day clicking and binding
        -----------------------------------------------------------------------*/


        function dayBind(cells) {
            cells.click(slotClick)
			.mousedown(daySelectionMousedown);
        }


        function slotBind(cells) {
            cells.click(slotClick)
			.mousedown(slotSelectionMousedown);
        }


        function slotClick(ev) {
            if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
                var col = Math.min(colCnt - 1, Math.floor((ev.pageX - dayTable.offset().left - axisWidth) / colWidth));
                var date = colDate(col);
                var rowMatch = this.parentNode.className.match(/fc-slot(\d+)/); // TODO: maybe use data
                if (rowMatch) {
                    var mins = parseInt(rowMatch[1]) * opt('slotMinutes');
                    var hours = Math.floor(mins / 60);
                    date.setHours(hours);
                    date.setMinutes(mins % 60 + minMinute);
                    trigger('dayClick', dayBodyCells[col], date, false, ev);
                } else {
                    trigger('dayClick', dayBodyCells[col], date, true, ev);
                }
            }
        }



        /* Semi-transparent Overlay Helpers
        -----------------------------------------------------*/


        function renderDayOverlay(startDate, endDate, refreshCoordinateGrid) { // endDate is exclusive
            if (refreshCoordinateGrid) {
                coordinateGrid.build();
            }
            var visStart = cloneDate(t.visStart);
            var startCol, endCol;
            if (rtl) {
                startCol = dayDiff(endDate, visStart) * dis + dit + 1;
                endCol = dayDiff(startDate, visStart) * dis + dit + 1;
            } else {
                startCol = dayDiff(startDate, visStart);
                endCol = dayDiff(endDate, visStart);
            }
            startCol = Math.max(0, startCol);
            endCol = Math.min(colCnt, endCol);
            if (startCol < endCol) {
                dayBind(
				renderCellOverlay(0, startCol, 0, endCol - 1)
			);
            }
        }


        function renderCellOverlay(row0, col0, row1, col1) { // only for all-day?
            var rect = coordinateGrid.rect(row0, col0, row1, col1, daySlotContent);
            return renderOverlay(rect, daySlotContent);
        }


        function renderSlotOverlay(overlayStart, overlayEnd) {
            var dayStart = cloneDate(t.visStart);
            var dayEnd = addDays(cloneDate(dayStart), 1);
            for (var i = 0; i < colCnt; i++) {
                var stretchStart = new Date(Math.max(dayStart, overlayStart));
                var stretchEnd = new Date(Math.min(dayEnd, overlayEnd));
                if (stretchStart < stretchEnd) {
                    var col = i * dis + dit;
                    var rect = coordinateGrid.rect(0, col, 0, col, slotContent); // only use it for horizontal coords
                    var top = timePosition(dayStart, stretchStart);
                    var bottom = timePosition(dayStart, stretchEnd);
                    rect.top = top;
                    rect.height = bottom - top;
                    slotBind(
					renderOverlay(rect, slotContent)
				);
                }
                addDays(dayStart, 1);
                addDays(dayEnd, 1);
            }
        }



        /* Coordinate Utilities
        -----------------------------------------------------------------------------*/


        coordinateGrid = new CoordinateGrid(function (rows, cols) {
            var e, n, p;
            dayHeadCells.each(function (i, _e) {
                e = $(_e);
                n = e.offset().left;
                if (i) {
                    p[1] = n;
                }
                p = [n];
                cols[i] = p;
            });
            p[1] = n + e.outerWidth();
            if (opt('allDaySlot')) {
                e = allDayRow;
                n = e.offset().top;
                rows[0] = [n, n + e.outerHeight()];
            }
            var slotTableTop = slotContent.offset().top;
            var slotScrollerTop = slotScroller.offset().top;
            var slotScrollerBottom = slotScrollerTop + slotScroller.outerHeight();
            function constrain(n) {
                return Math.max(slotScrollerTop, Math.min(slotScrollerBottom, n));
            }
            for (var i = 0; i < slotCnt; i++) {
                rows.push([
				constrain(slotTableTop + slotHeight * i),
				constrain(slotTableTop + slotHeight * (i + 1))
			]);
            }
        });


        hoverListener = new HoverListener(coordinateGrid);


        colContentPositions = new HorizontalPositionCache(function (col) {
            return dayBodyCellInners.eq(col);
        });


        function colContentLeft(col) {
            return colContentPositions.left(col);
        }


        function colContentRight(col) {
            return colContentPositions.right(col);
        }




        function dateCell(date) { // "cell" terminology is now confusing
            return {
                row: Math.floor(dayDiff(date, t.visStart) / 7),
                col: dayOfWeekCol(date.getDay())
            };
        }


        function cellDate(cell) {
            var d = colDate(cell.col);
            var slotIndex = cell.row;
            if (opt('allDaySlot')) {
                slotIndex--;
            }
            if (slotIndex >= 0) {
                addMinutes(d, minMinute + slotIndex * opt('slotMinutes'));
            }
            return d;
        }


        function colDate(col) { // returns dates with 00:00:00
            return addDays(cloneDate(t.visStart), col * dis + dit);
        }


        function cellIsAllDay(cell) {
            return opt('allDaySlot') && !cell.row;
        }


        function dayOfWeekCol(dayOfWeek) {
            return ((dayOfWeek - Math.max(firstDay, nwe) + colCnt) % colCnt) * dis + dit;
        }




        // get the Y coordinate of the given time on the given day (both Date objects)
        function timePosition(day, time) { // both date objects. day holds 00:00 of current day
            day = cloneDate(day, true);
            if (time < addMinutes(cloneDate(day), minMinute)) {
                return 0;
            }
            if (time >= addMinutes(cloneDate(day), maxMinute)) {
                return slotTable.height();
            }
            var slotMinutes = opt('slotMinutes'),
			minutes = time.getHours() * 60 + time.getMinutes() - minMinute,
			slotI = Math.floor(minutes / slotMinutes),
			slotTop = slotTopCache[slotI];
            if (slotTop === undefined) {
                slotTop = slotTopCache[slotI] = slotTable.find('tr:eq(' + slotI + ') td div')[0].offsetTop; //.position().top; // need this optimization???
            }
            return Math.max(0, Math.round(
			slotTop - 1 + slotHeight * ((minutes % slotMinutes) / slotMinutes)
		));
        }


        function allDayBounds() {
            return {
                left: axisWidth,
                right: viewWidth - gutterWidth
            }
        }


        function getAllDayRow(index) {
            return allDayRow;
        }


        function defaultEventEnd(event) {
            var start = cloneDate(event.start);
            if (event.allDay) {
                return start;
            }
            return addMinutes(start, opt('defaultEventMinutes'));
        }



        /* Selection
        ---------------------------------------------------------------------------------*/


        function defaultSelectionEnd(startDate, allDay) {
            if (allDay) {
                return cloneDate(startDate);
            }
            return addMinutes(cloneDate(startDate), opt('slotMinutes'));
        }


        function renderSelection(startDate, endDate, allDay) { // only for all-day
            if (allDay) {
                if (opt('allDaySlot')) {
                    renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true);
                }
            } else {
                renderSlotSelection(startDate, endDate);
            }
        }


        function renderSlotSelection(startDate, endDate) {
            var helperOption = opt('selectHelper');
            coordinateGrid.build();
            if (helperOption) {
                var col = dayDiff(startDate, t.visStart) * dis + dit;
                if (col >= 0 && col < colCnt) { // only works when times are on same day
                    var rect = coordinateGrid.rect(0, col, 0, col, slotContent); // only for horizontal coords
                    var top = timePosition(startDate, startDate);
                    var bottom = timePosition(startDate, endDate);
                    if (bottom > top) { // protect against selections that are entirely before or after visible range
                        rect.top = top;
                        rect.height = bottom - top;
                        rect.left += 2;
                        rect.width -= 5;
                        if ($.isFunction(helperOption)) {
                            var helperRes = helperOption(startDate, endDate);
                            if (helperRes) {
                                rect.position = 'absolute';
                                rect.zIndex = 8;
                                selectionHelper = $(helperRes)
								.css(rect)
								.appendTo(slotContent);
                            }
                        } else {
                            rect.isStart = true; // conside rect a "seg" now
                            rect.isEnd = true;   //
                            selectionHelper = $(slotSegHtml(
							{
							    title: '',
							    start: startDate,
							    end: endDate,
							    className: ['fc-select-helper'],
							    editable: false
							},
							rect
						));
                            selectionHelper.css('opacity', opt('dragOpacity'));
                        }
                        if (selectionHelper) {
                            slotBind(selectionHelper);
                            slotContent.append(selectionHelper);
                            setOuterWidth(selectionHelper, rect.width, true); // needs to be after appended
                            setOuterHeight(selectionHelper, rect.height, true);
                        }
                    }
                }
            } else {
                renderSlotOverlay(startDate, endDate);
            }
        }


        function clearSelection() {
            clearOverlays();
            if (selectionHelper) {
                selectionHelper.remove();
                selectionHelper = null;
            }
        }


        function slotSelectionMousedown(ev) {
            if (ev.which == 1 && opt('selectable')) { // ev.which==1 means left mouse button
                unselect(ev);
                var dates;
                hoverListener.start(function (cell, origCell) {
                    clearSelection();
                    if (cell && cell.col == origCell.col && !cellIsAllDay(cell)) {
                        var d1 = cellDate(origCell);
                        var d2 = cellDate(cell);
                        dates = [
						d1,
						addMinutes(cloneDate(d1), opt('slotMinutes')),
						d2,
						addMinutes(cloneDate(d2), opt('slotMinutes'))
					].sort(cmp);
                        renderSlotSelection(dates[0], dates[3]);
                    } else {
                        dates = null;
                    }
                }, ev);
                $(document).one('mouseup', function (ev) {
                    hoverListener.stop();
                    if (dates) {
                        if (+dates[0] == +dates[1]) {
                            reportDayClick(dates[0], false, ev);
                        }
                        reportSelection(dates[0], dates[3], false, ev);
                    }
                });
            }
        }


        function reportDayClick(date, allDay, ev) {
            trigger('dayClick', dayBodyCells[dayOfWeekCol(date.getDay())], date, allDay, ev);
        }



        /* External Dragging
        --------------------------------------------------------------------------------*/


        function dragStart(_dragElement, ev, ui) {
            hoverListener.start(function (cell) {
                clearOverlays();
                if (cell) {
                    if (cellIsAllDay(cell)) {
                        renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
                    } else {
                        var d1 = cellDate(cell);
                        var d2 = addMinutes(cloneDate(d1), opt('defaultEventMinutes'));
                        renderSlotOverlay(d1, d2);
                    }
                }
            }, ev);
        }


        function dragStop(_dragElement, ev, ui) {
            var cell = hoverListener.stop();
            clearOverlays();
            if (cell) {
                trigger('drop', _dragElement, cellDate(cell), cellIsAllDay(cell), ev, ui);
            }
        }


    }

    function AgendaEventRenderer() {
        var t = this;


        // exports
        t.renderEvents = renderEvents;
        t.compileDaySegs = compileDaySegs; // for DayEventRenderer
        t.clearEvents = clearEvents;
        t.slotSegHtml = slotSegHtml;
        t.bindDaySeg = bindDaySeg;


        // imports
        DayEventRenderer.call(t);
        var opt = t.opt;
        var trigger = t.trigger;
        //var setOverflowHidden = t.setOverflowHidden;
        var isEventDraggable = t.isEventDraggable;
        var isEventResizable = t.isEventResizable;
        var eventEnd = t.eventEnd;
        var reportEvents = t.reportEvents;
        var reportEventClear = t.reportEventClear;
        var eventElementHandlers = t.eventElementHandlers;
        var setHeight = t.setHeight;
        var getDaySegmentContainer = t.getDaySegmentContainer;
        var getSlotSegmentContainer = t.getSlotSegmentContainer;
        var getHoverListener = t.getHoverListener;
        var getMaxMinute = t.getMaxMinute;
        var getMinMinute = t.getMinMinute;
        var timePosition = t.timePosition;
        var colContentLeft = t.colContentLeft;
        var colContentRight = t.colContentRight;
        var renderDaySegs = t.renderDaySegs;
        var resizableDayEvent = t.resizableDayEvent; // TODO: streamline binding architecture
        var getColCnt = t.getColCnt;
        var getColWidth = t.getColWidth;
        var getSlotHeight = t.getSlotHeight;
        var getBodyContent = t.getBodyContent;
        var reportEventElement = t.reportEventElement;
        var showEvents = t.showEvents;
        var hideEvents = t.hideEvents;
        var eventDrop = t.eventDrop;
        var eventResize = t.eventResize;
        var renderDayOverlay = t.renderDayOverlay;
        var clearOverlays = t.clearOverlays;
        var calendar = t.calendar;
        var formatDate = calendar.formatDate;
        var formatDates = calendar.formatDates;



        /* Rendering
        ----------------------------------------------------------------------------*/


        function renderEvents(events, modifiedEventId, modifiedEventUid) {
            reportEvents(events);
            var i, len = events.length,
			dayEvents = [],
			slotEvents = [];
            for (i = 0; i < len; i++) {
                if (events[i].allDay) {
                    dayEvents.push(events[i]);
                } else {
                    slotEvents.push(events[i]);
                }
            }
            if (opt('allDaySlot')) {
                renderDaySegs(compileDaySegs(dayEvents), modifiedEventId, modifiedEventUid);
                setHeight(); // no params means set to viewHeight
            }
            renderSlotSegs(compileSlotSegs(slotEvents), modifiedEventId, modifiedEventUid);
        }


        function clearEvents() {
            reportEventClear();
            getDaySegmentContainer().empty();
            getSlotSegmentContainer().empty();
        }


        function compileDaySegs(events) {
            var levels = stackSegs(sliceSegs(events, $.map(events, exclEndDay), t.visStart, t.visEnd)),
			i, levelCnt = levels.length, level,
			j, seg,
			segs = [];
            for (i = 0; i < levelCnt; i++) {
                level = levels[i];
                for (j = 0; j < level.length; j++) {
                    seg = level[j];
                    seg.row = 0;
                    seg.level = i; // not needed anymore
                    segs.push(seg);
                }
            }
            return segs;
        }


        function compileSlotSegs(events) {
            var colCnt = getColCnt(),
			minMinute = getMinMinute(),
			maxMinute = getMaxMinute(),
			d = addMinutes(cloneDate(t.visStart), minMinute),
			visEventEnds = $.map(events, slotEventEnd),
			i, col,
			j, level,
			k, seg,
			segs = [];
            for (i = 0; i < colCnt; i++) {
                col = stackSegs(sliceSegs(events, visEventEnds, d, addMinutes(cloneDate(d), maxMinute - minMinute)));
                countForwardSegs(col);
                for (j = 0; j < col.length; j++) {
                    level = col[j];
                    for (k = 0; k < level.length; k++) {
                        seg = level[k];
                        seg.col = i;
                        seg.level = j;
                        segs.push(seg);
                    }
                }
                addDays(d, 1, true);
            }
            return segs;
        }


        function slotEventEnd(event) {
            if (event.end) {
                return cloneDate(event.end);
            } else {
                return addMinutes(cloneDate(event.start), opt('defaultEventMinutes'));
            }
        }


        // renders events in the 'time slots' at the bottom

        function renderSlotSegs(segs, modifiedEventId, modifiedEventUid) {
            var i, segCnt = segs.length, seg,
			event,
			classes,
			top, bottom,
			colI, levelI, forward,
			leftmost,
			availWidth,
			outerWidth,
			left,
			html = '',
			eventElements,
			eventElement,
			triggerRes,
			vsideCache = {},
			hsideCache = {},
			key, val,
			contentElement,
			height,
			slotSegmentContainer = getSlotSegmentContainer(),
			rtl, dis, dit,
			colCnt = getColCnt();

            if (rtl = opt('isRTL')) {
                dis = -1;
                dit = colCnt - 1;
            } else {
                dis = 1;
                dit = 0;
            }

            // calculate position/dimensions, create html
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                event = seg.event;
                top = timePosition(seg.start, seg.start);
                bottom = timePosition(seg.start, seg.end);
                colI = seg.col;
                levelI = seg.level;
                forward = seg.forward || 0;
                leftmost = colContentLeft(colI * dis + dit);
                availWidth = colContentRight(colI * dis + dit) - leftmost;
                availWidth = Math.min(availWidth - 6, availWidth * .95); // TODO: move this to CSS
                if (levelI) {
                    // indented and thin
                    outerWidth = availWidth / (levelI + forward + 1);
                } else {
                    if (forward) {
                        // moderately wide, aligned left still
                        outerWidth = ((availWidth / (forward + 1)) - (12 / 2)) * 2; // 12 is the predicted width of resizer =
                    } else {
                        // can be entire width, aligned left
                        outerWidth = availWidth;
                    }
                }
                left = leftmost +                                  // leftmost possible
				(availWidth / (levelI + forward + 1) * levelI) // indentation
				* dis + (rtl ? availWidth - outerWidth : 0);   // rtl
                seg.top = top;
                seg.left = left;
                seg.outerWidth = outerWidth;
                seg.outerHeight = bottom - top;
                html += slotSegHtml(event, seg);
            }
            slotSegmentContainer[0].innerHTML = html; // faster than html()
            eventElements = slotSegmentContainer.children();

            // retrieve elements, run through eventRender callback, bind event handlers
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                event = seg.event;
                eventElement = $(eventElements[i]); // faster than eq()
                triggerRes = trigger('eventRender', event, event, eventElement);
                if (triggerRes === false) {
                    eventElement.remove();
                } else {
                    if (triggerRes && triggerRes !== true) {
                        eventElement.remove();
                        eventElement = $(triggerRes)
						.css({
						    position: 'absolute',
						    top: seg.top,
						    left: seg.left
						})
						.appendTo(slotSegmentContainer);
                    }
                    seg.element = eventElement;
                    if (event._id === modifiedEventId && (!event.uid || !modifiedEventUid || event.uid === modifiedEventUid)) {
                        bindSlotSeg(event, eventElement, seg);
                    } else {
                        eventElement[0]._fci = i; // for lazySegBind
                    }
                    reportEventElement(event, eventElement);
                }
            }

            lazySegBind(slotSegmentContainer, segs, bindSlotSeg);

            // record event sides and title positions
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                if (eventElement = seg.element) {
                    val = vsideCache[key = seg.key = cssKey(eventElement[0])];
                    seg.vsides = val === undefined ? (vsideCache[key] = vsides(eventElement, true)) : val;
                    val = hsideCache[key];
                    seg.hsides = val === undefined ? (hsideCache[key] = hsides(eventElement, true)) : val;
                    contentElement = eventElement.find('.fc-event-title');
                    if (contentElement.length) {
                        seg.contentTop = contentElement[0].offsetTop;
                    }
                }
            }

            // set all positions/dimensions at once
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                if (eventElement = seg.element) {
                    eventElement[0].style.width = Math.max(0, seg.outerWidth - seg.hsides) + 'px';
                    height = Math.max(0, seg.outerHeight - seg.vsides);
                    eventElement[0].style.height = height + 'px';
                    event = seg.event;
                    if (seg.contentTop !== undefined && height - seg.contentTop < 10) {
                        // not enough room for title
                        var titleElement = eventElement.find('.fc-event-title');
                        var width = eventElement.width() - eventElement.find('.fc-event-icon').width() - eventElement.find('.fc-event-time').width() - eventElement.find('.fc-event-remove').width();
                        //ie не добавляет аттрибуты по-другому
                        titleElement[0].setAttribute('style', 'text-overflow: ellipsis; overflow: hidden; white-space: nowrap; display: inline-block; vertical-align: text-bottom; width: ' + width + 'px;');
                    }
                    trigger('eventAfterRender', event, event, eventElement);
                }
            }
        }


        function slotSegHtml(event, seg) {
            var html = "<";
            var url = event.url;
            var skinCss = getSkinCss(event, opt);
            var skinCssAttr = (skinCss ? " style='" + skinCss + "'" : '');
            var classes = ['fc-event', 'fc-event-skin', 'fc-event-vert'];
            if (isEventDraggable(event)) {
                classes.push('fc-event-draggable');
            }
            if (seg.isStart) {
                classes.push('fc-corner-top');
            }
            if (seg.isEnd) {
                classes.push('fc-corner-bottom');
            }
            classes = classes.concat(event.className);
            if (event.source) {
                classes = classes.concat(event.source.className || []);
            }
            if (url) {
                html += "a href='" + htmlEscape(event.url) + "'";
            } else {
                html += "div";
            }
            html +=
			" class='" + classes.join(' ') + "'" +
			" style='position:absolute;z-index:8;top:" + seg.top + "px;left:" + seg.left + "px;" + skinCss + "'" +
			">" +
			"<div class='fc-event-inner fc-event-skin'" + skinCssAttr + ">" +
			"<div class='fc-event-head fc-event-skin'" + skinCssAttr + ">" +
            "<span class='fc-event-icon'></span>" +
			"<span class='fc-event-time'>" +
            (event.timeNotSet ? '??:??&nbsp;-&nbsp;??:??' : $.telerik.datetime.format(event.start, $.telerik.cultureInfo.shortTime) + ' - ' + $.telerik.datetime.format(event.end, $.telerik.cultureInfo.shortTime)) +
			"</span>" +
            "<span class='fc-event-title'>" +
			htmlEscape(event.title) +
			"</span>" +
			"</div>" +
            "<div class='fc-event-content'></div>" +
			"<div class='fc-event-bg'></div>" +
			"</div>"; // close inner
            if (seg.isEnd && isEventResizable(event)) {
                html +=
				"<div class='ui-resizable-handle ui-resizable-s'>=</div>";
            }
            html +=
			"</" + (url ? "a" : "div") + ">";
            return html;
        }


        function bindDaySeg(event, eventElement, seg) {
            if (isEventDraggable(event)) {
                draggableDayEvent(event, eventElement, seg.isStart);
            }
            if (seg.isEnd && isEventResizable(event)) {
                resizableDayEvent(event, eventElement, seg);
            }
            eventElementHandlers(event, eventElement);
            // needs to be after, because resizableDayEvent might stopImmediatePropagation on click
        }


        function bindSlotSeg(event, eventElement, seg) {
            var timeElement = eventElement.find('div.fc-event-time');
            if (isEventDraggable(event)) {
                draggableSlotEvent(event, eventElement, timeElement);
            }
            if (seg.isEnd && isEventResizable(event)) {
                resizableSlotEvent(event, eventElement, timeElement);
            }
            eventElementHandlers(event, eventElement);
        }



        /* Dragging
        -----------------------------------------------------------------------------------*/


        // when event starts out FULL-DAY

        function draggableDayEvent(event, eventElement, isStart) {
            var origWidth;
            var revert;
            var allDay = true;
            var dayDelta;
            var dis = opt('isRTL') ? -1 : 1;
            var hoverListener = getHoverListener();
            var colWidth = getColWidth();
            var slotHeight = getSlotHeight();
            var minMinute = getMinMinute();
            eventElement.draggable({
                zIndex: 9,
                opacity: opt('dragOpacity', 'month'), // use whatever the month view was using
                revertDuration: opt('dragRevertDuration'),
                start: function (ev, ui) {
                    trigger('eventDragStart', eventElement, event, ev, ui);
                    hideEvents(event, eventElement);
                    origWidth = eventElement.width();
                    hoverListener.start(function (cell, origCell, rowDelta, colDelta) {
                        clearOverlays();
                        if (cell) {
                            //setOverflowHidden(true);
                            revert = false;
                            dayDelta = colDelta * dis;
                            if (!cell.row) {
                                // on full-days
                                renderDayOverlay(
								addDays(cloneDate(event.start), dayDelta),
								addDays(exclEndDay(event), dayDelta)
							);
                                resetElement();
                            } else {
                                // mouse is over bottom slots
                                if (isStart) {
                                    if (allDay) {
                                        // convert event to temporary slot-event
                                        eventElement.width(colWidth - 10); // don't use entire width
                                        setOuterHeight(
										eventElement,
										slotHeight * Math.round(
											(event.end ? ((event.end - event.start) / MINUTE_MS) : opt('defaultEventMinutes'))
											/ opt('slotMinutes')
										)
									);
                                        eventElement.draggable('option', 'grid', [colWidth, 1]);
                                        allDay = false;
                                    }
                                } else {
                                    revert = true;
                                }
                            }
                            revert = revert || (allDay && !dayDelta);
                        } else {
                            resetElement();
                            //setOverflowHidden(false);
                            revert = true;
                        }
                        eventElement.draggable('option', 'revert', revert);
                    }, ev, 'drag');
                },
                stop: function (ev, ui) {
                    hoverListener.stop();
                    clearOverlays();
                    trigger('eventDragStop', eventElement, event, ev, ui);
                    if (revert) {
                        // hasn't moved or is out of bounds (draggable has already reverted)
                        resetElement();
                        eventElement.css('filter', ''); // clear IE opacity side-effects
                        showEvents(event, eventElement);
                    } else {
                        // changed!
                        var minuteDelta = 0;
                        if (!allDay) {
                            minuteDelta = Math.round((eventElement.offset().top - getBodyContent().offset().top) / slotHeight)
							* opt('slotMinutes')
							+ minMinute
							- (event.start.getHours() * 60 + event.start.getMinutes());
                        }
                        eventDrop(this, event, dayDelta, minuteDelta, allDay, ev, ui);
                    }
                    //setOverflowHidden(false);
                }
            });
            function resetElement() {
                if (!allDay) {
                    eventElement
					.width(origWidth)
					.height('')
					.draggable('option', 'grid', null);
                    allDay = true;
                }
            }
        }


        // when event starts out IN TIMESLOTS

        function draggableSlotEvent(event, eventElement, timeElement) {
            var origPosition;
            var allDay = false;
            var dayDelta;
            var minuteDelta;
            var prevMinuteDelta;
            var dis = opt('isRTL') ? -1 : 1;
            var hoverListener = getHoverListener();
            var colCnt = getColCnt();
            var colWidth = getColWidth();
            var slotHeight = getSlotHeight();
            eventElement.draggable({
                zIndex: 9,
                scroll: false,
                grid: [colWidth, slotHeight],
                axis: colCnt == 1 ? 'y' : false,
                opacity: opt('dragOpacity'),
                revertDuration: opt('dragRevertDuration'),
                start: function (ev, ui) {
                    trigger('eventDragStart', eventElement, event, ev, ui);
                    hideEvents(event, eventElement);
                    origPosition = eventElement.position();
                    minuteDelta = prevMinuteDelta = 0;
                    hoverListener.start(function (cell, origCell, rowDelta, colDelta) {
                        eventElement.draggable('option', 'revert', !cell);
                        clearOverlays();
                        if (cell) {
                            dayDelta = colDelta * dis;
                            if (opt('allDaySlot') && !cell.row) {
                                // over full days
                                if (!allDay) {
                                    // convert to temporary all-day event
                                    allDay = true;
                                    timeElement.hide();
                                    eventElement.draggable('option', 'grid', null);
                                }
                                renderDayOverlay(
								addDays(cloneDate(event.start), dayDelta),
								addDays(exclEndDay(event), dayDelta)
							);
                            } else {
                                // on slots
                                resetElement();
                            }
                        }
                    }, ev, 'drag');
                },
                drag: function (ev, ui) {
                    minuteDelta = Math.round((ui.position.top - origPosition.top) / slotHeight) * opt('slotMinutes');
                    if (minuteDelta != prevMinuteDelta) {
                        if (!allDay) {
                            updateTimeText(minuteDelta);
                        }
                        prevMinuteDelta = minuteDelta;
                    }
                },
                stop: function (ev, ui) {
                    var cell = hoverListener.stop();
                    clearOverlays();
                    trigger('eventDragStop', eventElement, event, ev, ui);
                    if (cell && (dayDelta || minuteDelta || allDay || event.timeNotSet)) {
                        // changed!
                        event.timeNotSet = false;
                        eventDrop(this, event, dayDelta, allDay ? 0 : minuteDelta, allDay, ev, ui);
                    } else {
                        // either no change or out-of-bounds (draggable has already reverted)
                        resetElement();
                        eventElement.css('filter', ''); // clear IE opacity side-effects
                        eventElement.css(origPosition); // sometimes fast drags make event revert to wrong position
                        updateTimeText(0);
                        showEvents(event, eventElement);
                    }
                }
            });
            function updateTimeText(minuteDelta) {
                var newStart = addMinutes(cloneDate(event.start), minuteDelta);
                var newEnd;
                if (event.end) {
                    newEnd = addMinutes(cloneDate(event.end), minuteDelta);
                }
                timeElement.text(($.telerik.datetime.format(newStart, $.telerik.cultureInfo.shortTime) + ' - ' + $.telerik.datetime.format(newEnd, $.telerik.cultureInfo.shortTime)));
            }
            function resetElement() {
                // convert back to original slot-event
                if (allDay) {
                    timeElement.css('display', ''); // show() was causing display=inline
                    eventElement.draggable('option', 'grid', [colWidth, slotHeight]);
                    allDay = false;
                }
            }
        }



        /* Resizing
        --------------------------------------------------------------------------------------*/


        function resizableSlotEvent(event, eventElement, timeElement) {
            var slotDelta, prevSlotDelta;
            var slotHeight = getSlotHeight();
            eventElement.resizable({
                handles: {
                    s: 'div.ui-resizable-s'
                },
                grid: slotHeight,
                start: function (ev, ui) {
                    if (event.timeNotSet) {
                        event.end = new Date(event.start);
                        addMinutes(event.end, 30);
                    }
                    slotDelta = prevSlotDelta = 0;
                    hideEvents(event, eventElement);
                    eventElement.css('z-index', 9);
                    trigger('eventResizeStart', this, event, ev, ui);
                },
                resize: function (ev, ui) {
                    // don't rely on ui.size.height, doesn't take grid into account
                    slotDelta = Math.round((Math.max(slotHeight, eventElement.height()) - ui.originalSize.height) / slotHeight);
                    if (slotDelta != prevSlotDelta) {
                        var timeElementString = $.telerik.datetime.format(event.start, $.telerik.cultureInfo.shortTime);
                        if (slotDelta || event.end) {
                              timeElementString += ' - ' + $.telerik.datetime.format(addMinutes(eventEnd(event), opt('slotMinutes') * slotDelta), $.telerik.cultureInfo.shortTime);
                        }
                        timeElement.text(timeElementString);
                        prevSlotDelta = slotDelta;
                    }
                },
                stop: function (ev, ui) {
                    trigger('eventResizeStop', this, event, ev, ui);
                    if (slotDelta || event.timeNotSet) {
                        if (event.timeNotSet) {
                            event.end = new Date(event.start);
                            slotDelta++;
                        }
                        event.timeNotSet = false;
                        eventResize(this, event, 0, opt('slotMinutes') * slotDelta, ev, ui);
                    } else {
                        eventElement.css('z-index', 8);
                        showEvents(event, eventElement);
                        // BUG: if event was really short, need to put title back in span
                    }
                }
            });
        }


    }


    function countForwardSegs(levels) {
        var i, j, k, level, segForward, segBack;
        for (i = levels.length - 1; i > 0; i--) {
            level = levels[i];
            for (j = 0; j < level.length; j++) {
                segForward = level[j];
                for (k = 0; k < levels[i - 1].length; k++) {
                    segBack = levels[i - 1][k];
                    if (segsCollide(segForward, segBack)) {
                        segBack.forward = Math.max(segBack.forward || 0, (segForward.forward || 0) + 1);
                    }
                }
            }
        }
    }




    function View(element, calendar, viewName) {
        var t = this;


        // exports
        t.element = element;
        t.calendar = calendar;
        t.name = viewName;
        t.opt = opt;
        t.trigger = trigger;
        //t.setOverflowHidden = setOverflowHidden;
        t.isEventDraggable = isEventDraggable;
        t.isEventResizable = isEventResizable;
        t.reportEvents = reportEvents;
        t.eventEnd = eventEnd;
        t.reportEventElement = reportEventElement;
        t.reportEventClear = reportEventClear;
        t.eventElementHandlers = eventElementHandlers;
        t.showEvents = showEvents;
        t.hideEvents = hideEvents;
        t.eventDrop = eventDrop;
        t.eventResize = eventResize;
        // t.title
        // t.start, t.end
        // t.visStart, t.visEnd


        // imports
        var defaultEventEnd = t.defaultEventEnd;
        var normalizeEvent = calendar.normalizeEvent; // in EventManager
        var reportEventChange = calendar.reportEventChange;


        // locals
        var eventsByID = {};
        var eventElements = [];
        var eventElementsByID = {};
        var options = calendar.options;



        function opt(name, viewNameOverride) {
            var v = options[name];
            if (typeof v == 'object') {
                return smartProperty(v, viewNameOverride || viewName);
            }
            return v;
        }


        function trigger(name, thisObj) {
            return calendar.trigger.apply(
			calendar,
			[name, thisObj || t].concat(Array.prototype.slice.call(arguments, 2), [t])
		);
        }


        /*
        function setOverflowHidden(bool) {
        element.css('overflow', bool ? 'hidden' : '');
        }
        */


        function isEventDraggable(event) {
            return isEventEditable(event) && !opt('disableDragging');
        }


        function isEventResizable(event) { // but also need to make sure the seg.isEnd == true
            return isEventEditable(event) && !opt('disableResizing');
        }


        function isEventEditable(event) {
            return firstDefined(event.editable, (event.source || {}).editable, opt('editable'));
        }



        /* Event Data
        ------------------------------------------------------------------------------*/


        // report when view receives new events
        function reportEvents(events) { // events are already normalized at this point
            eventsByID = {};
            var i, len = events.length, event;
            for (i = 0; i < len; i++) {
                event = events[i];
                if (!eventsByID[event._id]) {
                    eventsByID[event._id] = [];
                }
                eventsByID[event._id][event.uid] = event;
            }
        }


        // returns a Date object for an event's end
        function eventEnd(event) {
            return event.end ? cloneDate(event.end) : defaultEventEnd(event);
        }



        /* Event Elements
        ------------------------------------------------------------------------------*/


        // report when view creates an element for an event
        function reportEventElement(event, element) {
            eventElements.push(element);
            if (!eventElementsByID[event._id]) {
                eventElementsByID[event._id] = [];
            }
            eventElementsByID[event._id][event.uid] = element;
        }


        function reportEventClear() {
            eventElements = [];
            eventElementsByID = {};
        }


        // attaches eventClick, eventMouseover, eventMouseout
        function eventElementHandlers(event, eventElement) {
            eventElement
			.click(function (ev) {
			    if (!eventElement.hasClass('ui-draggable-dragging') &&
					!eventElement.hasClass('ui-resizable-resizing')) {
			        return trigger('eventClick', this, event, ev);
			    }
			})
			.hover(
				function (ev) {
				    trigger('eventMouseover', this, event, ev);
				},
				function (ev) {
				    trigger('eventMouseout', this, event, ev);
				}
			);
            // TODO: don't fire eventMouseover/eventMouseout *while* dragging is occuring (on subject element)
            // TODO: same for resizing
        }


        function showEvents(event, exceptElement) {
            eachEventElement(event, exceptElement, 'show');
        }


        function hideEvents(event, exceptElement) {
            eachEventElement(event, exceptElement, 'hide');
        }


        function eachEventElement(event, exceptElement, funcName) {
            var element = eventElementsByID[event._id][event.uid];
            if (!exceptElement || element[0] != exceptElement[0]) {
                element[funcName]();
            }
        }



        /* Event Modification Reporting
        ---------------------------------------------------------------------------------*/


        function eventDrop(e, event, dayDelta, minuteDelta, allDay, ev, ui) {
            var oldAllDay = event.allDay;
            var eventId = event._id;
            moveEvents([eventsByID[eventId][event.uid]], dayDelta, minuteDelta, allDay);
            trigger(
			'eventDrop',
			e,
			event,
			dayDelta,
			minuteDelta,
			allDay,
			function () {
			    // TODO: investigate cases where this inverse technique might not work
			    moveEvents([eventsByID[eventId][event.uid]], -dayDelta, -minuteDelta, oldAllDay);
			    reportEventChange(eventId, event.uid);
			},
			ev,
			ui
		);
            reportEventChange(eventId, event.uid);
        }


        function eventResize(e, event, dayDelta, minuteDelta, ev, ui) {
            var eventId = event._id;
            elongateEvents([eventsByID[eventId][event.uid]], dayDelta, minuteDelta);
            trigger(
			'eventResize',
			e,
			event,
			dayDelta,
			minuteDelta,
			function () {
			    // TODO: investigate cases where this inverse technique might not work
			    elongateEvents([eventsByID[eventId][event.uid]], -dayDelta, -minuteDelta);
			    reportEventChange(eventId, event.uid);
			},
			ev,
			ui
		);
			reportEventChange(eventId, event.uid);
        }



        /* Event Modification Math
        ---------------------------------------------------------------------------------*/


        function moveEvents(events, dayDelta, minuteDelta, allDay) {
            minuteDelta = minuteDelta || 0;
            for (var e, len = events.length, i = 0; i < len; i++) {
                e = events[i];
                if (allDay !== undefined) {
                    e.allDay = allDay;
                }
                addMinutes(addDays(e.start, dayDelta, true), minuteDelta);
                if (e.end) {
                    e.end = addMinutes(addDays(e.end, dayDelta, true), minuteDelta);
                }
                normalizeEvent(e, options);
            }
        }


        function elongateEvents(events, dayDelta, minuteDelta) {
            minuteDelta = minuteDelta || 0;
            for (var e, len = events.length, i = 0; i < len; i++) {
                e = events[i];
                e.end = addMinutes(addDays(eventEnd(e), dayDelta, true), minuteDelta);
                normalizeEvent(e, options);
            }
        }


    }

    function DayEventRenderer() {
        var t = this;


        // exports
        t.renderDaySegs = renderDaySegs;
        t.resizableDayEvent = resizableDayEvent;


        // imports
        var opt = t.opt;
        var trigger = t.trigger;
        var isEventDraggable = t.isEventDraggable;
        var isEventResizable = t.isEventResizable;
        var eventEnd = t.eventEnd;
        var reportEventElement = t.reportEventElement;
        var showEvents = t.showEvents;
        var hideEvents = t.hideEvents;
        var eventResize = t.eventResize;
        var getRowCnt = t.getRowCnt;
        var getColCnt = t.getColCnt;
        var getColWidth = t.getColWidth;
        var allDayRow = t.allDayRow;
        var allDayBounds = t.allDayBounds;
        var colContentLeft = t.colContentLeft;
        var colContentRight = t.colContentRight;
        var dayOfWeekCol = t.dayOfWeekCol;
        var dateCell = t.dateCell;
        var compileDaySegs = t.compileDaySegs;
        var getDaySegmentContainer = t.getDaySegmentContainer;
        var bindDaySeg = t.bindDaySeg; //TODO: streamline this
        var formatDates = t.calendar.formatDates;
        var renderDayOverlay = t.renderDayOverlay;
        var clearOverlays = t.clearOverlays;
        var clearSelection = t.clearSelection;



        /* Rendering
        -----------------------------------------------------------------------------*/


        function renderDaySegs(segs, modifiedEventId, modifiedEventUid) {
            var segmentContainer = getDaySegmentContainer();
            var rowDivs;
            var rowCnt = getRowCnt();
            var colCnt = getColCnt();
            var i = 0;
            var rowI;
            var levelI;
            var colHeights;
            var j;
            var segCnt = segs.length;
            var seg;
            var top;
            var k;
            segmentContainer[0].innerHTML = daySegHTML(segs); // faster than .html()
            daySegElementResolve(segs, segmentContainer.children());
            daySegElementReport(segs);
            daySegHandlers(segs, segmentContainer, modifiedEventId, modifiedEventUid);
            daySegCalcHSides(segs);
            daySegSetWidths(segs);
            daySegCalcHeights(segs);
            rowDivs = getRowDivs();
            // set row heights, calculate event tops (in relation to row top)
            for (rowI = 0; rowI < rowCnt; rowI++) {
                levelI = 0;
                colHeights = [];
                for (j = 0; j < colCnt; j++) {
                    colHeights[j] = 0;
                }
                while (i < segCnt && (seg = segs[i]).row == rowI) {
                    // loop through segs in a row
                    top = arrayMax(colHeights.slice(seg.startCol, seg.endCol));
                    seg.top = top;
                    top += seg.outerHeight;
                    for (k = seg.startCol; k < seg.endCol; k++) {
                        colHeights[k] = top;
                    }
                    i++;
                }
                rowDivs[rowI].height(arrayMax(colHeights));
            }
            daySegSetTops(segs, getRowTops(rowDivs));
        }


        function renderTempDaySegs(segs, adjustRow, adjustTop) {
            var tempContainer = $("<div/>");
            var elements;
            var segmentContainer = getDaySegmentContainer();
            var i;
            var segCnt = segs.length;
            var element;
            tempContainer[0].innerHTML = daySegHTML(segs); // faster than .html()
            elements = tempContainer.children();
            segmentContainer.append(elements);
            daySegElementResolve(segs, elements);
            daySegCalcHSides(segs);
            daySegSetWidths(segs);
            daySegCalcHeights(segs);
            daySegSetTops(segs, getRowTops(getRowDivs()));
            elements = [];
            for (i = 0; i < segCnt; i++) {
                element = segs[i].element;
                if (element) {
                    if (segs[i].row === adjustRow) {
                        element.css('top', adjustTop);
                    }
                    elements.push(element[0]);
                }
            }
            return $(elements);
        }


        function daySegHTML(segs) { // also sets seg.left and seg.outerWidth
            var rtl = opt('isRTL');
            var i;
            var segCnt = segs.length;
            var seg;
            var event;
            var url;
            var classes;
            var bounds = allDayBounds();
            var minLeft = bounds.left;
            var maxLeft = bounds.right;
            var leftCol;
            var rightCol;
            var left;
            var right;
            var skinCss;
            var html = '';
            // calculate desired position/dimensions, create html
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                event = seg.event;
                classes = ['fc-event', 'fc-event-skin', 'fc-event-hori'];
                if (isEventDraggable(event)) {
                    classes.push('fc-event-draggable');
                }
                if (rtl) {
                    if (seg.isStart) {
                        classes.push('fc-corner-right');
                    }
                    if (seg.isEnd) {
                        classes.push('fc-corner-left');
                    }
                    leftCol = dayOfWeekCol(seg.end.getDay() - 1);
                    rightCol = dayOfWeekCol(seg.start.getDay());
                    left = seg.isEnd ? colContentLeft(leftCol) : minLeft;
                    right = seg.isStart ? colContentRight(rightCol) : maxLeft;
                } else {
                    if (seg.isStart) {
                        classes.push('fc-corner-left');
                    }
                    if (seg.isEnd) {
                        classes.push('fc-corner-right');
                    }
                    leftCol = dayOfWeekCol(seg.start.getDay());
                    rightCol = dayOfWeekCol(seg.end.getDay() - 1);
                    left = seg.isStart ? colContentLeft(leftCol) : minLeft;
                    right = seg.isEnd ? colContentRight(rightCol) : maxLeft;
                }
                classes = classes.concat(event.className);
                if (event.source) {
                    classes = classes.concat(event.source.className || []);
                }
                url = event.url;
                skinCss = getSkinCss(event, opt);
                if (url) {
                    html += "<a href='" + htmlEscape(url) + "'";
                } else {
                    html += "<div";
                }
                html +=
				" class='" + classes.join(' ') + "'" +
				" style='position:absolute;z-index:8;left:" + left + "px;" + skinCss + "'" +
				">" +
				"<div" +
				" class='fc-event-inner fc-event-skin'" +
				(skinCss ? " style='" + skinCss + "'" : '') +
				">";
                if (!event.allDay && seg.isStart) {
                    html +=
                    "<span class='fc-event-icon'></span>" +
					"<span class='fc-event-time'>" +
					($.telerik.datetime.format(event.start, $.telerik.cultureInfo.shortTime) + ' - ' + $.telerik.datetime.format(event.end, $.telerik.cultureInfo.shortTime)) +
                    " " +
					"</span>";
                }
                html +=
				"<span class='fc-event-title'>" + htmlEscape(event.title) + "</span>" +
				"</div>";
                if (seg.isEnd && isEventResizable(event)) {
                    html +=
					"<div class='ui-resizable-handle ui-resizable-" + (rtl ? 'w' : 'e') + "'>" +
					"&nbsp;&nbsp;&nbsp;" + // makes hit area a lot better for IE6/7
					"</div>";
                }
                html +=
				"</" + (url ? "a" : "div") + ">";
                seg.left = left;
                seg.outerWidth = right - left;
                seg.startCol = leftCol;
                seg.endCol = rightCol + 1; // needs to be exclusive
            }
            return html;
        }


        function daySegElementResolve(segs, elements) { // sets seg.element
            var i;
            var segCnt = segs.length;
            var seg;
            var event;
            var element;
            var triggerRes;
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                event = seg.event;
                element = $(elements[i]); // faster than .eq()
                triggerRes = trigger('eventRender', event, event, element);
                if (triggerRes === false) {
                    element.remove();
                } else {
                    if (triggerRes && triggerRes !== true) {
                        triggerRes = $(triggerRes)
						.css({
						    position: 'absolute',
						    left: seg.left
						});
                        element.replaceWith(triggerRes);
                        element = triggerRes;
                    }
                    seg.element = element;
                }
            }
        }


        function daySegElementReport(segs) {
            var i;
            var segCnt = segs.length;
            var seg;
            var element;
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                element = seg.element;
                if (element) {
                    reportEventElement(seg.event, element);
                }
            }
        }


        function daySegHandlers(segs, segmentContainer, modifiedEventId, modifiedEventUid) {
            var i;
            var segCnt = segs.length;
            var seg;
            var element;
            var event;
            // retrieve elements, run through eventRender callback, bind handlers
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                element = seg.element;
                if (element) {
                    event = seg.event;
                    if (event._id === modifiedEventId && (!event.uid || !modifiedEventUid || event.uid === modifiedEventUid)) {
                        bindDaySeg(event, element, seg);
                    } else {
                        element[0]._fci = i; // for lazySegBind
                    }
                }
            }
            lazySegBind(segmentContainer, segs, bindDaySeg);
        }


        function daySegCalcHSides(segs) { // also sets seg.key
            var i;
            var segCnt = segs.length;
            var seg;
            var element;
            var key, val;
            var hsideCache = {};
            // record event horizontal sides
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                element = seg.element;
                if (element) {
                    key = seg.key = cssKey(element[0]);
                    val = hsideCache[key];
                    if (val === undefined) {
                        val = hsideCache[key] = hsides(element, true);
                    }
                    seg.hsides = val;
                }
            }
        }


        function daySegSetWidths(segs) {
            var i;
            var segCnt = segs.length;
            var seg;
            var element;
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                element = seg.element;
                if (element) {
                    element[0].style.width = Math.max(0, seg.outerWidth - seg.hsides) + 'px';
                }
            }
        }


        function daySegCalcHeights(segs) {
            var i;
            var segCnt = segs.length;
            var seg;
            var element;
            var key, val;
            var vmarginCache = {};
            // record event heights
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                element = seg.element;
                if (element) {
                    key = seg.key; // created in daySegCalcHSides
                    val = vmarginCache[key];
                    if (val === undefined) {
                        val = vmarginCache[key] = vmargins(element);
                    }
                    seg.outerHeight = element[0].offsetHeight + val;
                }
            }
        }


        function getRowDivs() {
            var i;
            var rowCnt = getRowCnt();
            var rowDivs = [];
            for (i = 0; i < rowCnt; i++) {
                rowDivs[i] = allDayRow(i)
				.find('td:first div.fc-day-content > div'); // optimal selector?
            }
            return rowDivs;
        }


        function getRowTops(rowDivs) {
            var i;
            var rowCnt = rowDivs.length;
            var tops = [];
            for (i = 0; i < rowCnt; i++) {
                tops[i] = rowDivs[i][0].offsetTop; // !!?? but this means the element needs position:relative if in a table cell!!!!
            }
            return tops;
        }


        function daySegSetTops(segs, rowTops) { // also triggers eventAfterRender
            var i;
            var segCnt = segs.length;
            var seg;
            var element;
            var event;
            for (i = 0; i < segCnt; i++) {
                seg = segs[i];
                element = seg.element;
                if (element) {
                    element[0].style.top = rowTops[seg.row] + (seg.top || 0) + 'px';
                    event = seg.event;
                    trigger('eventAfterRender', event, event, element);
                }
            }
        }



        /* Resizing
        -----------------------------------------------------------------------------------*/


        function resizableDayEvent(event, element, seg) {
            var rtl = opt('isRTL');
            var direction = rtl ? 'w' : 'e';
            var handle = element.find('div.ui-resizable-' + direction);
            var isResizing = false;

            // TODO: look into using jquery-ui mouse widget for this stuff
            disableTextSelection(element); // prevent native <a> selection for IE
            element
			.mousedown(function (ev) { // prevent native <a> selection for others
			    ev.preventDefault();
			})
			.click(function (ev) {
			    if (isResizing) {
			        ev.preventDefault(); // prevent link from being visited (only method that worked in IE6)
			        ev.stopImmediatePropagation(); // prevent fullcalendar eventClick handler from being called
			        // (eventElementHandlers needs to be bound after resizableDayEvent)
			    }
			});

            handle.mousedown(function (ev) {
                if (ev.which != 1) {
                    return; // needs to be left mouse button
                }
                isResizing = true;
                var hoverListener = t.getHoverListener();
                var rowCnt = getRowCnt();
                var colCnt = getColCnt();
                var dis = rtl ? -1 : 1;
                var dit = rtl ? colCnt - 1 : 0;
                var elementTop = element.css('top');
                var dayDelta;
                var helpers;
                var eventCopy = $.extend({}, event);
                var minCell = dateCell(event.start);
                clearSelection();
                $('body')
				.css('cursor', direction + '-resize')
				.one('mouseup', mouseup);
                trigger('eventResizeStart', this, event, ev);
                hoverListener.start(function (cell, origCell) {
                    if (cell) {
                        var r = Math.max(minCell.row, cell.row);
                        var c = cell.col;
                        if (rowCnt == 1) {
                            r = 0; // hack for all-day area in agenda views
                        }
                        if (r == minCell.row) {
                            if (rtl) {
                                c = Math.min(minCell.col, c);
                            } else {
                                c = Math.max(minCell.col, c);
                            }
                        }
                        dayDelta = (r * 7 + c * dis + dit) - (origCell.row * 7 + origCell.col * dis + dit);
                        var newEnd = addDays(eventEnd(event), dayDelta, true);
                        if (dayDelta) {
                            eventCopy.end = newEnd;
                            var oldHelpers = helpers;
                            helpers = renderTempDaySegs(compileDaySegs([eventCopy]), seg.row, elementTop);
                            helpers.find('*').css('cursor', direction + '-resize');
                            if (oldHelpers) {
                                oldHelpers.remove();
                            }
                            hideEvents(event);
                        } else {
                            if (helpers) {
                                showEvents(event);
                                helpers.remove();
                                helpers = null;
                            }
                        }
                        clearOverlays();
                        renderDayOverlay(event.start, addDays(cloneDate(newEnd), 1)); // coordinate grid already rebuild at hoverListener.start
                    }
                }, ev);

                function mouseup(ev) {
                    trigger('eventResizeStop', this, event, ev);
                    $('body').css('cursor', '');
                    hoverListener.stop();
                    clearOverlays();
                    if (dayDelta) {
                        eventResize(this, event, dayDelta, 0, ev);
                        // event redraw will clear helpers
                    }
                    // otherwise, the drag handler already restored the old events

                    setTimeout(function () { // make this happen after the element's click event
                        isResizing = false;
                    }, 0);
                }

            });
        }


    }

    //BUG: unselect needs to be triggered when events are dragged+dropped

    function SelectionManager() {
        var t = this;


        // exports
        t.select = select;
        t.unselect = unselect;
        t.reportSelection = reportSelection;
        t.daySelectionMousedown = daySelectionMousedown;


        // imports
        var opt = t.opt;
        var trigger = t.trigger;
        var defaultSelectionEnd = t.defaultSelectionEnd;
        var renderSelection = t.renderSelection;
        var clearSelection = t.clearSelection;


        // locals
        var selected = false;



        // unselectAuto
        if (opt('selectable') && opt('unselectAuto')) {
            $(document).mousedown(function (ev) {
                var ignore = opt('unselectCancel');
                if (ignore) {
                    if ($(ev.target).parents(ignore).length) { // could be optimized to stop after first match
                        return;
                    }
                }
                unselect(ev);
            });
        }


        function select(startDate, endDate, allDay) {
            unselect();
            if (!endDate) {
                endDate = defaultSelectionEnd(startDate, allDay);
            }
            renderSelection(startDate, endDate, allDay);
            reportSelection(startDate, endDate, allDay);
        }


        function unselect(ev) {
            if (selected) {
                selected = false;
                clearSelection();
                trigger('unselect', null, ev);
            }
        }


        function reportSelection(startDate, endDate, allDay, ev) {
            selected = true;
            trigger('select', null, startDate, endDate, allDay, ev);
        }


        function daySelectionMousedown(ev) { // not really a generic manager method, oh well
            var cellDate = t.cellDate;
            var cellIsAllDay = t.cellIsAllDay;
            var hoverListener = t.getHoverListener();
            var reportDayClick = t.reportDayClick; // this is hacky and sort of weird
            if (ev.which == 1 && opt('selectable')) { // which==1 means left mouse button
                var dates;
                unselect(ev);
                var _mousedownElement = this;
                hoverListener.start(function (cell, origCell) { // TODO: maybe put cellDate/cellIsAllDay info in cell
                    clearSelection();
                    if (cell && cellIsAllDay(cell)) {
                        dates = [cellDate(origCell), cellDate(cell)].sort(cmp);
                        renderSelection(dates[0], dates[1], true);
                    } else {
                        dates = null;
                    }
                }, ev);
                if (dates && ev.target && ev.target.nodeName == 'DIV' && ev.target.className == 'fc-day-number') {
                    clearSelection();
                    t.calendar.gotoDate(dates[0].getFullYear(), dates[0].getMonth(), dates[0].getDate());
                    t.calendar.changeView('agendaDay');
                } else {
                    $(document).one('mouseup', function (ev) {
                        hoverListener.stop();
                        if (dates) {
                            if (+dates[0] == +dates[1]) {
                                reportDayClick(dates[0], true, ev);
                            }
                            reportSelection(dates[0], dates[1], true, ev);
                        }
                    });
                }
            }
        }


    }

    function OverlayManager() {
        var t = this;


        // exports
        t.renderOverlay = renderOverlay;
        t.clearOverlays = clearOverlays;


        // locals
        var usedOverlays = [];
        var unusedOverlays = [];


        function renderOverlay(rect, parent) {
            var e = unusedOverlays.shift();
            if (!e) {
                e = $("<div class='fc-cell-overlay' style='position:absolute;z-index:3'/>");
            }
            if (e[0].parentNode != parent[0]) {
                e.appendTo(parent);
            }
            usedOverlays.push(e.css(rect).show());
            return e;
        }


        function clearOverlays() {
            var e;
            while (e = usedOverlays.shift()) {
                unusedOverlays.push(e.hide().unbind());
            }
        }


    }

    function CoordinateGrid(buildFunc) {

        var t = this;
        var rows;
        var cols;


        t.build = function () {
            rows = [];
            cols = [];
            buildFunc(rows, cols);
        };


        t.cell = function (x, y) {
            var rowCnt = rows.length;
            var colCnt = cols.length;
            var i, r = -1, c = -1;
            for (i = 0; i < rowCnt; i++) {
                if (y >= rows[i][0] && y < rows[i][1]) {
                    r = i;
                    break;
                }
            }
            for (i = 0; i < colCnt; i++) {
                if (x >= cols[i][0] && x < cols[i][1]) {
                    c = i;
                    break;
                }
            }
            return (r >= 0 && c >= 0) ? { row: r, col: c} : null;
        };


        t.rect = function (row0, col0, row1, col1, originElement) { // row1,col1 is inclusive
            var origin = originElement.offset();
            return {
                top: rows[row0][0] - origin.top,
                left: cols[col0][0] - origin.left,
                width: cols[col1][1] - cols[col0][0],
                height: rows[row1][1] - rows[row0][0]
            };
        };

    }

    function HoverListener(coordinateGrid) {


        var t = this;
        var bindType;
        var change;
        var firstCell;
        var cell;


        t.start = function (_change, ev, _bindType) {
            change = _change;
            firstCell = cell = null;
            coordinateGrid.build();
            mouse(ev);
            bindType = _bindType || 'mousemove';
            $(document).bind(bindType, mouse);
        };


        function mouse(ev) {
            var newCell = coordinateGrid.cell(ev.pageX, ev.pageY);
            if (!newCell != !cell || newCell && (newCell.row != cell.row || newCell.col != cell.col)) {
                if (newCell) {
                    if (!firstCell) {
                        firstCell = newCell;
                    }
                    change(newCell, firstCell, newCell.row - firstCell.row, newCell.col - firstCell.col);
                } else {
                    change(newCell, firstCell);
                }
                cell = newCell;
            }
        }


        t.stop = function () {
            $(document).unbind(bindType, mouse);
            return cell;
        };


    }

    function HorizontalPositionCache(getElement) {

        var t = this,
		elements = {},
		lefts = {},
		rights = {};

        function e(i) {
            return elements[i] = elements[i] || getElement(i);
        }

        t.left = function (i) {
            return lefts[i] = lefts[i] === undefined ? e(i).position().left : lefts[i];
        };

        t.right = function (i) {
            return rights[i] = rights[i] === undefined ? t.left(i) + e(i).width() : rights[i];
        };

        t.clear = function () {
            elements = {};
            lefts = {};
            rights = {};
        };

    }

})(jQuery);



/*
 * jQuery autoResize (textarea auto-resizer)
 * @copyright James Padolsey http://james.padolsey.com
 * @version 1.04
 */

(function ($) {

    $.fn.autoResize = function (options) {

        // Just some abstracted details,
        // to make plugin users happy:
        var settings = $.extend({
            onResize: function () { },
            animate: true,
            animateDuration: 150,
            animateCallback: function () { },
            extraSpace: 20,
            limit: 1000
        }, options);

        // Only textarea's auto-resize:
        this.filter('textarea').each(function () {

            // Get rid of scrollbars and disable WebKit resizing:
            var textarea = $(this).css({ resize: 'none', 'overflow-y': 'hidden' });

            // Cache original height, for use later:
            var origHeight = textarea.height();

            // Need clone of textarea, hidden off screen:
            var clone = (function () {

                // Properties which may effect space taken up by chracters:
                var props = ['lineHeight', 'textDecoration', 'letterSpacing'];
                var propOb = {};

                // Create object of styles to apply:
                $.each(props, function (i, prop) {
                    propOb[prop] = textarea.css(prop);
                });

                // Clone the actual textarea removing unique properties
                // and insert before original textarea:
                return textarea.clone().removeAttr('id').removeAttr('name').css({
                    position: 'absolute',
                    top: 0,
                    left: -9999
                }).css(propOb).attr('tabIndex', '-1').insertBefore(textarea);

            })();
            var lastHeight = null;
            var getHeight = function () {
                // Prepare the clone:
                clone.width(textarea.width()).height(0).val($(textarea[0]).val()).scrollTop(10000);

                // Find the height of text:
                return Math.max(clone.scrollTop(), origHeight) + settings.extraSpace;
            };
            var updateSize = function () {
                var height = getHeight();
                var toChange = $(this).add(clone);

                // Don't do anything if scrollTip hasen't changed:
                if (lastHeight === height) { return; }
                lastHeight = height;

                // Check for limit:
                if (height >= settings.limit) {
                    lastHeight = settings.limit;
                    $(this).css('overflow-y', 'auto');
                    textarea.height(lastHeight);
                    return;
                } else {
                    $(this).css('overflow-y', 'hidden');
                }
                // Fire off callback:
                settings.onResize.call(this);

                // Either animate or directly apply height:
                settings.animate && textarea.css('display') === 'block' ?
                        toChange.stop().animate({ height: height }, settings.animateDuration, settings.animateCallback)
                        : toChange.height(height);
            };
            textarea[0].UpdateSize = updateSize;
            // Bind namespaced handlers to appropriate events:
            textarea
                    .unbind('.dynSiz')
                    .bind('keyup.dynSiz', updateSize)
                    .bind('keydown.dynSiz', updateSize)
                    .bind('change.dynSiz', updateSize);

            textarea[0].SetSizeToText = function (forcibly) {
                var height = getHeight();

                // Don't do anything if scrollTip hasen't changed:
                if (lastHeight === height && !forcibly) { return; }

                if (height >= settings.limit) {
                    $(this).css('overflow-y', 'auto');
                    height = settings.limit;
                } else {
                    $(this).css('overflow-y', 'hidden');
                }

                lastHeight = height;

                textarea.height(height);
            };
        });

        // Chain:
        return this;

    };



})(jQuery);


(function(G){var B,J,C,K,N,M,I,E,H,A,L;B=document.namespaces;J=!!document.createElement("canvas").getContext;if(!(J||B)){G.fn.maphilight=function(){return this};return }if(J){E=function(O){return Math.max(0,Math.min(parseInt(O,16),255))};H=function(O,P){return"rgba("+E(O.substr(0,2))+","+E(O.substr(2,2))+","+E(O.substr(4,2))+","+P+")"};C=function(O){var P=G('<canvas style="width:'+O.width+"px;height:"+O.height+'px;"></canvas>').get(0);P.getContext("2d").clearRect(0,0,P.width,P.height);return P};var F=function(Q,O,R,P,S){P=P||0;S=S||0;Q.beginPath();if(O=="rect"){Q.rect(R[0]+P,R[1]+S,R[2]-R[0],R[3]-R[1])}else{if(O=="poly"){Q.moveTo(R[0]+P,R[1]+S);for(i=2;i<R.length;i+=2){Q.lineTo(R[i]+P,R[i+1]+S)}}else{if(O=="circ"){Q.arc(R[0]+P,R[1]+S,R[2],0,Math.PI*2,false)}}}Q.closePath()};K=function(Q,T,U,X,O){var S,P=Q.getContext("2d");if(X.shadow){P.save();if(X.shadowPosition=="inside"){F(P,T,U);P.clip()}var R=Q.width*100;var W=Q.height*100;F(P,T,U,R,W);P.shadowOffsetX=X.shadowX-R;P.shadowOffsetY=X.shadowY-W;P.shadowBlur=X.shadowRadius;P.shadowColor=H(X.shadowColor,X.shadowOpacity);var V=X.shadowFrom;if(!V){if(X.shadowPosition=="outside"){V="fill"}else{V="stroke"}}if(V=="stroke"){P.strokeStyle="rgba(0,0,0,1)";P.stroke()}else{if(V=="fill"){P.fillStyle="rgba(0,0,0,1)";P.fill()}}P.restore();if(X.shadowPosition=="outside"){P.save();F(P,T,U);P.globalCompositeOperation="destination-out";P.fillStyle="rgba(0,0,0,1);";P.fill();P.restore()}}P.save();F(P,T,U);if(X.fill){P.fillStyle=H(X.fillColor,X.fillOpacity);P.fill()}if(X.stroke){P.strokeStyle=H(X.strokeColor,X.strokeOpacity);P.lineWidth=X.strokeWidth;P.stroke()}P.restore();if(X.fade){G(Q).css("opacity",0).animate({opacity:1},100)}};N=function(O){O.getContext("2d").clearRect(0,0,O.width,O.height)}}else{C=function(O){return G('<var style="zoom:1;overflow:hidden;display:block;width:'+O.width+"px;height:"+O.height+'px;"></var>').get(0)};K=function(P,S,T,W,O){var U,V,Q,R;U='<v:fill color="#'+W.fillColor+'" opacity="'+(W.fill?W.fillOpacity:0)+'" />';V=(W.stroke?'strokeweight="'+W.strokeWidth+'" stroked="t" strokecolor="#'+W.strokeColor+'"':'stroked="f"');Q='<v:stroke opacity="'+W.strokeOpacity+'"/>';if(S=="rect"){R=G('<v:rect name="'+O+'" filled="t" '+V+' style="zoom:1;margin:0;padding:0;display:block;position:absolute;left:'+T[0]+"px;top:"+T[1]+"px;width:"+(T[2]-T[0])+"px;height:"+(T[3]-T[1])+'px;"></v:rect>')}else{if(S=="poly"){R=G('<v:shape name="'+O+'" filled="t" '+V+' coordorigin="0,0" coordsize="'+P.width+","+P.height+'" path="m '+T[0]+","+T[1]+" l "+T.join(",")+' x e" style="zoom:1;margin:0;padding:0;display:block;position:absolute;top:0px;left:0px;width:'+P.width+"px;height:"+P.height+'px;"></v:shape>')}else{if(S=="circ"){R=G('<v:oval name="'+O+'" filled="t" '+V+' style="zoom:1;margin:0;padding:0;display:block;position:absolute;left:'+(T[0]-T[2])+"px;top:"+(T[1]-T[2])+"px;width:"+(T[2]*2)+"px;height:"+(T[2]*2)+'px;"></v:oval>')}}}R.get(0).innerHTML=U+Q;G(P).append(R)};N=function(O){G(O).find("[name=highlighted]").remove()}}M=function(P){var O,Q=P.getAttribute("coords").split(",");for(O=0;O<Q.length;O++){Q[O]=parseFloat(Q[O])}return[P.getAttribute("shape").toLowerCase().substr(0,4),Q]};L=function(Q,P){var O=G(Q);return G.extend({},P,G.metadata?O.metadata():false,O.data("maphilight"))};A=function(O){if(!O.complete){return false}if(typeof O.naturalWidth!="undefined"&&O.naturalWidth==0){return false}return true};I={position:"absolute",left:0,top:0,padding:0,border:0};var D=false;G.fn.maphilight=function(Q){Q=G.extend({},G.fn.maphilight.defaults,Q);if(!J&&G.browser.msie&&!D){document.namespaces.add("v","urn:schemas-microsoft-com:vml");var P=document.createStyleSheet();var O=["shape","rect","oval","circ","fill","stroke","imagedata","group","textbox"];G.each(O,function(){P.addRule("v\\:"+this,"behavior: url(#default#VML); antialias:true")});D=true}return this.each(function(){var W,T,a,S,V,X,Z,U,Y;W=G(this);if(!A(this)){return window.setTimeout(function(){W.maphilight(Q)},200)}a=G.extend({},Q,G.metadata?W.metadata():false,W.data("maphilight"));Y=W.get(0).getAttribute("usemap");S=G('map[name="'+Y.substr(1)+'"]');if(!(W.is("img")&&Y&&S.size()>0)){return }if(W.hasClass("maphilighted")){var R=W.parent();W.insertBefore(R);R.remove();G(S).unbind(".maphilight").find("area[coords]").unbind(".maphilight")}T=G("<div></div>").css({display:"block",background:'url("'+this.src+'")',position:"relative",padding:0,width:this.width,height:this.height});if(a.wrapClass){if(a.wrapClass===true){T.addClass(G(this).attr("class"))}else{T.addClass(a.wrapClass)}}W.before(T).css("opacity",0).css(I).remove();if(G.browser.msie){W.css("filter","Alpha(opacity=0)")}T.append(W);V=C(this);G(V).css(I);V.height=this.height;V.width=this.width;Z=function(f){var c,d;d=L(this,a);if(!d.neverOn&&!d.alwaysOn){c=M(this);K(V,c[0],c[1],d,"highlighted");if(d.groupBy){var b;if(/^[a-zA-Z][-a-zA-Z]+$/.test(d.groupBy)){b=S.find("area["+d.groupBy+'="'+G(this).attr(d.groupBy)+'"]')}else{b=S.find(d.groupBy)}var g=this;b.each(function(){if(this!=g){var h=L(this,a);if(!h.neverOn&&!h.alwaysOn){var e=M(this);K(V,e[0],e[1],h,"highlighted")}}})}if(!J){G(V).append("<v:rect></v:rect>")}}};G(S).bind("alwaysOn.maphilight",function(){if(X){N(X)}if(!J){G(V).empty()}G(S).find("area[coords]").each(function(){var b,c;c=L(this,a);if(c.alwaysOn){if(!X&&J){X=C(W.get());G(X).css(I);X.width=W.width();X.height=W.height();W.before(X)}c.fade=c.alwaysOnFade;b=M(this);if(J){K(X,b[0],b[1],c,"")}else{K(V,b[0],b[1],c,"")}}})});G(S).trigger("alwaysOn.maphilight").find("area[coords]").bind("mouseover.maphilight",Z).bind("mouseout.maphilight",function(b){N(V)});W.before(V);W.addClass("maphilighted")})};G.fn.maphilight.defaults={fill:true,fillColor:"000000",fillOpacity:0.2,stroke:true,strokeColor:"ff0000",strokeOpacity:1,strokeWidth:1,fade:true,alwaysOn:false,neverOn:false,groupBy:false,wrapClass:true,shadow:false,shadowX:0,shadowY:0,shadowRadius:6,shadowColor:"000000",shadowOpacity:0.8,shadowPosition:"outside",shadowFrom:false}})(jQuery);


/*!
 * jQuery AutoColumnList Plugin
 * http://neolot.com/narabotki/autocolumnlist-jquery-plugin-dlya-razdeleniya-spiskov-na-kolonki
 * Copyright (c) 2011 Yury Pokhylko aka Neolot
 * Version: 1.0.2 (03/29/2011)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 * Requires: jQuery v1.3.2 or later
 * Updated by mihdan (http://kobzarev.com/)
 */
(function ($) {
    var defaults = {
        columns: 4,
        classname: 'column',
        selector: 'li',
        min: 1,
        max: 50
    };

    $.fn.autocolumnlist = function (params) {

        var options = $.extend({}, defaults, params);

        return this.each(function () {

            var els = $(this).find(options.selector);
            var dimension = els.size();

            if (dimension > 0) {
                var elCol = Math.ceil(dimension / options.columns);
                if (elCol < options.min) {
                    elCol = options.min;
                }
                if (elCol > options.max) {
                    elCol = options.max;
                }
                var start = 0;
                var end = elCol;

                for (var i = 0; i < options.columns; i++) {

                    // Add "last" class for last column
                    if ((i + 1) == options.columns) {
                        els.slice(start, dimension).wrapAll('<div class="' + options.classname + ' last" />');

                        if (options.max * options.columns < dimension) {
                            els.slice(end, dimension).hide();
                        }

                    } else {
                        els.slice(start, end).wrapAll('<div class="' + options.classname + '" />');
                    }
                    start += elCol;
                    end += elCol;
                }
            }
        });
    };
})(jQuery);


/*
    tabSlideOUt v1.1
    
    By William Paoli: http://wpaoli.building58.com

    To use you must have an image ready to go as your tab
    Make sure to pass in at minimum the path to the image and its dimensions:
    
    example:
    
        $('.slide-out-div').tabSlideOut({
                tabHandle: '.handle',                         //class of the element that will be your tab -doesnt have to be an anchor
                pathToTabImage: 'images/contact_tab.gif',     //relative path to the image for the tab *required*
                imageHeight: '133px',                         //height of tab image *required*
                imageWidth: '44px',                           //width of tab image *required*    
        });

    
*/


(function($){
    $.fn.tabSlideOut = function(callerSettings) {
        var settings = $.extend({
            tabHandle: '.handle',
            speed: 300, 
            action: 'click',
            tabLocation: 'left',
            topPos: '200px',
            leftPos: '20px',
            fixedPosition: false,
            positioning: 'absolute',
            pathToTabImage: null,
            imageHeight: null,
            imageWidth: null,
            offsetrightanimate: 0,                       
        }, callerSettings||{});

        settings.tabHandle = $(settings.tabHandle);
        var obj = this;
        if (settings.fixedPosition === true) {
            settings.positioning = 'fixed';
        } else {
            settings.positioning = 'absolute';
        }
        
        //ie6 doesn't do well with the fixed option
        if (document.all && !window.opera && !window.XMLHttpRequest) {
            settings.positioning = 'absolute';
        }
        
        //set initial tabHandle css
        settings.tabHandle.css({ 
            'display': 'block',
            'width' : settings.imageWidth,
            //'textIndent' : '-99999px',
            'outline' : 'none',
            'position' : 'absolute'
        });
        if (settings.imageHeight) {
            settings.tabHandle.css({ 'height': settings.imageHeight });
        }
        if (settings.pathToTabImage) {
            settings.tabHandle.css({ 'background': 'url(' + settings.pathToTabImage + ') no-repeat' });
        }
        obj.css({
            'line-height' : '1',
            'position' : settings.positioning
        });

        
        var properties = {
                    containerWidth: parseInt(obj.outerWidth(), 10) + 'px',
                    containerHeight: parseInt(obj.outerHeight(), 10) + 'px',
                    tabWidth: parseInt(settings.tabHandle.outerWidth(), 10) + 'px',
                    tabHeight: parseInt(settings.tabHandle.outerHeight(), 10) + 'px'
                };

        //set calculated css
        if(settings.tabLocation === 'top' || settings.tabLocation === 'bottom') {
            obj.css({'left' : settings.leftPos});
            settings.tabHandle.css({'right' : 0});
        }
        
        if(settings.tabLocation === 'top') {
            obj.css({'top' : '-' + properties.containerHeight});
            settings.tabHandle.css({'bottom' : '-' + properties.tabHeight});
        }

        if(settings.tabLocation === 'bottom') {
            obj.css({'bottom' : '-' + properties.containerHeight, 'position' : 'fixed'});
            settings.tabHandle.css({'top' : '-' + properties.tabHeight});
            
        }
        
        if(settings.tabLocation === 'left' || settings.tabLocation === 'right') {
            obj.css({
                //'height' : properties.containerHeight,
                'top' : settings.topPos
            });
            
            settings.tabHandle.css({'top' : 0});
        }
        
        if(settings.tabLocation === 'left') {
            obj.css({ 'left': '-' + properties.containerWidth});
            settings.tabHandle.css({'right' : '-' + properties.tabWidth});
        }

        if(settings.tabLocation === 'right') {
            obj.css({ 'right': '-' + properties.containerWidth});
            settings.tabHandle.css({'left' : '-' + properties.tabWidth});
            
            $('html').css('overflow-x', 'hidden');
        }

        //functions for animation events
        
        settings.tabHandle.click(function(event){
            event.preventDefault();
        });
        
        var slideIn = function() {
            
            if (settings.tabLocation === 'top') {
                obj.animate({top:'-' + properties.containerHeight}, settings.speed).removeClass('open');
            } else if (settings.tabLocation === 'left') {
                obj.animate({left: '-' + properties.containerWidth}, settings.speed).removeClass('open');
            } else if (settings.tabLocation === 'right') {
                obj.animate({right: '-' + properties.containerWidth}, settings.speed).removeClass('open');
            } else if (settings.tabLocation === 'bottom') {
                obj.animate({bottom: '-' + properties.containerHeight}, settings.speed).removeClass('open');
            }    
            
        };
        
        var slideOut = function() {
            
            if (settings.tabLocation == 'top') {
                obj.animate({top:'-3px'},  settings.speed).addClass('open');
            } else if (settings.tabLocation == 'left') {
                obj.animate({left:'-3px'},  settings.speed).addClass('open');
            } else if (settings.tabLocation == 'right') {
                obj.animate({right:(-3 + settings.offsetrightanimate) + 'px'},  settings.speed).addClass('open');
            } else if (settings.tabLocation == 'bottom') {
                obj.animate({bottom:'-3px'},  settings.speed).addClass('open');
            }
        };

        var clickScreenToClose = function() {
            obj.click(function(event){
                event.stopPropagation();
            });
            
            $(document).click(function(){
                slideIn();
            });
        };
        
        var clickAction = function(){
            settings.tabHandle.click(function(event){
                if (obj.hasClass('open')) {
                    slideIn();
                } else {
                    slideOut();
                }
            });
            
            clickScreenToClose();
        };
        
        var hoverAction = function(){
            obj.hover(
                function(){
                    slideOut();
                },
                
                function(){
                    slideIn();
                });
                
                settings.tabHandle.click(function(event){
                    if (obj.hasClass('open')) {
                        slideIn();
                    }
                });
                clickScreenToClose();
                
        };
        
        //choose which type of action to bind
        if (settings.action === 'click') {
            clickAction();
        }
        
        if (settings.action === 'hover') {
            hoverAction();
        }
    };
})(jQuery);



/*! Hammer.JS - v1.0.6 - 2014-01-02
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(window, undefined) {
  'use strict';

/**
 * Hammer
 * use this to create instances
 * @param   {HTMLElement}   element
 * @param   {Object}        options
 * @returns {Hammer.Instance}
 * @constructor
 */
var Hammer = function(element, options) {
  return new Hammer.Instance(element, options || {});
};

// default settings
Hammer.defaults = {
  // add styles and attributes to the element to prevent the browser from doing
  // its native behavior. this doesnt prevent the scrolling, but cancels
  // the contextmenu, tap highlighting etc
  // set to false to disable this
  stop_browser_behavior: {
    // this also triggers onselectstart=false for IE
    userSelect       : 'none',
    // this makes the element blocking in IE10 >, you could experiment with the value
    // see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241
    touchAction      : 'none',
    touchCallout     : 'none',
    contentZooming   : 'none',
    userDrag         : 'none',
    tapHighlightColor: 'rgba(0,0,0,0)'
  }

  //
  // more settings are defined per gesture at gestures.js
  //
};

// detect touchevents
Hammer.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

// dont use mouseevents on mobile devices
Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && window.navigator.userAgent.match(Hammer.MOBILE_REGEX);

// eventtypes per touchevent (start, move, end)
// are filled by Hammer.event.determineEventTypes on setup
Hammer.EVENT_TYPES = {};

// direction defines
Hammer.DIRECTION_DOWN = 'down';
Hammer.DIRECTION_LEFT = 'left';
Hammer.DIRECTION_UP = 'up';
Hammer.DIRECTION_RIGHT = 'right';

// pointer type
Hammer.POINTER_MOUSE = 'mouse';
Hammer.POINTER_TOUCH = 'touch';
Hammer.POINTER_PEN = 'pen';

// touch event defines
Hammer.EVENT_START = 'start';
Hammer.EVENT_MOVE = 'move';
Hammer.EVENT_END = 'end';

// hammer document where the base events are added at
Hammer.DOCUMENT = window.document;

// plugins and gestures namespaces
Hammer.plugins = Hammer.plugins || {};
Hammer.gestures = Hammer.gestures || {};

// if the window events are set...
Hammer.READY = false;

/**
 * setup events to detect gestures on the document
 */
function setup() {
  if(Hammer.READY) {
    return;
  }

  // find what eventtypes we add listeners to
  Hammer.event.determineEventTypes();

  // Register all gestures inside Hammer.gestures
  Hammer.utils.each(Hammer.gestures, function(gesture){
    Hammer.detection.register(gesture);
  });

  // Add touch events on the document
  Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);
  Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);

  // Hammer is ready...!
  Hammer.READY = true;
}

Hammer.utils = {
  /**
   * extend method,
   * also used for cloning when dest is an empty object
   * @param   {Object}    dest
   * @param   {Object}    src
   * @parm  {Boolean}  merge    do a merge
   * @returns {Object}    dest
   */
  extend: function extend(dest, src, merge) {
    for(var key in src) {
      if(dest[key] !== undefined && merge) {
        continue;
      }
      dest[key] = src[key];
    }
    return dest;
  },


  /**
   * for each
   * @param obj
   * @param iterator
   */
  each: function(obj, iterator, context) {
    var i, length;
    // native forEach on arrays
    if ('forEach' in obj) {
      obj.forEach(iterator, context);
    }
    // arrays
    else if(obj.length !== undefined) {
      for (i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
    // objects
    else {
      for (i in obj) {
        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },

  /**
   * find if a node is in the given parent
   * used for event delegation tricks
   * @param   {HTMLElement}   node
   * @param   {HTMLElement}   parent
   * @returns {boolean}       has_parent
   */
  hasParent: function(node, parent) {
    while(node) {
      if(node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },


  /**
   * get the center of all the touches
   * @param   {Array}     touches
   * @returns {Object}    center
   */
  getCenter: function getCenter(touches) {
    var valuesX = [], valuesY = [];

    Hammer.utils.each(touches, function(touch) {
      // I prefer clientX because it ignore the scrolling position
      valuesX.push(typeof touch.clientX !== 'undefined' ? touch.clientX : touch.pageX );
      valuesY.push(typeof touch.clientY !== 'undefined' ? touch.clientY : touch.pageY );
    });

    return {
      pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
      pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
    };
  },


  /**
   * calculate the velocity between two points
   * @param   {Number}    delta_time
   * @param   {Number}    delta_x
   * @param   {Number}    delta_y
   * @returns {Object}    velocity
   */
  getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
    return {
      x: Math.abs(delta_x / delta_time) || 0,
      y: Math.abs(delta_y / delta_time) || 0
    };
  },


  /**
   * calculate the angle between two coordinates
   * @param   {Touch}     touch1
   * @param   {Touch}     touch2
   * @returns {Number}    angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var y = touch2.pageY - touch1.pageY,
      x = touch2.pageX - touch1.pageX;
    return Math.atan2(y, x) * 180 / Math.PI;
  },


  /**
   * angle to direction define
   * @param   {Touch}     touch1
   * @param   {Touch}     touch2
   * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.pageX - touch2.pageX),
      y = Math.abs(touch1.pageY - touch2.pageY);

    if(x >= y) {
      return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
    }
    else {
      return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
    }
  },


  /**
   * calculate the distance between two touches
   * @param   {Touch}     touch1
   * @param   {Touch}     touch2
   * @returns {Number}    distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.pageX - touch1.pageX,
      y = touch2.pageY - touch1.pageY;
    return Math.sqrt((x * x) + (y * y));
  },


  /**
   * calculate the scale factor between two touchLists (fingers)
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param   {Array}     start
   * @param   {Array}     end
   * @returns {Number}    scale
   */
  getScale: function getScale(start, end) {
    // need two fingers...
    if(start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) /
        this.getDistance(start[0], start[1]);
    }
    return 1;
  },


  /**
   * calculate the rotation degrees between two touchLists (fingers)
   * @param   {Array}     start
   * @param   {Array}     end
   * @returns {Number}    rotation
   */
  getRotation: function getRotation(start, end) {
    // need two fingers
    if(start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) -
        this.getAngle(start[1], start[0]);
    }
    return 0;
  },


  /**
   * boolean if the direction is vertical
   * @param    {String}    direction
   * @returns  {Boolean}   is_vertical
   */
  isVertical: function isVertical(direction) {
    return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);
  },


  /**
   * stop browser default behavior with css props
   * @param   {HtmlElement}   element
   * @param   {Object}        css_props
   */
  stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {
    if(!css_props || !element || !element.style) {
      return;
    }

    // with css properties for modern browsers
    Hammer.utils.each(['webkit', 'khtml', 'moz', 'Moz', 'ms', 'o', ''], function(vendor) {
      Hammer.utils.each(css_props, function(prop) {
          // vender prefix at the property
          if(vendor) {
            prop = vendor + prop.substring(0, 1).toUpperCase() + prop.substring(1);
          }
          // set the style
          if(prop in element.style) {
            element.style[prop] = prop;
          }
      });
    });

    // also the disable onselectstart
    if(css_props.userSelect == 'none') {
      element.onselectstart = function() {
        return false;
      };
    }

    // and disable ondragstart
    if(css_props.userDrag == 'none') {
      element.ondragstart = function() {
        return false;
      };
    }
  }
};


/**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @param   {Object}            [options={}]
 * @returns {Hammer.Instance}
 * @constructor
 */
Hammer.Instance = function(element, options) {
  var self = this;

  // setup HammerJS window events and register all gestures
  // this also sets up the default options
  setup();

  this.element = element;

  // start/stop detection option
  this.enabled = true;

  // merge options
  this.options = Hammer.utils.extend(
    Hammer.utils.extend({}, Hammer.defaults),
    options || {});

  // add some css to the element to prevent the browser from doing its native behavoir
  if(this.options.stop_browser_behavior) {
    Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
  }

  // start detection on touchstart
  Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {
    if(self.enabled) {
      Hammer.detection.startDetect(self, ev);
    }
  });

  // return instance
  return this;
};


Hammer.Instance.prototype = {
  /**
   * bind events to the instance
   * @param   {String}      gesture
   * @param   {Function}    handler
   * @returns {Hammer.Instance}
   */
  on: function onEvent(gesture, handler) {
    var gestures = gesture.split(' ');
    Hammer.utils.each(gestures, function(gesture) {
      this.element.addEventListener(gesture, handler, false);
    }, this);
    return this;
  },


  /**
   * unbind events to the instance
   * @param   {String}      gesture
   * @param   {Function}    handler
   * @returns {Hammer.Instance}
   */
  off: function offEvent(gesture, handler) {
    var gestures = gesture.split(' ');
    Hammer.utils.each(gestures, function(gesture) {
      this.element.removeEventListener(gesture, handler, false);
    }, this);
    return this;
  },


  /**
   * trigger gesture event
   * @param   {String}      gesture
   * @param   {Object}      [eventData]
   * @returns {Hammer.Instance}
   */
  trigger: function triggerEvent(gesture, eventData) {
    // optional
    if(!eventData) {
      eventData = {};
    }

    // create DOM event
    var event = Hammer.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

    // trigger on the target if it is in the instance element,
    // this is for event delegation tricks
    var element = this.element;
    if(Hammer.utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }

    element.dispatchEvent(event);
    return this;
  },


  /**
   * enable of disable hammer.js detection
   * @param   {Boolean}   state
   * @returns {Hammer.Instance}
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  }
};


/**
 * this holds the last move event,
 * used to fix empty touchend issue
 * see the onTouch event for an explanation
 * @type {Object}
 */
var last_move_event = null;


/**
 * when the mouse is hold down, this is true
 * @type {Boolean}
 */
var enable_detect = false;


/**
 * when touch events have been fired, this is true
 * @type {Boolean}
 */
var touch_triggered = false;


Hammer.event = {
  /**
   * simple addEventListener
   * @param   {HTMLElement}   element
   * @param   {String}        type
   * @param   {Function}      handler
   */
  bindDom: function(element, type, handler) {
    var types = type.split(' ');
    Hammer.utils.each(types, function(type){
      element.addEventListener(type, handler, false);
    });
  },


  /**
   * touch events with mouse fallback
   * @param   {HTMLElement}   element
   * @param   {String}        eventType        like Hammer.EVENT_MOVE
   * @param   {Function}      handler
   */
  onTouch: function onTouch(element, eventType, handler) {
    var self = this;

    this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
      var sourceEventType = ev.type.toLowerCase();

      // onmouseup, but when touchend has been fired we do nothing.
      // this is for touchdevices which also fire a mouseup on touchend
      if(sourceEventType.match(/mouse/) && touch_triggered) {
        return;
      }

      // mousebutton must be down or a touch event
      else if(sourceEventType.match(/touch/) ||   // touch events are always on screen
        sourceEventType.match(/pointerdown/) || // pointerevents touch
        (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed
        ) {
        enable_detect = true;
      }

      // mouse isn't pressed
      else if(sourceEventType.match(/mouse/) && !ev.which) {
        enable_detect = false;
      }


      // we are in a touch event, set the touch triggered bool to true,
      // this for the conflicts that may occur on ios and android
      if(sourceEventType.match(/touch|pointer/)) {
        touch_triggered = true;
      }

      // count the total touches on the screen
      var count_touches = 0;

      // when touch has been triggered in this detection session
      // and we are now handling a mouse event, we stop that to prevent conflicts
      if(enable_detect) {
        // update pointerevent
        if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {
          count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
        }
        // touch
        else if(sourceEventType.match(/touch/)) {
          count_touches = ev.touches.length;
        }
        // mouse
        else if(!touch_triggered) {
          count_touches = sourceEventType.match(/up/) ? 0 : 1;
        }

        // if we are in a end event, but when we remove one touch and
        // we still have enough, set eventType to move
        if(count_touches > 0 && eventType == Hammer.EVENT_END) {
          eventType = Hammer.EVENT_MOVE;
        }
        // no touches, force the end event
        else if(!count_touches) {
          eventType = Hammer.EVENT_END;
        }

        // store the last move event
        if(count_touches || last_move_event === null) {
          last_move_event = ev;
        }

        // trigger the handler
        handler.call(Hammer.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));

        // remove pointerevent from list
        if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {
          count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
        }
      }

      // on the end we reset everything
      if(!count_touches) {
        last_move_event = null;
        enable_detect = false;
        touch_triggered = false;
        Hammer.PointerEvent.reset();
      }
    });
  },


  /**
   * we have different events for each device/browser
   * determine what we need and set them in the Hammer.EVENT_TYPES constant
   */
  determineEventTypes: function determineEventTypes() {
    // determine the eventtype we want to set
    var types;

    // pointerEvents magic
    if(Hammer.HAS_POINTEREVENTS) {
      types = Hammer.PointerEvent.getEvents();
    }
    // on Android, iOS, blackberry, windows mobile we dont want any mouseevents
    else if(Hammer.NO_MOUSEEVENTS) {
      types = [
        'touchstart',
        'touchmove',
        'touchend touchcancel'];
    }
    // for non pointer events browsers and mixed browsers,
    // like chrome on windows8 touch laptop
    else {
      types = [
        'touchstart mousedown',
        'touchmove mousemove',
        'touchend touchcancel mouseup'];
    }

    Hammer.EVENT_TYPES[Hammer.EVENT_START] = types[0];
    Hammer.EVENT_TYPES[Hammer.EVENT_MOVE] = types[1];
    Hammer.EVENT_TYPES[Hammer.EVENT_END] = types[2];
  },


  /**
   * create touchlist depending on the event
   * @param   {Object}    ev
   * @param   {String}    eventType   used by the fakemultitouch plugin
   */
  getTouchList: function getTouchList(ev/*, eventType*/) {
    // get the fake pointerEvent touchlist
    if(Hammer.HAS_POINTEREVENTS) {
      return Hammer.PointerEvent.getTouchList();
    }
    // get the touchlist
    else if(ev.touches) {
      return ev.touches;
    }
    // make fake touchlist from mouse position
    else {
      ev.identifier = 1;
      return [ev];
    }
  },


  /**
   * collect event data for Hammer js
   * @param   {HTMLElement}   element
   * @param   {String}        eventType        like Hammer.EVENT_MOVE
   * @param   {Object}        eventData
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    // find out pointerType
    var pointerType = Hammer.POINTER_TOUCH;
    if(ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {
      pointerType = Hammer.POINTER_MOUSE;
    }

    return {
      center     : Hammer.utils.getCenter(touches),
      timeStamp  : new Date().getTime(),
      target     : ev.target,
      touches    : touches,
      eventType  : eventType,
      pointerType: pointerType,
      srcEvent   : ev,

      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function() {
        if(this.srcEvent.preventManipulation) {
          this.srcEvent.preventManipulation();
        }

        if(this.srcEvent.preventDefault) {
          this.srcEvent.preventDefault();
        }
      },

      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function() {
        this.srcEvent.stopPropagation();
      },

      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function() {
        return Hammer.detection.stopDetect();
      }
    };
  }
};

Hammer.PointerEvent = {
  /**
   * holds all pointers
   * @type {Object}
   */
  pointers: {},

  /**
   * get a list of pointers
   * @returns {Array}     touchlist
   */
  getTouchList: function() {
    var self = this;
    var touchlist = [];

    // we can use forEach since pointerEvents only is in IE10
    Hammer.utils.each(self.pointers, function(pointer){
      touchlist.push(pointer);
    });
    
    return touchlist;
  },

  /**
   * update the position of a pointer
   * @param   {String}   type             Hammer.EVENT_END
   * @param   {Object}   pointerEvent
   */
  updatePointer: function(type, pointerEvent) {
    if(type == Hammer.EVENT_END) {
      this.pointers = {};
    }
    else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }

    return Object.keys(this.pointers).length;
  },

  /**
   * check if ev matches pointertype
   * @param   {String}        pointerType     Hammer.POINTER_MOUSE
   * @param   {PointerEvent}  ev
   */
  matchType: function(pointerType, ev) {
    if(!ev.pointerType) {
      return false;
    }

    var pt = ev.pointerType,
      types = {};
    types[Hammer.POINTER_MOUSE] = (pt === ev.MSPOINTER_TYPE_MOUSE || pt === Hammer.POINTER_MOUSE);
    types[Hammer.POINTER_TOUCH] = (pt === ev.MSPOINTER_TYPE_TOUCH || pt === Hammer.POINTER_TOUCH);
    types[Hammer.POINTER_PEN] = (pt === ev.MSPOINTER_TYPE_PEN || pt === Hammer.POINTER_PEN);
    return types[pointerType];
  },


  /**
   * get events
   */
  getEvents: function() {
    return [
      'pointerdown MSPointerDown',
      'pointermove MSPointerMove',
      'pointerup pointercancel MSPointerUp MSPointerCancel'
    ];
  },

  /**
   * reset the list
   */
  reset: function() {
    this.pointers = {};
  }
};


Hammer.detection = {
  // contains all registred Hammer.gestures in the correct order
  gestures: [],

  // data of the current Hammer.gesture detection session
  current : null,

  // the previous Hammer.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,

  // when this becomes true, no gestures are fired
  stopped : false,


  /**
   * start Hammer.gesture detection
   * @param   {Hammer.Instance}   inst
   * @param   {Object}            eventData
   */
  startDetect: function startDetect(inst, eventData) {
    // already busy with a Hammer.gesture detection on an element
    if(this.current) {
      return;
    }

    this.stopped = false;

    this.current = {
      inst      : inst, // reference to HammerInstance we're working for
      startEvent: Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc
      lastEvent : false, // last eventData
      name      : '' // current gesture we're in/detected, can be 'tap', 'hold' etc
    };

    this.detect(eventData);
  },


  /**
   * Hammer.gesture detection
   * @param   {Object}    eventData
   */
  detect: function detect(eventData) {
    if(!this.current || this.stopped) {
      return;
    }

    // extend event data with calculations about scale, distance etc
    eventData = this.extendEventData(eventData);

    // instance options
    var inst_options = this.current.inst.options;

    // call Hammer.gesture handlers
    Hammer.utils.each(this.gestures, function(gesture) {
      // only when the instance options have enabled this gesture
      if(!this.stopped && inst_options[gesture.name] !== false) {
        // if a handler returns false, we stop with the detection
        if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {
          this.stopDetect();
          return false;
        }
      }
    }, this);

    // store as previous event event
    if(this.current) {
      this.current.lastEvent = eventData;
    }

    // endevent, but not the last touch, so dont stop
    if(eventData.eventType == Hammer.EVENT_END && !eventData.touches.length - 1) {
      this.stopDetect();
    }

    return eventData;
  },


  /**
   * clear the Hammer.gesture vars
   * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
   * to stop other Hammer.gestures from being fired
   */
  stopDetect: function stopDetect() {
    // clone current data to the store as the previous gesture
    // used for the double tap gesture, since this is an other gesture detect session
    this.previous = Hammer.utils.extend({}, this.current);

    // reset the current
    this.current = null;

    // stopped!
    this.stopped = true;
  },


  /**
   * extend eventData for Hammer.gestures
   * @param   {Object}   ev
   * @returns {Object}   ev
   */
  extendEventData: function extendEventData(ev) {
    var startEv = this.current.startEvent;

    // if the touches change, set the new touches over the startEvent touches
    // this because touchevents don't have all the touches on touchstart, or the
    // user must place his fingers at the EXACT same time on the screen, which is not realistic
    // but, sometimes it happens that both fingers are touching at the EXACT same time
    if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
      // extend 1 level deep to get the touchlist with the touch objects
      startEv.touches = [];
      Hammer.utils.each(ev.touches, function(touch) {
        startEv.touches.push(Hammer.utils.extend({}, touch));
      });
    }

    var delta_time = ev.timeStamp - startEv.timeStamp
      , delta_x = ev.center.pageX - startEv.center.pageX
      , delta_y = ev.center.pageY - startEv.center.pageY
      , velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y)
      , interimAngle
      , interimDirection;

    // end events (e.g. dragend) don't have useful values for interimDirection & interimAngle
    // because the previous event has exactly the same coordinates
    // so for end events, take the previous values of interimDirection & interimAngle
    // instead of recalculating them and getting a spurious '0'
    if(ev.eventType === 'end') {
      interimAngle = this.current.lastEvent && this.current.lastEvent.interimAngle;
      interimDirection = this.current.lastEvent && this.current.lastEvent.interimDirection;
    }
    else {
      interimAngle = this.current.lastEvent && Hammer.utils.getAngle(this.current.lastEvent.center, ev.center);
      interimDirection = this.current.lastEvent && Hammer.utils.getDirection(this.current.lastEvent.center, ev.center);
    }

    Hammer.utils.extend(ev, {
      deltaTime: delta_time,

      deltaX: delta_x,
      deltaY: delta_y,

      velocityX: velocity.x,
      velocityY: velocity.y,

      distance: Hammer.utils.getDistance(startEv.center, ev.center),

      angle: Hammer.utils.getAngle(startEv.center, ev.center),
      interimAngle: interimAngle,

      direction: Hammer.utils.getDirection(startEv.center, ev.center),
      interimDirection: interimDirection,

      scale: Hammer.utils.getScale(startEv.touches, ev.touches),
      rotation: Hammer.utils.getRotation(startEv.touches, ev.touches),

      startEvent: startEv
    });

    return ev;
  },


  /**
   * register new gesture
   * @param   {Object}    gesture object, see gestures.js for documentation
   * @returns {Array}     gestures
   */
  register: function register(gesture) {
    // add an enable gesture options if there is no given
    var options = gesture.defaults || {};
    if(options[gesture.name] === undefined) {
      options[gesture.name] = true;
    }

    // extend Hammer default options with the Hammer.gesture options
    Hammer.utils.extend(Hammer.defaults, options, true);

    // set its index
    gesture.index = gesture.index || 1000;

    // add Hammer.gesture to the list
    this.gestures.push(gesture);

    // sort the list by index
    this.gestures.sort(function(a, b) {
      if(a.index < b.index) { return -1; }
      if(a.index > b.index) { return 1; }
      return 0;
    });

    return this.gestures;
  }
};


/**
 * Drag
 * Move with x fingers (default 1) around on the page. Blocking the scrolling when
 * moving left and right is a good practice. When all the drag events are blocking
 * you disable scrolling on that area.
 * @events  drag, drapleft, dragright, dragup, dragdown
 */
Hammer.gestures.Drag = {
  name     : 'drag',
  index    : 50,
  defaults : {
    drag_min_distance            : 10,
    
    // Set correct_for_drag_min_distance to true to make the starting point of the drag
    // be calculated from where the drag was triggered, not from where the touch started.
    // Useful to avoid a jerk-starting drag, which can make fine-adjustments
    // through dragging difficult, and be visually unappealing.
    correct_for_drag_min_distance: true,
    
    // set 0 for unlimited, but this can conflict with transform
    drag_max_touches             : 1,
    
    // prevent default browser behavior when dragging occurs
    // be careful with it, it makes the element a blocking element
    // when you are using the drag gesture, it is a good practice to set this true
    drag_block_horizontal        : false,
    drag_block_vertical          : false,
    
    // drag_lock_to_axis keeps the drag gesture on the axis that it started on,
    // It disallows vertical directions if the initial direction was horizontal, and vice versa.
    drag_lock_to_axis            : false,
    
    // drag lock only kicks in when distance > drag_lock_min_distance
    // This way, locking occurs only when the distance has become large enough to reliably determine the direction
    drag_lock_min_distance       : 25
  },
  
  triggered: false,
  handler  : function dragGesture(ev, inst) {
    // current gesture isnt drag, but dragged is true
    // this means an other gesture is busy. now call dragend
    if(Hammer.detection.current.name != this.name && this.triggered) {
      inst.trigger(this.name + 'end', ev);
      this.triggered = false;
      return;
    }

    // max touches
    if(inst.options.drag_max_touches > 0 &&
      ev.touches.length > inst.options.drag_max_touches) {
      return;
    }

    switch(ev.eventType) {
      case Hammer.EVENT_START:
        this.triggered = false;
        break;

      case Hammer.EVENT_MOVE:
        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if(ev.distance < inst.options.drag_min_distance &&
          Hammer.detection.current.name != this.name) {
          return;
        }

        // we are dragging!
        if(Hammer.detection.current.name != this.name) {
          Hammer.detection.current.name = this.name;
          if(inst.options.correct_for_drag_min_distance && ev.distance > 0) {
            // When a drag is triggered, set the event center to drag_min_distance pixels from the original event center.
            // Without this correction, the dragged distance would jumpstart at drag_min_distance pixels instead of at 0.
            // It might be useful to save the original start point somewhere
            var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
            Hammer.detection.current.startEvent.center.pageX += ev.deltaX * factor;
            Hammer.detection.current.startEvent.center.pageY += ev.deltaY * factor;

            // recalculate event data using new start point
            ev = Hammer.detection.extendEventData(ev);
          }
        }

        // lock drag to axis?
        if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance)) {
          ev.drag_locked_to_axis = true;
        }
        var last_direction = Hammer.detection.current.lastEvent.direction;
        if(ev.drag_locked_to_axis && last_direction !== ev.direction) {
          // keep direction on the axis that the drag gesture started on
          if(Hammer.utils.isVertical(last_direction)) {
            ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
          }
          else {
            ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
          }
        }

        // first time, trigger dragstart event
        if(!this.triggered) {
          inst.trigger(this.name + 'start', ev);
          this.triggered = true;
        }

        // trigger normal event
        inst.trigger(this.name, ev);

        // direction event, like dragdown
        inst.trigger(this.name + ev.direction, ev);

        // block the browser events
        if((inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||
          (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {
          ev.preventDefault();
        }
        break;

      case Hammer.EVENT_END:
        // trigger dragend
        if(this.triggered) {
          inst.trigger(this.name + 'end', ev);
        }

        this.triggered = false;
        break;
    }
  }
};

/**
 * Hold
 * Touch stays at the same place for x time
 * @events  hold
 */
Hammer.gestures.Hold = {
  name    : 'hold',
  index   : 10,
  defaults: {
    hold_timeout  : 500,
    hold_threshold: 1
  },
  timer   : null,
  handler : function holdGesture(ev, inst) {
    switch(ev.eventType) {
      case Hammer.EVENT_START:
        // clear any running timers
        clearTimeout(this.timer);

        // set the gesture so we can check in the timeout if it still is
        Hammer.detection.current.name = this.name;

        // set timer and if after the timeout it still is hold,
        // we trigger the hold event
        this.timer = setTimeout(function() {
          if(Hammer.detection.current.name == 'hold') {
            inst.trigger('hold', ev);
          }
        }, inst.options.hold_timeout);
        break;

      // when you move or end we clear the timer
      case Hammer.EVENT_MOVE:
        if(ev.distance > inst.options.hold_threshold) {
          clearTimeout(this.timer);
        }
        break;

      case Hammer.EVENT_END:
        clearTimeout(this.timer);
        break;
    }
  }
};

/**
 * Release
 * Called as last, tells the user has released the screen
 * @events  release
 */
Hammer.gestures.Release = {
  name   : 'release',
  index  : Infinity,
  handler: function releaseGesture(ev, inst) {
    if(ev.eventType == Hammer.EVENT_END) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * Swipe
 * triggers swipe events when the end velocity is above the threshold
 * @events  swipe, swipeleft, swiperight, swipeup, swipedown
 */
Hammer.gestures.Swipe = {
  name    : 'swipe',
  index   : 40,
  defaults: {
    // set 0 for unlimited, but this can conflict with transform
    swipe_min_touches: 1,
    swipe_max_touches: 1,
    swipe_velocity   : 0.7
  },
  handler : function swipeGesture(ev, inst) {
    if(ev.eventType == Hammer.EVENT_END) {
      // max touches
      if(inst.options.swipe_max_touches > 0 &&
        ev.touches.length < inst.options.swipe_min_touches &&
        ev.touches.length > inst.options.swipe_max_touches) {
        return;
      }

      // when the distance we moved is too small we skip this gesture
      // or we can be already in dragging
      if(ev.velocityX > inst.options.swipe_velocity ||
        ev.velocityY > inst.options.swipe_velocity) {
        // trigger swipe events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};

/**
 * Tap/DoubleTap
 * Quick touch at a place or double at the same place
 * @events  tap, doubletap
 */
Hammer.gestures.Tap = {
  name    : 'tap',
  index   : 100,
  defaults: {
    tap_max_touchtime : 250,
    tap_max_distance  : 10,
    tap_always        : true,
    doubletap_distance: 20,
    doubletap_interval: 300
  },
  handler : function tapGesture(ev, inst) {
    if(ev.eventType == Hammer.EVENT_END && ev.srcEvent.type != 'touchcancel') {
      // previous gesture, for the double tap since these are two different gesture detections
      var prev = Hammer.detection.previous,
        did_doubletap = false;

      // when the touchtime is higher then the max touch time
      // or when the moving distance is too much
      if(ev.deltaTime > inst.options.tap_max_touchtime ||
        ev.distance > inst.options.tap_max_distance) {
        return;
      }

      // check if double tap
      if(prev && prev.name == 'tap' &&
        (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&
        ev.distance < inst.options.doubletap_distance) {
        inst.trigger('doubletap', ev);
        did_doubletap = true;
      }

      // do a single tap
      if(!did_doubletap || inst.options.tap_always) {
        Hammer.detection.current.name = 'tap';
        inst.trigger(Hammer.detection.current.name, ev);
      }
    }
  }
};

/**
 * Touch
 * Called as first, tells the user has touched the screen
 * @events  touch
 */
Hammer.gestures.Touch = {
  name    : 'touch',
  index   : -Infinity,
  defaults: {
    // call preventDefault at touchstart, and makes the element blocking by
    // disabling the scrolling of the page, but it improves gestures like
    // transforming and dragging.
    // be careful with using this, it can be very annoying for users to be stuck
    // on the page
    prevent_default    : false,

    // disable mouse events, so only touch (or pen!) input triggers events
    prevent_mouseevents: false
  },
  handler : function touchGesture(ev, inst) {
    if(inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }

    if(inst.options.prevent_default) {
      ev.preventDefault();
    }

    if(ev.eventType == Hammer.EVENT_START) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * Transform
 * User want to scale or rotate with 2 fingers
 * @events  transform, pinch, pinchin, pinchout, rotate
 */
Hammer.gestures.Transform = {
  name     : 'transform',
  index    : 45,
  defaults : {
    // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
    transform_min_scale   : 0.01,
    // rotation in degrees
    transform_min_rotation: 1,
    // prevent default browser behavior when two touches are on the screen
    // but it makes the element a blocking element
    // when you are using the transform gesture, it is a good practice to set this true
    transform_always_block: false
  },
  triggered: false,
  handler  : function transformGesture(ev, inst) {
    // current gesture isnt drag, but dragged is true
    // this means an other gesture is busy. now call dragend
    if(Hammer.detection.current.name != this.name && this.triggered) {
      inst.trigger(this.name + 'end', ev);
      this.triggered = false;
      return;
    }

    // atleast multitouch
    if(ev.touches.length < 2) {
      return;
    }

    // prevent default when two fingers are on the screen
    if(inst.options.transform_always_block) {
      ev.preventDefault();
    }

    switch(ev.eventType) {
      case Hammer.EVENT_START:
        this.triggered = false;
        break;

      case Hammer.EVENT_MOVE:
        var scale_threshold = Math.abs(1 - ev.scale);
        var rotation_threshold = Math.abs(ev.rotation);

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if(scale_threshold < inst.options.transform_min_scale &&
          rotation_threshold < inst.options.transform_min_rotation) {
          return;
        }

        // we are transforming!
        Hammer.detection.current.name = this.name;

        // first time, trigger dragstart event
        if(!this.triggered) {
          inst.trigger(this.name + 'start', ev);
          this.triggered = true;
        }

        inst.trigger(this.name, ev); // basic transform event

        // trigger rotate event
        if(rotation_threshold > inst.options.transform_min_rotation) {
          inst.trigger('rotate', ev);
        }

        // trigger pinch event
        if(scale_threshold > inst.options.transform_min_scale) {
          inst.trigger('pinch', ev);
          inst.trigger('pinch' + ((ev.scale < 1) ? 'in' : 'out'), ev);
        }
        break;

      case Hammer.EVENT_END:
        // trigger dragend
        if(this.triggered) {
          inst.trigger(this.name + 'end', ev);
        }

        this.triggered = false;
        break;
    }
  }
};

  // Based off Lo-Dash's excellent UMD wrapper (slightly modified) - https://github.com/bestiejs/lodash/blob/master/lodash.js#L5515-L5543
  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
  if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // define as an anonymous module
    define(function() {
      return Hammer;
    });
    // check for `exports` after `define` in case a build optimizer adds an `exports` object
  }
  else if(typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = Hammer;
  }
  else {
    window.Hammer = Hammer;
  }
})(this);


/*
 Jquery Iframe Auto Height Plugin
 Version 1.2.5 (09.10.2013)

 Author : Ilker Guller (http://ilkerguller.com)

 Description: This plugin can get contents of iframe and set height of iframe automatically. Also it has cross-domain fix (*).
 Details: http://github.com/Sly777/Iframe-Height-Jquery-Plugin
 */

(function($){var uuid=0;var iframeOptions={resizeMaxTry:4,resizeWaitTime:50,minimumHeight:200,defaultHeight:3000,heightOffset:0,exceptPages:"",debugMode:false,visibilitybeforeload:false,blockCrossDomain:false,externalHeightName:"bodyHeight",onMessageFunctionName:"getHeight",domainName:"*",watcher:false,watcherTime:400};$.iframeHeight=function(el,options){var base=this;$.iframeHeight.resizeTimeout=null;$.iframeHeight.resizeCount=0;base.$el=$(el);base.el=el;base.$el.before("<div id='iframeHeight-Container-"+uuid+"' style='padding: 0; margin: 0; border: none; background-color: transparent;'></div>");base.$el.appendTo("#iframeHeight-Container-"+uuid);base.$container=$("#iframeHeight-Container-"+uuid);base.$el.data("iframeHeight",base);base.watcher=null;base.debug={FirstTime:true,Init:function(){if(!('console'in window))console={};'log info warn error dir clear'.replace(/\w+/g,function(f){if(!(f in console))console[f]=console.log||new Function})},Log:function(message){if(this.FirstTime&&this.FirstTime===true){this.Init();this.FirstTime=false}if(base.options.debugMode&&base.options.debugMode===true&&console&&(message!==null||message!=="")){console["log"]("Iframe Plugin : "+message)}},GetBrowserInfo:(function(pub){var matched,browserObj;var uaMatch=function(ua){ua=ua.toLowerCase();if(/*@cc_on/*@if(@_jscript_version<=5.6)1@else@*/0/*@end@*/){ua="msie 6.0"}var match=/(chrome)[ \/]([\w.]+)/.exec(ua)||/(webkit)[ \/]([\w.]+)/.exec(ua)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua)||/(msie) ([\w.]+)/.exec(ua)||ua.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua)||[];return{browserObj:match[1]||"",version:match[2]||"0"}};matched=uaMatch(navigator.userAgent);browserObj={chrome:false,safari:false,mozilla:false,msie:false,webkit:false};if(matched.browserObj){browserObj[matched.browserObj]=true;browserObj.version=matched.version}if(browserObj.chrome){browserObj.webkit=true}else if(browserObj.webkit){browserObj.safari=true}pub=browserObj;return pub}(this.GetBrowserInfo||{}))};var isThisCDI=function(){try{var contentHtml;if(base.debug.GetBrowserInfo.msie&&base.debug.GetBrowserInfo.version=="7.0"){contentHtml=base.$el.get(0).contentWindow.location.href}else{contentHtml=base.$el.get(0).contentDocument.location.href}base.debug.Log("This page is non-Cross Domain - "+contentHtml);return false}catch(err){base.debug.Log("This page is Cross Domain");return true}};base.resetIframe=function(){if(base.options.visibilitybeforeload&&!(base.debug.GetBrowserInfo.msie&&base.debug.GetBrowserInfo.version=="7.0"))base.$el.css("visibility","hidden");base.debug.Log("Old Height is "+base.$el.height()+"px");base.$el.css("height","").removeAttr("height");base.debug.Log("Reset iframe");base.debug.Log("Height is "+base.$el.height()+"px after reset")};base.resizeFromOutside=function(event){if(base.options.blockCrossDomain){base.debug.Log("Blocked cross domain fix");return false}if(typeof event==="undefined")return false;if(typeof event.data=="string"){if(event.data=="reset"){base.$el.css("height","").removeAttr("height")}else{if(!/^ifh*/.test(event.data))return false;if(typeof parseInt(event.data.substring(3))!="number")return false;var frameHeightPx=parseInt(event.data.substring(3))+parseInt(base.options.heightOffset);base.resetIframe();base.setIframeHeight(frameHeightPx)}}else{return false}return true};base.checkMessageEvent=function(){if(base.options.blockCrossDomain||(base.debug.GetBrowserInfo.msie&&base.debug.GetBrowserInfo.version=="7.0")){base.debug.Log("Blocked cross domain fix");return false}base.resetIframe();if(base.options.visibilitybeforeload&&!(base.debug.GetBrowserInfo.msie&&base.debug.GetBrowserInfo.version=="7.0"))base.$el.css("visibility","visible");if(window.addEventListener){window.addEventListener('message',base.resizeFromOutside,false)}else if(window.attachEvent){window.attachEvent('onmessage',base.resizeFromOutside)}if(!base.$el.id){base.$el.id="iframe-id-"+(++uuid)}var frame=document.getElementById(base.$el.attr("id"));var message=base.options.onMessageFunctionName;if(frame.contentWindow.postMessage){frame.contentWindow.postMessage(message,"*")}else{base.debug.Log("Your browser does not support the postMessage method!");return false}base.debug.Log("Cross Domain Iframe started");return true};var tryFixIframe=function(){if($.iframeHeight.resizeCount<=base.options.resizeMaxTry){$.iframeHeight.resizeCount++;$.iframeHeight.resizeTimeout=setTimeout($.iframeHeight.resizeIframe,base.options.resizeWaitTime);base.debug.Log($.iframeHeight.resizeCount+" time(s) tried")}else{clearTimeout($.iframeHeight.resizeTimeout);$.iframeHeight.resizeCount=0;base.debug.Log("set default height for iframe");base.setIframeHeight(base.options.defaultHeight+base.options.heightOffset)}};base.sendInfotoTop=function(){if(top.length>0&&typeof JSON!="undefined"){var data={};data[base.options.externalHeightName].value=$(document).height();var domain='*';data=JSON.stringify(data);top.postMessage(data,domain);base.debug.Log("sent info to top page");return false}return true};base.setIframeHeight=function(_height){base.$el.height(_height).css("height",_height);if(base.$el.data("iframeheight")!=_height)base.$container.height(_height).css("height",_height);if(base.options.visibilitybeforeload&&!(base.debug.GetBrowserInfo.msie&&base.debug.GetBrowserInfo.version=="7.0"))base.$el.css("visibility","visible");base.debug.Log("Now iframe height is "+_height+"px");base.$el.data("iframeheight",_height)};$.iframeHeight.resizeIframe=function(){base.resetIframe();if(isThisCDI()){base.$el.height(base.options.defaultHeight+base.options.heightOffset).css("height",base.options.defaultHeight+base.options.heightOffset);if(base.options.visibilitybeforeload&&!(base.debug.GetBrowserInfo.msie&&base.debug.GetBrowserInfo.version=="7.0"))base.$el.css("visibility","visible");base.checkMessageEvent()}else{if(base.$el.css("height")===base.options.minimumHeight+"px"){base.resetIframe()}if(base.$el.get(0).contentWindow.document.body!==null){base.debug.Log("This page has body info");var _pageHeight=$(base.$el.get(0).contentWindow.document).height();var _pageName=base.$el.get(0).contentWindow.document.location.pathname.substring(base.$el.get(0).contentWindow.document.location.pathname.lastIndexOf('/')+1).toLowerCase();base.debug.Log("page height : "+_pageHeight+"px || page name : "+_pageName);if((_pageHeight<=base.options.minimumHeight&&base.options.exceptPages.indexOf(_pageName)==-1)){tryFixIframe()}else if(_pageHeight>base.options.minimumHeight&&base.options.exceptPages.indexOf(_pageName)==-1){base.setIframeHeight(_pageHeight+base.options.heightOffset)}}else{base.debug.Log("This page has not body info");tryFixIframe()}}};this.$el.bind("updateIframe",function(){$.iframeHeight.resizeIframe();base.debug.Log("Updated Iframe Manually")});this.$el.bind("killWatcher",function(){window.clearInterval(base.watcher);base.debug.Log("Killed Watcher")});base.init=function(){base.options=$.extend({},$.iframeHeight.defaultOptions,options);if(base.options.watcher==true)base.options.blockCrossDomain=true;base.debug.Log(base.options);if(base.$el.get(0).tagName===undefined||base.$el.get(0).tagName.toLowerCase()!=="iframe"){base.debug.Log("This element is not iframe!");return false}$.iframeHeight.resizeIframe();base.$el.load(function(){$.iframeHeight.resizeIframe()});if(base.options.watcher){base.watcher=setInterval(function(){$.iframeHeight.resizeIframe();base.debug.Log("Checked Iframe")},base.options.watcherTime)}return true};base.init()};$.iframeHeight.defaultOptions=iframeOptions;$.fn.iframeHeight=function(options){return this.each(function(){(new $.iframeHeight(this,options))})};$.iframeHeightExternal=function(){if(arguments.length===1){if($.isPlainObject(arguments[0])){iframeOptions=arguments[0]}}if(window.addEventListener){window.addEventListener("message",OnMessage,false)}else if(window.attachEvent){window.attachEvent("onmessage",OnMessage)}function OnMessage(event){var _domain;if('domain'in event){_domain=event.domain}if('origin'in event){_domain=event.origin}if(iframeOptions.domainName!=="*"){if(_domain!==iframeOptions.domainName){$.iframeHeight.debug.Log("It's not same domain. Blocked!");return}}if(event.data==iframeOptions.onMessageFunctionName){var message="ifh"+$(document).height();event.source.postMessage(message,event.origin)}}return{update:function(){this.reset();window.__domainname=iframeOptions.domainName;setTimeout(function(){var message="ifh"+$(document).height();parent.postMessage(message,window.__domainname)},90)},reset:function(){parent.postMessage("reset",iframeOptions.domainName)}}}})(jQuery);



/*
 * jQuery.fullscreen library v0.4.2
 * Copyright (c) 2013 Vladimir Zhuravlev
 *
 * @license https://github.com/private-face/jquery.fullscreen/blob/master/LICENSE
 *
 * Date: Tue Jul 22 11:54:54 CDT 2014
 **/
(function(e){function t(e){return e!==void 0}function n(t,n,l){var r=function(){};r.prototype=n.prototype,t.prototype=new r,t.prototype.constructor=t,n.prototype.constructor=n,t._super=n.prototype,l&&e.extend(t.prototype,l)}function l(e,n){var l;"string"==typeof e&&(n=e,e=document);for(var i=0;r.length>i;++i){n=n.replace(r[i][0],r[i][1]);for(var o=0;s.length>o;++o)if(l=s[o],l+=0===o?n:n.charAt(0).toUpperCase()+n.substr(1),t(e[l]))return e[l]}return void 0}var r=[["",""],["exit","cancel"],["screen","Screen"]],s=["","o","ms","moz","webkit","webkitCurrent"],i=navigator.userAgent,o=l("fullscreenEnabled"),u=-1!==i.indexOf("Android")&&-1!==i.indexOf("Chrome"),c=!u&&t(l("fullscreenElement"))&&(!t(o)||o===!0),_=e.fn.jquery.split("."),h=2>parseInt(_[0])&&7>parseInt(_[1]),f=function(){this.__options=null,this._fullScreenElement=null,this.__savedStyles={}};f.prototype={_DEFAULT_OPTIONS:{styles:{boxSizing:"border-box",MozBoxSizing:"border-box",WebkitBoxSizing:"border-box"},toggleClass:null},__documentOverflow:"",__htmlOverflow:"",_preventDocumentScroll:function(){this.__documentOverflow=e("body")[0].style.overflow,this.__htmlOverflow=e("html")[0].style.overflow,e("body, html").css("overflow","hidden")},_allowDocumentScroll:function(){e("body")[0].style.overflow=this.__documentOverflow,e("html")[0].style.overflow=this.__htmlOverflow},_fullScreenChange:function(){this.__options&&(this.isFullScreen()?(this._preventDocumentScroll(),this._triggerEvents()):(this._allowDocumentScroll(),this._revertStyles(),this._triggerEvents(),this._fullScreenElement=null))},_fullScreenError:function(t){this.__options&&(this._revertStyles(),this._fullScreenElement=null,t&&e(document).trigger("fscreenerror",[t]))},_triggerEvents:function(){e(this._fullScreenElement).trigger(this.isFullScreen()?"fscreenopen":"fscreenclose"),e(document).trigger("fscreenchange",[this.isFullScreen(),this._fullScreenElement])},_saveAndApplyStyles:function(){var t=e(this._fullScreenElement);this.__savedStyles={};for(var n in this.__options.styles)this.__savedStyles[n]=this._fullScreenElement.style[n],this._fullScreenElement.style[n]=this.__options.styles[n];this.__options.toggleClass&&t.addClass(this.__options.toggleClass)},_revertStyles:function(){var t=e(this._fullScreenElement);for(var n in this.__options.styles)this._fullScreenElement.style[n]=this.__savedStyles[n];this.__options.toggleClass&&t.removeClass(this.__options.toggleClass)},open:function(t,n){t!==this._fullScreenElement&&(this.isFullScreen()&&this.exit(),this._fullScreenElement=t,this.__options=e.extend(!0,{},this._DEFAULT_OPTIONS,n),this._saveAndApplyStyles())},exit:null,isFullScreen:null,isNativelySupported:function(){return c}};var p=function(){p._super.constructor.apply(this,arguments),this.exit=e.proxy(l("exitFullscreen"),document),this._DEFAULT_OPTIONS=e.extend(!0,{},this._DEFAULT_OPTIONS,{styles:{width:"100%",height:"100%"}}),e(document).bind(this._prefixedString("fullscreenchange")+" MSFullscreenChange",e.proxy(this._fullScreenChange,this)).bind(this._prefixedString("fullscreenerror")+" MSFullscreenError",e.proxy(this._fullScreenError,this))};n(p,f,{VENDOR_PREFIXES:["","o","moz","webkit"],_prefixedString:function(t){return e.map(this.VENDOR_PREFIXES,function(e){return e+t}).join(" ")},open:function(e){p._super.open.apply(this,arguments);var t=l(e,"requestFullscreen");t.call(e)},exit:e.noop,isFullScreen:function(){return null!==l("fullscreenElement")},element:function(){return l("fullscreenElement")}});var a=function(){a._super.constructor.apply(this,arguments),this._DEFAULT_OPTIONS=e.extend({},this._DEFAULT_OPTIONS,{styles:{position:"fixed",zIndex:"2147483647",left:0,top:0,bottom:0,right:0}}),this.__delegateKeydownHandler()};n(a,f,{__isFullScreen:!1,__delegateKeydownHandler:function(){var t=e(document);t.delegate("*","keydown.fullscreen",e.proxy(this.__keydownHandler,this));var n=h?t.data("events"):e._data(document).events,l=n.keydown;h?n.live.unshift(n.live.pop()):l.splice(0,0,l.splice(l.delegateCount-1,1)[0])},__keydownHandler:function(e){return this.isFullScreen()&&27===e.which?(this.exit(),!1):!0},_revertStyles:function(){a._super._revertStyles.apply(this,arguments),this._fullScreenElement.offsetHeight},open:function(){a._super.open.apply(this,arguments),this.__isFullScreen=!0,this._fullScreenChange()},exit:function(){this.__isFullScreen=!1,this._fullScreenChange()},isFullScreen:function(){return this.__isFullScreen},element:function(){return this.__isFullScreen?this._fullScreenElement:null}}),e.fullscreen=c?new p:new a,e.fn.fullscreen=function(t){var n=this[0];return t=e.extend({toggleClass:null,overflow:"hidden"},t),t.styles={overflow:t.overflow},delete t.overflow,n&&e.fullscreen.open(n,t),this}})(jQuery);


(function () {
    var old = $.ui.dialog.prototype._create;
    $.ui.dialog.prototype._create = function (d) {
        old.call(this, d);
        var self = this,
            options = self.options,
            oldHeight = options.height,
            oldWidth = options.width,
            uiDialogTitlebarFull = $('<a href="#"></a>')
                .addClass(
                    'ui-dialog-titlebar-full ' +
                        'ui-corner-all'
                )
                .attr('role', 'button')
                .hover(
                    function () {
                        uiDialogTitlebarFull.addClass('ui-state-hover');
                    },
                    function () {
                        uiDialogTitlebarFull.removeClass('ui-state-hover');
                    }
                )
                .toggle(
                    function () {
                        self._setOptions({
                            height: window.innerHeight - 10,
                            width: window.innerWidth - 30
                        });
                        self._position('center');
                        return false;
                    },
                    function () {
                        self._setOptions({
                            height: oldHeight,
                            width: oldWidth
                        });
                        self._position('center');
                        return false;
                    }
                )
                .focus(function () {
                    uiDialogTitlebarFull.addClass('ui-state-focus');
                })
                .blur(function () {
                    uiDialogTitlebarFull.removeClass('ui-state-focus');
                })
                .appendTo(self.uiDialogTitlebar);

        $('<span></span>')
            .addClass(
                'ui-icon ' +
                    'ui-icon-newwin'
            )
            .text(options.fullText ? options.fullText : '')
            .appendTo(uiDialogTitlebarFull);

    };
})();


eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('(m($){18 W=2v.4T,D=2v.4S,F=2v.4R,u=2v.4Q;m V(){C $("<4P/>")};$.N=m(T,c){18 O=$(T),1F,A=V(),1k=V(),I=V().r(V()).r(V()).r(V()),B=V().r(V()).r(V()).r(V()),E=$([]),1K,G,l,17={v:0,l:0},Q,M,1l,1g={v:0,l:0},12=0,1J="1H",2k,2j,1t,1s,S,1B,1A,2o,2n,14,1Q,a,b,j,g,f={a:0,b:0,j:0,g:0,H:0,L:0},2u=R.4O,1M=4N.4M,$p,d,i,o,w,h,2p;m 1n(x){C x+17.v-1g.v};m 1m(y){C y+17.l-1g.l};m 1b(x){C x-17.v+1g.v};m 1a(y){C y-17.l+1g.l};m 1z(3J){C 3J.4L-1g.v};m 1y(3I){C 3I.4K-1g.l};m 13(32){18 1i=32||1t,1h=32||1s;C{a:u(f.a*1i),b:u(f.b*1h),j:u(f.j*1i),g:u(f.g*1h),H:u(f.j*1i)-u(f.a*1i),L:u(f.g*1h)-u(f.b*1h)}};m 23(a,b,j,g,31){18 1i=31||1t,1h=31||1s;f={a:u(a/1i||0),b:u(b/1h||0),j:u(j/1i||0),g:u(g/1h||0)};f.H=f.j-f.a;f.L=f.g-f.b};m 1f(){9(!1F||!O.H()){C}17={v:u(O.2t().v),l:u(O.2t().l)};Q=O.2Y();M=O.3H();17.l+=(O.30()-M)>>1;17.v+=(O.2q()-Q)>>1;1B=u(c.4J/1t)||0;1A=u(c.4I/1s)||0;2o=u(F(c.4H/1t||1<<24,Q));2n=u(F(c.4G/1s||1<<24,M));9($().4F=="1.3.2"&&1J=="21"&&!2u["4E"]){17.l+=D(R.1q.2r,2u.2r);17.v+=D(R.1q.2s,2u.2s)}1g=/1H|4D/.1c(1l.q("1p"))?{v:u(1l.2t().v)-1l.2s(),l:u(1l.2t().l)-1l.2r()}:1J=="21"?{v:$(R).2s(),l:$(R).2r()}:{v:0,l:0};G=1n(0);l=1m(0);9(f.j>Q||f.g>M){1U()}};m 1V(3F){9(!1Q){C}A.q({v:1n(f.a),l:1m(f.b)}).r(1k).H(w=f.H).L(h=f.L);1k.r(I).r(E).q({v:0,l:0});I.H(D(w-I.2q()+I.2Y(),0)).L(D(h-I.30()+I.3H(),0));$(B[0]).q({v:G,l:l,H:f.a,L:M});$(B[1]).q({v:G+f.a,l:l,H:w,L:f.b});$(B[2]).q({v:G+f.j,l:l,H:Q-f.j,L:M});$(B[3]).q({v:G+f.a,l:l+f.g,H:w,L:M-f.g});w-=E.2q();h-=E.30();2O(E.3f){15 8:$(E[4]).q({v:w>>1});$(E[5]).q({v:w,l:h>>1});$(E[6]).q({v:w>>1,l:h});$(E[7]).q({l:h>>1});15 4:E.3G(1,3).q({v:w});E.3G(2,4).q({l:h})}9(3F!==Y){9($.N.2Z!=2R){$(R).U($.N.2z,$.N.2Z)}9(c.1T){$(R)[$.N.2z]($.N.2Z=2R)}}9(1j&&I.2q()-I.2Y()==2){I.q("3E",0);3x(m(){I.q("3E","4C")},0)}};m 22(3D){1f();1V(3D);a=1n(f.a);b=1m(f.b);j=1n(f.j);g=1m(f.g)};m 27(2X,2w){c.1P?2X.4B(c.1P,2w):2X.1r()};m 1d(2W){18 x=1b(1z(2W))-f.a,y=1a(1y(2W))-f.b;9(!2p){1f();2p=11;A.1G("4A",m(){2p=Y})}S="";9(c.2D){9(y<=c.1W){S="n"}X{9(y>=f.L-c.1W){S="s"}}9(x<=c.1W){S+="w"}X{9(x>=f.H-c.1W){S+="e"}}}A.q("2V",S?S+"-19":c.26?"4z":"");9(1K){1K.4y()}};m 2S(4x){$("1q").q("2V","");9(c.4w||f.H*f.L==0){27(A.r(B),m(){$(J).1r()})}$(R).U("P",2l);A.P(1d);c.2f(T,13())};m 2C(1X){9(1X.3z!=1){C Y}1f();9(S){$("1q").q("2V",S+"-19");a=1n(f[/w/.1c(S)?"j":"a"]);b=1m(f[/n/.1c(S)?"g":"b"]);$(R).P(2l).1G("1x",2S);A.U("P",1d)}X{9(c.26){2k=G+f.a-1z(1X);2j=l+f.b-1y(1X);A.U("P",1d);$(R).P(2T).1G("1x",m(){c.2f(T,13());$(R).U("P",2T);A.P(1d)})}X{O.1O(1X)}}C Y};m 1w(3C){9(14){9(3C){j=D(G,F(G+Q,a+W(g-b)*14*(j>a||-1)));g=u(D(l,F(l+M,b+W(j-a)/14*(g>b||-1))));j=u(j)}X{g=D(l,F(l+M,b+W(j-a)/14*(g>b||-1)));j=u(D(G,F(G+Q,a+W(g-b)*14*(j>a||-1))));g=u(g)}}};m 1U(){a=F(a,G+Q);b=F(b,l+M);9(W(j-a)<1B){j=a-1B*(j<a||-1);9(j<G){a=G+1B}X{9(j>G+Q){a=G+Q-1B}}}9(W(g-b)<1A){g=b-1A*(g<b||-1);9(g<l){b=l+1A}X{9(g>l+M){b=l+M-1A}}}j=D(G,F(j,G+Q));g=D(l,F(g,l+M));1w(W(j-a)<W(g-b)*14);9(W(j-a)>2o){j=a-2o*(j<a||-1);1w()}9(W(g-b)>2n){g=b-2n*(g<b||-1);1w(11)}f={a:1b(F(a,j)),j:1b(D(a,j)),b:1a(F(b,g)),g:1a(D(b,g)),H:W(j-a),L:W(g-b)};1V();c.2g(T,13())};m 2l(2U){j=/w|e|^$/.1c(S)||14?1z(2U):1n(f.j);g=/n|s|^$/.1c(S)||14?1y(2U):1m(f.g);1U();C Y};m 1v(3B,3A){j=(a=3B)+f.H;g=(b=3A)+f.L;$.2c(f,{a:1b(a),b:1a(b),j:1b(j),g:1a(g)});1V();c.2g(T,13())};m 2T(2m){a=D(G,F(2k+1z(2m),G+Q-f.H));b=D(l,F(2j+1y(2m),l+M-f.L));1v(a,b);2m.4v();C Y};m 2h(){$(R).U("P",2h);1f();j=a;g=b;1U();S="";9(!B.2y(":4u")){A.r(B).1r().2E(c.1P||0)}1Q=11;$(R).U("1x",1N).P(2l).1G("1x",2S);A.U("P",1d);c.3y(T,13())};m 1N(){$(R).U("P",2h).U("1x",1N);27(A.r(B));23(1b(a),1a(b),1b(a),1a(b));9(!(J 4t $.N)){c.2g(T,13());c.2f(T,13())}};m 2A(2i){9(2i.3z!=1||B.2y(":4s")){C Y}1f();2k=a=1z(2i);2j=b=1y(2i);$(R).P(2h).1x(1N);C Y};m 2B(){22(Y)};m 2x(){1F=11;25(c=$.2c({1S:"4r",26:11,20:"1q",2D:11,1W:10,3w:m(){},3y:m(){},2g:m(){},2f:m(){}},c));A.r(B).q({3b:""});9(c.2F){1Q=11;1f();1V();A.r(B).1r().2E(c.1P||0)}3x(m(){c.3w(T,13())},0)};18 2R=m(16){18 k=c.1T,d,t,2N=16.4q;d=!1L(k.2P)&&(16.2e||16.3t.2e)?k.2P:!1L(k.2a)&&16.3u?k.2a:!1L(k.2b)&&16.3v?k.2b:!1L(k.2Q)?k.2Q:10;9(k.2Q=="19"||(k.2b=="19"&&16.3v)||(k.2a=="19"&&16.3u)||(k.2P=="19"&&(16.2e||16.3t.2e))){2O(2N){15 37:d=-d;15 39:t=D(a,j);a=F(a,j);j=D(t+d,a);1w();1u;15 38:d=-d;15 40:t=D(b,g);b=F(b,g);g=D(t+d,b);1w(11);1u;3s:C}1U()}X{a=F(a,j);b=F(b,g);2O(2N){15 37:1v(D(a-d,G),b);1u;15 38:1v(a,D(b-d,l));1u;15 39:1v(a+F(d,Q-1b(j)),b);1u;15 40:1v(a,b+F(d,M-1a(g)));1u;3s:C}}C Y};m 1R(3r,2M){3p(18 2d 4p 2M){9(c[2d]!==1Y){3r.q(2M[2d],c[2d])}}};m 25(K){9(K.20){(1l=$(K.20)).2G(A.r(B))}$.2c(c,K);1f();9(K.2L!=3q){E.1o();E=$([]);i=K.2L?K.2L=="4o"?4:8:0;3g(i--){E=E.r(V())}E.29(c.1S+"-4n").q({1p:"1H",36:0,1I:12+1||1});9(!4m(E.q("H"))>=0){E.H(5).L(5)}9(o=c.2K){E.q({2K:o,2H:"3m"})}1R(E,{3n:"2J-28",3l:"2I-28",3o:"1e"})}1t=c.4l/Q||1;1s=c.4k/M||1;9(K.a!=3q){23(K.a,K.b,K.j,K.g);K.2F=!K.1r}9(K.1T){c.1T=$.2c({2b:1,2a:"19"},K.1T)}B.29(c.1S+"-4j");1k.29(c.1S+"-4i");3p(i=0;i++<4;){$(I[i-1]).29(c.1S+"-2J"+i)}1R(1k,{4h:"2I-28",4g:"1e"});1R(I,{3o:"1e",2K:"2J-H"});1R(B,{4f:"2I-28",4e:"1e"});9(o=c.3n){$(I[0]).q({2H:"3m",3k:o})}9(o=c.3l){$(I[1]).q({2H:"4d",3k:o})}A.2G(1k.r(I).r(1K)).2G(E);9(1j){9(o=(B.q("3j")||"").3i(/1e=(\\d+)/)){B.q("1e",o[1]/1Z)}9(o=(I.q("3j")||"").3i(/1e=(\\d+)/)){I.q("1e",o[1]/1Z)}}9(K.1r){27(A.r(B))}X{9(K.2F&&1F){1Q=11;A.r(B).2E(c.1P||0);22()}}14=(d=(c.4c||"").4b(/:/))[0]/d[1];O.r(B).U("1O",2A);9(c.1E||c.1D===Y){A.U("P",1d).U("1O",2C);$(3h).U("19",2B)}X{9(c.1D||c.1E===Y){9(c.2D||c.26){A.P(1d).1O(2C)}$(3h).19(2B)}9(!c.4a){O.r(B).1O(2A)}}c.1D=c.1E=1Y};J.1o=m(){25({1E:11});A.r(B).1o()};J.49=m(){C c};J.33=25;J.48=13;J.47=23;J.46=1N;J.45=22;18 1j=(/44 ([\\w.]+)/i.43(1M)||[])[1],3c=/42/i.1c(1M),3d=/41/i.1c(1M)&&!/3Z/i.1c(1M);$p=O;3g($p.3f){12=D(12,!1L($p.q("z-3e"))?$p.q("z-3e"):12);9($p.q("1p")=="21"){1J="21"}$p=$p.20(":3Y(1q)")}12=c.1I||12;9(1j){O.3X("3W","3V")}$.N.2z=1j||3d?"3U":"3T";9(3c){1K=V().q({H:"1Z%",L:"1Z%",1p:"1H",1I:12+2||2})}A.r(B).q({3b:"3a",1p:1J,3S:"3a",1I:12||"0"});A.q({1I:12+2||2});1k.r(I).q({1p:"1H",36:0});T.35||T.3R=="35"||!O.2y("3Q")?2x():O.1G("3P",2x);9(!1F&&1j&&1j>=7){T.34=T.34}};$.2w.N=m(Z){Z=Z||{};J.3O(m(){9($(J).1C("N")){9(Z.1o){$(J).1C("N").1o();$(J).3N("N")}X{$(J).1C("N").33(Z)}}X{9(!Z.1o){9(Z.1D===1Y&&Z.1E===1Y){Z.1D=11}$(J).1C("N",3M $.N(J,Z))}}});9(Z.3L){C $(J).1C("N")}C J}})(3K);',62,304,'|||||||||if|x1|y1|_7|||_23|y2|||x2||top|function||||css|add|||_4|left|||||_a|_d|return|_2|_e|_3|_10|width|_c|this|_55|height|_13|imgAreaSelect|_8|mousemove|_12|document|_1c|_6|unbind|_5|_1|else|false|_58||true|_16|_2c|_21|case|_50|_11|var|resize|_29|_28|test|_3a|opacity|_30|_15|sy|sx|_35|_b|_14|_27|_26|remove|position|body|hide|_1b|_1a|break|_45|_42|mouseup|evY|evX|_1e|_1d|data|enable|disable|_9|one|absolute|zIndex|_17|_f|isNaN|ua|_4a|mousedown|fadeSpeed|_22|_51|classPrefix|keys|_31|_32|resizeMargin|_40|undefined|100|parent|fixed|_36|_2e||_4f|movable|_38|color|addClass|ctrl|shift|extend|_54|altKey|onSelectEnd|onSelectChange|_49|_4c|_19|_18|_3e|_48|_20|_1f|_25|outerWidth|scrollTop|scrollLeft|offset|_24|Math|fn|_4e|is|keyPress|_4b|_4d|_3f|resizable|fadeIn|show|append|borderStyle|background|border|borderWidth|handles|_53|key|switch|alt|arrows|_34|_3c|_41|_44|cursor|_3b|_39|innerWidth|onKeyPress|outerHeight|_2f|_2d|setOptions|src|complete|fontSize||||hidden|visibility|_56|_57|index|length|while|window|match|filter|borderColor|borderColor2|solid|borderColor1|borderOpacity|for|null|_52|default|originalEvent|ctrlKey|shiftKey|onInit|setTimeout|onSelectStart|which|_47|_46|_43|_37|margin|_33|slice|innerHeight|_2b|_2a|jQuery|instance|new|removeData|each|load|img|readyState|overflow|keypress|keydown|on|unselectable|attr|not|chrome||webkit|opera|exec|msie|update|cancelSelection|setSelection|getSelection|getOptions|persistent|split|aspectRatio|dashed|outerOpacity|outerColor|selectionOpacity|selectionColor|selection|outer|imageHeight|imageWidth|parseInt|handle|corners|in|keyCode|imgareaselect|animated|instanceof|visible|preventDefault|autoHide|_3d|toggle|move|mouseout|fadeOut|auto|relative|getBoundingClientRect|jquery|maxHeight|maxWidth|minHeight|minWidth|pageY|pageX|userAgent|navigator|documentElement|div|round|min|max|abs'.split('|')))



/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.4.1
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG or VML.  
 * 
 * This file contains the util functions
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {
    
    var pointHelper = function(p1, p2, fn) {
        p1 = jsPlumbUtil.isArray(p1) ? p1 : [p1.x, p1.y];
        p2 = jsPlumbUtil.isArray(p2) ? p2 : [p2.x, p2.y];    
        return fn(p1, p2);
    };
    
    jsPlumbUtil = {
        isArray : function(a) {
            return Object.prototype.toString.call(a) === "[object Array]";	
        },
        isNumber : function(n) {
            return Object.prototype.toString.call(n) === "[object Number]";  
        },
        isString : function(s) {
            return typeof s === "string";
        },
        isBoolean: function(s) {
            return typeof s === "boolean";
        },
        isNull : function(s) { return s == null; },  
        isObject : function(o) {
            return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";	
        },
        isDate : function(o) {
            return Object.prototype.toString.call(o) === "[object Date]";
        },
        isFunction: function(o) {
            return Object.prototype.toString.call(o) === "[object Function]";
        },
        clone : function(a) {
            if (this.isString(a)) return "" + a;
            else if (this.isBoolean(a)) return !!a;
            else if (this.isDate(a)) return new Date(a.getTime());
            else if (this.isFunction(a)) return a;
            else if (this.isArray(a)) {
                var b = [];
                for (var i = 0; i < a.length; i++)
                    b.push(this.clone(a[i]));
                return b;
            }
            else if (this.isObject(a)) {
                var b = {};
                for (var i in a)
                    b[i] = this.clone(a[i]);
                return b;		
            }
            else return a;
        },
        merge : function(a, b) {		
            var c = this.clone(a);		
            for (var i in b) {
                if (c[i] == null || this.isString(b[i]) || this.isBoolean(b[i]))
                    c[i] = b[i];
                else {
                    if (this.isArray(b[i])/* && this.isArray(c[i])*/) {
                        var ar = [];
                        // if c's object is also an array we can keep its values.
                        if (this.isArray(c[i])) ar.push.apply(ar, c[i]);
                        ar.push.apply(ar, b[i]);
                        c[i] = ar;
                    }
                    else if(this.isObject(b[i])) {	
                        // overwite c's value with an object if it is not already one.
                        if (!this.isObject(c[i])) 
                            c[i] = {};
                        for (var j in b[i])
                            c[i][j] = b[i][j];
                    }
                }
            }
            return c;
        },
        copyValues:function(names, from, to) {
            for (var i = 0; i < names.length; i++)
                to[names[i]] = from[names[i]];
        },
        //
        // chain a list of functions, supplied by [ object, method name, args ], and return on the first
        // one that returns the failValue. if none return the failValue, return the successValue.
        //
        functionChain : function(successValue, failValue, fns) {        
            for (var i = 0; i < fns.length; i++) {
                var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
                if (o === failValue) {
                    return o;
                }
            }                
            return successValue;
        },
        // take the given model and expand out any parameters.
        populate : function(model, values) {		
            // for a string, see if it has parameter matches, and if so, try to make the substitutions.
            var getValue = function(fromString) {
                    var matches = fromString.match(/(\${.*?})/g);
                    if (matches != null) {
                        for (var i = 0; i < matches.length; i++) {
                            var val = values[matches[i].substring(2, matches[i].length - 1)];
                            if (val != null) {
                                fromString = fromString.replace(matches[i], val);
                            }
                        }							
                    }
                    return fromString;
                },		
                // process one entry.
                _one = function(d) {
                    if (d != null) {
                        if (jsPlumbUtil.isString(d)) {
                            return getValue(d);
                        }
                        else if (jsPlumbUtil.isArray(d)) {
                            var r = [];	
                            for (var i = 0; i < d.length; i++)
                                r.push(_one(d[i]));
                            return r;
                        }
                        else if (jsPlumbUtil.isObject(d)) {
                            var r = {};
                            for (var i in d) {
                                r[i] = _one(d[i]);
                            }
                            return r;
                        }
                        else {
                            return d;
                        }
                    }
                };
            
            return _one(model);	
        },
        convertStyle : function(s, ignoreAlpha) {
            // TODO: jsPlumb should support a separate 'opacity' style member.
            if ("transparent" === s) return s;
            var o = s,
                pad = function(n) { return n.length == 1 ? "0" + n : n; },
                hex = function(k) { return pad(Number(k).toString(16)); },
                pattern = /(rgb[a]?\()(.*)(\))/;
            if (s.match(pattern)) {
                var parts = s.match(pattern)[2].split(",");
                o = "#" + hex(parts[0]) + hex(parts[1]) + hex(parts[2]);
                if (!ignoreAlpha && parts.length == 4) 
                    o = o + hex(parts[3]);
            }
            return o;
        },
        gradient : function(p1, p2) {
            return pointHelper(p1, p2, function(_p1, _p2) { 
                if (_p2[0] == _p1[0])
                    return _p2[1] > _p1[1] ? Infinity : -Infinity;
                else if (_p2[1] == _p1[1]) 
                    return _p2[0] > _p1[0] ? 0 : -0;
                else 
                    return (_p2[1] - _p1[1]) / (_p2[0] - _p1[0]); 
            });		
        },
        normal : function(p1, p2) {
            return -1 / this.gradient(p1, p2);
        },
        lineLength : function(p1, p2) {
            return pointHelper(p1, p2, function(_p1, _p2) {
                return Math.sqrt(Math.pow(_p2[1] - _p1[1], 2) + Math.pow(_p2[0] - _p1[0], 2));			
            });
        },
        segment : function(p1, p2) {
            return pointHelper(p1, p2, function(_p1, _p2) {
                if (_p2[0] > _p1[0]) {
                    return (_p2[1] > _p1[1]) ? 2 : 1;
                }
                else if (_p2[0] == _p1[0]) {
                    return _p2[1] > _p1[1] ? 2 : 1;    
                }
                else {
                    return (_p2[1] > _p1[1]) ? 3 : 4;
                }
            });
        },
        theta : function(p1, p2) {
            return pointHelper(p1, p2, function(_p1, _p2) {
                var m = jsPlumbUtil.gradient(_p1, _p2),
                    t = Math.atan(m),
                    s = jsPlumbUtil.segment(_p1, _p2);
                if ((s == 4 || s== 3)) t += Math.PI;
                if (t < 0) t += (2 * Math.PI);
            
                return t;
            });
        },
        intersects : function(r1, r2) {
            var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h,
                a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h;
        
        return  ( (x1 <= a1 && a1 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
                ( (x1 <= a2 && a2 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
                ( (x1 <= a1 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||
                ( (x1 <= a2 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||	
                ( (a1 <= x1 && x1 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
                ( (a1 <= x2 && x2 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
                ( (a1 <= x1 && x1 <= a2) && (b1 <= y2 && y2 <= b2) ) ||
                ( (a1 <= x2 && x1 <= a2) && (b1 <= y2 && y2 <= b2) );
        },
        segmentMultipliers : [null, [1, -1], [1, 1], [-1, 1], [-1, -1] ],
        inverseSegmentMultipliers : [null, [-1, -1], [-1, 1], [1, 1], [1, -1] ],
        pointOnLine : function(fromPoint, toPoint, distance) {
            var m = jsPlumbUtil.gradient(fromPoint, toPoint),
                s = jsPlumbUtil.segment(fromPoint, toPoint),
                segmentMultiplier = distance > 0 ? jsPlumbUtil.segmentMultipliers[s] : jsPlumbUtil.inverseSegmentMultipliers[s],
                theta = Math.atan(m),
                y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
                x =  Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
            return { x:fromPoint.x + x, y:fromPoint.y + y };
        },
        /**
         * calculates a perpendicular to the line fromPoint->toPoint, that passes through toPoint and is 'length' long.
         * @param fromPoint
         * @param toPoint
         * @param length
         */
        perpendicularLineTo : function(fromPoint, toPoint, length) {
            var m = jsPlumbUtil.gradient(fromPoint, toPoint),
                theta2 = Math.atan(-1 / m),
                y =  length / 2 * Math.sin(theta2),
                x =  length / 2 * Math.cos(theta2);
            return [{x:toPoint.x + x, y:toPoint.y + y}, {x:toPoint.x - x, y:toPoint.y - y}];
        },
        findWithFunction : function(a, f) {
            if (a)
                for (var i = 0; i < a.length; i++) if (f(a[i])) return i;
            return -1;
        },
        clampToGrid : function(x, y, grid, dontClampX, dontClampY) {
            var _gridClamp = function(n, g) { 
                var e = n % g, 
                    f = Math.floor(n / g), 
                    inc = e >= (g / 2) ? 1 : 0; 
                return (f + inc) * g; 
            };
            return [
                dontClampX || grid == null ? x : _gridClamp(x, grid[0]),
                dontClampY || grid == null ? y : _gridClamp(y, grid[1])
            ];		
        },
        indexOf : function(l, v) {
            return jsPlumbUtil.findWithFunction(l, function(_v) { return _v == v; });	
        },
        removeWithFunction : function(a, f) {
            var idx = jsPlumbUtil.findWithFunction(a, f);
            if (idx > -1) a.splice(idx, 1);
            return idx != -1;
        },
        remove : function(l, v) {
            var idx = jsPlumbUtil.indexOf(l, v);	
            if (idx > -1) l.splice(idx, 1);
            return idx != -1;
        },
        // TODO support insert index
        addWithFunction : function(list, item, hashFunction) {
            if (jsPlumbUtil.findWithFunction(list, hashFunction) == -1) list.push(item);
        },
        addToList : function(map, key, value) {
            var l = map[key];
            if (l == null) {
                l = [], map[key] = l;
            }
            l.push(value);
            return l;
        },
        /**
         * EventGenerator
         * Superclass for objects that generate events - jsPlumb extends this, as does jsPlumbUIComponent, which all the UI elements extend.
         */
        EventGenerator : function() {
            var _listeners = {}, self = this, eventsSuspended = false;
            
            // this is a list of events that should re-throw any errors that occur during their dispatch. as of 1.3.0 this is private to
            // jsPlumb, but it seems feasible that people might want to manipulate this list.  the thinking is that we don't want event
            // listeners to bring down jsPlumb - or do we.  i can't make up my mind about this, but i know i want to hear about it if the "ready"
            // event fails, because then my page has most likely not initialised.  so i have this halfway-house solution.  it will be interesting
            // to hear what other people think.
            var eventsToDieOn = [ "ready" ];
                                    
            /*
             * Binds a listener to an event.  
             * 
             * Parameters:
             * 	event		-	name of the event to bind to.
             * 	listener	-	function to execute.
             */
            this.bind = function(event, listener) {
                jsPlumbUtil.addToList(_listeners, event, listener);		
                return self;		
            };
            /*
             * Fires an update for the given event.
             * 
             * Parameters:
             * 	event				-	event to fire
             * 	value				-	value to pass to the event listener(s).
             *  originalEvent	 	- 	the original event from the browser
             */			
            this.fire = function(event, value, originalEvent) {
                if (!eventsSuspended && _listeners[event]) {
                    for ( var i = 0; i < _listeners[event].length; i++) {
                        // doing it this way rather than catching and then possibly re-throwing means that an error propagated by this
                        // method will have the whole call stack available in the debugger.
                        if (jsPlumbUtil.findWithFunction(eventsToDieOn, function(e) { return e === event}) != -1)
                            _listeners[event][i](value, originalEvent);
                        else {
                            // for events we don't want to die on, catch and log.
                            try {
                                _listeners[event][i](value, originalEvent);
                            } catch (e) {
                                jsPlumbUtil.log("jsPlumb: fire failed for event " + event + " : " + e);
                            }
                        }
                    }
                }
                return self;
            };
            /*
             * Clears either all listeners, or listeners for some specific event.
             * 
             * Parameters:
             * 	event	-	optional. constrains the clear to just listeners for this event.
             */
            this.unbind = function(event) {
                if (event)
                    delete _listeners[event];
                else {
                    _listeners = {};
                }
                return self;
            };
            
            this.getListener = function(forEvent) {
                return _listeners[forEvent];
            };		
            
            this.setSuspendEvents = function(val) {
                eventsSuspended = val;    
            };
            
            this.isSuspendEvents = function() {
                return eventsSuspended;
            };
        },
        logEnabled : true,
        log : function() {
            if (jsPlumbUtil.logEnabled && typeof console != "undefined") {
                try {
                    var msg = arguments[arguments.length - 1];
                    console.log(msg);
                }
                catch (e) {} 
            }
        },
        group : function(g) { if (jsPlumbUtil.logEnabled && typeof console != "undefined") console.group(g); },
        groupEnd : function(g) { if (jsPlumbUtil.logEnabled && typeof console != "undefined") console.groupEnd(g); },
        time : function(t) { if (jsPlumbUtil.logEnabled && typeof console != "undefined") console.time(t); },
        timeEnd : function(t) { if (jsPlumbUtil.logEnabled && typeof console != "undefined") console.timeEnd(t); },
        
        /**
		 * helper to remove an element from the DOM.
		 */
		removeElement : function(element) {
			if (element != null && element.parentNode != null) {
				element.parentNode.removeChild(element);
			}
		},
        /**
		 * helper to remove a list of elements from the DOM.
		 */
		removeElements : function(elements) {
			for ( var i = 0; i < elements.length; i++)
				jsPlumbUtil.removeElement(elements[i]);
		}
    };
})();/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.4.1
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the base functionality for DOM type adapters. 
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {
    
		var canvasAvailable = !!document.createElement('canvas').getContext,
		svgAvailable = !!window.SVGAngle || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),
		// http://stackoverflow.com/questions/654112/how-do-you-detect-support-for-vml-or-svg-in-a-browser
		vmlAvailable = function() {		    
            if (vmlAvailable.vml == undefined) { 
                    var a = document.body.appendChild(document.createElement('div'));
            a.innerHTML = '<v:shape id="vml_flag1" adj="1" />';
            var b = a.firstChild;
            b.style.behavior = "url(#default#VML)";
            vmlAvailable.vml = b ? typeof b.adj == "object": true;
            a.parentNode.removeChild(a);
            }
            return vmlAvailable.vml;
		};
        
    /**
		Manages dragging for some instance of jsPlumb.
	*/
	var DragManager = function(_currentInstance) {		
		var _draggables = {}, _dlist = [], _delements = {}, _elementsWithEndpoints = {},			
			// elementids mapped to the draggable to which they belong.
			_draggablesForElements = {};

        /**
            register some element as draggable.  right now the drag init stuff is done elsewhere, and it is
            possible that will continue to be the case.
        */
		this.register = function(el) {
            var jpcl = jsPlumb.CurrentLibrary;
            el = jpcl.getElementObject(el);
            var id = _currentInstance.getId(el),
                domEl = jpcl.getDOMElement(el),
                parentOffset = jpcl.getOffset(el);
                    
            if (!_draggables[id]) {
                _draggables[id] = el;
                _dlist.push(el);
                _delements[id] = {};
            }
				
			// look for child elements that have endpoints and register them against this draggable.
			var _oneLevel = function(p, startOffset) {
                if (p) {											
                    for (var i = 0; i < p.childNodes.length; i++) {
                        if (p.childNodes[i].nodeType != 3 && p.childNodes[i].nodeType != 8) {
                            var cEl = jpcl.getElementObject(p.childNodes[i]),
                                cid = _currentInstance.getId(cEl, null, true);
                            if (cid && _elementsWithEndpoints[cid] && _elementsWithEndpoints[cid] > 0) {
                                var cOff = jpcl.getOffset(cEl);
                                _delements[id][cid] = {
                                    id:cid,
                                    offset:{
                                        left:cOff.left - parentOffset.left,
                                        top:cOff.top - parentOffset.top
                                    }
                                };
                                _draggablesForElements[cid] = id;
                            }
                            _oneLevel(p.childNodes[i]);
                        }	
                    }
                }
			};

			_oneLevel(domEl);
		};
		
		// refresh the offsets for child elements of this element. 
		this.updateOffsets = function(elId) {
			var jpcl = jsPlumb.CurrentLibrary,
				el = jpcl.getElementObject(elId),
				id = _currentInstance.getId(el),
				children = _delements[id],
				parentOffset = jpcl.getOffset(el);
				
			if (children) {
				for (var i in children) {
					var cel = jpcl.getElementObject(i),
						cOff = jpcl.getOffset(cel);
						
					_delements[id][i] = {
						id:i,
						offset:{
							left:cOff.left - parentOffset.left,
							top:cOff.top - parentOffset.top
						}
					};
					_draggablesForElements[i] = id;
				}
			}
		};

		/**
			notification that an endpoint was added to the given el.  we go up from that el's parent
			node, looking for a parent that has been registered as a draggable. if we find one, we add this
			el to that parent's list of elements to update on drag (if it is not there already)
		*/
		this.endpointAdded = function(el) {
			var jpcl = jsPlumb.CurrentLibrary, b = document.body, id = _currentInstance.getId(el), c = jpcl.getDOMElement(el), 
				p = c.parentNode, done = p == b;

			_elementsWithEndpoints[id] = _elementsWithEndpoints[id] ? _elementsWithEndpoints[id] + 1 : 1;

			while (p != null && p != b) {
				var pid = _currentInstance.getId(p, null, true);
				if (pid && _draggables[pid]) {
					var idx = -1, pEl = jpcl.getElementObject(p), pLoc = jpcl.getOffset(pEl);
					
					if (_delements[pid][id] == null) {
						var cLoc = jsPlumb.CurrentLibrary.getOffset(el);
						_delements[pid][id] = {
							id:id,
							offset:{
								left:cLoc.left - pLoc.left,
								top:cLoc.top - pLoc.top
							}
						};
						_draggablesForElements[id] = pid;
					}
					break;
				}
				p = p.parentNode;
			}	
		};

		this.endpointDeleted = function(endpoint) {
			if (_elementsWithEndpoints[endpoint.elementId]) {
				_elementsWithEndpoints[endpoint.elementId]--;
				if (_elementsWithEndpoints[endpoint.elementId] <= 0) {
					for (var i in _delements) {
						if (_delements[i]) {
                            delete _delements[i][endpoint.elementId];
                            delete _draggablesForElements[endpoint.elementId];
                        }
					}
				}
			}		
		};	
		
		this.changeId = function(oldId, newId) {				
			_delements[newId] = _delements[oldId];			
			_delements[oldId] = {};
			_draggablesForElements[newId] = _draggablesForElements[oldId];
			_draggablesForElements[oldId] = null;			
		};

		this.getElementsForDraggable = function(id) {
			return _delements[id];	
		};

		this.elementRemoved = function(elementId) {
			var elId = _draggablesForElements[elementId];
			if (elId) {
				delete _delements[elId][elementId];
				delete _draggablesForElements[elementId];
			}
		};

		this.reset = function() {
			_draggables = {};
			_dlist = [];
			_delements = {};
			_elementsWithEndpoints = {};
		};
		
	};
        
    // for those browsers that dont have it.  they still don't have it! but at least they won't crash.
	if (!window.console)
		window.console = { time:function(){}, timeEnd:function(){}, group:function(){}, groupEnd:function(){}, log:function(){} };
            
    window.jsPlumbAdapter = {
        
        headless:false,
        
        appendToRoot : function(node) {
            document.body.appendChild(node);
        },
        getRenderModes : function() {
            return [ "canvas", "svg", "vml" ]
        },
        isRenderModeAvailable : function(m) {
            return {
                "canvas":canvasAvailable,
                "svg":svgAvailable,
                "vml":vmlAvailable()
            }[m];
        },
        getDragManager : function(_jsPlumb) {
            return new DragManager(_jsPlumb);
        },
        setRenderMode : function(mode) {
            var renderMode;
            
            if (mode) {
				mode = mode.toLowerCase();            
			            
                var canvasAvailable = this.isRenderModeAvailable("canvas"),
                    svgAvailable = this.isRenderModeAvailable("svg"),
                    vmlAvailable = this.isRenderModeAvailable("vml");
                
                // now test we actually have the capability to do this.						
                if (mode === "svg") {
                    if (svgAvailable) renderMode = "svg"
                    else if (canvasAvailable) renderMode = "canvas"
                    else if (vmlAvailable) renderMode = "vml"
                }
                else if (mode === "canvas" && canvasAvailable) renderMode = "canvas";
                else if (vmlAvailable) renderMode = "vml";
            }

			return renderMode;
        }
    };
    
})();/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.4.1
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the jsPlumb core code.
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (simon.porritt@gmail.com)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */

;(function() {
			
    var _findWithFunction = jsPlumbUtil.findWithFunction,
	_indexOf = jsPlumbUtil.indexOf,
    _removeWithFunction = jsPlumbUtil.removeWithFunction,
    _remove = jsPlumbUtil.remove,
    // TODO support insert index
    _addWithFunction = jsPlumbUtil.addWithFunction,
    _addToList = jsPlumbUtil.addToList,
	/**
		an isArray function that even works across iframes...see here:
		
		http://tobyho.com/2011/01/28/checking-types-in-javascript/

		i was originally using "a.constructor == Array" as a test.
	*/
	_isArray = jsPlumbUtil.isArray,
	_isString = jsPlumbUtil.isString,
	_isObject = jsPlumbUtil.isObject;
		
	var _att = function(el, attName) { return jsPlumb.CurrentLibrary.getAttribute(_gel(el), attName); },
		_setAttribute = function(el, attName, attValue) { jsPlumb.CurrentLibrary.setAttribute(_gel(el), attName, attValue); },
		_addClass = function(el, clazz) { jsPlumb.CurrentLibrary.addClass(_gel(el), clazz); },
		_hasClass = function(el, clazz) { return jsPlumb.CurrentLibrary.hasClass(_gel(el), clazz); },
		_removeClass = function(el, clazz) { jsPlumb.CurrentLibrary.removeClass(_gel(el), clazz); },
		_gel = function(el) { return jsPlumb.CurrentLibrary.getElementObject(el); },
		_getOffset = function(el, _instance) {
            var o = jsPlumb.CurrentLibrary.getOffset(_gel(el));
            if(!o) return o;
			if (_instance != null) {
                var z = _instance.getZoom();
                return {left:o.left / z, top:o.top / z };    
            }
            else
                return o;
        },		
		_getSize = function(el) {
            return jsPlumb.CurrentLibrary.getSize(_gel(el));
        },
		_log = jsPlumbUtil.log,
		_group = jsPlumbUtil.group,
		_groupEnd = jsPlumbUtil.groupEnd,
		_time = jsPlumbUtil.time,
		_timeEnd = jsPlumbUtil.timeEnd,
		
		/**
		 * creates a timestamp, using milliseconds since 1970, but as a string.
		 */
		_timestamp = function() { return "" + (new Date()).getTime(); },
		
		/*
		 * Class:jsPlumbUIComponent
		 * Abstract superclass for UI components Endpoint and Connection.  Provides the abstraction of paintStyle/hoverPaintStyle,
		 * and also extends jsPlumbUtil.EventGenerator to provide the bind and fire methods.
		 */
		jsPlumbUIComponent = window.jsPlumbUIComponent = function(params) {
			var self = this, 
				a = arguments, 
				_hover = false, 
				parameters = params.parameters || {}, 
				idPrefix = self.idPrefix,
				id = idPrefix + (new Date()).getTime(),
				paintStyle = null,
				hoverPaintStyle = null;

			self._jsPlumb = params["_jsPlumb"];			
			self.getId = function() { return id; };			
			self.hoverClass = params.hoverClass || self._jsPlumb.Defaults.HoverClass || jsPlumb.Defaults.HoverClass;				
			
			// all components can generate events
			jsPlumbUtil.EventGenerator.apply(this);
			if (params.events) {
				for (var i in params.events)
					self.bind(i, params.events[i]);
			}

			// all components get this clone function.
			// TODO issue 116 showed a problem with this - it seems 'a' that is in
			// the clone function's scope is shared by all invocations of it, the classic
			// JS closure problem.  for now, jsPlumb does a version of this inline where 
			// it used to call clone.  but it would be nice to find some time to look
			// further at this.
			this.clone = function() {
				var o = new Object();
				self.constructor.apply(o, a);
				return o;
			};
			
			this.getParameter = function(name) { return parameters[name]; },
			this.getParameters = function() { 
				return parameters; 
			},
			this.setParameter = function(name, value) { parameters[name] = value; },
			this.setParameters = function(p) { parameters = p; },			
			this.overlayPlacements = [];			
			
			// user can supply a beforeDetach callback, which will be executed before a detach
			// is performed; returning false prevents the detach.
			var beforeDetach = params.beforeDetach;
			this.isDetachAllowed = function(connection) {
				var r = true;
				if (beforeDetach) {
					try { 
						r = beforeDetach(connection); 
					}
					catch (e) { _log("jsPlumb: beforeDetach callback failed", e); }
				}
				return r;
			};
			
			// user can supply a beforeDrop callback, which will be executed before a dropped
			// connection is confirmed. user can return false to reject connection.
			var beforeDrop = params.beforeDrop;
			this.isDropAllowed = function(sourceId, targetId, scope, connection, dropEndpoint) {
				var r = self._jsPlumb.checkCondition("beforeDrop", { 
					sourceId:sourceId, 
					targetId:targetId, 
					scope:scope,
					connection:connection,
					dropEndpoint:dropEndpoint 
				});
				if (beforeDrop) {
					try { 
						r = beforeDrop({ 
							sourceId:sourceId, 
							targetId:targetId, 
							scope:scope, 
							connection:connection,
							dropEndpoint:dropEndpoint
						}); 
					}
					catch (e) { _log("jsPlumb: beforeDrop callback failed", e); }
				}
				return r;
			};
									
			// helper method to update the hover style whenever it, or paintStyle, changes.
			// we use paintStyle as the foundation and merge hoverPaintStyle over the
			// top.
			var _updateHoverStyle = function() {
				if (paintStyle && hoverPaintStyle) {
					var mergedHoverStyle = {};
					jsPlumb.extend(mergedHoverStyle, paintStyle);
					jsPlumb.extend(mergedHoverStyle, hoverPaintStyle);
					delete self["hoverPaintStyle"];
					// we want the fillStyle of paintStyle to override a gradient, if possible.
					if (mergedHoverStyle.gradient && paintStyle.fillStyle)
						delete mergedHoverStyle["gradient"];
					hoverPaintStyle = mergedHoverStyle;
				}
			};
			
			/*
		     * Sets the paint style and then repaints the element.
		     * 
		     * Parameters:
		     * 	style - Style to use.
		     */
		    this.setPaintStyle = function(style, doNotRepaint) {
		    	paintStyle = style;
		    	self.paintStyleInUse = paintStyle;
		    	_updateHoverStyle();
		    	if (!doNotRepaint) self.repaint();
		    };

		    /**
		    * Gets the component's paint style.
		    *
		    * Returns:
		    * the component's paint style. if there is no hoverPaintStyle set then this will be the paint style used all the time, otherwise this is the style used when the mouse is not hovering.
		    */
		    this.getPaintStyle = function() {
		    	return paintStyle;
		    };
		    
		    /*
		     * Sets the paint style to use when the mouse is hovering over the element. This is null by default.
		     * The hover paint style is applied as extensions to the paintStyle; it does not entirely replace
		     * it.  This is because people will most likely want to change just one thing when hovering, say the
		     * color for example, but leave the rest of the appearance the same.
		     * 
		     * Parameters:
		     * 	style - Style to use when the mouse is hovering.
		     *  doNotRepaint - if true, the component will not be repainted.  useful when setting things up initially.
		     */
		    this.setHoverPaintStyle = function(style, doNotRepaint) {		    	
		    	hoverPaintStyle = style;
		    	_updateHoverStyle();
		    	if (!doNotRepaint) self.repaint();
		    };

		    /**
		    * Gets the component's hover paint style.
		    *
		    * Returns:
		    * the component's hover paint style. may be null.
		    */
		    this.getHoverPaintStyle = function() {
		    	return hoverPaintStyle;
		    };
		    
		    /*
		     * sets/unsets the hover state of this element.
		     * 
		     * Parameters:
		     * 	hover - hover state boolean
		     * 	ignoreAttachedElements - if true, does not notify any attached elements of the change in hover state.  used mostly to avoid infinite loops.
		     */
		    this.setHover = function(hover, ignoreAttachedElements, timestamp) {
		    	// while dragging, we ignore these events.  this keeps the UI from flashing and
		    	// swishing and whatevering.
				if (!self._jsPlumb.currentlyDragging && !self._jsPlumb.isHoverSuspended()) {
		    
			    	_hover = hover;
                        
                    if (self.canvas != null) {
                        if (self.hoverClass != null) {
                            if (hover) 
                                jpcl.addClass(self.canvas, self.hoverClass);						
                            else
                                jpcl.removeClass(self.canvas, self.hoverClass);
                        }
                        
                        if (hover) 
                            jpcl.addClass(self.canvas, self._jsPlumb.hoverClass);						
                        else
                            jpcl.removeClass(self.canvas, self._jsPlumb.hoverClass);
                    }
		   		 	if (hoverPaintStyle != null) {
						self.paintStyleInUse = hover ? hoverPaintStyle : paintStyle;
						if (!self._jsPlumb.isSuspendDrawing()) {
							timestamp = timestamp || _timestamp();
							self.repaint({timestamp:timestamp, recalc:false});
						}
					}
					// get the list of other affected elements, if supported by this component.
					// for a connection, its the endpoints.  for an endpoint, its the connections! surprise.
					if (self.getAttachedElements && !ignoreAttachedElements)
						_updateAttachedElements(hover, _timestamp(), self);
				}
		    };
		    
		    this.isHover = function() { return _hover; };
            
            this.bindListeners = function(obj, _self, _hoverFunction) {
                obj.bind("click", function(ep, e) { _self.fire("click", _self, e); });
                obj.bind("dblclick", function(ep, e) { _self.fire("dblclick", _self, e); });
                obj.bind("contextmenu", function(ep, e) { _self.fire("contextmenu", _self, e); });
                obj.bind("mouseenter", function(ep, e) {
                    if (!_self.isHover()) {
                        _hoverFunction(true);
                        _self.fire("mouseenter", _self, e);
                    }
                });
                obj.bind("mouseexit", function(ep, e) {
                    if (_self.isHover()) {
                        _hoverFunction(false);
                        _self.fire("mouseexit", _self, e);
                    }
                });	  
                obj.bind("mousedown", function(ep, e) { _self.fire("mousedown", _self, e); });
                obj.bind("mouseup", function(ep, e) { _self.fire("mouseup", _self, e); });
            };
		
			var jpcl = jsPlumb.CurrentLibrary,
				events = [ "click", "dblclick", "mouseenter", "mouseout", "mousemove", "mousedown", "mouseup", "contextmenu" ],
				eventFilters = { "mouseout":"mouseexit" },
				bindOne = function(o, c, evt) {
					var filteredEvent = eventFilters[evt] || evt;
					jpcl.bind(o, evt, function(ee) {
						c.fire(filteredEvent, c, ee);
					});
				},
				unbindOne = function(o, evt) {
					var filteredEvent = eventFilters[evt] || evt;
					jpcl.unbind(o, evt);
				};
		    
		    this.attachListeners = function(o, c) {
				for (var i = 0, j = events.length; i < j; i++) {
					bindOne(o, c, events[i]); 			
				}
			};
		    
		    var _updateAttachedElements = function(state, timestamp, sourceElement) {
		    	var affectedElements = self.getAttachedElements();		// implemented in subclasses
		    	if (affectedElements) {
		    		for (var i = 0, j = affectedElements.length; i < j; i++) {
		    			if (!sourceElement || sourceElement != affectedElements[i])
		    				affectedElements[i].setHover(state, true, timestamp);			// tell the attached elements not to inform their own attached elements.
		    		}
		    	}
		    };
		    
		    this.reattachListenersForElement = function(o) {
			    if (arguments.length > 1) {
		    		for (var i = 0, j = events.length; i < j; i++)
		    			unbindOne(o, events[i]);
			    	for (var i = 1, j = arguments.length; i < j; i++)
		    			self.attachListeners(o, arguments[i]);
		    	}
		    };		    	    
			
			/*
			 * TYPES
			 */
			var _types = [],
				_splitType = function(t) { return t == null ? null : t.split(" ")},				
				_applyTypes = function(params, doNotRepaint) {
					if (self.getDefaultType) {
						var td = self.getTypeDescriptor();
							
						var o = jsPlumbUtil.merge({}, self.getDefaultType());
						for (var i = 0, j = _types.length; i < j; i++)
							o = jsPlumbUtil.merge(o, self._jsPlumb.getType(_types[i], td));						
							
						if (params) {
							o = jsPlumbUtil.populate(o, params);
						}
					
						self.applyType(o, doNotRepaint);					
						if (!doNotRepaint) self.repaint();
					}
				};
			
			/*
				Function: setType	
				Sets the type, removing all existing types.
			*/
			self.setType = function(typeId, params, doNotRepaint) {				
				_types = _splitType(typeId) || [];
				_applyTypes(params, doNotRepaint);									
			};
			
			/*
			 * Function : getType
			 * Gets the 'types' of this component.
			 */
			self.getType = function() {
				return _types;
			};

			/**
				Function: reapplyTypes
				Reapply all existing types, but with the given new params.
			*/
			self.reapplyTypes = function(params, doNotRepaint) {
				_applyTypes(params, doNotRepaint);
			};
			
			self.hasType = function(typeId) {
				return jsPlumbUtil.indexOf(_types, typeId) != -1;
			};
			
			/*
				Function: addType
				adds a type. will not be re-added it already exists.
			*/
			self.addType = function(typeId, params, doNotRepaint) {
				var t = _splitType(typeId), _cont = false;
				if (t != null) {
					for (var i = 0, j = t.length; i < j; i++) {
						if (!self.hasType(t[i])) {
							_types.push(t[i]);
							_cont = true;						
						}
					}
					if (_cont) _applyTypes(params, doNotRepaint);
				}
			};
			
			self.removeType = function(typeId, doNotRepaint) {
				var t = _splitType(typeId), _cont = false, _one = function(tt) {
					var idx = jsPlumbUtil.indexOf(_types, tt);
					if (idx != -1) {
						_types.splice(idx, 1);
						return true;
					}
					return false;
				};
				
				if (t != null) {
					for (var i = 0,j = t.length; i < j; i++) {
						_cont = _one(t[i]) || _cont;
					}
					if (_cont) _applyTypes(null, doNotRepaint);
				}
			};
			
			self.toggleType = function(typeId, params, doNotRepaint) {
				var t = _splitType(typeId);
				if (t != null) {
					for (var i = 0, j = t.length; i < j; i++) {
						var idx = jsPlumbUtil.indexOf(_types, t[i]);
						if (idx != -1)
							_types.splice(idx, 1);
						else
							_types.push(t[i]);
					}
						
					_applyTypes(params, doNotRepaint);
				}
			};
			
			this.applyType = function(t, doNotRepaint) {
				self.setPaintStyle(t.paintStyle, doNotRepaint);				
				self.setHoverPaintStyle(t.hoverPaintStyle, doNotRepaint);
				if (t.parameters){
					for (var i in t.parameters)
						self.setParameter(i, t.parameters[i]);
				}
			};
            
            // CSS classes
            this.addClass = function(clazz) {
                if (self.canvas != null)
                    _addClass(self.canvas, clazz);
            };
			
            this.removeClass = function(clazz) {
                if (self.canvas != null)
                    _removeClass(self.canvas, clazz);
            };                    
		},

		overlayCapableJsPlumbUIComponent = window.overlayCapableJsPlumbUIComponent = function(params) {
			jsPlumbUIComponent.apply(this, arguments);
			var self = this;			
			this.overlays = [];

			var processOverlay = function(o) {
				var _newOverlay = null;
				if (_isArray(o)) {	// this is for the shorthand ["Arrow", { width:50 }] syntax
					// there's also a three arg version:
					// ["Arrow", { width:50 }, {location:0.7}] 
					// which merges the 3rd arg into the 2nd.
					var type = o[0],
						// make a copy of the object so as not to mess up anyone else's reference...
						p = jsPlumb.extend({component:self, _jsPlumb:self._jsPlumb}, o[1]);
					if (o.length == 3) jsPlumb.extend(p, o[2]);
					_newOverlay = new jsPlumb.Overlays[self._jsPlumb.getRenderMode()][type](p);					
				} else if (o.constructor == String) {
					_newOverlay = new jsPlumb.Overlays[self._jsPlumb.getRenderMode()][o]({component:self, _jsPlumb:self._jsPlumb});
				} else {
					_newOverlay = o;
				}										
					
				self.overlays.push(_newOverlay);
			},
			calculateOverlaysToAdd = function(params) {
				var defaultKeys = self.defaultOverlayKeys || [],
					o = params.overlays,
					checkKey = function(k) {
						return self._jsPlumb.Defaults[k] || jsPlumb.Defaults[k] || [];
					};
				
				if (!o) o = [];

				for (var i = 0, j = defaultKeys.length; i < j; i++)
					o.unshift.apply(o, checkKey(defaultKeys[i]));
				
				return o;
			}

			var _overlays = calculateOverlaysToAdd(params);
			if (_overlays) {
				for (var i = 0, j = _overlays.length; i < j; i++) {
					processOverlay(_overlays[i]);
				}
			}

		    // overlay finder helper method
			var _getOverlayIndex = function(id) {
				var idx = -1;
				for (var i = 0, j = self.overlays.length; i < j; i++) {
					if (id === self.overlays[i].id) {
						idx = i;
						break;
					}
				}
				return idx;
			};
						
			this.addOverlay = function(overlay, doNotRepaint) { 
				processOverlay(overlay); 
				if (!doNotRepaint) self.repaint();
			};
						
			this.getOverlay = function(id) {
				var idx = _getOverlayIndex(id);
				return idx >= 0 ? self.overlays[idx] : null;
			};
			
			this.getOverlays = function() {
				return self.overlays;
			};			
			
			this.hideOverlay = function(id) {
				var o = self.getOverlay(id);
				if (o) o.hide();
			};

			this.hideOverlays = function() {
				for (var i = 0, j = self.overlays.length; i < j; i++)
					self.overlays[i].hide();
			};
						
			this.showOverlay = function(id) {
				var o = self.getOverlay(id);
				if (o) o.show();
			};

			this.showOverlays = function() {
				for (var i = 0, j = self.overlays.length; i < j; i++)
					self.overlays[i].show();
			};
			
			this.removeAllOverlays = function() {
				for (var i = 0, j = self.overlays.length; i < j; i++) {
					if (self.overlays[i].cleanup) self.overlays[i].cleanup();
				}

				self.overlays.splice(0, self.overlays.length);
				self.repaint();
			};
						
			this.removeOverlay = function(overlayId) {
				var idx = _getOverlayIndex(overlayId);
				if (idx != -1) {
					var o = self.overlays[idx];
					if (o.cleanup) o.cleanup();
					self.overlays.splice(idx, 1);
				}
			};
						
			this.removeOverlays = function() {
				for (var i = 0, j = arguments.length; i < j; i++)
					self.removeOverlay(arguments[i]);
			};

			// this is a shortcut helper method to let people add a label as
			// overlay.			
			var _internalLabelOverlayId = "__label",
			_makeLabelOverlay = function(params) {

				var _params = {
					cssClass:params.cssClass,
					labelStyle : this.labelStyle,					
					id:_internalLabelOverlayId,
					component:self,
					_jsPlumb:self._jsPlumb
				},
				mergedParams = jsPlumb.extend(_params, params);

				return new jsPlumb.Overlays[self._jsPlumb.getRenderMode()].Label( mergedParams );
			};
			if (params.label) {
				var loc = params.labelLocation || self.defaultLabelLocation || 0.5,
					labelStyle = params.labelStyle || self._jsPlumb.Defaults.LabelStyle || jsPlumb.Defaults.LabelStyle;			
				this.overlays.push(_makeLabelOverlay({
					label:params.label,
					location:loc,
					labelStyle:labelStyle
				}));
			}
			
			this.setLabel = function(l) {
				var lo = self.getOverlay(_internalLabelOverlayId);
				if (!lo) {
					var params = l.constructor == String || l.constructor == Function ? { label:l } : l;
					lo = _makeLabelOverlay(params);	
					this.overlays.push(lo);
				}
				else {
					if (l.constructor == String || l.constructor == Function) lo.setLabel(l);
					else {
						if (l.label) lo.setLabel(l.label);
						if (l.location) lo.setLocation(l.location);
					}
				}
				
				if (!self._jsPlumb.isSuspendDrawing()) 
					self.repaint();
			};

			
			this.getLabel = function() {
				var lo = self.getOverlay(_internalLabelOverlayId);
				return lo != null ? lo.getLabel() : null;
			};

			
			this.getLabelOverlay = function() {
				return self.getOverlay(_internalLabelOverlayId);
			};
			
			var superAt = this.applyType;
			this.applyType = function(t, doNotRepaint) {
				superAt(t, doNotRepaint);
				self.removeAllOverlays();
				if (t.overlays) {
					for (var i = 0, j = t.overlays.length; i < j; i++)
						self.addOverlay(t.overlays[i], true);
				}
			};
            
            var superHover = this.setHover;
            this.setHover = function(hover, ignoreAttachedElements, timestamp) {
                superHover.apply(self, arguments);    
                for (var i = 0, j = self.overlays.length; i < j; i++) {
					self.overlays[i][hover ? "addClass":"removeClass"](self._jsPlumb.hoverClass);
				}
            };
		};		
		
		var _jsPlumbInstanceIndex = 0,
			getInstanceIndex = function() {
				var i = _jsPlumbInstanceIndex + 1;
				_jsPlumbInstanceIndex++;
				return i;
			};

		var jsPlumbInstance = function(_defaults) {
		
		
		this.Defaults = {
			Anchor : "BottomCenter",
			Anchors : [ null, null ],
            ConnectionsDetachable : true,
            ConnectionOverlays : [ ],
            Connector : "Bezier",
			Container : null,
			DoNotThrowErrors:false,
			DragOptions : { },
			DropOptions : { },
			Endpoint : "Dot",
			EndpointOverlays : [ ],
			Endpoints : [ null, null ],
			EndpointStyle : { fillStyle : "#456" },
			EndpointStyles : [ null, null ],
			EndpointHoverStyle : null,
			EndpointHoverStyles : [ null, null ],
			HoverPaintStyle : null,
			LabelStyle : { color : "black" },
			LogEnabled : false,
			Overlays : [ ],
			MaxConnections : 1, 
			PaintStyle : { lineWidth : 8, strokeStyle : "#456" },            
			ReattachConnections:false,
			RenderMode : "svg",
			Scope : "jsPlumb_DefaultScope"
		};
		if (_defaults) jsPlumb.extend(this.Defaults, _defaults);
		
		this.logEnabled = this.Defaults.LogEnabled;
		
		var _connectionTypes = { }, _endpointTypes = {};
		this.registerConnectionType = function(id, type) {
			_connectionTypes[id] = jsPlumb.extend({}, type);
		};
		this.registerConnectionTypes = function(types) {
			for (var i in types)
				_connectionTypes[i] = jsPlumb.extend({}, types[i]);
		};
		this.registerEndpointType = function(id, type) {
			_endpointTypes[id] = jsPlumb.extend({}, type);
		};
		this.registerEndpointTypes = function(types) {
			for (var i in types)
				_endpointTypes[i] = jsPlumb.extend({}, types[i]);
		};
		this.getType = function(id, typeDescriptor) {
			return typeDescriptor ===  "connection" ? _connectionTypes[id] : _endpointTypes[id];
		};

		jsPlumbUtil.EventGenerator.apply(this);
		var _currentInstance = this,
			_instanceIndex = getInstanceIndex(),
			_bb = _currentInstance.bind,
			_initialDefaults = {},
            _zoom = 1;
            
        this.getInstanceIndex = function() {
            return _instanceIndex;
        };
            
        this.setZoom = function(z, repaintEverything) {
            _zoom = z;
            if (repaintEverything) _currentInstance.repaintEverything();
        };
        this.getZoom = function() { return _zoom; };
                        
		for (var i in this.Defaults)
			_initialDefaults[i] = this.Defaults[i];

		this.bind = function(event, fn) {		
			if ("ready" === event && initialized) fn();
			else _bb.apply(_currentInstance,[event, fn]);
		};

		_currentInstance.importDefaults = function(d) {
			for (var i in d) {
				_currentInstance.Defaults[i] = d[i];
			}	
		};
		
		_currentInstance.restoreDefaults = function() {
			_currentInstance.Defaults = jsPlumb.extend({}, _initialDefaults);
		};
		
    var log = null,
        resizeTimer = null,
        initialized = false,
        _connectionBeingDragged = null,        
        connectionsByScope = {},
        /**
         * map of element id -> endpoint lists. an element can have an arbitrary
         * number of endpoints on it, and not all of them have to be connected
         * to anything.
         */
        endpointsByElement = {},
        endpointsByUUID = {},
        offsets = {},
        offsetTimestamps = {},
        floatingConnections = {},
        draggableStates = {},		
        canvasList = [],
        sizes = [],
        //listeners = {}, // a map: keys are event types, values are lists of listeners.
        DEFAULT_SCOPE = this.Defaults.Scope,
        renderMode = null,  // will be set in init()							
		

		/**
		 * appends an element to some other element, which is calculated as follows:
		 * 
		 * 1. if _currentInstance.Defaults.Container exists, use that element.
		 * 2. if the 'parent' parameter exists, use that.
		 * 3. otherwise just use the root element (for DOM usage, the document body).
		 * 
		 */
		_appendElement = function(el, parent) {
			if (_currentInstance.Defaults.Container)
				jsPlumb.CurrentLibrary.appendElement(el, _currentInstance.Defaults.Container);
			else if (!parent)
				jsPlumbAdapter.appendToRoot(el);
			else
				jsPlumb.CurrentLibrary.appendElement(el, parent);
		},

		_curIdStamp = 1,
		_idstamp = function() { return "" + _curIdStamp++; },		
		
		/**
		 * YUI, for some reason, put the result of a Y.all call into an object that contains
		 * a '_nodes' array, instead of handing back an array-like object like the other
		 * libraries do.
		 */
		_convertYUICollection = function(c) {
			return c._nodes ? c._nodes : c;
		},                

		/**
		 * Draws an endpoint and its connections. this is the main entry point into drawing connections as well
		 * as endpoints, since jsPlumb is endpoint-centric under the hood.
		 * 
		 * @param element element to draw (of type library specific element object)
		 * @param ui UI object from current library's event system. optional.
		 * @param timestamp timestamp for this paint cycle. used to speed things up a little by cutting down the amount of offset calculations we do.
		 */
		_draw = function(element, ui, timestamp, clearEdits) {
		    if(!element.is(":visible")) { return true; }
			// TODO is it correct to filter by headless at this top level? how would a headless adapter ever repaint?
            if (!jsPlumbAdapter.headless && !_suspendDrawing) {
			    var id = _att(element, "id"),
			    	repaintEls = _currentInstance.dragManager.getElementsForDraggable(id);			    

			    if (timestamp == null) timestamp = _timestamp();

			    _currentInstance.anchorManager.redraw(id, ui, timestamp, null, clearEdits);
			    if (repaintEls) {
				    for (var i in repaintEls) {
						_currentInstance.anchorManager.redraw(repaintEls[i].id, ui, timestamp, repaintEls[i].offset, clearEdits);			    	
				    }
				}
            }
		},

		/**
		 * executes the given function against the given element if the first
		 * argument is an object, or the list of elements, if the first argument
		 * is a list. the function passed in takes (element, elementId) as
		 * arguments.
		 */
		_elementProxy = function(element, fn) {
			var retVal = null;
			if (_isArray(element)) {
				retVal = [];
				for ( var i = 0, j = element.length; i < j; i++) {
					var el = _gel(element[i]), id = _att(el, "id");
					retVal.push(fn(el, id)); // append return values to what we will return
				}
			} else {
				var el = _gel(element), id = _att(el, "id");
				retVal = fn(el, id);
			}
			return retVal;
		},				

		/**
		 * gets an Endpoint by uuid.
		 */
		_getEndpoint = function(uuid) { return endpointsByUUID[uuid]; },

		/**
		 * inits a draggable if it's not already initialised.
		 */
		_initDraggableIfNecessary = function(element, isDraggable, dragOptions) {
			// TODO move to DragManager?
			if (!jsPlumbAdapter.headless) {
				var draggable = isDraggable == null ? false : isDraggable, jpcl = jsPlumb.CurrentLibrary;
				if (draggable) {
					if (jpcl.isDragSupported(element) && !jpcl.isAlreadyDraggable(element)) {
						var options = dragOptions || _currentInstance.Defaults.DragOptions || jsPlumb.Defaults.DragOptions;
						options = jsPlumb.extend( {}, options); // make a copy.
						var dragEvent = jpcl.dragEvents["drag"],
							stopEvent = jpcl.dragEvents["stop"],
							startEvent = jpcl.dragEvents["start"];
	
						options[startEvent] = _wrap(options[startEvent], function() {
							_currentInstance.setHoverSuspended(true);							
							_currentInstance.select({source:element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
							_currentInstance.select({target:element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
						});
	
						options[dragEvent] = _wrap(options[dragEvent], function() {                            
							var ui = jpcl.getUIPosition(arguments, _currentInstance.getZoom());
							_draw(element, ui, null, true);
							_addClass(element, "jsPlumb_dragged");
						});
						options[stopEvent] = _wrap(options[stopEvent], function() {
							var ui = jpcl.getUIPosition(arguments, _currentInstance.getZoom());
							_draw(element, ui);
							_removeClass(element, "jsPlumb_dragged");
							_currentInstance.setHoverSuspended(false);							
							_currentInstance.select({source:element}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
							_currentInstance.select({target:element}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
						});
						var elId = _getId(element); // need ID
						draggableStates[elId] = true;  
						var draggable = draggableStates[elId];
						options.disabled = draggable == null ? false : !draggable;
						jpcl.initDraggable(element, options, false, _currentInstance);
						_currentInstance.dragManager.register(element);
					}
				}
			}
		},
		
		/*
		* prepares a final params object that can be passed to _newConnection, taking into account defaults, events, etc.
		*/
		_prepareConnectionParams = function(params, referenceParams) {
			var _p = jsPlumb.extend( {
				sourceIsNew:true,
				targetIsNew:true
			}, params);
			if (referenceParams) jsPlumb.extend(_p, referenceParams);
			
			// hotwire endpoints passed as source or target to sourceEndpoint/targetEndpoint, respectively.
			if (_p.source && _p.source.endpoint) _p.sourceEndpoint = _p.source;
			if (_p.target && _p.target.endpoint) _p.targetEndpoint = _p.target;
			
			// test for endpoint uuids to connect
			if (params.uuids) {
				_p.sourceEndpoint = _getEndpoint(params.uuids[0]);
				_p.targetEndpoint = _getEndpoint(params.uuids[1]);
			}						

			// now ensure that if we do have Endpoints already, they're not full.
			// source:
			if (_p.sourceEndpoint && _p.sourceEndpoint.isFull()) {
				_log(_currentInstance, "could not add connection; source endpoint is full");
				return;
			}

			// target:
			if (_p.targetEndpoint && _p.targetEndpoint.isFull()) {
				_log(_currentInstance, "could not add connection; target endpoint is full");
				return;
			}
			
			// at this point, if we have source or target Endpoints, they were not new and we should mark the
			// flag to reflect that.  this is for use later with the deleteEndpointsOnDetach flag.
			if (_p.sourceEndpoint && !_p.sourceEndpoint.addedViaMouse) _p.sourceIsNew = false;
			if (_p.targetEndpoint && !_p.targetEndpoint.addedViaMouse) _p.targetIsNew = false;
			
			// if source endpoint mandates connection type and nothing specified in our params, use it.
			if (!_p.type && _p.sourceEndpoint)
				_p.type = _p.sourceEndpoint.connectionType;
			
			// copy in any connectorOverlays that were specified on the source endpoint.
			// it doesnt copy target endpoint overlays.  i'm not sure if we want it to or not.
			if (_p.sourceEndpoint && _p.sourceEndpoint.connectorOverlays) {
				_p.overlays = _p.overlays || [];
				for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
					_p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
				}
			}		
            
            // pointer events
            if (!_p["pointer-events"] && _p.sourceEndpoint && _p.sourceEndpoint.connectorPointerEvents)
                _p["pointer-events"] = _p.sourceEndpoint.connectorPointerEvents;
						
			
			// if there's a target specified (which of course there should be), and there is no
			// target endpoint specified, and 'newConnection' was not set to true, then we check to
			// see if a prior call to makeTarget has provided us with the specs for the target endpoint, and
			// we use those if so.  additionally, if the makeTarget call was specified with 'uniqueEndpoint' set
			// to true, then if that target endpoint has already been created, we re-use it.
			if (_p.target && !_p.target.endpoint && !_p.targetEndpoint && !_p.newConnection) {				
				var tid = _getId(_p.target),
					tep =_targetEndpointDefinitions[tid],
					existingUniqueEndpoint = _targetEndpoints[tid];				

				if (tep) {			
					// if target not enabled, return.
					if (!_targetsEnabled[tid]) return;

					// check for max connections??						
					var newEndpoint = existingUniqueEndpoint != null ? existingUniqueEndpoint : _currentInstance.addEndpoint(_p.target, tep);
					if (_targetEndpointsUnique[tid]) _targetEndpoints[tid] = newEndpoint;
					 _p.targetEndpoint = newEndpoint;
					 newEndpoint._makeTargetCreator = true;
					 _p.targetIsNew = true;
				}
			}

			// same thing, but for source.
			if (_p.source && !_p.source.endpoint && !_p.sourceEndpoint && !_p.newConnection) {
				var tid = _getId(_p.source),
					tep = _sourceEndpointDefinitions[tid],
					existingUniqueEndpoint = _sourceEndpoints[tid];				

				if (tep) {
					// if source not enabled, return.					
					if (!_sourcesEnabled[tid]) return;
				
					var newEndpoint = existingUniqueEndpoint != null ? existingUniqueEndpoint : _currentInstance.addEndpoint(_p.source, tep);
					if (_sourceEndpointsUnique[tid]) _sourceEndpoints[tid] = newEndpoint;
					 _p.sourceEndpoint = newEndpoint;
					 _p.sourceIsNew = true;
				}
			}
			
			return _p;
		},
		
		_newConnection = function(params) {
			var connectionFunc = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
			    endpointFunc = _currentInstance.Defaults.EndpointType || jsPlumb.Endpoint,
			    parent = jsPlumb.CurrentLibrary.getParent;
			
			if (params.container)
				params["parent"] = params.container;
			else {
				if (params.sourceEndpoint)
					params["parent"] = params.sourceEndpoint.parent;
				else if (params.source.constructor == endpointFunc)
					params["parent"] = params.source.parent;
				else params["parent"] = parent(params.source);
			}
			
			params["_jsPlumb"] = _currentInstance;
            params.newConnection = _newConnection;
            params.newEndpoint = _newEndpoint;
            params.endpointsByUUID = endpointsByUUID;             
            params.endpointsByElement = endpointsByElement;  
            params.finaliseConnection = _finaliseConnection;
			var con = new connectionFunc(params);
			con.id = "con_" + _idstamp();
			_eventFireProxy("click", "click", con);
			_eventFireProxy("dblclick", "dblclick", con);
            _eventFireProxy("contextmenu", "contextmenu", con);
			return con;
		},
		
		/**
		* adds the connection to the backing model, fires an event if necessary and then redraws
		*/
		_finaliseConnection = function(jpc, params, originalEvent) {
            params = params || {};
			// add to list of connections (by scope).
            if (!jpc.suspendedEndpoint)
			    _addToList(connectionsByScope, jpc.scope, jpc);					
			
            // always inform the anchor manager
            // except that if jpc has a suspended endpoint it's not true to say the
            // connection is new; it has just (possibly) moved. the question is whether
            // to make that call here or in the anchor manager.  i think perhaps here.
            _currentInstance.anchorManager.newConnection(jpc);
			// force a paint
			_draw(jpc.source);
			
			// fire an event
			if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {
			
				var eventArgs = {
					connection:jpc,
					source : jpc.source, target : jpc.target,
					sourceId : jpc.sourceId, targetId : jpc.targetId,
					sourceEndpoint : jpc.endpoints[0], targetEndpoint : jpc.endpoints[1]
				};
			
				_currentInstance.fire("jsPlumbConnection", eventArgs, originalEvent);
				// this is from 1.3.11 onwards. "jsPlumbConnection" always felt so unnecessary, so
				// I've added this alias in 1.3.11, with a view to removing "jsPlumbConnection" completely in a future version. be aware, of course, you should only register listeners for one or the other of these events.
				_currentInstance.fire("connection", eventArgs, originalEvent);
			}
		},
		
		_eventFireProxy = function(event, proxyEvent, obj) {
			obj.bind(event, function(originalObject, originalEvent) {
				_currentInstance.fire(proxyEvent, obj, originalEvent);
			});
		},
		
		/**
		 * for the given endpoint params, returns an appropriate parent element for the UI elements that will be added.
		 * this function is used by _newEndpoint (directly below), and also in the makeSource function in jsPlumb.
		 * 
		 *   the logic is to first look for a "container" member of params, and pass that back if found.  otherwise we
		 *   handoff to the 'getParent' function in the current library.
		 */
		_getParentFromParams = function(params) {
			if (params.container)
				return params.container;
			else {
                var tag = jsPlumb.CurrentLibrary.getTagName(params.source),
                    p = jsPlumb.CurrentLibrary.getParent(params.source);
                if (tag && tag.toLowerCase() === "td")
                    return jsPlumb.CurrentLibrary.getParent(p);
                else return p;
            }
		},
		
		/**
			factory method to prepare a new endpoint.  this should always be used instead of creating Endpoints
			manually, since this method attaches event listeners and an id.
		*/
		_newEndpoint = function(params) {
				var endpointFunc = _currentInstance.Defaults.EndpointType || jsPlumb.Endpoint;
				var _p = jsPlumb.extend({}, params);				
				_p.parent = _getParentFromParams(_p);
				_p["_jsPlumb"] = _currentInstance;
                _p.newConnection = _newConnection;
                _p.newEndpoint = _newEndpoint;                
                _p.endpointsByUUID = endpointsByUUID;             
                _p.endpointsByElement = endpointsByElement;  
                _p.finaliseConnection = _finaliseConnection;
                _p.fireDetachEvent = fireDetachEvent;
                _p.floatingConnections = floatingConnections;
                _p.getParentFromParams = _getParentFromParams;
                _p.connectionsByScope = connectionsByScope;
				var ep = new endpointFunc(_p);
				ep.id = "ep_" + _idstamp();
				_eventFireProxy("click", "endpointClick", ep);
				_eventFireProxy("dblclick", "endpointDblClick", ep);
				_eventFireProxy("contextmenu", "contextmenu", ep);
				if (!jsPlumbAdapter.headless)
					_currentInstance.dragManager.endpointAdded(params.source);
			return ep;
		},
		
		/**
		 * performs the given function operation on all the connections found
		 * for the given element id; this means we find all the endpoints for
		 * the given element, and then for each endpoint find the connectors
		 * connected to it. then we pass each connection in to the given
		 * function.
		 */
		_operation = function(elId, func, endpointFunc) {
			var endpoints = endpointsByElement[elId];
			if (endpoints && endpoints.length) {
				for ( var i = 0, ii = endpoints.length; i < ii; i++) {
					for ( var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {
						var retVal = func(endpoints[i].connections[j]);
						// if the function passed in returns true, we exit.
						// most functions return false.
						if (retVal) return;
					}
					if (endpointFunc) endpointFunc(endpoints[i]);
				}
			}
		},
		/**
		 * perform an operation on all elements.
		 */
		_operationOnAll = function(func) {
			for ( var elId in endpointsByElement) {
				_operation(elId, func);
			}
		},		
				        
		/**
		 * Sets whether or not the given element(s) should be draggable,
		 * regardless of what a particular plumb command may request.
		 * 
		 * @param element
		 *            May be a string, a element objects, or a list of
		 *            strings/elements.
		 * @param draggable
		 *            Whether or not the given element(s) should be draggable.
		 */
		_setDraggable = function(element, draggable) {
			return _elementProxy(element, function(el, id) {
				draggableStates[id] = draggable;
				if (jsPlumb.CurrentLibrary.isDragSupported(el)) {
					jsPlumb.CurrentLibrary.setDraggable(el, draggable);
				}
			});
		},
		/**
		 * private method to do the business of hiding/showing.
		 * 
		 * @param el
		 *            either Id of the element in question or a library specific
		 *            object for the element.
		 * @param state
		 *            String specifying a value for the css 'display' property
		 *            ('block' or 'none').
		 */
		_setVisible = function(el, state, alsoChangeEndpoints) {
			state = state === "block";
			var endpointFunc = null;
			if (alsoChangeEndpoints) {
				if (state) endpointFunc = function(ep) {
					ep.setVisible(true, true, true);
				};
				else endpointFunc = function(ep) {
					ep.setVisible(false, true, true);
				};
			}
			var id = _att(el, "id");
			_operation(id, function(jpc) {
				if (state && alsoChangeEndpoints) {		
					// this test is necessary because this functionality is new, and i wanted to maintain backwards compatibility.
					// this block will only set a connection to be visible if the other endpoint in the connection is also visible.
					var oidx = jpc.sourceId === id ? 1 : 0;
					if (jpc.endpoints[oidx].isVisible()) jpc.setVisible(true);
				}
				else  // the default behaviour for show, and what always happens for hide, is to just set the visibility without getting clever.
					jpc.setVisible(state);
			}, endpointFunc);
		},
		/**
		 * toggles the draggable state of the given element(s).
		 * 
		 * @param el
		 *            either an id, or an element object, or a list of
		 *            ids/element objects.
		 */
		_toggleDraggable = function(el) {
			return _elementProxy(el, function(el, elId) {
				var state = draggableStates[elId] == null ? false : draggableStates[elId];
				state = !state;
				draggableStates[elId] = state;
				jsPlumb.CurrentLibrary.setDraggable(el, state);
				return state;
			});
		},
		/**
		 * private method to do the business of toggling hiding/showing.
		 * 
		 * @param elId
		 *            Id of the element in question
		 */
		_toggleVisible = function(elId, changeEndpoints) {
			var endpointFunc = null;
			if (changeEndpoints) {
				endpointFunc = function(ep) {
					var state = ep.isVisible();
					ep.setVisible(!state);
				};
			}
			_operation(elId, function(jpc) {
				var state = jpc.isVisible();
				jpc.setVisible(!state);				
			}, endpointFunc);
			// todo this should call _elementProxy, and pass in the
			// _operation(elId, f) call as a function. cos _toggleDraggable does
			// that.
		},
		/**
		 * updates the offset and size for a given element, and stores the
		 * values. if 'offset' is not null we use that (it would have been
		 * passed in from a drag call) because it's faster; but if it is null,
		 * or if 'recalc' is true in order to force a recalculation, we get the current values.
		 */
		_updateOffset = function(params) {
			var timestamp = params.timestamp, recalc = params.recalc, offset = params.offset, elId = params.elId;
			if (_suspendDrawing && !timestamp) timestamp = _suspendedAt;
			if (!recalc) {
				if (timestamp && timestamp === offsetTimestamps[elId])
					return {o:offsets[elId], s:sizes[elId]};
			}
			if (recalc || !offset) { // if forced repaint or no offset available, we recalculate.
				// get the current size and offset, and store them
				var s = _gel(elId);
				if (s != null) {						
					sizes[elId] = _getSize(s);
					offsets[elId] = _getOffset(s, _currentInstance);
					offsetTimestamps[elId] = timestamp;
				}
			} else {
				offsets[elId] = offset;
                if (sizes[elId] == null) {
                    var s = _gel(elId);
                    if (s != null) sizes[elId] = _getSize(s);
                }
            }
			
			if(offsets[elId] && !offsets[elId].right) {
				offsets[elId].right = offsets[elId].left + sizes[elId][0];
				offsets[elId].bottom = offsets[elId].top + sizes[elId][1];	
				offsets[elId].width = sizes[elId][0];
				offsets[elId].height = sizes[elId][1];	
				offsets[elId].centerx = offsets[elId].left + (offsets[elId].width / 2);
				offsets[elId].centery = offsets[elId].top + (offsets[elId].height / 2);				
			}
			//return offsets[elId];
            return {o:offsets[elId], s:sizes[elId]};
		},

		// TODO comparison performance
		_getCachedData = function(elId) {
			var o = offsets[elId];
			if (!o) 
                return _updateOffset({elId:elId});
			else
                return {o:o, s:sizes[elId]};
		},

		/**
		 * gets an id for the given element, creating and setting one if
		 * necessary.  the id is of the form
		 *
		 *	jsPlumb_<instance index>_<index in instance>
		 *
		 * where "index in instance" is a monotonically increasing integer that starts at 0,
		 * for each instance.  this method is used not only to assign ids to elements that do not
		 * have them but also to connections and endpoints.
		 */
		_getId = function(element, uuid, doNotCreateIfNotFound) {
			var ele = _gel(element);
			var id = _att(ele, "id");
			if (!id || id == "undefined") {
				// check if fixed uuid parameter is given
				if (arguments.length == 2 && arguments[1] != undefined)
					id = uuid;
				else if (arguments.length == 1 || (arguments.length == 3 && !arguments[2]))
					id = "jsPlumb_" + _instanceIndex + "_" + _idstamp();
				
                if (!doNotCreateIfNotFound) _setAttribute(ele, "id", id);
			}
			return id;
		},		

		/**
		 * wraps one function with another, creating a placeholder for the
		 * wrapped function if it was null. this is used to wrap the various
		 * drag/drop event functions - to allow jsPlumb to be notified of
		 * important lifecycle events without imposing itself on the user's
		 * drag/drop functionality. TODO: determine whether or not we should
		 * support an error handler concept, if one of the functions fails.
		 * 
		 * @param wrappedFunction original function to wrap; may be null.
		 * @param newFunction function to wrap the original with.
		 * @param returnOnThisValue Optional. Indicates that the wrappedFunction should 
		 * not be executed if the newFunction returns a value matching 'returnOnThisValue'.
		 * note that this is a simple comparison and only works for primitives right now.
		 */
        // TODO move to util.
		_wrap = function(wrappedFunction, newFunction, returnOnThisValue) {
			wrappedFunction = wrappedFunction || function() { };
			newFunction = newFunction || function() { };
			return function() {
				var r = null;
				try {
					r = newFunction.apply(this, arguments);
				} catch (e) {
					_log(_currentInstance, "jsPlumb function failed : " + e);
				}
				if (returnOnThisValue == null || (r !== returnOnThisValue)) {
					try {
						wrappedFunction.apply(this, arguments);
					} catch (e) {
						_log(_currentInstance, "wrapped function failed : " + e);
					}
				}
				return r;
			};
		};	

        this.isConnectionBeingDragged = function() { return _connectionBeingDragged != null; };
        this.setConnectionBeingDragged = function(c) {_connectionBeingDragged = c; };
            
		this.connectorClass = "_jsPlumb_connector";            		
		this.hoverClass = "_jsPlumb_hover";            		
		this.endpointClass = "_jsPlumb_endpoint";		
		this.endpointConnectedClass = "_jsPlumb_endpoint_connected";		
		this.endpointFullClass = "_jsPlumb_endpoint_full";		
		this.endpointDropAllowedClass = "_jsPlumb_endpoint_drop_allowed";		
		this.endpointDropForbiddenClass = "_jsPlumb_endpoint_drop_forbidden";		
		this.overlayClass = "_jsPlumb_overlay";				
		this.draggingClass = "_jsPlumb_dragging";		
		this.elementDraggingClass = "_jsPlumb_element_dragging";			
		this.sourceElementDraggingClass = "_jsPlumb_source_element_dragging";
		this.targetElementDraggingClass = "_jsPlumb_target_element_dragging";
		this.endpointAnchorClassPrefix = "_jsPlumb_endpoint_anchor";	

		this.Anchors = {};		
		this.Connectors = {  "canvas":{}, "svg":{}, "vml":{} };				
		this.Endpoints = { "canvas":{}, "svg":{}, "vml":{} };
		this.Overlays = { "canvas":{}, "svg":{}, "vml":{}};		
		this.ConnectorRenderers = {};
				

// --------------------------- jsPLumbInstance public API ---------------------------------------------------------
		
		this.addClass = function(el, clazz) { return jsPlumb.CurrentLibrary.addClass(el, clazz); };		
		this.removeClass = function(el, clazz) { return jsPlumb.CurrentLibrary.removeClass(el, clazz); };		
		this.hasClass = function(el, clazz) { return jsPlumb.CurrentLibrary.hasClass(el, clazz); };
				
		this.addEndpoint = function(el, params, referenceParams) {
			referenceParams = referenceParams || {};
			var p = jsPlumb.extend({}, referenceParams);
			jsPlumb.extend(p, params);
			p.endpoint = p.endpoint || _currentInstance.Defaults.Endpoint || jsPlumb.Defaults.Endpoint;
			p.paintStyle = p.paintStyle || _currentInstance.Defaults.EndpointStyle || jsPlumb.Defaults.EndpointStyle;
            // YUI wrapper
			el = _convertYUICollection(el);							

			var results = [], 
				inputs = (_isArray(el) || (el.length != null && !_isString(el))) ? el : [ el ];
						
			for (var i = 0, j = inputs.length; i < j; i++) {
				var _el = _gel(inputs[i]), id = _getId(_el);
				p.source = _el;
                _updateOffset({ elId : id, timestamp:_suspendedAt });
				var e = _newEndpoint(p);
				if (p.parentAnchor) e.parentAnchor = p.parentAnchor;
				_addToList(endpointsByElement, id, e);
				var myOffset = offsets[id], myWH = sizes[id];
				var anchorLoc = e.anchor.compute( { xy : [ myOffset.left, myOffset.top ], wh : myWH, element : e, timestamp:_suspendedAt });
				var endpointPaintParams = { anchorLoc : anchorLoc, timestamp:_suspendedAt };
				
				if (_suspendDrawing) endpointPaintParams.recalc = false;
				if (!_suspendDrawing) e.paint(endpointPaintParams);
				
				results.push(e);
				//if (!jsPlumbAdapter.headless)
					//_currentInstance.dragManager.endpointAdded(_el);
			}
			
			return results.length == 1 ? results[0] : results;
		};
		
		
		this.addEndpoints = function(el, endpoints, referenceParams) {
			var results = [];
			for ( var i = 0, j = endpoints.length; i < j; i++) {
				var e = _currentInstance.addEndpoint(el, endpoints[i], referenceParams);
				if (_isArray(e))
					Array.prototype.push.apply(results, e);
				else results.push(e);
			}
			return results;
		};

		
		this.animate = function(el, properties, options) {
			var ele = _gel(el), id = _att(el, "id");
			options = options || {};
			var stepFunction = jsPlumb.CurrentLibrary.dragEvents['step'];
			var completeFunction = jsPlumb.CurrentLibrary.dragEvents['complete'];
			options[stepFunction] = _wrap(options[stepFunction], function() {
				_currentInstance.repaint(id);
			});

			// onComplete repaints, just to make sure everything looks good at the end of the animation.
			options[completeFunction] = _wrap(options[completeFunction],
					function() {
						_currentInstance.repaint(id);
					});

			jsPlumb.CurrentLibrary.animate(ele, properties, options);
		};		
		
		/**
		* checks for a listener for the given condition, executing it if found, passing in the given value.
		* condition listeners would have been attached using "bind" (which is, you could argue, now overloaded, since
		* firing click events etc is a bit different to what this does).  i thought about adding a "bindCondition"
		* or something, but decided against it, for the sake of simplicity. jsPlumb will never fire one of these
		* condition events anyway.
		*/
		this.checkCondition = function(conditionName, value) {
			var l = _currentInstance.getListener(conditionName),
				r = true;
				
			if (l && l.length > 0) {
				try {
					for (var i = 0, j = l.length; i < j; i++) {
						r = r && l[i](value); 
					}
				}
				catch (e) { 
					_log(_currentInstance, "cannot check condition [" + conditionName + "]" + e); 
				}
			}
			return r;
		};
		
		/**
		 * checks a condition asynchronously: fires the event handler and passes the handler
		 * a 'proceed' function and a 'stop' function. The handler MUST execute one or other
		 * of these once it has made up its mind.
		 *
		 * Note that although this reads the listener list for the given condition, it
		 * does not loop through and hit each listener, because that, with asynchronous
		 * callbacks, would be messy. so it uses only the first listener registered.
		 */ 
		this.checkASyncCondition = function(conditionName, value, proceed, stop) {
			var l = _currentInstance.getListener(conditionName);
				
			if (l && l.length > 0) {
				try {
					l[0](value, proceed, stop); 					
				}
				catch (e) { 
					_log(_currentInstance, "cannot asynchronously check condition [" + conditionName + "]" + e); 
				}
			}	
		};

		
		this.connect = function(params, referenceParams) {
			// prepare a final set of parameters to create connection with
			var _p = _prepareConnectionParams(params, referenceParams), jpc;
			// TODO probably a nicer return value if the connection was not made.  _prepareConnectionParams
			// will return null (and log something) if either endpoint was full.  what would be nicer is to 
			// create a dedicated 'error' object.
			if (_p) {
				// a connect call will delete its created endpoints on detach, unless otherwise specified.
				// this is because the endpoints belong to this connection only, and are no use to
				// anyone else, so they hang around like a bad smell.
				if (_p.deleteEndpointsOnDetach == null)
					_p.deleteEndpointsOnDetach = true;

				// create the connection.  it is not yet registered 
				jpc = _newConnection(_p);
				// now add it the model, fire an event, and redraw
				_finaliseConnection(jpc, _p);										
			}
			return jpc;
		};
		
		// delete the given endpoint: either an Endpoint here, or its UUID.
		this.deleteEndpoint = function(object, doNotRepaintAfterwards) {
			_currentInstance.doWhileSuspended(function() {
				var endpoint = (typeof object == "string") ? endpointsByUUID[object] : object;			
				if (endpoint) {					
					var uuid = endpoint.getUuid();
					if (uuid) endpointsByUUID[uuid] = null;				
					endpoint.detachAll().cleanup();
					if (endpoint.endpoint.cleanup) endpoint.endpoint.cleanup();
					jsPlumbUtil.removeElements(endpoint.endpoint.getDisplayElements());
					_currentInstance.anchorManager.deleteEndpoint(endpoint);
					for (var e in endpointsByElement) {
						var endpoints = endpointsByElement[e];
						if (endpoints) {
							var newEndpoints = [];
							for (var i = 0, j = endpoints.length; i < j; i++)
								if (endpoints[i] != endpoint) newEndpoints.push(endpoints[i]);
							
							endpointsByElement[e] = newEndpoints;
						}
						if(endpointsByElement[e].length <1){
							delete endpointsByElement[e];
						}
					}				
					if (!jsPlumbAdapter.headless)
						_currentInstance.dragManager.endpointDeleted(endpoint);								
				}
				return _currentInstance;									
			}, doNotRepaintAfterwards);
		};
		
		
		// delete every endpoint and their connections. distinct from reset because we dont clear listeners here.
		this.deleteEveryEndpoint = function() {
			_currentInstance.doWhileSuspended(function() {
				for ( var id in endpointsByElement) {
					var endpoints = endpointsByElement[id];
					if (endpoints && endpoints.length) {
						for ( var i = 0, j = endpoints.length; i < j; i++) {
							_currentInstance.deleteEndpoint(endpoints[i], true);
						}
					}
				}			
				endpointsByElement = {};			
				endpointsByUUID = {};
				_currentInstance.anchorManager.reset();
				_currentInstance.dragManager.reset();							
			});
			return _currentInstance;
		};

		var fireDetachEvent = function(jpc, doFireEvent, originalEvent) {
            // may have been given a connection, or in special cases, an object
            var connType =  _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                argIsConnection = jpc.constructor == connType,
                params = argIsConnection ? {
                    connection:jpc,
				    source : jpc.source, target : jpc.target,
				    sourceId : jpc.sourceId, targetId : jpc.targetId,
				    sourceEndpoint : jpc.endpoints[0], targetEndpoint : jpc.endpoints[1]
                } : jpc;

			if (doFireEvent) {
				_currentInstance.fire("jsPlumbConnectionDetached", params, originalEvent);
				// introduced in 1.3.11..an alias because the original event name is unwieldy.  in future versions this will be the only event and the other will no longer be fired.
				_currentInstance.fire("connectionDetached", params, originalEvent);
			}
            _currentInstance.anchorManager.connectionDetached(params);
		};	

		// detach a connection
		this.detach = function() {

            if (arguments.length == 0) return;
            var connType =  _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                firstArgIsConnection = arguments[0].constructor == connType,
                params = arguments.length == 2 ? firstArgIsConnection ? (arguments[1] || {}) : arguments[0] : arguments[0],
                fireEvent = (params.fireEvent !== false),
                forceDetach = params.forceDetach,
                conn = firstArgIsConnection ? arguments[0] : params.connection;
                                                    
				if (conn) {             
                    if (forceDetach || jsPlumbUtil.functionChain(true, false, [
                            [ conn.endpoints[0], "isDetachAllowed", [ conn ] ],    
                            [ conn.endpoints[1], "isDetachAllowed", [ conn ] ],
                            [ conn, "isDetachAllowed", [ conn ] ],
                            [ _currentInstance, "checkCondition", [ "beforeDetach", conn ] ] ])) {
                        
                        conn.endpoints[0].detach(conn, false, true, fireEvent); 
                    }
                }
                else {
					var _p = jsPlumb.extend( {}, params); // a backwards compatibility hack: source should be thought of as 'params' in this case.
					// test for endpoint uuids to detach
					if (_p.uuids) {
						_getEndpoint(_p.uuids[0]).detachFrom(_getEndpoint(_p.uuids[1]), fireEvent);
					} else if (_p.sourceEndpoint && _p.targetEndpoint) {
						_p.sourceEndpoint.detachFrom(_p.targetEndpoint);
					} else {
						var sourceId = _getId(_p.source),
						    targetId = _getId(_p.target);
						_operation(sourceId, function(jpc) {
						    if ((jpc.sourceId == sourceId && jpc.targetId == targetId) || (jpc.targetId == sourceId && jpc.sourceId == targetId)) {
							    if (_currentInstance.checkCondition("beforeDetach", jpc)) {
                                    jpc.endpoints[0].detach(jpc, false, true, fireEvent);
								}
							}
						});
					}
				}
		};

		// detach all connections from some element.
		this.detachAllConnections = function(el, params) {
            params = params || {};
            el = _gel(el);
			var id = _att(el, "id"),
                endpoints = endpointsByElement[id];
			if (endpoints && endpoints.length) {
				for ( var i = 0, j = endpoints.length; i < j; i++) {
					endpoints[i].detachAll(params.fireEvent);
				}
			}
			return _currentInstance;
		};

		// detach every connection but leave endpoints in place (unless a connection is set to auto delete them)
		this.detachEveryConnection = function(params) {
            params = params || {};
			for ( var id in endpointsByElement) {
				var endpoints = endpointsByElement[id];
				if (endpoints && endpoints.length) {
					for ( var i = 0, j = endpoints.length; i < j; i++) {
						endpoints[i].detachAll(params.fireEvent);
					}
				}
			}
			connectionsByScope = {};
			return _currentInstance;
		};


		 
		this.draggable = function(el, options) {
			if (typeof el == 'object' && el.length) {
				for ( var i = 0, j = el.length; i < j; i++) {
					var ele = _gel(el[i]);
					if (ele) _initDraggableIfNecessary(ele, true, options);
				}
			} 
			else if (el._nodes) { 	// TODO this is YUI specific; really the logic should be forced
				// into the library adapters (for jquery and mootools aswell)
				for ( var i = 0, j = el._nodes.length; i < j; i++) {
					var ele = _gel(el._nodes[i]);
					if (ele) _initDraggableIfNecessary(ele, true, options);
				}
			}
			else {
				var ele = _gel(el);
				if (ele) _initDraggableIfNecessary(ele, true, options);
			}
			return _currentInstance;
		};


		// just a library-agnostic wrapper.
		this.extend = function(o1, o2) {
			return jsPlumb.CurrentLibrary.extend(o1, o2);
		};
		
		// gets the default endpoint type. used when subclassing. see wiki.
		this.getDefaultEndpointType = function() {
			return jsPlumb.Endpoint;
		};
		
		// gets the default connection type. used when subclassing.  see wiki.
		this.getDefaultConnectionType = function() {
			return jsPlumb.Connection;
		};

		// helpers for select/selectEndpoints
		var _setOperation = function(list, func, args, selector) {
				for (var i = 0, j = list.length; i < j; i++) {
					list[i][func].apply(list[i], args);
				}	
				return selector(list);
			},
			_getOperation = function(list, func, args) {
				var out = [];
				for (var i = 0, j = list.length; i < j; i++) {					
					out.push([ list[i][func].apply(list[i], args), list[i] ]);
				}	
				return out;
			},
			setter = function(list, func, selector) {
				return function() {
					return _setOperation(list, func, arguments, selector);
				};
			},
			getter = function(list, func) {
				return function() {
					return _getOperation(list, func, arguments);
				};	
			},
			prepareList = function(input, doNotGetIds) {
				var r = [];
				if (input) {
					if (typeof input == 'string') {
						if (input === "*") return input;
						r.push(input);
					}
					else {
						if (doNotGetIds) r = input;
						else { 
							for (var i = 0, j = input.length; i < j; i++) 
								r.push(_getId(_gel(input[i])));
						}	
					}
				}
				return r;
			},
			filterList = function(list, value, missingIsFalse) {
				if (list === "*") return true;
				return list.length > 0 ? _indexOf(list, value) != -1 : !missingIsFalse;
			};

		// get some connections, specifying source/target/scope
		this.getConnections = function(options, flat) {
			if (!options) {
				options = {};
			} else if (options.constructor == String) {
				options = { "scope": options };
			}
			var
			scope = options.scope || _currentInstance.getDefaultScope(),
			scopes = prepareList(scope, true),
			sources = prepareList(options.source),
			targets = prepareList(options.target),			
			results = (!flat && scopes.length > 1) ? {} : [],
			_addOne = function(scope, obj) {
				if (!flat && scopes.length > 1) {
					var ss = results[scope];
					if (ss == null) {
						ss = []; results[scope] = ss;
					}
					ss.push(obj);
				} else results.push(obj);
			};
			for ( var i in connectionsByScope) {
				if (filterList(scopes, i)) {
					for ( var j = 0, jj = connectionsByScope[i].length; j < jj; j++) {
						var c = connectionsByScope[i][j];
						if (filterList(sources, c.sourceId) && filterList(targets, c.targetId))
							_addOne(i, c);
					}
				}
			}
			return results;
		};
		
		var _curryEach = function(list, executor) {
				return function(f) {
					for (var i = 0, ii = list.length; i < ii; i++) {
						f(list[i]);
					}
					return executor(list);
				};		
			},
			_curryGet = function(list) {
				return function(idx) {
					return list[idx];
				};
			};
			
		var _makeCommonSelectHandler = function(list, executor) {
            var out = {
                    length:list.length,
				    each:_curryEach(list, executor),
				    get:_curryGet(list)
                },
                setters = ["setHover", "removeAllOverlays", "setLabel", "addClass", "addOverlay", "removeOverlay", 
                           "removeOverlays", "showOverlay", "hideOverlay", "showOverlays", "hideOverlays", "setPaintStyle",
                           "setHoverPaintStyle", "setSuspendEvents", "setParameter", "setParameters", "setVisible", 
                           "repaint", "addType", "toggleType", "removeType", "removeClass", "setType", "bind", "unbind" ],
                
                getters = ["getLabel", "getOverlay", "isHover", "getParameter", "getParameters", "getPaintStyle",
                           "getHoverPaintStyle", "isVisible", "hasType", "getType", "isSuspendEvents" ];
            
            for (var i = 0, ii = setters.length; i < ii; i++)
                out[setters[i]] = setter(list, setters[i], executor);
            
            for (var i = 0, ii = getters.length; i < ii; i++)
                out[getters[i]] = getter(list, getters[i]);       
            
            return out;
		};
		
		var	_makeConnectionSelectHandler = function(list) {
			var common = _makeCommonSelectHandler(list, _makeConnectionSelectHandler);
			return jsPlumb.CurrentLibrary.extend(common, {
				// setters									
				setDetachable:setter(list, "setDetachable", _makeConnectionSelectHandler),
				setReattach:setter(list, "setReattach", _makeConnectionSelectHandler),
				setConnector:setter(list, "setConnector", _makeConnectionSelectHandler),			
				detach:function() {
					for (var i = 0, ii = list.length; i < ii; i++)
						_currentInstance.detach(list[i]);
				},				
				// getters
				isDetachable:getter(list, "isDetachable"),
				isReattach:getter(list, "isReattach")
			});
		};
		
		var	_makeEndpointSelectHandler = function(list) {
			var common = _makeCommonSelectHandler(list, _makeEndpointSelectHandler);
			return jsPlumb.CurrentLibrary.extend(common, {
				setEnabled:setter(list, "setEnabled", _makeEndpointSelectHandler),				
				setAnchor:setter(list, "setAnchor", _makeEndpointSelectHandler),
				isEnabled:getter(list, "isEnabled"),
				detachAll:function() {
					for (var i = 0, ii = list.length; i < ii; i++)
						list[i].detachAll();
				},
				"remove":function() {
					for (var i = 0, ii = list.length; i < ii; i++)
						_currentInstance.deleteEndpoint(list[i]);
				}
			});
		};
			

		this.select = function(params) {
			params = params || {};
			params.scope = params.scope || "*";
			var c = params.connections || _currentInstance.getConnections(params, true);
			return _makeConnectionSelectHandler(c);							
		};
		

		this.selectEndpoints = function(params) {
			params = params || {};
			params.scope = params.scope || "*";
			var noElementFilters = !params.element && !params.source && !params.target,			
				elements = noElementFilters ? "*" : prepareList(params.element),
				sources = noElementFilters ? "*" : prepareList(params.source),
				targets = noElementFilters ? "*" : prepareList(params.target),
				scopes = prepareList(params.scope, true);
			
			var ep = [];
			
			for (var el in endpointsByElement) {
				var either = filterList(elements, el, true),
					source = filterList(sources, el, true),
					sourceMatchExact = sources != "*",
					target = filterList(targets, el, true),
					targetMatchExact = targets != "*"; 
					
				// if they requested 'either' then just match scope. otherwise if they requested 'source' (not as a wildcard) then we have to match only endpoints that have isSource set to to true, and the same thing with isTarget.  
				if ( either || source  || target ) {
					inner:
					for (var i = 0, ii = endpointsByElement[el].length; i < ii; i++) {
						var _ep = endpointsByElement[el][i];
						if (filterList(scopes, _ep.scope, true)) {
						
							var noMatchSource = (sourceMatchExact && sources.length > 0 && !_ep.isSource),
								noMatchTarget = (targetMatchExact && targets.length > 0 && !_ep.isTarget);
						
							if (noMatchSource || noMatchTarget)								  
								  continue inner; 
							 							
							ep.push(_ep);		
						}
					}
				}					
			}
			
			return _makeEndpointSelectHandler(ep);
		};

		// get all connections managed by the instance of jsplumb.
		this.getAllConnections = function() {
			return connectionsByScope;
		};


		this.getDefaultScope = function() {
			return DEFAULT_SCOPE;
		};

		// get an endpoint by uuid.
		this.getEndpoint = _getEndpoint;
				
		// get endpoints for some element.
		this.getEndpoints = function(el) {
			return endpointsByElement[_getId(el)];
		};		

		/*
		 * Gets an element's id, creating one if necessary. really only exposed
		 * for the lib-specific functionality to access; would be better to pass
		 * the current instance into the lib-specific code (even though this is
		 * a static call. i just don't want to expose it to the public API).
		 */
		this.getId = _getId;
		this.getOffset = function(id) { 
			var o = offsets[id]; 
			return _updateOffset({elId:id});
		};
		
		// gets a library-agnostic selector.  not necessary for use outside of jsplumb, since
		// you already know what library you're using it with.	
		this.getSelector = function() {
			return jsPlumb.CurrentLibrary.getSelector.apply(null, arguments);
		};
		
		// get the size of the element with the given id, perhaps from cache.
		this.getSize = function(id) { 
			var s = sizes[id]; 
			if (!s) _updateOffset({elId:id});
			return sizes[id];
		};		
		
		this.appendElement = _appendElement;
		
		var _hoverSuspended = false;
		this.isHoverSuspended = function() { return _hoverSuspended; };
		this.setHoverSuspended = function(s) { _hoverSuspended = s; };

		var _isAvailable = function(m) {
			return function() {
				return jsPlumbAdapter.isRenderModeAvailable(m);
			};
		}
		this.isCanvasAvailable = _isAvailable("canvas");
		this.isSVGAvailable = _isAvailable("svg");
		this.isVMLAvailable = _isAvailable("vml");

		// set an element's connections to be hidden
		this.hide = function(el, changeEndpoints) {
			_setVisible(el, "none", changeEndpoints);
			return _currentInstance;
		};
		
		// exposed for other objects to use to get a unique id.
		this.idstamp = _idstamp;
		
		/**
		 * callback from the current library to tell us to prepare ourselves (attach
		 * mouse listeners etc; can't do that until the library has provided a bind method)		 
		 */
		this.init = function() {
			if (!initialized) {                
                _currentInstance.anchorManager = new jsPlumb.AnchorManager({jsPlumbInstance:_currentInstance});                
				_currentInstance.setRenderMode(_currentInstance.Defaults.RenderMode);  // calling the method forces the capability logic to be run.										
				initialized = true;
				_currentInstance.fire("ready", _currentInstance);
			}
		};
		
		this.log = log;
		this.jsPlumbUIComponent = jsPlumbUIComponent;		

		/*
		 * Creates an anchor with the given params.
		 * 
		 * 
		 * Returns: The newly created Anchor.
		 * Throws: an error if a named anchor was not found.
		 */
		this.makeAnchor = function() {
			var _a = function(t, p) {
				if (jsPlumb.Anchors[t]) return new jsPlumb.Anchors[t](p);
				if (!_currentInstance.Defaults.DoNotThrowErrors)
					throw { msg:"jsPlumb: unknown anchor type '" + t + "'" };
			};
			if (arguments.length == 0) return null;
			var specimen = arguments[0], elementId = arguments[1], jsPlumbInstance = arguments[2], newAnchor = null;			
			// if it appears to be an anchor already...
			if (specimen.compute && specimen.getOrientation) return specimen;  //TODO hazy here about whether it should be added or is already added somehow.
			// is it the name of an anchor type?
			else if (typeof specimen == "string") {
				//newAnchor = jsPlumb.Anchors[arguments[0]]({elementId:elementId, jsPlumbInstance:_currentInstance});
				newAnchor = _a(arguments[0], {elementId:elementId, jsPlumbInstance:_currentInstance});
			}
			// is it an array? it will be one of:
			// 		an array of [name, params] - this defines a single anchor
			//		an array of arrays - this defines some dynamic anchors
			//		an array of numbers - this defines a single anchor.				
			else if (_isArray(specimen)) {
				if (_isArray(specimen[0]) || _isString(specimen[0])) {
					if (specimen.length == 2 && _isString(specimen[0]) && _isObject(specimen[1])) {
						var pp = jsPlumb.extend({elementId:elementId, jsPlumbInstance:_currentInstance}, specimen[1]);
						//newAnchor = new jsPlumb.Anchors[specimen[0]](pp);
						newAnchor = _a(specimen[0], pp);
					}
					else
						newAnchor = new jsPlumb.DynamicAnchor({anchors:specimen, selector:null, elementId:elementId, jsPlumbInstance:jsPlumbInstance});
				}
				else {
					var anchorParams = {
						x:specimen[0], y:specimen[1],
						orientation : (specimen.length >= 4) ? [ specimen[2], specimen[3] ] : [0,0],
						offsets : (specimen.length >= 6) ? [ specimen[4], specimen[5] ] : [ 0, 0 ],
						elementId:elementId,
                        jsPlumbInstance:jsPlumbInstance,
                        cssClass:specimen.length == 7 ? specimen[6] : null
					};						
					newAnchor = new jsPlumb.Anchor(anchorParams);
					newAnchor.clone = function() { return new jsPlumb.Anchor(anchorParams); };						 					
				}
			}
			
			if (!newAnchor.id) newAnchor.id = "anchor_" + _idstamp();
			return newAnchor;
		};

		/**
		 * makes a list of anchors from the given list of types or coords, eg
		 * ["TopCenter", "RightMiddle", "BottomCenter", [0, 1, -1, -1] ]
		 */
		this.makeAnchors = function(types, elementId, jsPlumbInstance) {
			var r = [];
			for ( var i = 0, ii = types.length; i < ii; i++) {
				if (typeof types[i] == "string")
					r.push(jsPlumb.Anchors[types[i]]({elementId:elementId, jsPlumbInstance:jsPlumbInstance}));
				else if (_isArray(types[i]))
					r.push(_currentInstance.makeAnchor(types[i], elementId, jsPlumbInstance));
			}
			return r;
		};

		/**
		 * Makes a dynamic anchor from the given list of anchors (which may be in shorthand notation as strings or dimension arrays, or Anchor
		 * objects themselves) and the given, optional, anchorSelector function (jsPlumb uses a default if this is not provided; most people will
		 * not need to provide this - i think). 
		 */
		this.makeDynamicAnchor = function(anchors, anchorSelector) {
			return new jsPlumb.DynamicAnchor({anchors:anchors, selector:anchorSelector, elementId:null, jsPlumbInstance:_currentInstance});
		};
		
		
		var _targetEndpointDefinitions = {},
			_targetEndpoints = {},
			_targetEndpointsUnique = {},
			_targetMaxConnections = {},
			_setEndpointPaintStylesAndAnchor = function(ep, epIndex) {
				ep.paintStyle = ep.paintStyle ||
				 				_currentInstance.Defaults.EndpointStyles[epIndex] ||
	                            _currentInstance.Defaults.EndpointStyle ||
	                            jsPlumb.Defaults.EndpointStyles[epIndex] ||
	                            jsPlumb.Defaults.EndpointStyle;
				ep.hoverPaintStyle = ep.hoverPaintStyle ||
	                           _currentInstance.Defaults.EndpointHoverStyles[epIndex] ||
	                           _currentInstance.Defaults.EndpointHoverStyle ||
	                           jsPlumb.Defaults.EndpointHoverStyles[epIndex] ||
	                           jsPlumb.Defaults.EndpointHoverStyle;                            

				ep.anchor = ep.anchor ||
	                      	_currentInstance.Defaults.Anchors[epIndex] ||
	                      	_currentInstance.Defaults.Anchor ||
	                      	jsPlumb.Defaults.Anchors[epIndex] ||
	                      	jsPlumb.Defaults.Anchor;                           
					
				ep.endpoint = ep.endpoint ||
							  _currentInstance.Defaults.Endpoints[epIndex] ||
							  _currentInstance.Defaults.Endpoint ||
							  jsPlumb.Defaults.Endpoints[epIndex] ||
							  jsPlumb.Defaults.Endpoint;
			};

		// see API docs
		this.makeTarget = function(el, params, referenceParams) {						
			
			var p = jsPlumb.extend({_jsPlumb:_currentInstance}, referenceParams);
			jsPlumb.extend(p, params);
			_setEndpointPaintStylesAndAnchor(p, 1);                                                    
			var jpcl = jsPlumb.CurrentLibrary,
			    targetScope = p.scope || _currentInstance.Defaults.Scope,
			    deleteEndpointsOnDetach = !(p.deleteEndpointsOnDetach === false),
			    maxConnections = p.maxConnections || -1,
				onMaxConnections = p.onMaxConnections;
			_doOne = function(_el) {
				
				// get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
				// and use the endpoint definition if found.
				var elid = _getId(_el);
				_targetEndpointDefinitions[elid] = p;
				_targetEndpointsUnique[elid] = p.uniqueEndpoint,
				_targetMaxConnections[elid] = maxConnections,
				_targetsEnabled[elid] = true,
				proxyComponent = new jsPlumbUIComponent(p);								
				
				var dropOptions = jsPlumb.extend({}, p.dropOptions || {}),
				_drop = function() {

					var originalEvent = jsPlumb.CurrentLibrary.getDropEvent(arguments),
						targetCount = _currentInstance.select({target:elid}).length;																							

					_currentInstance.currentlyDragging = false;
					var draggable = _gel(jpcl.getDragObject(arguments)),
						id = _att(draggable, "dragId"),				
						// restore the original scope if necessary (issue 57)
						scope = _att(draggable, "originalScope"),
						jpc = floatingConnections[id],
						source = jpc.endpoints[0],
						_endpoint = p.endpoint ? jsPlumb.extend({}, p.endpoint) : {};
						
					if (!_targetsEnabled[elid] || _targetMaxConnections[elid] > 0 && targetCount >= _targetMaxConnections[elid]){
						if (onMaxConnections) {
							onMaxConnections({
								element:_el,
								connection:jpc
							}, originalEvent);
						}
						return false;
					}

					// unlock the source anchor to allow it to refresh its position if necessary
					source.anchor.locked = false;					
										
					if (scope) jpcl.setDragScope(draggable, scope);				
					
					// check if drop is allowed here.					
					//var _continue = jpc.isDropAllowed(jpc.sourceId, _getId(_el), jpc.scope);		
					var _continue = proxyComponent.isDropAllowed(jpc.sourceId, _getId(_el), jpc.scope, jpc, null);		
					
					// regardless of whether the connection is ok, reconfigure the existing connection to 
					// point at the current info. we need this to be correct for the detach event that will follow.
					// clear the source endpoint from the list to detach. we will detach this connection at this
					// point, but we want to keep the source endpoint.  the target is a floating endpoint and should
					// be removed.  TODO need to figure out whether this code can result in endpoints kicking around
					// when they shouldnt be.  like is this a full detach of a connection?  can it be?
					if (jpc.endpointsToDeleteOnDetach) {
						if (source === jpc.endpointsToDeleteOnDetach[0])
							jpc.endpointsToDeleteOnDetach[0] = null;
						else if (source === jpc.endpointsToDeleteOnDetach[1])
							jpc.endpointsToDeleteOnDetach[1] = null;
					}
					// reinstate any suspended endpoint; this just puts the connection back into
					// a state in which it will report sensible values if someone asks it about
					// its target.  we're going to throw this connection away shortly so it doesnt matter
					// if we manipulate it a bit.
					if (jpc.suspendedEndpoint) {
						jpc.targetId = jpc.suspendedEndpoint.elementId;
						jpc.target = jpcl.getElementObject(jpc.suspendedEndpoint.elementId);
						jpc.endpoints[1] = jpc.suspendedEndpoint;
					}																										
					
					if (_continue) {
					
						// detach this connection from the source.						
						source.detach(jpc, false, true, false);
					
						// make a new Endpoint for the target												
						var newEndpoint = _targetEndpoints[elid] || _currentInstance.addEndpoint(_el, p);
						if (p.uniqueEndpoint) _targetEndpoints[elid] = newEndpoint;  // may of course just store what it just pulled out. that's ok.
						newEndpoint._makeTargetCreator = true;
																
						// if the anchor has a 'positionFinder' set, then delegate to that function to find
						// out where to locate the anchor.
						if (newEndpoint.anchor.positionFinder != null) {
							var dropPosition = jpcl.getUIPosition(arguments, _currentInstance.getZoom()),
							elPosition = _getOffset(_el, _currentInstance),
							elSize = _getSize(_el),
							ap = newEndpoint.anchor.positionFinder(dropPosition, elPosition, elSize, newEndpoint.anchor.constructorParams);
							newEndpoint.anchor.x = ap[0];
							newEndpoint.anchor.y = ap[1];
							// now figure an orientation for it..kind of hard to know what to do actually. probably the best thing i can do is to
							// support specifying an orientation in the anchor's spec. if one is not supplied then i will make the orientation 
							// be what will cause the most natural link to the source: it will be pointing at the source, but it needs to be
							// specified in one axis only, and so how to make that choice? i think i will use whichever axis is the one in which
							// the target is furthest away from the source.
						}
						var c = _currentInstance.connect({
							source:source,
							target:newEndpoint,
							scope:scope,
							previousConnection:jpc,
							container:jpc.parent,
							deleteEndpointsOnDetach:deleteEndpointsOnDetach,
                            endpointsToDeleteOnDetach : deleteEndpointsOnDetach ? [ source, newEndpoint ] : null,
							// 'endpointWillMoveAfterConnection' is set by the makeSource function, and it indicates that the
							// given endpoint will actually transfer from the element it is currently attached to to some other
							// element after a connection has been established.  in that case, we do not want to fire the
							// connection event, since it will have the wrong data in it; makeSource will do it for us.
							// this is controlled by the 'parent' parameter on a makeSource call.
							doNotFireConnectionEvent:source.endpointWillMoveAfterConnection
						});

						// delete the original target endpoint.  but only want to do this if the endpoint was created
						// automatically and has no other connections.
						if (jpc.endpoints[1]._makeTargetCreator && jpc.endpoints[1].connections.length < 2)
							_currentInstance.deleteEndpoint(jpc.endpoints[1]);

						c.repaint();
					}				
					// if not allowed to drop...
					else {
						// TODO this code is identical (pretty much) to what happens when a connection
						// dragged from a normal endpoint is in this situation. refactor.
						// is this an existing connection, and will we reattach?
						if (jpc.suspendedEndpoint) {
							//if (source.isReattach) {
							if (jpc.isReattach()) {
								jpc.setHover(false);
								jpc.floatingAnchorIndex = null;
								jpc.suspendedEndpoint.addConnection(jpc);
								_currentInstance.repaint(source.elementId);
							}
							else
								source.detach(jpc, false, true, true, originalEvent);  // otherwise, detach the connection and tell everyone about it.
						}
						
					}														
				};
				
				var dropEvent = jpcl.dragEvents['drop'];
				dropOptions["scope"] = dropOptions["scope"] || targetScope;
				dropOptions[dropEvent] = _wrap(dropOptions[dropEvent], _drop);
				
				jpcl.initDroppable(_el, dropOptions, true);
			};
			
			el = _convertYUICollection(el);			
			
			var inputs = el.length && el.constructor != String ? el : [ el ];
						
			for (var i = 0, ii = inputs.length; i < ii; i++) {			
				_doOne(_gel(inputs[i]));
			}

			return _currentInstance;
		};

		// see api docs
		this.unmakeTarget = function(el, doNotClearArrays) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			var elid = _getId(el);			

			// TODO this is not an exhaustive unmake of a target, since it does not remove the droppable stuff from
			// the element.  the effect will be to prevent it form behaving as a target, but it's not completely purged.
			if (!doNotClearArrays) {
				delete _targetEndpointDefinitions[elid];
				delete _targetEndpointsUnique[elid];
				delete _targetMaxConnections[elid];
				delete _targetsEnabled[elid];                
			}

			return _currentInstance;
		};
		
		// see api docs
		this.makeTargets = function(els, params, referenceParams) {
			for ( var i = 0, ii = els.length; i < ii; i++) {
				_currentInstance.makeTarget(els[i], params, referenceParams);				
			}
		};
		
		
		var _sourceEndpointDefinitions = {},
			_sourceEndpoints = {},
			_sourceEndpointsUnique = {},
			_sourcesEnabled = {},
			_sourceTriggers = {},
			_sourceMaxConnections = {},
			_targetsEnabled = {},
			selectorFilter = function(evt, _el, selector) {	            
                var t = evt.target || evt.srcElement, ok = false, 
                    sel = _currentInstance.getSelector(_el, selector);
                for (var j = 0; j < sel.length; j++) {
                    if (sel[j] == t) {
                        ok = true;
                        break;
                    }
                }
                return ok;	            
	        };

	    // see api docs
		this.makeSource = function(el, params, referenceParams) {
			var p = jsPlumb.extend({}, referenceParams);
			jsPlumb.extend(p, params);
			_setEndpointPaintStylesAndAnchor(p, 0);   
			var jpcl = jsPlumb.CurrentLibrary,
				maxConnections = p.maxConnections || -1,
				onMaxConnections = p.onMaxConnections,
				_doOne = function(_el) {
					// get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
					// and use the endpoint definition if found.
					var elid = _getId(_el),
						parentElement = function() {
							return p.parent == null ? p.parent : p.parent === "parent" ? jpcl.getElementObject(jpcl.getDOMElement(_el).parentNode) : jpcl.getElementObject(p.parent);
						},
						idToRegisterAgainst = p.parent != null ? _currentInstance.getId(parentElement()) : elid;
					
					_sourceEndpointDefinitions[idToRegisterAgainst] = p;
					_sourceEndpointsUnique[idToRegisterAgainst] = p.uniqueEndpoint;
					_sourcesEnabled[idToRegisterAgainst] = true;

					var stopEvent = jpcl.dragEvents["stop"],
						dragEvent = jpcl.dragEvents["drag"],
						dragOptions = jsPlumb.extend({ }, p.dragOptions || {}),
						existingDrag = dragOptions.drag,
						existingStop = dragOptions.stop,
						ep = null,
						endpointAddedButNoDragYet = false;
				
					_sourceMaxConnections[idToRegisterAgainst] = maxConnections;	

					// set scope if its not set in dragOptions but was passed in in params
					dragOptions["scope"] = dragOptions["scope"] || p.scope;

					dragOptions[dragEvent] = _wrap(dragOptions[dragEvent], function() {
						if (existingDrag) existingDrag.apply(this, arguments);
						endpointAddedButNoDragYet = false;
					});
					
					dragOptions[stopEvent] = _wrap(dragOptions[stopEvent], function() { 							
						if (existingStop) existingStop.apply(this, arguments);								

	                    //_currentlyDown = false;
						_currentInstance.currentlyDragging = false;
						
						if (ep.connections.length == 0)
							_currentInstance.deleteEndpoint(ep);
						else {
							
							jpcl.unbind(ep.canvas, "mousedown"); 
									
							// reset the anchor to the anchor that was initially provided. the one we were using to drag
							// the connection was just a placeholder that was located at the place the user pressed the
							// mouse button to initiate the drag.
							var anchorDef = p.anchor || _currentInstance.Defaults.Anchor,
								oldAnchor = ep.anchor,
								oldConnection = ep.connections[0];

							ep.setAnchor(_currentInstance.makeAnchor(anchorDef, elid, _currentInstance));																							
							
							if (p.parent) {						
								var parent = parentElement();
								if (parent) {	
									var currentId = ep.elementId,
										potentialParent = p.container || _currentInstance.Defaults.Container || jsPlumb.Defaults.Container;			
																	
									ep.setElement(parent, potentialParent);
									ep.endpointWillMoveAfterConnection = false;														
									_currentInstance.anchorManager.rehomeEndpoint(currentId, parent);																					
									oldConnection.previousConnection = null;
									// remove from connectionsByScope
									_removeWithFunction(connectionsByScope[oldConnection.scope], function(c) {
										return c.id === oldConnection.id;
									});										
									_currentInstance.anchorManager.connectionDetached({
										sourceId:oldConnection.sourceId,
										targetId:oldConnection.targetId,
										connection:oldConnection
									});											
									_finaliseConnection(oldConnection);					
								}
							}						
							
							ep.repaint();			
							_currentInstance.repaint(ep.elementId);																		
							_currentInstance.repaint(oldConnection.targetId);
						}				
					});
					// when the user presses the mouse, add an Endpoint, if we are enabled.
					var mouseDownListener = function(e) {

						// if disabled, return.
						if (!_sourcesEnabled[idToRegisterAgainst]) return;
	                    
	                    // if a filter was given, run it, and return if it says no.
						if (p.filter) {
							var evt = jpcl.getOriginalEvent(e),
								r = jsPlumbUtil.isString(p.filter) ? selectorFilter(evt, _el, p.filter) : p.filter(evt, _el);
							
							if (r === false) return;
						}
						
						// if maxConnections reached
						var sourceCount = _currentInstance.select({source:idToRegisterAgainst}).length
						if (_sourceMaxConnections[idToRegisterAgainst] >= 0 && sourceCount >= _sourceMaxConnections[idToRegisterAgainst]) {
							if (onMaxConnections) {
								onMaxConnections({
									element:_el,
									maxConnections:maxConnections
								}, e);
							}
							return false;
						}					

						// make sure we have the latest offset for this div 
						var myOffsetInfo = _updateOffset({elId:elid}).o,
							z = _currentInstance.getZoom(),		
							x = ( ((e.pageX || e.page.x) / z) - myOffsetInfo.left) / myOffsetInfo.width, 
						    y = ( ((e.pageY || e.page.y) / z) - myOffsetInfo.top) / myOffsetInfo.height,
						    parentX = x, 
						    parentY = y;					
								
						// if there is a parent, the endpoint will actually be added to it now, rather than the div
						// that was the source.  in that case, we have to adjust the anchor position so it refers to
						// the parent.
						if (p.parent) {
							var pEl = parentElement(), pId = _getId(pEl);
							myOffsetInfo = _updateOffset({elId:pId}).o;
							parentX = ((e.pageX || e.page.x) - myOffsetInfo.left) / myOffsetInfo.width, 
						    parentY = ((e.pageY || e.page.y) - myOffsetInfo.top) / myOffsetInfo.height;
						}											
						
						// we need to override the anchor in here, and force 'isSource', but we don't want to mess with
						// the params passed in, because after a connection is established we're going to reset the endpoint
						// to have the anchor we were given.
						var tempEndpointParams = {};
						jsPlumb.extend(tempEndpointParams, p);
						tempEndpointParams.isSource = true;
						tempEndpointParams.anchor = [x,y,0,0];
						tempEndpointParams.parentAnchor = [ parentX, parentY, 0, 0 ];
						tempEndpointParams.dragOptions = dragOptions;
						// if a parent was given we need to turn that into a "container" argument.  this is, by default,
						// the parent of the element we will move to, so parent of p.parent in this case.  however, if
						// the user has specified a 'container' on the endpoint definition or on 
						// the defaults, we should use that.
						if (p.parent) {
							var potentialParent = tempEndpointParams.container || _currentInstance.Defaults.Container || jsPlumb.Defaults.Container;
							if (potentialParent)
								tempEndpointParams.container = potentialParent;
							else
								tempEndpointParams.container = jsPlumb.CurrentLibrary.getParent(parentElement());
						}
						
						ep = _currentInstance.addEndpoint(elid, tempEndpointParams);

						endpointAddedButNoDragYet = true;
						// we set this to prevent connections from firing attach events before this function has had a chance
						// to move the endpoint.
						ep.endpointWillMoveAfterConnection = p.parent != null;
						ep.endpointWillMoveTo = p.parent ? parentElement() : null;
						ep.addedViaMouse = true;

	                    var _delTempEndpoint = function() {
							// this mouseup event is fired only if no dragging occurred, by jquery and yui, but for mootools
							// it is fired even if dragging has occurred, in which case we would blow away a perfectly
							// legitimate endpoint, were it not for this check.  the flag is set after adding an
							// endpoint and cleared in a drag listener we set in the dragOptions above.
							if(endpointAddedButNoDragYet) {
								_currentInstance.deleteEndpoint(ep);
	                        }
						};

						_currentInstance.registerListener(ep.canvas, "mouseup", _delTempEndpoint);
	                    _currentInstance.registerListener(_el, "mouseup", _delTempEndpoint);
						
						// and then trigger its mousedown event, which will kick off a drag, which will start dragging
						// a new connection from this endpoint.
						jpcl.trigger(ep.canvas, "mousedown", e);
						
					};
	               
	                // register this on jsPlumb so that it can be cleared by a reset.
	                _currentInstance.registerListener(_el, "mousedown", mouseDownListener);
	                _sourceTriggers[elid] = mouseDownListener;

	                // lastly, if a filter was provided, set it as a dragFilter on the element,
	                // to prevent the element drag function from kicking in when we want to
	                // drag a new connection
	                if (p.filter && jsPlumbUtil.isString(p.filter)) {
	                	jpcl.setDragFilter(_el, p.filter);
	                }
				};
			
			el = _convertYUICollection(el);			
			
			var inputs = el.length && el.constructor != String ? el : [ el ];
						
			for (var i = 0, ii = inputs.length; i < ii; i++) {			
				_doOne(_gel(inputs[i]));
			}

			return _currentInstance;
		};
	
		// see api docs		
		this.unmakeSource = function(el, doNotClearArrays) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			var id = _getId(el),
				mouseDownListener = _sourceTriggers[id];
			
			if (mouseDownListener) 
				_currentInstance.unregisterListener(el, "mousedown", mouseDownListener);

			if (!doNotClearArrays) {
				delete _sourceEndpointDefinitions[id];
				delete _sourceEndpointsUnique[id];
				delete _sourcesEnabled[id];
				delete _sourceTriggers[id];
				delete _sourceMaxConnections[id];
			}

			return _currentInstance;
		};

		// see api docs
		this.unmakeEverySource = function() {
			for (var i in _sourcesEnabled)
				_currentInstance.unmakeSource(i, true);

			_sourceEndpointDefinitions = {};
			_sourceEndpointsUnique = {};
			_sourcesEnabled = {};
			_sourceTriggers = {};
		};
		
		// see api docs
		this.unmakeEveryTarget = function() {
			for (var i in _targetsEnabled)
				_currentInstance.unmakeTarget(i, true);
			
			_targetEndpointDefinitions = {};
			_targetEndpointsUnique = {};
			_targetMaxConnections = {};
			_targetsEnabled = {};

			return _currentInstance;
		};
		
		
		this.makeSources = function(els, params, referenceParams) {
			for ( var i = 0, ii = els.length; i < ii; i++) {
				_currentInstance.makeSource(els[i], params, referenceParams);				
			}

			return _currentInstance;
		};

		// does the work of setting a source enabled or disabled.
		var _setEnabled = function(type, el, state, toggle) {
			var a = type == "source" ? _sourcesEnabled : _targetsEnabled;									

			if (_isString(el)) a[el] = toggle ? !a[el] : state;
			else if (el.length) {
				el = _convertYUICollection(el);
				for (var i = 0, ii = el.length; i < ii; i++) {
					var id = _el = jsPlumb.CurrentLibrary.getElementObject(el[i]), id = _getId(_el);
					a[id] = toggle ? !a[id] : state;
				}
			}	
			return _currentInstance;
		};

		
		this.setSourceEnabled = function(el, state) {
			return _setEnabled("source", el, state);
		};

			
		this.toggleSourceEnabled = function(el) {
			_setEnabled("source", el, null, true);	
			return _currentInstance.isSourceEnabled(el);
		};

		
		this.isSource = function(el) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			return _sourcesEnabled[_getId(el)] != null;
		};

		
		this.isSourceEnabled = function(el) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			return _sourcesEnabled[_getId(el)] === true;
		};

		
		this.setTargetEnabled = function(el, state) {
			return _setEnabled("target", el, state);
		};

			
		this.toggleTargetEnabled = function(el) {
			_setEnabled("target", el, null, true);	
			return _currentInstance.isTargetEnabled(el);
		};

		
		this.isTarget = function(el) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			return _targetsEnabled[_getId(el)] != null;
		};

		
		this.isTargetEnabled = function(el) {
			el = jsPlumb.CurrentLibrary.getElementObject(el);
			return _targetsEnabled[_getId(el)] === true;
		};
				
		this.ready = function(fn) {
			_currentInstance.bind("ready", fn);
		};

		// repaint some element's endpoints and connections
		this.repaint = function(el, ui, timestamp) {
			// support both lists...
			if (typeof el == 'object' && el.length)
				for ( var i = 0, ii = el.length; i < ii; i++) {			
					_draw(_gel(el[i]), ui, timestamp);
				}
			else // ...and single strings.				
				_draw(_gel(el), ui, timestamp);
				
			return _currentInstance;
		};

		// repaint every endpoint and connection.
		this.repaintEverything = function() {	
			console.info("repaint");
			var timestamp = null;// _timestamp();			
			for ( var elId in endpointsByElement) {
				_draw(_gel(elId), null, timestamp);				
			}
			return _currentInstance;
		};

		
		this.removeAllEndpoints = function(el, recurse) {
            var _one = function(_el) {                
                var elId = jsPlumbUtil.isString(_el) ? _el : _getId(_gel(_el)),
                    ebe = endpointsByElement[elId];
                if (ebe) {
                    for ( var i = 0, ii = ebe.length; i < ii; i++) 
                        _currentInstance.deleteEndpoint(ebe[i]);
                }
                delete endpointsByElement[elId];
                
                if (recurse) {
                    var del = jsPlumb.CurrentLibrary.getDOMElement(_gel(_el));
                    if (del && del.nodeType != 3 && del.nodeType != 8 ) {
                        for (var i = 0, ii = del.childNodes.length; i < ii; i++) {
                            _one(del.childNodes[i]);
                        }
                    }
                }
                
            };
            _one(el);
			return _currentInstance;
		};
                    
        this.remove = function(el) {
            var _el = _gel(el);
            var id = jsPlumbUtil.isString(el) ? el : _getId(_el);
            _currentInstance.doWhileSuspended(function() {
            	_currentInstance.removeAllEndpoints(id, true);
            	_currentInstance.dragManager.elementRemoved(id);
            });
            jsPlumb.CurrentLibrary.removeElement(_el);
        };

		var _registeredListeners = {},
			_unbindRegisteredListeners = function() {
				for (var i in _registeredListeners) {
					for (var j = 0, jj = _registeredListeners[i].length; j < jj; j++) {
						var info = _registeredListeners[i][j];
						jsPlumb.CurrentLibrary.unbind(info.el, info.event, info.listener);
					}
				}
				_registeredListeners = {};
			};

        // internal register listener method.  gives us a hook to clean things up
        // with if the user calls jsPlumb.reset.
        this.registerListener = function(el, type, listener) {
            jsPlumb.CurrentLibrary.bind(el, type, listener);
            _addToList(_registeredListeners, type, {el:el, event:type, listener:listener});
        };

        this.unregisterListener = function(el, type, listener) {
        	jsPlumb.CurrentLibrary.unbind(el, type, listener);
        	_removeWithFunction(_registeredListeners, function(rl) {
        		return rl.type == type && rl.listener == listener;
        	});
        };

		
		this.reset = function() {			
			_currentInstance.deleteEveryEndpoint();
			_currentInstance.unbind();
			_targetEndpointDefinitions = {};
			_targetEndpoints = {};
			_targetEndpointsUnique = {};
			_targetMaxConnections = {};
			_sourceEndpointDefinitions = {};
			_sourceEndpoints = {};
			_sourceEndpointsUnique = {};
			_sourceMaxConnections = {};
			_unbindRegisteredListeners();
			_currentInstance.anchorManager.reset();
			if (!jsPlumbAdapter.headless)
				_currentInstance.dragManager.reset();
		};
		

		this.setDefaultScope = function(scope) {
			DEFAULT_SCOPE = scope;
			return _currentInstance;
		};

		// sets whether or not some element should be currently draggable.
		this.setDraggable = _setDraggable;

		// sets the id of some element, changing whatever we need to to keep track.
		this.setId = function(el, newId, doNotSetAttribute) {
		
			var id = el.constructor == String ? el : _currentInstance.getId(el),
				sConns = _currentInstance.getConnections({source:id, scope:'*'}, true),
				tConns = _currentInstance.getConnections({target:id, scope:'*'}, true);

			newId = "" + newId;
							
			if (!doNotSetAttribute) {
				el = jsPlumb.CurrentLibrary.getElementObject(id);
				jsPlumb.CurrentLibrary.setAttribute(el, "id", newId);
			}
			
			el = jsPlumb.CurrentLibrary.getElementObject(newId);
			

			endpointsByElement[newId] = endpointsByElement[id] || [];
			for (var i = 0, ii = endpointsByElement[newId].length; i < ii; i++) {
				endpointsByElement[newId][i].setElementId(newId);
				endpointsByElement[newId][i].setReferenceElement(el);
			}
			delete endpointsByElement[id];

			_currentInstance.anchorManager.changeId(id, newId);
			if (!jsPlumbAdapter.headless)		
				_currentInstance.dragManager.changeId(id, newId);

			var _conns = function(list, epIdx, type) {
				for (var i = 0, ii = list.length; i < ii; i++) {
					list[i].endpoints[epIdx].setElementId(newId);
					list[i].endpoints[epIdx].setReferenceElement(el);
					list[i][type + "Id"] = newId;
					list[i][type] = el;
				}
			};
			_conns(sConns, 0, "source");
			_conns(tConns, 1, "target");
			
			_currentInstance.repaint(newId);
		};

		// called to notify us that an id WAS changed, and we should do our changes, but we
		// dont need to change the element's DOM attribute.
		this.setIdChanged = function(oldId, newId) {
			_currentInstance.setId(oldId, newId, true);
		};

		this.setDebugLog = function(debugLog) {
			log = debugLog;
		};

		
		var _suspendDrawing = false,
            _suspendedAt = null;

         // set whether or not drawing is suspended. you should use this when doing bulk painting,
         // like when first drawing a UI.
		this.setSuspendDrawing = function(val, repaintAfterwards) {
		    _suspendDrawing = val;
				if (val) _suspendedAt = new Date().getTime(); else _suspendedAt = null;
		    if (repaintAfterwards) _currentInstance.repaintEverything();
		};
        	
        // returns whether or not drawing is currently suspended.		
		this.isSuspendDrawing = function() {
			return _suspendDrawing;
		};
            
        // return timestamp for when drawing was suspended.
        this.getSuspendedAt = function() { return _suspendedAt; };

        // suspends drawing, runs the given function, then re-enables drawing (and repaints,
        // unless you tell it not to)
        this.doWhileSuspended = function(fn, doNotRepaintAfterwards) {
			_currentInstance.setSuspendDrawing(true);
			try {
				fn();
			}
			catch (e) {
				_log("Function run while suspended failed", e);
			}
			_currentInstance.setSuspendDrawing(false, !doNotRepaintAfterwards);
        };
            
        this.updateOffset = _updateOffset;
        this.getOffset = function(elId) { return offsets[elId]; };
        this.getSize = function(elId) { return sizes[elId]; };            
        this.getCachedData = _getCachedData;
        this.timestamp = _timestamp;
		
		/*
		 * Property: SVG
		 * Constant for use with the setRenderMode method
		 */
		 /*
		  * Property: VML
		  * Constant for use with the setRenderMode method
		  */
		/*
		 * Property: CANVAS
		 * Constant for use with the setRenderMode method
		 */
		this.SVG = "svg";
		
		this.CANVAS = "canvas";
		
		this.VML = "vml";
		
		/*
		 * Function: setRenderMode
		 * Sets render mode: jsPlumb.SVG or jsPlumb.VML.  jsPlumb will fall back to VML if it determines that
		 * what you asked for is not supported (and that VML is).  If you asked for VML but the browser does
		 * not support it, jsPlumb uses SVG.
		 *
		 * Parameters:
		 * mode	-	a string representing the mode. Use one of the jsPlumb render mode constants as discussed above.
		 * 
		 * Returns:
		 * The render mode that jsPlumb set, which of course may be different from that requested.
		 */
		this.setRenderMode = function(mode) {			
			renderMode = jsPlumbAdapter.setRenderMode(mode);
			return renderMode;
		};
		
		/*
		 * Function: getRenderMode
		 *
		 * Returns:
		 * The current render mode.
		 */
		this.getRenderMode = function() { return renderMode; };

		
		this.show = function(el, changeEndpoints) {
			_setVisible(el, "block", changeEndpoints);
			return _currentInstance;
		};

		/*
		 * Function: sizeCanvas 
		 * Helper to size a canvas. You would typically use
		 * this when writing your own Connector or Endpoint implementation.
		 * 
		 * Parameters: 
		 * 	x - [int] x position for the Canvas origin 
		 * 	y - [int] y position for the Canvas origin 
		 * 	w - [int] width of the canvas 
		 * 	h - [int] height of the canvas
		 *  
		 * Returns: 
		 * 	The current jsPlumb instance
		 */
		this.sizeCanvas = function(canvas, x, y, w, h) {
			if (canvas) {
				canvas.style.height = h + "px";
				canvas.height = h;
				canvas.style.width = w + "px";
				canvas.width = w;
				canvas.style.left = x + "px";
				canvas.style.top = y + "px";
			}
			return _currentInstance;
		};

		/**
		 * gets some test hooks. nothing writable.
		 */
		this.getTestHarness = function() {
			return {
				endpointsByElement : endpointsByElement,  
				endpointCount : function(elId) {
					var e = endpointsByElement[elId];
					return e ? e.length : 0;
				},
				connectionCount : function(scope) {
					scope = scope || DEFAULT_SCOPE;
					var c = connectionsByScope[scope];
					return c ? c.length : 0;
				},
				//findIndex : _findIndex,
				getId : _getId,
				makeAnchor:self.makeAnchor,
				makeDynamicAnchor:self.makeDynamicAnchor
			};
		};
		
		
		// TODO: update this method to return the current state.
		this.toggleVisible = _toggleVisible;
		this.toggleDraggable = _toggleDraggable;		

		/*
		 * Helper method to wrap an existing function with one of
		 * your own. This is used by the various implementations to wrap event
		 * callbacks for drag/drop etc; it allows jsPlumb to be transparent in
		 * its handling of these things. If a user supplies their own event
		 * callback, for anything, it will always be called. 
		 */
		this.wrap = _wrap;			
		this.addListener = this.bind;
		
        /*
            helper method to take an xy location and adjust it for the parent's offset and scroll.
        */
		this.adjustForParentOffsetAndScroll = function(xy, el) {

			var offsetParent = null, result = xy;
			if (el.tagName.toLowerCase() === "svg" && el.parentNode) {
				offsetParent = el.parentNode;
			}
			else if (el.offsetParent) {
				offsetParent = el.offsetParent;					
			}
			if (offsetParent != null) {
				var po = offsetParent.tagName.toLowerCase() === "body" ? {left:0,top:0} : _getOffset(offsetParent, _currentInstance),
					so = offsetParent.tagName.toLowerCase() === "body" ? {left:0,top:0} : {left:offsetParent.scrollLeft, top:offsetParent.scrollTop};					


				// i thought it might be cool to do this:
				//	lastReturnValue[0] = lastReturnValue[0] - offsetParent.offsetLeft + offsetParent.scrollLeft;
				//	lastReturnValue[1] = lastReturnValue[1] - offsetParent.offsetTop + offsetParent.scrollTop;					
				// but i think it ignores margins.  my reasoning was that it's quicker to not hand off to some underlying					
				// library.
				
				result[0] = xy[0] - po.left + so.left;
				result[1] = xy[1] - po.top + so.top;
			}
		
			return result;
			
		};

		if (!jsPlumbAdapter.headless) {
			_currentInstance.dragManager = jsPlumbAdapter.getDragManager(_currentInstance);
			_currentInstance.recalculateOffsets = _currentInstance.dragManager.updateOffsets;
	    }
				    
    };

// --------------------- static instance + AMD registration -------------------------------------------	
	
// create static instance and assign to window if window exists.	
	var jsPlumb = new jsPlumbInstance();
	if (typeof window != 'undefined') window.jsPlumb = jsPlumb;
// add 'getInstance' method to static instance
	jsPlumb.getInstance = function(_defaults) {
		var j = new jsPlumbInstance(_defaults);
		j.init();
		return j;
	};
// maybe register static instance as an AMD module, and getInstance method too.
	if ( typeof define === "function") {
		define( "jsplumb", [], function () { return jsPlumb; } );
		define( "jsplumbinstance", [], function () { return jsPlumb.getInstance(); } );
	}
 // CommonJS 
	if (typeof exports !== 'undefined') {
      exports.jsPlumb = jsPlumb;
  	}
	
	
// --------------------- end static instance + AMD registration -------------------------------------------		
	
})();
/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.4.1
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the code for creating and manipulating anchors.
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (simon.porritt@gmail.com)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {	
    
    //
	// manages anchors for all elements.
	//
	jsPlumb.AnchorManager = function(params) {
		var _amEndpoints = {},
            continuousAnchors = {},
            continuousAnchorLocations = {},
            userDefinedContinuousAnchorLocations = {},        
            continuousAnchorOrientations = {},
            Orientation = { HORIZONTAL : "horizontal", VERTICAL : "vertical", DIAGONAL : "diagonal", IDENTITY:"identity" },
			connectionsByElementId = {},
			self = this,
            anchorLists = {},
            jsPlumbInstance = params.jsPlumbInstance,
            jpcl = jsPlumb.CurrentLibrary,
            floatingConnections = {},
            // TODO this functions uses a crude method of determining orientation between two elements.
	       // 'diagonal' should be chosen when the angle of the line between the two centers is around
	       // one of 45, 135, 225 and 315 degrees. maybe +- 15 degrees.
            // used by AnchorManager.redraw
            calculateOrientation = function(sourceId, targetId, sd, td, sourceAnchor, targetAnchor) {
        
                if (sourceId === targetId) return {
                    orientation:Orientation.IDENTITY,
                    a:["top", "top"]
                };
        
                var theta = Math.atan2((td.centery - sd.centery) , (td.centerx - sd.centerx)),
                    theta2 = Math.atan2((sd.centery - td.centery) , (sd.centerx - td.centerx)),
                    h = ((sd.left <= td.left && sd.right >= td.left) || (sd.left <= td.right && sd.right >= td.right) ||
                        (sd.left <= td.left && sd.right >= td.right) || (td.left <= sd.left && td.right >= sd.right)),
                    v = ((sd.top <= td.top && sd.bottom >= td.top) || (sd.top <= td.bottom && sd.bottom >= td.bottom) ||
                        (sd.top <= td.top && sd.bottom >= td.bottom) || (td.top <= sd.top && td.bottom >= sd.bottom)),
                    possiblyTranslateEdges = function(edges) {
                        // this function checks to see if either anchor is Continuous, and if so, runs the suggested edge
                        // through the anchor: Continuous anchors can say which faces they support, and they get to choose 
                        // whether a certain face is honoured, or, if not, which face to replace it with. the behaviour when
                        // choosing an alternate face is to try for the opposite face first, then the next one clockwise, and then
                        // the opposite of that one.
                        return [
                            sourceAnchor.isContinuous ? sourceAnchor.verifyEdge(edges[0]) : edges[0],    
                            targetAnchor.isContinuous ? targetAnchor.verifyEdge(edges[1]) : edges[1]
                        ];
                    },
                    out = {
                        orientation:Orientation.DIAGONAL,
                        theta:theta,
                        theta2:theta2
                    };                        
                
                if (! (h || v)) {                    
                    if (td.left > sd.left && td.top > sd.top)
                        out.a = ["right", "top"];
                    else if (td.left > sd.left && sd.top > td.top)
                        out.a = [ "top", "left"];
                    else if (td.left < sd.left && td.top < sd.top)
                        out.a = [ "top", "right"];
                    else if (td.left < sd.left && td.top > sd.top)
                        out.a = ["left", "top" ];                            
                }
                else if (h) {
                    out.orientation = Orientation.HORIZONTAL;
                    out.a = sd.top < td.top ? ["bottom", "top"] : ["top", "bottom"];                    
                }
                else {
                    out.orientation = Orientation.VERTICAL;
                    out.a = sd.left < td.left ? ["right", "left"] : ["left", "right"];
                }
                
                out.a = possiblyTranslateEdges(out.a);
                return out;
            },
                // used by placeAnchors function
            placeAnchorsOnLine = function(desc, elementDimensions, elementPosition,
                            connections, horizontal, otherMultiplier, reverse) {
                var a = [], step = elementDimensions[horizontal ? 0 : 1] / (connections.length + 1);
        
                for (var i = 0; i < connections.length; i++) {
                    var val = (i + 1) * step, other = otherMultiplier * elementDimensions[horizontal ? 1 : 0];
                    if (reverse)
                      val = elementDimensions[horizontal ? 0 : 1] - val;
        
                    var dx = (horizontal ? val : other), x = elementPosition[0] + dx,  xp = dx / elementDimensions[0],
                        dy = (horizontal ? other : val), y = elementPosition[1] + dy, yp = dy / elementDimensions[1];
        
                    a.push([ x, y, xp, yp, connections[i][1], connections[i][2] ]);
                }
        
                return a;
            },
            // used by edgeSortFunctions        
            currySort = function(reverseAngles) {
                return function(a,b) {
                    var r = true;
                    if (reverseAngles) {
                        /*if (a[0][0] < b[0][0])
                            r = true;
                        else
                            r = a[0][1] > b[0][1];*/
                        r = a[0][0] < b[0][0];
                    }
                    else {
                        /*if (a[0][0] > b[0][0])
                            r= true;
                        else
                            r =a[0][1] > b[0][1];
                        */
                        r = a[0][0] > b[0][0];
                    }
                    return r === false ? -1 : 1;
                };
            },
                // used by edgeSortFunctions
            leftSort = function(a,b) {
                // first get adjusted values
                var p1 = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0],
                p2 = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0];
                if (p1 > p2) return 1;
                else return a[0][1] > b[0][1] ? 1 : -1;
            },
                // used by placeAnchors
            edgeSortFunctions = {
                "top":function(a, b) { return a[0] > b[0] ? 1 : -1 },
                "right":currySort(true),
                "bottom":currySort(true),
                "left":leftSort
            },
                // used by placeAnchors
            _sortHelper = function(_array, _fn) { return _array.sort(_fn); },
                // used by AnchorManager.redraw
            placeAnchors = function(elementId, _anchorLists) {		
                var cd = jsPlumbInstance.getCachedData(elementId), sS = cd.s, sO = cd.o,
                placeSomeAnchors = function(desc, elementDimensions, elementPosition, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
                    if (unsortedConnections.length > 0) {
                        var sc = _sortHelper(unsortedConnections, edgeSortFunctions[desc]), // puts them in order based on the target element's pos on screen			    
                            reverse = desc === "right" || desc === "top",
                            anchors = placeAnchorsOnLine(desc, elementDimensions,
                                                     elementPosition, sc,
                                                     isHorizontal, otherMultiplier, reverse );
        
                        // takes a computed anchor position and adjusts it for parent offset and scroll, then stores it.
                        var _setAnchorLocation = function(endpoint, anchorPos) {
                            var a = jsPlumbInstance.adjustForParentOffsetAndScroll([anchorPos[0], anchorPos[1]], endpoint.canvas);
                            continuousAnchorLocations[endpoint.id] = [ a[0], a[1], anchorPos[2], anchorPos[3] ];
                            continuousAnchorOrientations[endpoint.id] = orientation;
                        };
        
                        for (var i = 0; i < anchors.length; i++) {
                            var c = anchors[i][4], weAreSource = c.endpoints[0].elementId === elementId, weAreTarget = c.endpoints[1].elementId === elementId;
                            if (weAreSource)
                                _setAnchorLocation(c.endpoints[0], anchors[i]);
                            else if (weAreTarget)
                                _setAnchorLocation(c.endpoints[1], anchors[i]);
                        }
                    }
                };
        
                placeSomeAnchors("bottom", sS, [sO.left,sO.top], _anchorLists.bottom, true, 1, [0,1]);
                placeSomeAnchors("top", sS, [sO.left,sO.top], _anchorLists.top, true, 0, [0,-1]);
                placeSomeAnchors("left", sS, [sO.left,sO.top], _anchorLists.left, false, 0, [-1,0]);
                placeSomeAnchors("right", sS, [sO.left,sO.top], _anchorLists.right, false, 1, [1,0]);
            };

        this.reset = function() {
        	_amEndpoints = {};
        	connectionsByElementId = {};
            anchorLists = {};
        };			
        this.addFloatingConnection = function(key, conn) {
            floatingConnections[key] = conn;
        };
        this.removeFloatingConnection = function(key) {
            delete floatingConnections[key];
        };                                                 
 		this.newConnection = function(conn) {
			var sourceId = conn.sourceId, targetId = conn.targetId,
				ep = conn.endpoints,
                doRegisterTarget = true,
			    registerConnection = function(otherIndex, otherEndpoint, otherAnchor, elId, c) {
					if ((sourceId == targetId) && otherAnchor.isContinuous){
                       // remove the target endpoint's canvas.  we dont need it.
                        jpcl.removeElement(ep[1].canvas);
                        doRegisterTarget = false;
                    }
					jsPlumbUtil.addToList(connectionsByElementId, elId, [c, otherEndpoint, otherAnchor.constructor == jsPlumb.DynamicAnchor]);
			    };

			registerConnection(0, ep[0], ep[0].anchor, targetId, conn);
            if (doRegisterTarget)
            	registerConnection(1, ep[1], ep[1].anchor, sourceId, conn);
		};
        var removeEndpointFromAnchorLists = function(endpoint) {
            (function(list, eId) {
                if (list) {  // transient anchors dont get entries in this list.
                    var f = function(e) { return e[4] == eId; };
                    jsPlumbUtil.removeWithFunction(list["top"], f);
                    jsPlumbUtil.removeWithFunction(list["left"], f);
                    jsPlumbUtil.removeWithFunction(list["bottom"], f);
                    jsPlumbUtil.removeWithFunction(list["right"], f);
                }
            })(anchorLists[endpoint.elementId], endpoint.id);
        };
		this.connectionDetached = function(connInfo) {
            var connection = connInfo.connection || connInfo,
			    sourceId = connInfo.sourceId,
                targetId = connInfo.targetId,
				ep = connection.endpoints,
				removeConnection = function(otherIndex, otherEndpoint, otherAnchor, elId, c) {
					if (otherAnchor.constructor == jsPlumb.FloatingAnchor) {
						// no-op
					}
					else {
						jsPlumbUtil.removeWithFunction(connectionsByElementId[elId], function(_c) {
							return _c[0].id == c.id;
						});
					}
				};
				
			removeConnection(1, ep[1], ep[1].anchor, sourceId, connection);
			removeConnection(0, ep[0], ep[0].anchor, targetId, connection);

            // remove from anchorLists            
            removeEndpointFromAnchorLists(connection.endpoints[0]);
            removeEndpointFromAnchorLists(connection.endpoints[1]);

            self.redraw(connection.sourceId);
            self.redraw(connection.targetId);
		};
		this.add = function(endpoint, elementId) {
			jsPlumbUtil.addToList(_amEndpoints, elementId, endpoint);
		};
		this.changeId = function(oldId, newId) {
			connectionsByElementId[newId] = connectionsByElementId[oldId];
			_amEndpoints[newId] = _amEndpoints[oldId];
			delete connectionsByElementId[oldId];
			delete _amEndpoints[oldId];	
		};
		this.getConnectionsFor = function(elementId) {
			return connectionsByElementId[elementId] || [];
		};
		this.getEndpointsFor = function(elementId) {
			return _amEndpoints[elementId] || [];
		};
		this.deleteEndpoint = function(endpoint) {
			jsPlumbUtil.removeWithFunction(_amEndpoints[endpoint.elementId], function(e) {
				return e.id == endpoint.id;
			});
            removeEndpointFromAnchorLists(endpoint);
		};
		this.clearFor = function(elementId) {
			delete _amEndpoints[elementId];
			_amEndpoints[elementId] = [];
		};
        // updates the given anchor list by either updating an existing anchor's info, or adding it. this function
        // also removes the anchor from its previous list, if the edge it is on has changed.
        // all connections found along the way (those that are connected to one of the faces this function
        // operates on) are added to the connsToPaint list, as are their endpoints. in this way we know to repaint
        // them wthout having to calculate anything else about them.
        var _updateAnchorList = function(lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, elId, connsToPaint, endpointsToPaint) {        
            // first try to find the exact match, but keep track of the first index of a matching element id along the way.s
            var exactIdx = -1,
                firstMatchingElIdx = -1,
                endpoint = conn.endpoints[idx],
                endpointId = endpoint.id,
                oIdx = [1,0][idx],
                values = [ [ theta, order ], conn, aBoolean, otherElId, endpointId ],
                listToAddTo = lists[edgeId],
                listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null;

            if (listToRemoveFrom) {
                var rIdx = jsPlumbUtil.findWithFunction(listToRemoveFrom, function(e) { return e[4] == endpointId });
                if (rIdx != -1) {
                    listToRemoveFrom.splice(rIdx, 1);
                    // get all connections from this list
                    for (var i = 0; i < listToRemoveFrom.length; i++) {
                        jsPlumbUtil.addWithFunction(connsToPaint, listToRemoveFrom[i][1], function(c) { return c.id == listToRemoveFrom[i][1].id });
                        jsPlumbUtil.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[idx], function(e) { return e.id == listToRemoveFrom[i][1].endpoints[idx].id });
                        jsPlumbUtil.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[oIdx], function(e) { return e.id == listToRemoveFrom[i][1].endpoints[oIdx].id });
                    }
                }
            }

            for (var i = 0; i < listToAddTo.length; i++) {
                if (params.idx == 1 && listToAddTo[i][3] === otherElId && firstMatchingElIdx == -1)
                    firstMatchingElIdx = i;
                jsPlumbUtil.addWithFunction(connsToPaint, listToAddTo[i][1], function(c) { return c.id == listToAddTo[i][1].id });                
                jsPlumbUtil.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[idx], function(e) { return e.id == listToAddTo[i][1].endpoints[idx].id });
                jsPlumbUtil.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[oIdx], function(e) { return e.id == listToAddTo[i][1].endpoints[oIdx].id });
            }
            if (exactIdx != -1) {
                listToAddTo[exactIdx] = values;
            }
            else {
                var insertIdx = reverse ? firstMatchingElIdx != -1 ? firstMatchingElIdx : 0 : listToAddTo.length; // of course we will get this from having looked through the array shortly.
                listToAddTo.splice(insertIdx, 0, values);
            }

            // store this for next time.
            endpoint._continuousAnchorEdge = edgeId;
        };
		this.redraw = function(elementId, ui, timestamp, offsetToUI, clearEdits) {
		
			if (!jsPlumbInstance.isSuspendDrawing()) {
				// get all the endpoints for this element
				var ep = _amEndpoints[elementId] || [],
					endpointConnections = connectionsByElementId[elementId] || [],
					connectionsToPaint = [],
					endpointsToPaint = [],
	                anchorsToUpdate = [];
	            
				timestamp = timestamp || jsPlumbInstance.timestamp();
				// offsetToUI are values that would have been calculated in the dragManager when registering
				// an endpoint for an element that had a parent (somewhere in the hierarchy) that had been
				// registered as draggable.
				offsetToUI = offsetToUI || {left:0, top:0};
				if (ui) {
					ui = {
						left:ui.left + offsetToUI.left,
						top:ui.top + offsetToUI.top
					}
				}
									
				// valid for one paint cycle.
				var myOffset = jsPlumbInstance.updateOffset( { elId : elementId, offset : ui, recalc : false, timestamp : timestamp }),
	                orientationCache = {};
				
				// actually, first we should compute the orientation of this element to all other elements to which
				// this element is connected with a continuous anchor (whether both ends of the connection have
				// a continuous anchor or just one)
	                        
	            for (var i = 0; i < endpointConnections.length; i++) {
	                var conn = endpointConnections[i][0],
						sourceId = conn.sourceId,
	                    targetId = conn.targetId,
	                    sourceContinuous = conn.endpoints[0].anchor.isContinuous,
	                    targetContinuous = conn.endpoints[1].anchor.isContinuous;
	
	                if (sourceContinuous || targetContinuous) {
		                var oKey = sourceId + "_" + targetId,
		                    oKey2 = targetId + "_" + sourceId,
		                    o = orientationCache[oKey],
		                    oIdx = conn.sourceId == elementId ? 1 : 0;
	
		                if (sourceContinuous && !anchorLists[sourceId]) anchorLists[sourceId] = { top:[], right:[], bottom:[], left:[] };
		                if (targetContinuous && !anchorLists[targetId]) anchorLists[targetId] = { top:[], right:[], bottom:[], left:[] };
	
		                if (elementId != targetId) jsPlumbInstance.updateOffset( { elId : targetId, timestamp : timestamp }); 
		                if (elementId != sourceId) jsPlumbInstance.updateOffset( { elId : sourceId, timestamp : timestamp }); 
	
		                var td = jsPlumbInstance.getCachedData(targetId),
							sd = jsPlumbInstance.getCachedData(sourceId);
	
		                if (targetId == sourceId && (sourceContinuous || targetContinuous)) {
		                    // here we may want to improve this by somehow determining the face we'd like
						    // to put the connector on.  ideally, when drawing, the face should be calculated
						    // by determining which face is closest to the point at which the mouse button
							// was released.  for now, we're putting it on the top face.                            
		                    _updateAnchorList(
                                anchorLists[sourceId], 
                                -Math.PI / 2, 
                                0, 
                                conn, 
                                false, 
                                targetId, 
                                0, false, "top", sourceId, connectionsToPaint, endpointsToPaint);
						}
		                else {
		                    if (!o) {
		                        o = calculateOrientation(sourceId, targetId, sd.o, td.o, conn.endpoints[0].anchor, conn.endpoints[1].anchor);
		                        orientationCache[oKey] = o;
		                        // this would be a performance enhancement, but the computed angles need to be clamped to
		                        //the (-PI/2 -> PI/2) range in order for the sorting to work properly.
		                    /*  orientationCache[oKey2] = {
		                            orientation:o.orientation,
		                            a:[o.a[1], o.a[0]],
		                            theta:o.theta + Math.PI,
		                            theta2:o.theta2 + Math.PI
		                        };*/
		                    }
		                    if (sourceContinuous) _updateAnchorList(anchorLists[sourceId], o.theta, 0, conn, false, targetId, 0, false, o.a[0], sourceId, connectionsToPaint, endpointsToPaint);
		                    if (targetContinuous) _updateAnchorList(anchorLists[targetId], o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], targetId, connectionsToPaint, endpointsToPaint);
		                }
	
		                if (sourceContinuous) jsPlumbUtil.addWithFunction(anchorsToUpdate, sourceId, function(a) { return a === sourceId; });
		                if (targetContinuous) jsPlumbUtil.addWithFunction(anchorsToUpdate, targetId, function(a) { return a === targetId; });
		                jsPlumbUtil.addWithFunction(connectionsToPaint, conn, function(c) { return c.id == conn.id; });
		                if ((sourceContinuous && oIdx == 0) || (targetContinuous && oIdx == 1))
		                	jsPlumbUtil.addWithFunction(endpointsToPaint, conn.endpoints[oIdx], function(e) { return e.id == conn.endpoints[oIdx].id; });
		            }
	            }				
				// place Endpoints whose anchors are continuous but have no Connections
				for (var i = 0; i < ep.length; i++) {
					if (ep[i].connections.length == 0 && ep[i].anchor.isContinuous) {
						if (!anchorLists[elementId]) anchorLists[elementId] = { top:[], right:[], bottom:[], left:[] };
						_updateAnchorList(anchorLists[elementId], -Math.PI / 2, 0, {endpoints:[ep[i], ep[i]], paint:function(){}}, false, elementId, 0, false, "top", elementId, connectionsToPaint, endpointsToPaint)
						jsPlumbUtil.addWithFunction(anchorsToUpdate, elementId, function(a) { return a === elementId; })
					}
				}
	            // now place all the continuous anchors we need to;
	            for (var i = 0; i < anchorsToUpdate.length; i++) {
					placeAnchors(anchorsToUpdate[i], anchorLists[anchorsToUpdate[i]]);
				}

				// now that continuous anchors have been placed, paint all the endpoints for this element
	            // TODO performance: add the endpoint ids to a temp array, and then when iterating in the next
	            // loop, check that we didn't just paint that endpoint. we can probably shave off a few more milliseconds this way.
				for (var i = 0; i < ep.length; i++) {				
                    ep[i].paint( { timestamp : timestamp, offset : myOffset, dimensions : myOffset.s });
				}
	            // ... and any other endpoints we came across as a result of the continuous anchors.
	            for (var i = 0; i < endpointsToPaint.length; i++) {
                    var cd = jsPlumbInstance.getCachedData(endpointsToPaint[i].elementId);
                    endpointsToPaint[i].paint( { timestamp : timestamp, offset : cd, dimensions : cd.s });
				}

				// paint all the standard and "dynamic connections", which are connections whose other anchor is
				// static and therefore does need to be recomputed; we make sure that happens only one time.
	
				// TODO we could have compiled a list of these in the first pass through connections; might save some time.
				for (var i = 0; i < endpointConnections.length; i++) {
					var otherEndpoint = endpointConnections[i][1];
					if (otherEndpoint.anchor.constructor == jsPlumb.DynamicAnchor) {			 							
						otherEndpoint.paint({ elementWithPrecedence:elementId });								
	                    jsPlumbUtil.addWithFunction(connectionsToPaint, endpointConnections[i][0], function(c) { return c.id == endpointConnections[i][0].id; });
						// all the connections for the other endpoint now need to be repainted
						for (var k = 0; k < otherEndpoint.connections.length; k++) {
							if (otherEndpoint.connections[k] !== endpointConnections[i][0])							
	                            jsPlumbUtil.addWithFunction(connectionsToPaint, otherEndpoint.connections[k], function(c) { return c.id == otherEndpoint.connections[k].id; });
						}
					} else if (otherEndpoint.anchor.constructor == jsPlumb.Anchor) {					
	                    jsPlumbUtil.addWithFunction(connectionsToPaint, endpointConnections[i][0], function(c) { return c.id == endpointConnections[i][0].id; });
					}
				}
				// paint current floating connection for this element, if there is one.
				var fc = floatingConnections[elementId];
				if (fc) 
					fc.paint({timestamp:timestamp, recalc:false, elId:elementId});
				                
				// paint all the connections
				for (var i = 0; i < connectionsToPaint.length; i++) {
					connectionsToPaint[i].paint({elId:elementId, timestamp:timestamp, recalc:false, clearEdits:clearEdits});
				}
			}
		};
		this.rehomeEndpoint = function(currentId, element) {
			var eps = _amEndpoints[currentId] || [], 
				elementId = jsPlumbInstance.getId(element);
			if (elementId !== currentId) {
				for (var i = 0; i < eps.length; i++) {
					self.add(eps[i], elementId);
				}
				eps.splice(0, eps.length);
			}
		};
        
        var ContinuousAnchor = function(anchorParams) {
            jsPlumbUtil.EventGenerator.apply(this);
            this.type = "Continuous";
            this.isDynamic = true;
            this.isContinuous = true;
            var faces = anchorParams.faces || ["top", "right", "bottom", "left"],
                clockwise = !(anchorParams.clockwise === false),
                availableFaces = { },
                opposites = { "top":"bottom", "right":"left","left":"right","bottom":"top" },
                clockwiseOptions = { "top":"right", "right":"bottom","left":"top","bottom":"left" },
                antiClockwiseOptions = { "top":"left", "right":"top","left":"bottom","bottom":"right" },
                secondBest = clockwise ? clockwiseOptions : antiClockwiseOptions,
                lastChoice = clockwise ? antiClockwiseOptions : clockwiseOptions,
                cssClass = anchorParams.cssClass || "";
            
            for (var i = 0; i < faces.length; i++) { availableFaces[faces[i]] = true; }
          
            // if the given edge is suported, returns it. otherwise looks for a substitute that _is_
            // supported. if none supported we also return the request edge.
            this.verifyEdge = function(edge) {
                if (availableFaces[edge]) return edge;
                else if (availableFaces[opposites[edge]]) return opposites[edge];
                else if (availableFaces[secondBest[edge]]) return secondBest[edge];
                else if (availableFaces[lastChoice[edge]]) return lastChoice[edge];
                return edge; // we have to give them something.
            };
            
            this.compute = function(params) {
                return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0,0];
            };
            this.getCurrentLocation = function(endpoint) {
                return userDefinedContinuousAnchorLocations[endpoint.id] || continuousAnchorLocations[endpoint.id] || [0,0];
            };
            this.getOrientation = function(endpoint) {
                return continuousAnchorOrientations[endpoint.id] || [0,0];
            };
            this.clearUserDefinedLocation = function() { 
                delete userDefinedContinuousAnchorLocations[anchorParams.elementId]; 
            };
            this.setUserDefinedLocation = function(loc) { 
                userDefinedContinuousAnchorLocations[anchorParams.elementId] = loc; 
            };            
            this.getCssClass = function() { return cssClass; };
            this.setCssClass = function(c) { cssClass = c; };
        };        
        
        // continuous anchors
        jsPlumbInstance.continuousAnchorFactory = {
            get:function(params) {
                var existing = continuousAnchors[params.elementId];
                if (!existing) {
                    existing = new ContinuousAnchor(params);                    
                    continuousAnchors[params.elementId] = existing;
                }
                return existing;
            }
        };
	};
    
    /**
     * Anchors model a position on some element at which an Endpoint may be located.  They began as a first class citizen of jsPlumb, ie. a user
     * was required to create these themselves, but over time this has been replaced by the concept of referring to them either by name (eg. "TopMiddle"),
     * or by an array describing their coordinates (eg. [ 0, 0.5, 0, -1 ], which is the same as "TopMiddle").  jsPlumb now handles all of the
     * creation of Anchors without user intervention.
     */
    jsPlumb.Anchor = function(params) {
        var self = this;
        this.x = params.x || 0;
        this.y = params.y || 0;
        this.elementId = params.elementId;        

        jsPlumbUtil.EventGenerator.apply(this);
        
        var orientation = params.orientation || [ 0, 0 ],
            jsPlumbInstance = params.jsPlumbInstance,
            lastTimestamp = null, lastReturnValue = null, userDefinedLocation = null,
            cssClass = params.cssClass || "";

        this.getCssClass = function() { return cssClass; };
        
        this.offsets = params.offsets || [ 0, 0 ];
        self.timestamp = null;        
        this.compute = function(params) {
            
            var xy = params.xy, wh = params.wh, element = params.element, timestamp = params.timestamp;                    
            if(params.clearUserDefinedLocation)
                userDefinedLocation = null;
            
            if (timestamp && timestamp === self.timestamp)
                return lastReturnValue;        
            
            if (userDefinedLocation != null) {
                lastReturnValue = userDefinedLocation;
            }
            else {                
                
                lastReturnValue = [ xy[0] + (self.x * wh[0]) + self.offsets[0], xy[1] + (self.y * wh[1]) + self.offsets[1] ];                    
                // adjust loc if there is an offsetParent
                lastReturnValue = jsPlumbInstance.adjustForParentOffsetAndScroll(lastReturnValue, element.canvas);
            }
            
            self.timestamp = timestamp;
            return lastReturnValue;
        };

        this.getOrientation = function(_endpoint) { return orientation; };

        this.equals = function(anchor) {
            if (!anchor) return false;
            var ao = anchor.getOrientation();
            var o = this.getOrientation();
            return this.x == anchor.x && this.y == anchor.y
                    && this.offsets[0] == anchor.offsets[0]
                    && this.offsets[1] == anchor.offsets[1]
                    && o[0] == ao[0] && o[1] == ao[1];
        };

        this.getCurrentLocation = function() { return lastReturnValue; };
        
        this.getUserDefinedLocation = function() { 
            return userDefinedLocation;
        };
        
        this.setUserDefinedLocation = function(l) {
            userDefinedLocation = l;
        };
        this.clearUserDefinedLocation = function() {
            userDefinedLocation = null;
        };
    };

    /**
     * An Anchor that floats. its orientation is computed dynamically from
     * its position relative to the anchor it is floating relative to.  It is used when creating 
     * a connection through drag and drop.
     * 
     * TODO FloatingAnchor could totally be refactored to extend Anchor just slightly.
     */
    jsPlumb.FloatingAnchor = function(params) {
        
        jsPlumb.Anchor.apply(this, arguments);

        // this is the anchor that this floating anchor is referenced to for
        // purposes of calculating the orientation.
        var ref = params.reference,
            jpcl = jsPlumb.CurrentLibrary,
            jsPlumbInstance = params.jsPlumbInstance,
            // the canvas this refers to.
            refCanvas = params.referenceCanvas,
            size = jpcl.getSize(jpcl.getElementObject(refCanvas)),                

        // these are used to store the current relative position of our
        // anchor wrt the reference anchor. they only indicate
        // direction, so have a value of 1 or -1 (or, very rarely, 0). these
        // values are written by the compute method, and read
        // by the getOrientation method.
        xDir = 0, yDir = 0,
        // temporary member used to store an orientation when the floating
        // anchor is hovering over another anchor.
        orientation = null,
        _lastResult = null;

        // set these to 0 each; they are used by certain types of connectors in the loopback case,
        // when the connector is trying to clear the element it is on. but for floating anchor it's not
        // very important.
        this.x = 0; this.y = 0;

        this.isFloating = true;

        this.compute = function(params) {
            var xy = params.xy, element = params.element,
            result = [ xy[0] + (size[0] / 2), xy[1] + (size[1] / 2) ]; // return origin of the element. we may wish to improve this so that any object can be the drag proxy.
                        
            // adjust loc if there is an offsetParent
            result = jsPlumbInstance.adjustForParentOffsetAndScroll(result, element.canvas);
            
            _lastResult = result;
            return result;
        };

        this.getOrientation = function(_endpoint) {
            if (orientation) return orientation;
            else {
                var o = ref.getOrientation(_endpoint);
                // here we take into account the orientation of the other
                // anchor: if it declares zero for some direction, we declare zero too. this might not be the most awesome. perhaps we can come
                // up with a better way. it's just so that the line we draw looks like it makes sense. maybe this wont make sense.
                return [ Math.abs(o[0]) * xDir * -1,
                        Math.abs(o[1]) * yDir * -1 ];
            }
        };

        /**
         * notification the endpoint associated with this anchor is hovering
         * over another anchor; we want to assume that anchor's orientation
         * for the duration of the hover.
         */
        this.over = function(anchor) { 
            orientation = anchor.getOrientation(); 
        };

        /**
         * notification the endpoint associated with this anchor is no
         * longer hovering over another anchor; we should resume calculating
         * orientation as we normally do.
         */
        this.out = function() { orientation = null; };

        this.getCurrentLocation = function() { return _lastResult; };
    };

    /* 
     * A DynamicAnchor is an Anchor that contains a list of other Anchors, which it cycles
     * through at compute time to find the one that is located closest to
     * the center of the target element, and returns that Anchor's compute
     * method result. this causes endpoints to follow each other with
     * respect to the orientation of their target elements, which is a useful
     * feature for some applications.
     * 
     */
    jsPlumb.DynamicAnchor = function(params) {
        jsPlumb.Anchor.apply(this, arguments);
        
        this.isSelective = true;
        this.isDynamic = true;			
        var _anchors = [], self = this,            
            _convert = function(anchor) { 
                return anchor.constructor == jsPlumb.Anchor ? anchor: params.jsPlumbInstance.makeAnchor(anchor, params.elementId, params.jsPlumbInstance); 
            };

        for (var i = 0; i < params.anchors.length; i++) 
            _anchors[i] = _convert(params.anchors[i]);			
        this.addAnchor = function(anchor) { _anchors.push(_convert(anchor)); };
        this.getAnchors = function() { return _anchors; };
        this.locked = false;
        var _curAnchor = _anchors.length > 0 ? _anchors[0] : null,
            _curIndex = _anchors.length > 0 ? 0 : -1,
            _lastAnchor = _curAnchor,
            self = this,
        
            // helper method to calculate the distance between the centers of the two elements.
            _distance = function(anchor, cx, cy, xy, wh) {
                var ax = xy[0] + (anchor.x * wh[0]), ay = xy[1] + (anchor.y * wh[1]),				
                    acx = xy[0] + (wh[0] / 2), acy = xy[1] + (wh[1] / 2);
                return (Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) +
                        Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2)));
            },        
            // default method uses distance between element centers.  you can provide your own method in the dynamic anchor
            // constructor (and also to jsPlumb.makeDynamicAnchor). the arguments to it are four arrays: 
            // xy - xy loc of the anchor's element
            // wh - anchor's element's dimensions
            // txy - xy loc of the element of the other anchor in the connection
            // twh - dimensions of the element of the other anchor in the connection.
            // anchors - the list of selectable anchors
            _anchorSelector = params.selector || function(xy, wh, txy, twh, anchors) {
                var cx = txy[0] + (twh[0] / 2), cy = txy[1] + (twh[1] / 2);
                var minIdx = -1, minDist = Infinity;
                for ( var i = 0; i < anchors.length; i++) {
                    var d = _distance(anchors[i], cx, cy, xy, wh);
                    if (d < minDist) {
                        minIdx = i + 0;
                        minDist = d;
                    }
                }
                return anchors[minIdx];
            };
        
        this.compute = function(params) {				
            var xy = params.xy, wh = params.wh, timestamp = params.timestamp, txy = params.txy, twh = params.twh;				
            
            if(params.clearUserDefinedLocation)
                userDefinedLocation = null;
            
            var udl = self.getUserDefinedLocation();
            if (udl != null) {
                return udl;
            }
            
            // if anchor is locked or an opposite element was not given, we
            // maintain our state. anchor will be locked
            // if it is the source of a drag and drop.
            if (self.locked || txy == null || twh == null)
                return _curAnchor.compute(params);				
            else
                params.timestamp = null; // otherwise clear this, i think. we want the anchor to compute.
            
            _curAnchor = _anchorSelector(xy, wh, txy, twh, _anchors);
            self.x = _curAnchor.x;
            self.y = _curAnchor.y;        

            if (_curAnchor != _lastAnchor)
                self.fire("anchorChanged", _curAnchor);

            _lastAnchor = _curAnchor;
            
            return _curAnchor.compute(params);
        };

        this.getCurrentLocation = function() {
            return self.getUserDefinedLocation() || (_curAnchor != null ? _curAnchor.getCurrentLocation() : null);
        };

        this.getOrientation = function(_endpoint) { return _curAnchor != null ? _curAnchor.getOrientation(_endpoint) : [ 0, 0 ]; };
        this.over = function(anchor) { if (_curAnchor != null) _curAnchor.over(anchor); };
        this.out = function() { if (_curAnchor != null) _curAnchor.out(); };

        this.getCssClass = function() { return (_curAnchor && _curAnchor.getCssClass()) || ""; };
    };            
    
// -------- basic anchors ------------------    
    var _curryAnchor = function(x, y, ox, oy, type, fnInit) {
        jsPlumb.Anchors[type] = function(params) {
            var a = params.jsPlumbInstance.makeAnchor([ x, y, ox, oy, 0, 0 ], params.elementId, params.jsPlumbInstance);
            a.type = type;
            if (fnInit) fnInit(a, params);
            return a;
        };
    };
    	
	_curryAnchor(0.5, 0, 0,-1, "TopCenter");
    _curryAnchor(0.5, 1, 0, 1, "BottomCenter");
    _curryAnchor(0, 0.5, -1, 0, "LeftMiddle");
    _curryAnchor(1, 0.5, 1, 0, "RightMiddle");
    // from 1.4.1: Top, Right, Bottom, Left
    _curryAnchor(0.5, 0, 0,-1, "Top");
    _curryAnchor(0.5, 1, 0, 1, "Bottom");
    _curryAnchor(0, 0.5, -1, 0, "Left");
    _curryAnchor(1, 0.5, 1, 0, "Right");
    _curryAnchor(0.5, 0.5, 0, 0, "Center");
    _curryAnchor(1, 0, 0,-1, "TopRight");
    _curryAnchor(1, 1, 0, 1, "BottomRight");
    _curryAnchor(0, 0, 0, -1, "TopLeft");
    _curryAnchor(0, 1, 0, 1, "BottomLeft");
    
// ------- dynamic anchors -------------------    
			
    // default dynamic anchors chooses from Top, Right, Bottom, Left
	jsPlumb.Defaults.DynamicAnchors = function(params) {
		return params.jsPlumbInstance.makeAnchors(["TopCenter", "RightMiddle", "BottomCenter", "LeftMiddle"], params.elementId, params.jsPlumbInstance);
	};
    
    // default dynamic anchors bound to name 'AutoDefault'
	jsPlumb.Anchors["AutoDefault"]  = function(params) { 
		var a = params.jsPlumbInstance.makeDynamicAnchor(jsPlumb.Defaults.DynamicAnchors(params));
		a.type = "AutoDefault";
		return a;
	};	
    
// ------- continuous anchors -------------------    
    
    var _curryContinuousAnchor = function(type, faces) {
        jsPlumb.Anchors[type] = function(params) {
            var a = params.jsPlumbInstance.makeAnchor(["Continuous", { faces:faces }], params.elementId, params.jsPlumbInstance);
            a.type = type;
            return a;
        };
    };
    
    jsPlumb.Anchors["Continuous"] = function(params) {
		return params.jsPlumbInstance.continuousAnchorFactory.get(params);
	};
                
    _curryContinuousAnchor("ContinuousLeft", ["left"]);    
    _curryContinuousAnchor("ContinuousTop", ["top"]);                 
    _curryContinuousAnchor("ContinuousBottom", ["bottom"]);                 
    _curryContinuousAnchor("ContinuousRight", ["right"]); 
    
// ------- position assign anchors -------------------    
    
    // this anchor type lets you assign the position at connection time.
	jsPlumb.Anchors["Assign"] = _curryAnchor(0, 0, 0, 0, "Assign", function(anchor, params) {
		// find what to use as the "position finder". the user may have supplied a String which represents
		// the id of a position finder in jsPlumb.AnchorPositionFinders, or the user may have supplied the
		// position finder as a function.  we find out what to use and then set it on the anchor.
		var pf = params.position || "Fixed";
		anchor.positionFinder = pf.constructor == String ? params.jsPlumbInstance.AnchorPositionFinders[pf] : pf;
		// always set the constructor params; the position finder might need them later (the Grid one does,
		// for example)
		anchor.constructorParams = params;
	});	

    // these are the default anchor positions finders, which are used by the makeTarget function.  supplying
    // a position finder argument to that function allows you to specify where the resulting anchor will
    // be located
	jsPlumb.AnchorPositionFinders = {
		"Fixed": function(dp, ep, es, params) {
			return [ (dp.left - ep.left) / es[0], (dp.top - ep.top) / es[1] ];	
		},
		"Grid":function(dp, ep, es, params) {
			var dx = dp.left - ep.left, dy = dp.top - ep.top,
				gx = es[0] / (params.grid[0]), gy = es[1] / (params.grid[1]),
				mx = Math.floor(dx / gx), my = Math.floor(dy / gy);
			return [ ((mx * gx) + (gx / 2)) / es[0], ((my * gy) + (gy / 2)) / es[1] ];
		}
	};
    
// ------- perimeter anchors -------------------    
		
	jsPlumb.Anchors["Perimeter"] = function(params) {
		params = params || {};
		var anchorCount = params.anchorCount || 60,
			shape = params.shape;
		
		if (!shape) throw new Error("no shape supplied to Perimeter Anchor type");		
		
		var _circle = function() {
                var r = 0.5, step = Math.PI * 2 / anchorCount, current = 0, a = [];
                for (var i = 0; i < anchorCount; i++) {
                    var x = r + (r * Math.sin(current)),
                        y = r + (r * Math.cos(current));                                
                    a.push( [ x, y, 0, 0 ] );
                    current += step;
                }
                return a;	
            },
            _path = function(segments) {
                var anchorsPerFace = anchorCount / segments.length, a = [],
                    _computeFace = function(x1, y1, x2, y2, fractionalLength) {
                        anchorsPerFace = anchorCount * fractionalLength;
                        var dx = (x2 - x1) / anchorsPerFace, dy = (y2 - y1) / anchorsPerFace;
                        for (var i = 0; i < anchorsPerFace; i++) {
                            a.push( [
                                x1 + (dx * i),
                                y1 + (dy * i),
                                0,
                                0
                            ]);
                        }
                    };
								
                for (var i = 0; i < segments.length; i++)
                    _computeFace.apply(null, segments[i]);
														
                return a;					
            },
			_shape = function(faces) {												
                var s = [];
                for (var i = 0; i < faces.length; i++) {
                    s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length]);
                }
                return _path(s);
			},
			_rectangle = function() {
				return _shape([
					[ 0, 0, 1, 0 ], [ 1, 0, 1, 1 ], [ 1, 1, 0, 1 ], [ 0, 1, 0, 0 ]
				]);		
			};
		
		var _shapes = {
			"Circle":_circle,
			"Ellipse":_circle,
			"Diamond":function() {
				return _shape([
						[ 0.5, 0, 1, 0.5 ], [ 1, 0.5, 0.5, 1 ], [ 0.5, 1, 0, 0.5 ], [ 0, 0.5, 0.5, 0 ]
				]);
			},
			"Rectangle":_rectangle,
			"Square":_rectangle,
			"Triangle":function() {
				return _shape([
						[ 0.5, 0, 1, 1 ], [ 1, 1, 0, 1 ], [ 0, 1, 0.5, 0]
				]);	
			},
			"Path":function(params) {
                var points = params.points, p = [], tl = 0;
				for (var i = 0; i < points.length - 1; i++) {
                    var l = Math.sqrt(Math.pow(points[i][2] - points[i][0]) + Math.pow(points[i][3] - points[i][1]));
                    tl += l;
					p.push([points[i][0], points[i][1], points[i+1][0], points[i+1][1], l]);						
				}
                for (var i = 0; i < p.length; i++) {
                    p[i][4] = p[i][4] / tl;
                }
				return _path(p);
			}
		},
        _rotate = function(points, amountInDegrees) {
            var o = [], theta = amountInDegrees / 180 * Math.PI ;
            for (var i = 0; i < points.length; i++) {
                var _x = points[i][0] - 0.5,
                    _y = points[i][1] - 0.5;
                    
                o.push([
                    0.5 + ((_x * Math.cos(theta)) - (_y * Math.sin(theta))),
                    0.5 + ((_x * Math.sin(theta)) + (_y * Math.cos(theta))),
                    points[i][2],
                    points[i][3]
                ]);
            }
            return o;
        };
		
		if (!_shapes[shape]) throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");
		
		var da = _shapes[shape](params);
        if (params.rotation) da = _rotate(da, params.rotation);
        var a = params.jsPlumbInstance.makeDynamicAnchor(da);
		a.type = "Perimeter";
		return a;
	};
})();;(function() {
        
    // create the drag handler for a connection
    var _makeConnectionDragHandler = function(placeholder, _jsPlumb) {
        var stopped = false;
        return {
            drag : function() {
                if (stopped) {
                    stopped = false;
                    return true;
                }
                var _ui = jsPlumb.CurrentLibrary.getUIPosition(arguments, _jsPlumb.getZoom());
        
                if (placeholder.element) {
                    jsPlumb.CurrentLibrary.setOffset(placeholder.element, _ui);                    
                    _jsPlumb.repaint(placeholder.element, _ui);
                }
            },
            stopDrag : function() {
                stopped = true;
            }
        };
    };
        
    // creates a placeholder div for dragging purposes, adds it to the DOM, and pre-computes its offset.    
    var _makeDraggablePlaceholder = function(placeholder, parent, _jsPlumb) {
        var n = document.createElement("div");
        n.style.position = "absolute";
        var placeholderDragElement = jsPlumb.CurrentLibrary.getElementObject(n);
        jsPlumb.CurrentLibrary.appendElement(n, parent);
        var id = _jsPlumb.getId(placeholderDragElement);
        _jsPlumb.updateOffset( { elId : id });
        // create and assign an id, and initialize the offset.
        placeholder.id = id;
        placeholder.element = placeholderDragElement;
    };
    
    // create a floating endpoint (for drag connections)
    var _makeFloatingEndpoint = function(paintStyle, referenceAnchor, endpoint, referenceCanvas, sourceElement, _jsPlumb, _newEndpoint) {			
        var floatingAnchor = new jsPlumb.FloatingAnchor( { reference : referenceAnchor, referenceCanvas : referenceCanvas, jsPlumbInstance:_jsPlumb });
        //setting the scope here should not be the way to fix that mootools issue.  it should be fixed by not
        // adding the floating endpoint as a droppable.  that makes more sense anyway!
        return _newEndpoint({ paintStyle : paintStyle, endpoint : endpoint, anchor : floatingAnchor, source : sourceElement, scope:"__floating" });
    };

    var typeParameters = [ "connectorStyle", "connectorHoverStyle", "connectorOverlays",
                "connector", "connectionType", "connectorClass", "connectorHoverClass" ];

    jsPlumb.Endpoint = function(params) {
        var self = this, 
            _jsPlumb = params["_jsPlumb"],
            jpcl = jsPlumb.CurrentLibrary,
            _att = jpcl.getAttribute,
            _gel = jpcl.getElementObject,
            _ju = jsPlumbUtil,
            _getOffset = jpcl.getOffset,
            _newConnection = params.newConnection,
            _newEndpoint = params.newEndpoint,
            _finaliseConnection = params.finaliseConnection,
            _fireDetachEvent = params.fireDetachEvent,
            floatingConnections = params.floatingConnections;
        
        self.idPrefix = "_jsplumb_e_";			
        self.defaultLabelLocation = [ 0.5, 0.5 ];
        self.defaultOverlayKeys = ["Overlays", "EndpointOverlays"];
        this.parent = params.parent;
        overlayCapableJsPlumbUIComponent.apply(this, arguments);
        params = params || {};
        
// TYPE		
        
        this.getTypeDescriptor = function() { return "endpoint"; };
        this.getDefaultType = function() {								
            return {
                parameters:{},
                scope:null,
                maxConnections:self._jsPlumb.Defaults.MaxConnections,
                paintStyle:self._jsPlumb.Defaults.EndpointStyle || jsPlumb.Defaults.EndpointStyle,
                endpoint:self._jsPlumb.Defaults.Endpoint || jsPlumb.Defaults.Endpoint,
                hoverPaintStyle:self._jsPlumb.Defaults.EndpointHoverStyle || jsPlumb.Defaults.EndpointHoverStyle,				
                overlays:self._jsPlumb.Defaults.EndpointOverlays || jsPlumb.Defaults.EndpointOverlays,
                connectorStyle:params.connectorStyle,				
                connectorHoverStyle:params.connectorHoverStyle,
                connectorClass:params.connectorClass,
                connectorHoverClass:params.connectorHoverClass,
                connectorOverlays:params.connectorOverlays,
                connector:params.connector,
                connectorTooltip:params.connectorTooltip
            };
        };
        var superAt = this.applyType;
        this.applyType = function(t, doNotRepaint) {
            superAt(t, doNotRepaint);
            if (t.maxConnections != null) _maxConnections = t.maxConnections;
            if (t.scope) self.scope = t.scope;
            _ju.copyValues(typeParameters, t, self);
        };			
// END TYPE
    
        var visible = true, __enabled = !(params.enabled === false);
        
        this.isVisible = function() { return visible; };        
        this.setVisible = function(v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
            visible = v;
            if (self.canvas) self.canvas.style.display = v ? "block" : "none";
            self[v ? "showOverlays" : "hideOverlays"]();
            if (!doNotChangeConnections) {
                for (var i = 0; i < self.connections.length; i++) {
                    self.connections[i].setVisible(v);
                    if (!doNotNotifyOtherEndpoint) {
                        var oIdx = self === self.connections[i].endpoints[0] ? 1 : 0;
                        // only change the other endpoint if this is its only connection.
                        if (self.connections[i].endpoints[oIdx].connections.length == 1) self.connections[i].endpoints[oIdx].setVisible(v, true, true);
                    }
                }
            }
        };			
        
        this.isEnabled = function() { return __enabled; };
        this.setEnabled = function(e) { __enabled = e; };

        var _element = params.source,  _uuid = params.uuid, floatingEndpoint = null,  inPlaceCopy = null;
        if (_uuid) params.endpointsByUUID[_uuid] = self;
        var _elementId = _att(_element, "id");
        this.elementId = _elementId;
        this.element = _element;
        
        self.setElementId = function(_elId) {
            _elementId = _elId;
            self.elementId = _elId;
            self.anchor.elementId = _elId
        };
        
        self.setReferenceElement = function(_el) {
            _element = _el;
            self.element = _el;
        };
        
        var _connectionCost = params.connectionCost;
        this.getConnectionCost = function() { return _connectionCost; };
        this.setConnectionCost = function(c) {
            _connectionCost = c; 
        };
        
        var _connectionsDirected = params.connectionsDirected;
        this.areConnectionsDirected = function() { return _connectionsDirected; };
        this.setConnectionsDirected = function(b) { _connectionsDirected = b; };                        

        var _currentAnchorClass = "",
            _updateAnchorClass = function() {
                jpcl.removeClass(_element, _jsPlumb.endpointAnchorClassPrefix + "_" + _currentAnchorClass);
                self.removeClass(_jsPlumb.endpointAnchorClassPrefix + "_" + _currentAnchorClass);
                _currentAnchorClass = self.anchor.getCssClass();
                self.addClass(_jsPlumb.endpointAnchorClassPrefix + "_" + _currentAnchorClass);
                jpcl.addClass(_element, _jsPlumb.endpointAnchorClassPrefix + "_" + _currentAnchorClass);
            };

        this.setAnchor = function(anchorParams, doNotRepaint) {
            self.anchor = _jsPlumb.makeAnchor(anchorParams, _elementId, _jsPlumb);
            _updateAnchorClass();
            self.anchor.bind("anchorChanged", function(currentAnchor) {
                self.fire("anchorChanged", {endpoint:self, anchor:currentAnchor});
                _updateAnchorClass();
            });
            if (!doNotRepaint)
                _jsPlumb.repaint(_elementId);
        };

        this.cleanup = function() {
            jpcl.removeClass(_element, _jsPlumb.endpointAnchorClassPrefix + "_" + _currentAnchorClass);
        };

        var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : (_jsPlumb.Defaults.Anchor || "Top");
        self.setAnchor(anchorParamsToUse, true);
            
        // ANCHOR MANAGER
        if (!params._transient) // in place copies, for example, are transient.  they will never need to be retrieved during a paint cycle, because they dont move, and then they are deleted.
            _jsPlumb.anchorManager.add(self, _elementId);

        var _endpoint = null, originalEndpoint = null;
        this.setEndpoint = function(ep) {

            var _e = function(t, p) {
                var rm = _jsPlumb.getRenderMode();
                if (jsPlumb.Endpoints[rm][t]) return new jsPlumb.Endpoints[rm][t](p);
                if (!_jsPlumb.Defaults.DoNotThrowErrors)
                    throw { msg:"jsPlumb: unknown endpoint type '" + t + "'" };
            };            

            var endpointArgs = {
                _jsPlumb:self._jsPlumb,
                cssClass:params.cssClass,
                parent:params.parent,
                container:params.container,
                tooltip:params.tooltip,
                connectorTooltip:params.connectorTooltip,
                endpoint:self
            };
            if (_ju.isString(ep)) 
                _endpoint = _e(ep, endpointArgs);
            else if (_ju.isArray(ep)) {
                endpointArgs = _ju.merge(ep[1], endpointArgs);
                _endpoint = _e(ep[0], endpointArgs);
            }
            else {
                _endpoint = ep.clone();
            }

            // assign a clone function using a copy of endpointArgs. this is used when a drag starts: the endpoint that was dragged is cloned,
            // and the clone is left in its place while the original one goes off on a magical journey. 
            // the copy is to get around a closure problem, in which endpointArgs ends up getting shared by
            // the whole world.
            var argsForClone = jsPlumb.extend({}, endpointArgs);						
            _endpoint.clone = function() {
                var o = new Object();
                _endpoint.constructor.apply(o, [argsForClone]);
                return o;
            };

            self.endpoint = _endpoint;
            self.type = self.endpoint.type;
        };
         
        this.setEndpoint(params.endpoint || _jsPlumb.Defaults.Endpoint || jsPlumb.Defaults.Endpoint || "Dot");							
        originalEndpoint = _endpoint;        

        // override setHover to pass it down to the underlying endpoint
        var _sh = self.setHover;
        self.setHover = function() {
            self.endpoint.setHover.apply(self.endpoint, arguments);
            _sh.apply(self, arguments);
        };
        // endpoint delegates to first connection for hover, if there is one.
        var internalHover = function(state) {
          if (self.connections.length > 0)
            self.connections[0].setHover(state, false);
          else
            self.setHover(state);
        };
        
        // bind listeners from endpoint to self, with the internal hover function defined above.
        self.bindListeners(self.endpoint, self, internalHover);
                                
        this.setPaintStyle(params.paintStyle || 
                           params.style || 
                           _jsPlumb.Defaults.EndpointStyle || 
                           jsPlumb.Defaults.EndpointStyle, true);
        this.setHoverPaintStyle(params.hoverPaintStyle || 
                                _jsPlumb.Defaults.EndpointHoverStyle || 
                                jsPlumb.Defaults.EndpointHoverStyle, true);
        this.paintStyleInUse = this.getPaintStyle();
        var originalPaintStyle = this.getPaintStyle();

        _ju.copyValues(typeParameters, params, this);        

        this.isSource = params.isSource || false;
        this.isTarget = params.isTarget || false;
        
        var _maxConnections = params.maxConnections || _jsPlumb.Defaults.MaxConnections; // maximum number of connections this endpoint can be the source of.
                    
        this.getAttachedElements = function() {
            return self.connections;
        };
                    
        this.canvas = this.endpoint.canvas;		
        // add anchor class (need to do this on construction because we set anchor first)
        self.addClass(_jsPlumb.endpointAnchorClassPrefix + "_" + _currentAnchorClass);	
        jpcl.addClass(_element, _jsPlumb.endpointAnchorClassPrefix + "_" + _currentAnchorClass);
        this.connections = params.connections || [];
        this.connectorPointerEvents = params["connector-pointer-events"];
        
        this.scope = params.scope || _jsPlumb.getDefaultScope();        
        this.timestamp = null;
        self.reattachConnections = params.reattach || _jsPlumb.Defaults.ReattachConnections;
        self.connectionsDetachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.connectionsDetachable === false || params.detachable === false)
            self.connectionsDetachable = false;
        var dragAllowedWhenFull = params.dragAllowedWhenFull || true;
        
        if (params.onMaxConnections)
            self.bind("maxConnections", params.onMaxConnections);

        this.computeAnchor = function(params) {
            return self.anchor.compute(params);
        };
        
        this.addConnection = function(connection) {
            self.connections.push(connection);                  
            self[(self.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);       
            self[(self.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass); 
        };		        
        this.detach = function(connection, ignoreTarget, forceDetach, fireEvent, originalEvent) {
            var idx = _ju.findWithFunction(self.connections, function(c) { return c.id == connection.id}), 
                actuallyDetached = false;
            fireEvent = (fireEvent !== false);
            if (idx >= 0) {		
                // 1. does the connection have a before detach (note this also checks jsPlumb's bound
                // detach handlers; but then Endpoint's check will, too, hmm.)
                if (forceDetach || connection._forceDetach || connection.isDetachable() || connection.isDetachAllowed(connection)) {
                    // get the target endpoint
                    var t = connection.endpoints[0] == self ? connection.endpoints[1] : connection.endpoints[0];
                    if (forceDetach || connection._forceDetach || (self.isDetachAllowed(connection) /*&& t.isDetachAllowed(connection)*/)) {                
                        self.connections.splice(idx, 1);										
                        // avoid circular loop
                        if (!ignoreTarget) {                        
                            t.detach(connection, true, forceDetach);
                            // check connection to see if we want to delete the endpoints associated with it.
                            // we only detach those that have just this connection; this scenario is most
                            // likely if we got to this bit of code because it is set by the methods that
                            // create their own endpoints, like .connect or .makeTarget. the user is
                            // not likely to have interacted with those endpoints.
                            if (connection.endpointsToDeleteOnDetach){
                                for (var i = 0; i < connection.endpointsToDeleteOnDetach.length; i++) {
                                    var cde = connection.endpointsToDeleteOnDetach[i];
                                    if (cde && cde.connections.length == 0) 
                                        _jsPlumb.deleteEndpoint(cde);							
                                }
                            }
                        }
                        if (connection.getConnector() != null)
                            _ju.removeElements(connection.getConnector().getDisplayElements(), connection.parent);
                        _ju.removeWithFunction(params.connectionsByScope[connection.scope], function(c) {
                            return c.id == connection.id;
                        });
                        self[(self.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);       
                        self[(self.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass); 
                        actuallyDetached = true;                        
                        _fireDetachEvent(connection, (!ignoreTarget && fireEvent), originalEvent);
                    }
                }
            }
            return actuallyDetached;
        };			
        
        this.detachAll = function(fireEvent, originalEvent) {
            while (self.connections.length > 0) {
                self.detach(self.connections[0], false, true, fireEvent, originalEvent);
            }
            return self;
        };
            
        this.detachFrom = function(targetEndpoint, fireEvent, originalEvent) {
            var c = [];
            for ( var i = 0; i < self.connections.length; i++) {
                if (self.connections[i].endpoints[1] == targetEndpoint
                        || self.connections[i].endpoints[0] == targetEndpoint) {
                    c.push(self.connections[i]);
                }
            }
            for ( var i = 0; i < c.length; i++) {
                if (self.detach(c[i], false, true, fireEvent, originalEvent))
                    c[i].setHover(false, false);					
            }
            return self;
        };	
        
        this.detachFromConnection = function(connection) {
            var idx =  _ju.findWithFunction(self.connections, function(c) { return c.id == connection.id});
            if (idx >= 0) {
                self.connections.splice(idx, 1);
                self[(self.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);       
                self[(self.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass); 
            }
        };
        
        this.getElement = function() {
            return _element;
        };		
                 
        this.setElement = function(el, container) {
            var parentId = _jsPlumb.getId(el);
            // remove the endpoint from the list for the current endpoint's element
            _ju.removeWithFunction(params.endpointsByElement[self.elementId], function(e) {
                return e.id == self.id;
            });
            _element = _gel(el);
            _elementId = _jsPlumb.getId(_element);
            self.elementId = _elementId;
            // need to get the new parent now
            var newParentElement = params.getParentFromParams({source:parentId, container:container}),
            curParent = jpcl.getParent(self.canvas);
            jpcl.removeElement(self.canvas, curParent);
            jpcl.appendElement(self.canvas, newParentElement);								
            
            // now move connection(s)...i would expect there to be only one but we will iterate.
            for (var i = 0; i < self.connections.length; i++) {
                self.connections[i].moveParent(newParentElement);
                self.connections[i].sourceId = _elementId;
                self.connections[i].source = _element;					
            }	
            _ju.addToList(params.endpointsByElement, parentId, self);
            
        };
        
        this.getUuid = function() {
            return _uuid;
        };

        /**
         * private but must be exposed.
         */
        self.makeInPlaceCopy = function() {
            var loc = self.anchor.getCurrentLocation(self),
                o = self.anchor.getOrientation(self),
                acc = self.anchor.getCssClass(),
                inPlaceAnchor = {
                    bind:function() { },
                    compute:function() { return [ loc[0], loc[1] ]},
                    getCurrentLocation : function() { return [ loc[0], loc[1] ]},
                    getOrientation:function() { return o; },
                    getCssClass:function() { return acc; }
                };

            return _newEndpoint( { 
                anchor : inPlaceAnchor, 
                source : _element, 
                paintStyle : this.getPaintStyle(), 
                endpoint : params.hideOnDrag ? "Blank" : _endpoint,
                _transient:true,
                scope:self.scope
            });
        };
        
        this.isConnectedTo = function(endpoint) {
            var found = false;
            if (endpoint) {
                for ( var i = 0; i < self.connections.length; i++) {
                    if (self.connections[i].endpoints[1] == endpoint) {
                        found = true;
                        break;
                    }
                }
            }
            return found;
        };

        /**
         * private but needs to be exposed.
         */
        this.isFloating = function() {
            return floatingEndpoint != null;
        };
        
        /**
         * returns a connection from the pool; used when dragging starts.  just gets the head of the array if it can.
         */
        this.connectorSelector = function() {
            var candidate = self.connections[0];
            if (self.isTarget && candidate) return candidate;
            else {
                return (self.connections.length < _maxConnections) || _maxConnections == -1 ? null : candidate;
            }
        };
        
        this.isFull = function() {
            return !(self.isFloating() || _maxConnections < 1 || self.connections.length < _maxConnections);				
        };
                    
        this.setDragAllowedWhenFull = function(allowed) {
            dragAllowedWhenFull = allowed;
        };
            
        
        this.setStyle = self.setPaintStyle;

        /**
         * a deep equals check. everything must match, including the anchor,
         * styles, everything. TODO: finish Endpoint.equals
         */
        this.equals = function(endpoint) {
            return this.anchor.equals(endpoint.anchor);
        };
        
        // a helper function that tries to find a connection to the given element, and returns it if so. if elementWithPrecedence is null,
        // or no connection to it is found, we return the first connection in our list.
        var findConnectionToUseForDynamicAnchor = function(elementWithPrecedence) {
            var idx = 0;
            if (elementWithPrecedence != null) {
                for (var i = 0; i < self.connections.length; i++) {
                    if (self.connections[i].sourceId == elementWithPrecedence || self.connections[i].targetId == elementWithPrecedence) {
                        idx = i;
                        break;
                    }
                }
            }
            
            return self.connections[idx];
        };
        
        this.paint = function(params) {
            params = params || {};
            var timestamp = params.timestamp, recalc = !(params.recalc === false);								
            if (!timestamp || self.timestamp !== timestamp) {						
                var info = _jsPlumb.updateOffset({ elId:_elementId, timestamp:timestamp, recalc:recalc });
                var xy = params.offset ? params.offset.o : info.o;
                if(xy) {
                    var ap = params.anchorPoint,connectorPaintStyle = params.connectorPaintStyle;
                    if (ap == null) {
                        var wh = params.dimensions || info.s;
                        if (xy == null || wh == null) {
                            info = _jsPlumb.updateOffset( { elId : _elementId, timestamp : timestamp });
                            xy = info.o;
                            wh = info.s;
                        }
                        var anchorParams = { xy : [ xy.left, xy.top ], wh : wh, element : self, timestamp : timestamp };
                        if (recalc && self.anchor.isDynamic && self.connections.length > 0) {
                            var c = findConnectionToUseForDynamicAnchor(params.elementWithPrecedence),
                                oIdx = c.endpoints[0] == self ? 1 : 0,
                                oId = oIdx == 0 ? c.sourceId : c.targetId,
                                oInfo = _jsPlumb.getCachedData(oId),
                                oOffset = oInfo.o, oWH = oInfo.s;
                            if(!oOffset) { _jsPlumb.detachEveryConnection(); return false; }
                            anchorParams.txy = [ oOffset.left, oOffset.top ];
                            anchorParams.twh = oWH;
                            anchorParams.tElement = c.endpoints[oIdx];
                        }
                        ap = self.anchor.compute(anchorParams);
                    }
                                        
                    _endpoint.compute(ap, self.anchor.getOrientation(self), self.paintStyleInUse, connectorPaintStyle || self.paintStyleInUse);
                    _endpoint.paint(self.paintStyleInUse, self.anchor);					
                    self.timestamp = timestamp;

                    // paint overlays
                    for ( var i = 0; i < self.overlays.length; i++) {
                        var o = self.overlays[i];
                        if (o.isVisible()) { 
                            self.overlayPlacements[i] = o.draw(self.endpoint, self.paintStyleInUse);
                            o.paint(self.overlayPlacements[i]);    
                        }
                    }
                }
            }
        };

        this.repaint = this.paint;        

        // is this a connection source? we make it draggable and have the
        // drag listener maintain a connection with a floating endpoint.
        if (jpcl.isDragSupported(_element)) {
            var placeholderInfo = { id:null, element:null },
                jpc = null,
                existingJpc = false,
                existingJpcParams = null,
                _dragHandler = _makeConnectionDragHandler(placeholderInfo, _jsPlumb);

            var start = function() {	
            // drag might have started on an endpoint that is not actually a source, but which has
            // one or more connections.
                jpc = self.connectorSelector();
                var _continue = true;
                // if not enabled, return
                if (!self.isEnabled()) _continue = false;
                // if no connection and we're not a source, return.
                if (jpc == null && !params.isSource) _continue = false;
                // otherwise if we're full and not allowed to drag, also return false.
                if (params.isSource && self.isFull() && !dragAllowedWhenFull) _continue = false;
                // if the connection was setup as not detachable or one of its endpoints
                // was setup as connectionsDetachable = false, or Defaults.ConnectionsDetachable
                // is set to false...
                if (jpc != null && !jpc.isDetachable()) _continue = false;

                if (_continue === false) {
                    // this is for mootools and yui. returning false from this causes jquery to stop drag.
                    // the events are wrapped in both mootools and yui anyway, but i don't think returning
                    // false from the start callback would stop a drag.
                    if (jpcl.stopDrag) jpcl.stopDrag();
                    _dragHandler.stopDrag();
                    return false;
                }

                self.addClass("endpointDrag");

                // if we're not full but there was a connection, make it null. we'll create a new one.
                if (jpc && !self.isFull() && params.isSource) jpc = null;

                _jsPlumb.updateOffset( { elId : _elementId });
                inPlaceCopy = self.makeInPlaceCopy();
                inPlaceCopy.referenceEndpoint = self;
                inPlaceCopy.paint();																
                
                _makeDraggablePlaceholder(placeholderInfo, self.parent, _jsPlumb);
                
                // set the offset of this div to be where 'inPlaceCopy' is, to start with.
                // TODO merge this code with the code in both Anchor and FloatingAnchor, because it
                // does the same stuff.
                var ipcoel = _gel(inPlaceCopy.canvas),
                    ipco = _getOffset(ipcoel, _jsPlumb),
                    po = _jsPlumb.adjustForParentOffsetAndScroll([ipco.left, ipco.top], inPlaceCopy.canvas),
                    canvasElement = _gel(self.canvas);                               
                    
                jpcl.setOffset(placeholderInfo.element, {left:po[0], top:po[1]});															
                
                // when using makeSource and a parent, we first draw the source anchor on the source element, then
                // move it to the parent.  note that this happens after drawing the placeholder for the
                // first time.
                if (self.parentAnchor) self.anchor = _jsPlumb.makeAnchor(self.parentAnchor, self.elementId, _jsPlumb);
                
                // store the id of the dragging div and the source element. the drop function will pick these up.					
                jpcl.setAttribute(canvasElement, "dragId", placeholderInfo.id);
                jpcl.setAttribute(canvasElement, "elId", _elementId);
                floatingEndpoint = _makeFloatingEndpoint(self.getPaintStyle(), self.anchor, _endpoint, self.canvas, placeholderInfo.element, _jsPlumb, _newEndpoint);
                self.canvas.style.visibility = "hidden";            
                
                if (jpc == null) {                                                                                                                                                         
                    self.anchor.locked = true;
                    self.setHover(false, false);                        
                    // create a connection. one end is this endpoint, the other is a floating endpoint.                    
                    jpc = _newConnection({
                        sourceEndpoint : self,
                        targetEndpoint : floatingEndpoint,
                        source : self.endpointWillMoveTo || _element,  // for makeSource with parent option.  ensure source element is represented correctly.
                        target : placeholderInfo.element,
                        anchors : [ self.anchor, floatingEndpoint.anchor ],
                        paintStyle : params.connectorStyle, // this can be null. Connection will use the default.
                        hoverPaintStyle:params.connectorHoverStyle,
                        connector : params.connector, // this can also be null. Connection will use the default.
                        overlays : params.connectorOverlays,
                        type:self.connectionType,
                        cssClass:self.connectorClass,
                        hoverClass:self.connectorHoverClass
                    });
                    jpc.addClass(_jsPlumb.draggingClass);
                    floatingEndpoint.addClass(_jsPlumb.draggingClass);
                    // fire an event that informs that a connection is being dragged						
                    _jsPlumb.fire("connectionDrag", jpc);

                } else {
                    existingJpc = true;
                    jpc.setHover(false);						
                    // if existing connection, allow to be dropped back on the source endpoint (issue 51).
                    _initDropTarget(ipcoel, false, true);
                    // new anchor idx
                    var anchorIdx = jpc.endpoints[0].id == self.id ? 0 : 1;
                    jpc.floatingAnchorIndex = anchorIdx;					// save our anchor index as the connection's floating index.						
                    self.detachFromConnection(jpc);							// detach from the connection while dragging is occurring.
                    
                    // store the original scope (issue 57)
                    var dragScope = jsPlumb.CurrentLibrary.getDragScope(canvasElement);
                    jpcl.setAttribute(canvasElement, "originalScope", dragScope);
                    // now we want to get this endpoint's DROP scope, and set it for now: we can only be dropped on drop zones
                    // that have our drop scope (issue 57).
                    var dropScope = jpcl.getDropScope(canvasElement);
                    jpcl.setDragScope(canvasElement, dropScope);
            
                    // now we replace ourselves with the temporary div we created above:
                    if (anchorIdx == 0) {
                        existingJpcParams = [ jpc.source, jpc.sourceId, i, dragScope ];
                        jpc.source = placeholderInfo.element;
                        jpc.sourceId = placeholderInfo.id;
                    } else {
                        existingJpcParams = [ jpc.target, jpc.targetId, i, dragScope ];
                        jpc.target = placeholderInfo.element;
                        jpc.targetId = placeholderInfo.id;
                    }

                    // lock the other endpoint; if it is dynamic it will not move while the drag is occurring.
                    jpc.endpoints[anchorIdx == 0 ? 1 : 0].anchor.locked = true;
                    // store the original endpoint and assign the new floating endpoint for the drag.
                    jpc.suspendedEndpoint = jpc.endpoints[anchorIdx];
                    
                    // PROVIDE THE SUSPENDED ELEMENT, BE IT A SOURCE OR TARGET (ISSUE 39)
                    jpc.suspendedElement = jpc.endpoints[anchorIdx].getElement();
                    jpc.suspendedElementId = jpc.endpoints[anchorIdx].elementId;
                    jpc.suspendedElementType = anchorIdx == 0 ? "source" : "target";
                    
                    jpc.suspendedEndpoint.setHover(false);
                    floatingEndpoint.referenceEndpoint = jpc.suspendedEndpoint;
                    jpc.endpoints[anchorIdx] = floatingEndpoint;

                    jpc.addClass(_jsPlumb.draggingClass);
                    floatingEndpoint.addClass(_jsPlumb.draggingClass);
                    // fire an event that informs that a connection is being dragged
                    _jsPlumb.fire("connectionDrag", jpc);

                }
                // register it and register connection on it.
                floatingConnections[placeholderInfo.id] = jpc;
                _jsPlumb.anchorManager.addFloatingConnection(placeholderInfo.id, jpc);
                floatingEndpoint.addConnection(jpc);
                // only register for the target endpoint; we will not be dragging the source at any time
                // before this connection is either discarded or made into a permanent connection.
                _ju.addToList(params.endpointsByElement, placeholderInfo.id, floatingEndpoint);
                // tell jsplumb about it
                _jsPlumb.currentlyDragging = true;
            };

            var dragOptions = params.dragOptions || {},
                defaultOpts = jsPlumb.extend( {}, jpcl.defaultDragOptions),
                startEvent = jpcl.dragEvents["start"],
                stopEvent = jpcl.dragEvents["stop"],
                dragEvent = jpcl.dragEvents["drag"];
            
            dragOptions = jsPlumb.extend(defaultOpts, dragOptions);
            dragOptions.scope = dragOptions.scope || self.scope;
            dragOptions[startEvent] = _jsPlumb.wrap(dragOptions[startEvent], start);
            // extracted drag handler function so can be used by makeSource
            dragOptions[dragEvent] = _jsPlumb.wrap(dragOptions[dragEvent], _dragHandler.drag);
            dragOptions[stopEvent] = _jsPlumb.wrap(dragOptions[stopEvent],
                function() {
                    var originalEvent = jpcl.getDropEvent(arguments);					
                    _ju.removeWithFunction(params.endpointsByElement[placeholderInfo.id], function(e) {
                        return e.id == floatingEndpoint.id;
                    });
                    _ju.removeElement(inPlaceCopy.canvas, _element);
                    _jsPlumb.anchorManager.clearFor(placeholderInfo.id);						
                    var idx = jpc.floatingAnchorIndex == null ? 1 : jpc.floatingAnchorIndex;
                    jpc.endpoints[idx == 0 ? 1 : 0].anchor.locked = false;
                
                // commented out pending decision on drag proxy stuff.
                //	self.setPaintStyle(originalPaintStyle); // reset to original; may have been changed by drag proxy.
                
                    if (jpc.endpoints[idx] == floatingEndpoint) {
                        // if the connection was an existing one:
                        if (existingJpc && jpc.suspendedEndpoint) {
                            // fix for issue35, thanks Sylvain Gizard: when firing the detach event make sure the
                            // floating endpoint has been replaced.
                            if (idx == 0) {
                                jpc.source = existingJpcParams[0];
                                jpc.sourceId = existingJpcParams[1];
                            } else {
                                jpc.target = existingJpcParams[0];
                                jpc.targetId = existingJpcParams[1];
                            }
                            
                            // restore the original scope (issue 57)
                            jpcl.setDragScope(existingJpcParams[2], existingJpcParams[3]);
                            jpc.endpoints[idx] = jpc.suspendedEndpoint;
                            if (jpc.isReattach() || jpc._forceReattach || jpc._forceDetach || !jpc.endpoints[idx == 0 ? 1 : 0].detach(jpc, false, false, true, originalEvent)) {									
                                jpc.setHover(false);
                                jpc.floatingAnchorIndex = null;
                                jpc.suspendedEndpoint.addConnection(jpc);
                                _jsPlumb.repaint(existingJpcParams[1]);
                            }
                            jpc._forceDetach = null;
                            jpc._forceReattach = null;
                        } else {
                            // TODO this looks suspiciously kind of like an Endpoint.detach call too.
                            // i wonder if this one should post an event though.  maybe this is good like this.
                            _ju.removeElements(jpc.getConnector().getDisplayElements(), self.parent);
                            self.detachFromConnection(jpc);								
                        }																
                    }
                    
                    // remove floating endpoint _after_ checking beforeDetach 
                    _ju.removeElements( [ placeholderInfo.element[0], floatingEndpoint.canvas ], _element); // TODO: clean up the connection canvas (if the user aborted)
                    _jsPlumb.dragManager.elementRemoved(floatingEndpoint.elementId);
                    self.canvas.style.visibility = "visible";
                    
                    self.anchor.locked = false;												
                    self.paint({recalc:false});

                    jpc.removeClass(_jsPlumb.draggingClass);
                    floatingEndpoint.removeClass(_jsPlumb.draggingClass);
                    _jsPlumb.fire("connectionDragStop", jpc);

                    jpc = null;						
                    inPlaceCopy = null;							
                    delete params.endpointsByElement[floatingEndpoint.elementId];
                    floatingEndpoint.anchor = null;
                    floatingEndpoint = null;
                    _jsPlumb.currentlyDragging = false;

                });
            
            var i = _gel(self.canvas);				
            jpcl.initDraggable(i, dragOptions, true, _jsPlumb);
        }

        // pulled this out into a function so we can reuse it for the inPlaceCopy canvas; you can now drop detached connections
        // back onto the endpoint you detached it from.
        var _initDropTarget = function(canvas, forceInit, isTransient, endpoint) {
            if ((params.isTarget || forceInit) && jpcl.isDropSupported(_element)) {
                var dropOptions = params.dropOptions || _jsPlumb.Defaults.DropOptions || jsPlumb.Defaults.DropOptions;
                dropOptions = jsPlumb.extend( {}, dropOptions);
                dropOptions.scope = dropOptions.scope || self.scope;
                var dropEvent = jpcl.dragEvents['drop'],
                    overEvent = jpcl.dragEvents['over'],
                    outEvent = jpcl.dragEvents['out'],
                    drop = function() {

                        self["removeClass"](_jsPlumb.endpointDropAllowedClass);
                        self["removeClass"](_jsPlumb.endpointDropForbiddenClass);
                                                    
                        var originalEvent = jpcl.getDropEvent(arguments),
                            draggable = _gel(jpcl.getDragObject(arguments)),
                            id = _att(draggable, "dragId"),
                            elId = _att(draggable, "elId"),						
                            scope = _att(draggable, "originalScope"),
                            jpc = floatingConnections[id];
                            
                        // if this is a drop back where the connection came from, mark it force rettach and
                        // return; the stop handler will reattach. without firing an event.
                        var redrop = jpc.suspendedEndpoint && (jpc.suspendedEndpoint.id == self.id ||
                                        self.referenceEndpoint && jpc.suspendedEndpoint.id == self.referenceEndpoint.id) ;							
                        if (redrop) {								
                            jpc._forceReattach = true;
                            return;
                        }

                        if (jpc != null) {
                            var idx = jpc.floatingAnchorIndex == null ? 1 : jpc.floatingAnchorIndex, oidx = idx == 0 ? 1 : 0;
                            
                            // restore the original scope if necessary (issue 57)						
                            if (scope) jsPlumb.CurrentLibrary.setDragScope(draggable, scope);							
                            
                            var endpointEnabled = endpoint != null ? endpoint.isEnabled() : true;
                            
                            if (self.isFull()) {
                                self.fire("maxConnections", { 
                                    endpoint:self, 
                                    connection:jpc, 
                                    maxConnections:_maxConnections 
                                }, originalEvent);
                            }
                                                            
                            if (!self.isFull() && !(idx == 0 && !self.isSource) && !(idx == 1 && !self.isTarget) && endpointEnabled) {
                                var _doContinue = true;

                                // the second check here is for the case that the user is dropping it back
                                // where it came from.
                                if (jpc.suspendedEndpoint && jpc.suspendedEndpoint.id != self.id) {
                                    if (idx == 0) {
                                        jpc.source = jpc.suspendedEndpoint.element;
                                        jpc.sourceId = jpc.suspendedEndpoint.elementId;
                                    } else {
                                        jpc.target = jpc.suspendedEndpoint.element;
                                        jpc.targetId = jpc.suspendedEndpoint.elementId;
                                    }

                                    if (!jpc.isDetachAllowed(jpc) || !jpc.endpoints[idx].isDetachAllowed(jpc) || !jpc.suspendedEndpoint.isDetachAllowed(jpc) || !_jsPlumb.checkCondition("beforeDetach", jpc))
                                        _doContinue = false;								
                                }
            
                                // these have to be set before testing for beforeDrop.
                                if (idx == 0) {
                                    jpc.source = self.element;
                                    jpc.sourceId = self.elementId;
                                } else {
                                    jpc.target = self.element;
                                    jpc.targetId = self.elementId;
                                }
                                                            
// ------------ wrap the execution path in a function so we can support asynchronous beforeDrop																
                                    
                                // we want to execute this regardless.
                                var commonFunction = function() {
                                    jpc.floatingAnchorIndex = null;
                                };	
                                                                                                
                                var continueFunction = function() {
                                    // remove this jpc from the current endpoint
                                    jpc.endpoints[idx].detachFromConnection(jpc);
                                    if (jpc.suspendedEndpoint) jpc.suspendedEndpoint.detachFromConnection(jpc);
                                    jpc.endpoints[idx] = self;
                                    self.addConnection(jpc);
                                    
                                    // copy our parameters in to the connection:
                                    var params = self.getParameters();
                                    for (var aParam in params)
                                        jpc.setParameter(aParam, params[aParam]);

                                    if (!jpc.suspendedEndpoint) {  
                                        if (params.draggable)
                                            jsPlumb.CurrentLibrary.initDraggable(self.element, dragOptions, true, _jsPlumb);
                                    }
                                    else {
                                        var suspendedElement = jpc.suspendedEndpoint.getElement(), suspendedElementId = jpc.suspendedEndpoint.elementId;
                                        // fire a detach event
                                        _fireDetachEvent({
                                            source : idx == 0 ? suspendedElement : jpc.source, 
                                            target : idx == 1 ? suspendedElement : jpc.target,
                                            sourceId : idx == 0 ? suspendedElementId : jpc.sourceId, 
                                            targetId : idx == 1 ? suspendedElementId : jpc.targetId,
                                            sourceEndpoint : idx == 0 ? jpc.suspendedEndpoint : jpc.endpoints[0], 
                                            targetEndpoint : idx == 1 ? jpc.suspendedEndpoint : jpc.endpoints[1],
                                            connection : jpc
                                        }, true, originalEvent);
                                    }

                                    // mark endpoints to delete on detach
                                    if (jpc.endpoints[0].addedViaMouse) jpc.endpointsToDeleteOnDetach[0] = jpc.endpoints[0];
                                    if (jpc.endpoints[1].addedViaMouse) jpc.endpointsToDeleteOnDetach[1] = jpc.endpoints[1];

                                    // finalise will inform the anchor manager and also add to
                                    // connectionsByScope if necessary.
                                    _finaliseConnection(jpc, null, originalEvent);
                                    
                                    commonFunction();
                                };
                                
                                var dontContinueFunction = function() {
                                    // otherwise just put it back on the endpoint it was on before the drag.
                                    if (jpc.suspendedEndpoint) {									
                                        jpc.endpoints[idx] = jpc.suspendedEndpoint;
                                        jpc.setHover(false);
                                        jpc._forceDetach = true;
                                        if (idx == 0) {
                                            jpc.source = jpc.suspendedEndpoint.element;
                                            jpc.sourceId = jpc.suspendedEndpoint.elementId;
                                        } else {
                                            jpc.target = jpc.suspendedEndpoint.element;
                                            jpc.targetId = jpc.suspendedEndpoint.elementId;;
                                        }
                                        jpc.suspendedEndpoint.addConnection(jpc);

                                        jpc.endpoints[0].repaint();
                                        jpc.repaint();
                                        _jsPlumb.repaint(jpc.sourceId);
                                        jpc._forceDetach = false;
                                    }
                                    
                                    commonFunction();
                                };
                                
// --------------------------------------
                                // now check beforeDrop.  this will be available only on Endpoints that are setup to
                                // have a beforeDrop condition (although, secretly, under the hood all Endpoints and 
                                // the Connection have them, because they are on jsPlumbUIComponent.  shhh!), because
                                // it only makes sense to have it on a target endpoint.
                                _doContinue = _doContinue && self.isDropAllowed(jpc.sourceId, jpc.targetId, jpc.scope, jpc, self);
                                                                                                                    
                                if (_doContinue) {
                                    continueFunction();
                                }
                                else {
                                    dontContinueFunction();
                                }

                                //commonFunction();
                            }
                            _jsPlumb.currentlyDragging = false;
                            delete floatingConnections[id];		
                            _jsPlumb.anchorManager.removeFloatingConnection(id);
                        }
                    };
                
                dropOptions[dropEvent] = _jsPlumb.wrap(dropOptions[dropEvent], drop);
                dropOptions[overEvent] = _jsPlumb.wrap(dropOptions[overEvent], function() {					
                    var draggable = jpcl.getDragObject(arguments),
                        id = _att( _gel(draggable), "dragId"),
                        _jpc = floatingConnections[id];
                        
                    if (_jpc != null) {								
                        var idx = _jpc.floatingAnchorIndex == null ? 1 : _jpc.floatingAnchorIndex;
                        // here we should fire the 'over' event if we are a target and this is a new connection,
                        // or we are the same as the floating endpoint.								
                        var _cont = (self.isTarget && _jpc.floatingAnchorIndex != 0) || (_jpc.suspendedEndpoint && self.referenceEndpoint && self.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            var bb = _jsPlumb.checkCondition("checkDropAllowed", { 
                                sourceEndpoint:_jpc.endpoints[idx], 
                                targetEndpoint:self,
                                connection:_jpc
                            }); 
                            self[(bb ? "add" : "remove") + "Class"](_jsPlumb.endpointDropAllowedClass);
                            self[(bb ? "remove" : "add") + "Class"](_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.over(self.anchor);
                        }
                    }						
                });	
                dropOptions[outEvent] = _jsPlumb.wrap(dropOptions[outEvent], function() {					
                    var draggable = jpcl.getDragObject(arguments),
                        id = _att( _gel(draggable), "dragId"),
                        _jpc = floatingConnections[id];
                        
                    if (_jpc != null) {
                        var idx = _jpc.floatingAnchorIndex == null ? 1 : _jpc.floatingAnchorIndex;
                        var _cont = (self.isTarget && _jpc.floatingAnchorIndex != 0) || (_jpc.suspendedEndpoint && self.referenceEndpoint && self.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            self["removeClass"](_jsPlumb.endpointDropAllowedClass);
                            self["removeClass"](_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.out();
                        }
                    }
                });
                jpcl.initDroppable(canvas, dropOptions, true, isTransient);
            }
        };
        
        // initialise the endpoint's canvas as a drop target.  this will be ignored if the endpoint is not a target or drag is not supported.
        _initDropTarget(_gel(self.canvas), true, !(params._transient || self.anchor.isFloating), self);
        
         // finally, set type if it was provided
         if (params.type)
            self.addType(params.type, params.data, _jsPlumb.isSuspendDrawing());

        return self;        					
    };	
})();;(function() {
    
    jsPlumb.Connection = function(params) {
        var self = this, visible = true, _internalHover, _superClassHover,
            _jsPlumb = params["_jsPlumb"],
            jpcl = jsPlumb.CurrentLibrary,
            _att = jpcl.getAttribute,
            _gel = jpcl.getElementObject,
            _ju = jsPlumbUtil,
            _getOffset = jpcl.getOffset,
            _newConnection = params.newConnection,
            _newEndpoint = params.newEndpoint,
            connector = null;
        
        self.idPrefix = "_jsplumb_c_";
        self.defaultLabelLocation = 0.5;
        self.defaultOverlayKeys = ["Overlays", "ConnectionOverlays"];
        this.parent = params.parent;
        overlayCapableJsPlumbUIComponent.apply(this, arguments);
        // ************** get the source and target and register the connection. *******************
        
// VISIBILITY						
        
        this.isVisible = function() { return visible; };
        
        this.setVisible = function(v) {
            visible = v;
            self[v ? "showOverlays" : "hideOverlays"]();
            if (connector && connector.canvas) connector.canvas.style.display = v ? "block" : "none";
            self.repaint();
        };
// END VISIBILITY	
                    
// EDITABLE
        
        var editable = params.editable === true;        
        this.setEditable = function(e) {
            if (connector && connector.isEditable())
                editable = e;
            
            return editable;
        };        
        this.isEditable = function() { return editable; };
        this.editStarted = function() {            
            self.fire("editStarted", {
                path:connector.getPath()
            });            
            _jsPlumb.setHoverSuspended(true);
        };
        this.editCompleted = function() {            
            self.fire("editCompleted", {
                path:connector.getPath()
            });       
            self.setHover(false);     
            _jsPlumb.setHoverSuspended(false);
        };
        this.editCanceled = function() {
            self.fire("editCanceled", {
                path:connector.getPath()
            });
            self.setHover(false);
            _jsPlumb.setHoverSuspended(false);
        };
       
// END EDITABLE            
        
// ADD CLASS/REMOVE CLASS - override to support adding/removing to/from endpoints
        var _ac = this.addClass, _rc = this.removeClass;
        this.addClass = function(c, informEndpoints) {
            _ac(c);
            if (informEndpoints) {
                self.endpoints[0].addClass(c);
                self.endpoints[1].addClass(c);                    
            }
        };
        this.removeClass = function(c, informEndpoints) {
            _rc(c);
            if (informEndpoints) {
                self.endpoints[0].removeClass(c);
                self.endpoints[1].removeClass(c);                    
            }
        };            
        
// TYPE		
        
        this.getTypeDescriptor = function() { return "connection"; };
        this.getDefaultType = function() {
            return {
                parameters:{},
                scope:null,
                detachable:self._jsPlumb.Defaults.ConnectionsDetachable,
                rettach:self._jsPlumb.Defaults.ReattachConnections,
                paintStyle:self._jsPlumb.Defaults.PaintStyle || jsPlumb.Defaults.PaintStyle,
                connector:self._jsPlumb.Defaults.Connector || jsPlumb.Defaults.Connector,
                hoverPaintStyle:self._jsPlumb.Defaults.HoverPaintStyle || jsPlumb.Defaults.HoverPaintStyle,				
                overlays:self._jsPlumb.Defaults.ConnectorOverlays || jsPlumb.Defaults.ConnectorOverlays
            };
        };
        var superAt = this.applyType;
        this.applyType = function(t, doNotRepaint) {
            superAt(t, doNotRepaint);
            if (t.detachable != null) self.setDetachable(t.detachable);
            if (t.reattach != null) self.setReattach(t.reattach);
            if (t.scope) self.scope = t.scope;
            editable = t.editable;
            self.setConnector(t.connector, doNotRepaint);
        };			
// END TYPE

// HOVER			
        // override setHover to pass it down to the underlying connector
        _superClassHover = self.setHover;
        self.setHover = function(state) {
            connector.setHover.apply(connector, arguments);				
            _superClassHover.apply(self, arguments);
        };
        
        _internalHover = function(state) {
            if (!_jsPlumb.isConnectionBeingDragged()) {
                self.setHover(state, false);
            }
        };
// END HOVER

        var makeConnector = function(renderMode, connectorName, connectorArgs) {
            var c = new Object();
            if (!_jsPlumb.Defaults.DoNotThrowErrors && jsPlumb.Connectors[connectorName] == null)
                    throw { msg:"jsPlumb: unknown connector type '" + connectorName + "'" };

            jsPlumb.Connectors[connectorName].apply(c, [connectorArgs]);
            jsPlumb.ConnectorRenderers[renderMode].apply(c, [connectorArgs]);	
            return c;
        };                        
                
        this.setConnector = function(connectorSpec, doNotRepaint) {
            if (connector != null) _ju.removeElements(connector.getDisplayElements());
            var connectorArgs = { 
                _jsPlumb:self._jsPlumb, 
                parent:params.parent, 
                cssClass:params.cssClass, 
                container:params.container, 
                tooltip:self.tooltip,
                "pointer-events":params["pointer-events"]
            },
            renderMode = _jsPlumb.getRenderMode();
            
            if (_ju.isString(connectorSpec)) 
                connector = makeConnector(renderMode, connectorSpec, connectorArgs); // lets you use a string as shorthand.
            else if (_ju.isArray(connectorSpec)) {
                if (connectorSpec.length == 1)
                    connector = makeConnector(renderMode, connectorSpec[0], connectorArgs);
                else
                    connector = makeConnector(renderMode, connectorSpec[0], _ju.merge(connectorSpec[1], connectorArgs));
            }
            // binds mouse listeners to the current connector.
            self.bindListeners(connector, self, _internalHover);
            
            self.canvas = connector.canvas;

            if (editable && jsPlumb.ConnectorEditors != null && jsPlumb.ConnectorEditors[connector.type] && connector.isEditable()) {
                new jsPlumb.ConnectorEditors[connector.type]({
                    connector:connector,
                    connection:self,
                    params:params.editorParams || { }
                });
            }
            else {                    
                editable = false;
            }                
                
            if (!doNotRepaint) self.repaint();
        };

        this.getConnector = function() { return connector; };
        
// INITIALISATION CODE			
                    
        this.source = _gel(params.source);
        this.target = _gel(params.target);
        // sourceEndpoint and targetEndpoint override source/target, if they are present. but 
        // source is not overridden if the Endpoint has declared it is not the final target of a connection;
        // instead we use the source that the Endpoint declares will be the final source element.
        if (params.sourceEndpoint) this.source = params.sourceEndpoint.endpointWillMoveTo || params.sourceEndpoint.getElement();			
        if (params.targetEndpoint) this.target = params.targetEndpoint.getElement();
        
        // if a new connection is the result of moving some existing connection, params.previousConnection
        // will have that Connection in it. listeners for the jsPlumbConnection event can look for that
        // member and take action if they need to.
        self.previousConnection = params.previousConnection;
                    
        this.sourceId = _att(this.source, "id");
        this.targetId = _att(this.target, "id");
        this.scope = params.scope; // scope may have been passed in to the connect call. if it wasn't, we will pull it from the source endpoint, after having initialised the endpoints.			
        this.endpoints = [];
        this.endpointStyles = [];
        // wrapped the main function to return null if no input given. this lets us cascade defaults properly.
        var _makeAnchor = function(anchorParams, elementId) {
            return (anchorParams) ? _jsPlumb.makeAnchor(anchorParams, elementId, _jsPlumb) : null;
        },
        prepareEndpoint = function(existing, index, params, element, elementId, connectorPaintStyle, connectorHoverPaintStyle) {
            var e;
            if (existing) {
                self.endpoints[index] = existing;
                existing.addConnection(self);					
            } else {
                if (!params.endpoints) params.endpoints = [ null, null ];
                var ep = params.endpoints[index] 
                        || params.endpoint
                        || _jsPlumb.Defaults.Endpoints[index]
                        || jsPlumb.Defaults.Endpoints[index]
                        || _jsPlumb.Defaults.Endpoint
                        || jsPlumb.Defaults.Endpoint;

                if (!params.endpointStyles) params.endpointStyles = [ null, null ];
                if (!params.endpointHoverStyles) params.endpointHoverStyles = [ null, null ];
                var es = params.endpointStyles[index] || params.endpointStyle || _jsPlumb.Defaults.EndpointStyles[index] || jsPlumb.Defaults.EndpointStyles[index] || _jsPlumb.Defaults.EndpointStyle || jsPlumb.Defaults.EndpointStyle;
                // Endpoints derive their fillStyle from the connector's strokeStyle, if no fillStyle was specified.
                if (es.fillStyle == null && connectorPaintStyle != null)
                    es.fillStyle = connectorPaintStyle.strokeStyle;
                
                // TODO: decide if the endpoint should derive the connection's outline width and color.  currently it does:
                //*
                if (es.outlineColor == null && connectorPaintStyle != null) 
                    es.outlineColor = connectorPaintStyle.outlineColor;
                if (es.outlineWidth == null && connectorPaintStyle != null) 
                    es.outlineWidth = connectorPaintStyle.outlineWidth;
                //*/
                
                var ehs = params.endpointHoverStyles[index] || params.endpointHoverStyle || _jsPlumb.Defaults.EndpointHoverStyles[index] || jsPlumb.Defaults.EndpointHoverStyles[index] || _jsPlumb.Defaults.EndpointHoverStyle || jsPlumb.Defaults.EndpointHoverStyle;
                // endpoint hover fill style is derived from connector's hover stroke style.  TODO: do we want to do this by default? for sure?
                if (connectorHoverPaintStyle != null) {
                    if (ehs == null) ehs = {};
                    if (ehs.fillStyle == null) {
                        ehs.fillStyle = connectorHoverPaintStyle.strokeStyle;
                    }
                }
                var a = params.anchors ? params.anchors[index] : 
                    params.anchor ? params.anchor :
                    _makeAnchor(_jsPlumb.Defaults.Anchors[index], elementId) || 
                    _makeAnchor(jsPlumb.Defaults.Anchors[index], elementId) || 
                    _makeAnchor(_jsPlumb.Defaults.Anchor, elementId) || 
                    _makeAnchor(jsPlumb.Defaults.Anchor, elementId),					
                u = params.uuids ? params.uuids[index] : null;
                e = _newEndpoint({ 
                    paintStyle : es,  hoverPaintStyle:ehs,  endpoint : ep,  connections : [ self ], 
                    uuid : u,  anchor : a,  source : element, scope  : params.scope, container:params.container,
                    reattach:params.reattach || _jsPlumb.Defaults.ReattachConnections,
                    detachable:params.detachable || _jsPlumb.Defaults.ConnectionsDetachable
                });
                self.endpoints[index] = e;
                
                if (params.drawEndpoints === false) e.setVisible(false, true, true);
                                    
            }
            return e;
        };					

        var eS = prepareEndpoint(params.sourceEndpoint, 0, params, self.source,
                                 self.sourceId, params.paintStyle, params.hoverPaintStyle);			
        if (eS) _ju.addToList(params.endpointsByElement, this.sourceId, eS);						
        var eT = prepareEndpoint(params.targetEndpoint, 1, params, self.target, 
                                 self.targetId, params.paintStyle, params.hoverPaintStyle);
        if (eT) _ju.addToList(params.endpointsByElement, this.targetId, eT);
        // if scope not set, set it to be the scope for the source endpoint.
        if (!this.scope) this.scope = this.endpoints[0].scope;		
        
        // if delete endpoints on detach, keep a record of just exactly which endpoints they are.
        self.endpointsToDeleteOnDetach = [null, null];
        if (params.deleteEndpointsOnDetach) {
            if (params.sourceIsNew) self.endpointsToDeleteOnDetach[0] = self.endpoints[0];
            if (params.targetIsNew) self.endpointsToDeleteOnDetach[1] = self.endpoints[1];
        }
        // or if the endpoints were supplied, use them.
        if (params.endpointsToDeleteOnDetach)
            self.endpointsToDeleteOnDetach = params.endpointsToDeleteOnDetach;
                    
        // TODO these could surely be refactored into some method that tries them one at a time until something exists
        self.setConnector(this.endpoints[0].connector || 
                          this.endpoints[1].connector || 
                          params.connector || 
                          _jsPlumb.Defaults.Connector || 
                          jsPlumb.Defaults.Connector, true);

        if (params.path)
            connector.setPath(params.path);
        
        this.setPaintStyle(this.endpoints[0].connectorStyle || 
                           this.endpoints[1].connectorStyle || 
                           params.paintStyle || 
                           _jsPlumb.Defaults.PaintStyle || 
                           jsPlumb.Defaults.PaintStyle, true);
                    
        this.setHoverPaintStyle(this.endpoints[0].connectorHoverStyle || 
                                this.endpoints[1].connectorHoverStyle || 
                                params.hoverPaintStyle || 
                                _jsPlumb.Defaults.HoverPaintStyle || 
                                jsPlumb.Defaults.HoverPaintStyle, true);
        
        this.paintStyleInUse = this.getPaintStyle();
        
        var _suspendedAt = _jsPlumb.getSuspendedAt();
        _jsPlumb.updateOffset( { elId : this.sourceId, timestamp:_suspendedAt });
        _jsPlumb.updateOffset( { elId : this.targetId, timestamp:_suspendedAt });

        if(!_jsPlumb.isSuspendDrawing()) {                    
            // paint the endpoints
            var myInfo = _jsPlumb.getCachedData(this.sourceId),
                myOffset = myInfo.o, myWH = myInfo.s,
                otherInfo = _jsPlumb.getCachedData(this.targetId),
                otherOffset = otherInfo.o,
                otherWH = otherInfo.s,
                initialTimestamp = _suspendedAt || _jsPlumb.timestamp(),
                anchorLoc = this.endpoints[0].anchor.compute( {
                    xy : [ myOffset.left, myOffset.top ], wh : myWH, element : this.endpoints[0],
                    elementId:this.endpoints[0].elementId,
                    txy : [ otherOffset.left, otherOffset.top ], twh : otherWH, tElement : this.endpoints[1],
                    timestamp:initialTimestamp
                });

            this.endpoints[0].paint( { anchorLoc : anchorLoc, timestamp:initialTimestamp });

            anchorLoc = this.endpoints[1].anchor.compute( {
                xy : [ otherOffset.left, otherOffset.top ], wh : otherWH, element : this.endpoints[1],
                elementId:this.endpoints[1].elementId,				
                txy : [ myOffset.left, myOffset.top ], twh : myWH, tElement : this.endpoints[0],
                timestamp:initialTimestamp				
            });
            this.endpoints[1].paint({ anchorLoc : anchorLoc, timestamp:initialTimestamp });
        }
                                
// END INITIALISATION CODE			
        
// DETACHABLE 				
        var _detachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.detachable === false) _detachable = false;
        if(self.endpoints[0].connectionsDetachable === false) _detachable = false;
        if(self.endpoints[1].connectionsDetachable === false) _detachable = false;        
        this.isDetachable = function() {
            return _detachable === true;
        };        
        this.setDetachable = function(detachable) {
          _detachable = detachable === true;
        };
// END DETACHABLE

// REATTACH
        var _reattach = params.reattach ||
            self.endpoints[0].reattachConnections ||
            self.endpoints[1].reattachConnections ||
            _jsPlumb.Defaults.ReattachConnections;        
        this.isReattach = function() {
            return _reattach === true;
        };        
        this.setReattach = function(reattach) {
          _reattach = reattach === true;
        };

// END REATTACH
        
// COST + DIRECTIONALITY
        // if cost not supplied, try to inherit from source endpoint
        var _cost = params.cost || self.endpoints[0].getConnectionCost();			
        self.getCost = function() { return _cost; };
        self.setCost = function(c) { _cost = c; };			
        var directed = params.directed;
        // inherit directed flag if set no source endpoint
        if (params.directed == null) directed = self.endpoints[0].areConnectionsDirected();
        self.isDirected = function() { return directed === true; };
// END COST + DIRECTIONALITY
                    
// PARAMETERS						
        // merge all the parameters objects into the connection.  parameters set
        // on the connection take precedence; then target endpoint params, then
        // finally source endpoint params.
        // TODO jsPlumb.extend could be made to take more than two args, and it would
        // apply the second through nth args in order.
        var _p = jsPlumb.extend({}, this.endpoints[0].getParameters());
        jsPlumb.extend(_p, this.endpoints[1].getParameters());
        jsPlumb.extend(_p, self.getParameters());
        self.setParameters(_p);
// END PARAMETERS
                    
// MISCELLANEOUS	
        
        this.getAttachedElements = function() {
            return self.endpoints;
        };
        
        //
        // changes the parent element of this connection to newParent.  not exposed for the public API.
        //
        this.moveParent = function(newParent) {
            var jpcl = jsPlumb.CurrentLibrary, curParent = jpcl.getParent(connector.canvas);				
            if (connector.bgCanvas) {
                jpcl.removeElement(connector.bgCanvas);
                jpcl.appendElement(connector.bgCanvas, newParent);
            }
            jpcl.removeElement(connector.canvas);
            jpcl.appendElement(connector.canvas, newParent);                
            // this only applies for DOMOverlays
            for (var i = 0; i < self.overlays.length; i++) {
                if (self.overlays[i].isAppendedAtTopLevel) {
                    jpcl.removeElement(self.overlays[i].canvas);
                    jpcl.appendElement(self.overlays[i].canvas, newParent);
                    if (self.overlays[i].reattachListeners) 
                        self.overlays[i].reattachListeners(connector);
                }
            }
            if (connector.reattachListeners)		// this is for SVG/VML; change an element's parent and you have to reinit its listeners.
                connector.reattachListeners();     // the Canvas implementation doesn't have to care about this
        };
        
// END MISCELLANEOUS

// PAINTING
            
        /*
         * Paints the Connection.  Not exposed for public usage. 
         * 
         * Parameters:
         * 	elId - Id of the element that is in motion.
         * 	ui - current library's event system ui object (present if we came from a drag to get here).
         *  recalc - whether or not to recalculate all anchors etc before painting. 
         *  timestamp - timestamp of this paint.  If the Connection was last painted with the same timestamp, it does not paint again.
         */
        var lastPaintedAt = null;			
        this.paint = function(params) {
            
            if (visible) {
                    
                params = params || {};
                var elId = params.elId, ui = params.ui, recalc = params.recalc, timestamp = params.timestamp,
                    // if the moving object is not the source we must transpose the two references.
                    swap = false,
                    tId = swap ? this.sourceId : this.targetId, sId = swap ? this.targetId : this.sourceId,
                    tIdx = swap ? 0 : 1, sIdx = swap ? 1 : 0;

                if (timestamp == null || timestamp != lastPaintedAt) {                        
                    var sourceInfo = _jsPlumb.updateOffset( { elId : elId, offset : ui, recalc : recalc, timestamp : timestamp }).o,
                        targetInfo = _jsPlumb.updateOffset( { elId : tId, timestamp : timestamp }).o, // update the target if this is a forced repaint. otherwise, only the source has been moved.
                        sE = this.endpoints[sIdx], tE = this.endpoints[tIdx];

                    if (params.clearEdits) {
                        sE.anchor.clearUserDefinedLocation();
                        tE.anchor.clearUserDefinedLocation();
                        connector.setEdited(false);
                    }
                    
                    var sAnchorP = sE.anchor.getCurrentLocation(sE),				
                        tAnchorP = tE.anchor.getCurrentLocation(tE);                                
					if(!tAnchorP) return true;
                    connector.resetBounds();

                    connector.compute({
                        sourcePos:sAnchorP,
                        targetPos:tAnchorP, 
                        sourceEndpoint:this.endpoints[sIdx],
                        targetEndpoint:this.endpoints[tIdx],
                        lineWidth:self.paintStyleInUse.lineWidth,                        					
                        sourceInfo:sourceInfo,
                        targetInfo:targetInfo,
                        clearEdits:params.clearEdits === true
                    });                                                                                        

                    var overlayExtents = {
                        minX:Infinity,
                        minY:Infinity,
                        maxX:-Infinity,
                        maxY:-Infinity
                    };                    
                    // compute overlays. we do this first so we can get their placements, and adjust the
                    // container if needs be (if an overlay would be clipped)
                    for ( var i = 0; i < self.overlays.length; i++) {
                        var o = self.overlays[i];
                        if (o.isVisible()) {
                            self.overlayPlacements[i] = o.draw(connector, self.paintStyleInUse);
                            overlayExtents.minX = Math.min(overlayExtents.minX, self.overlayPlacements[i].minX);
                            overlayExtents.maxX = Math.max(overlayExtents.maxX, self.overlayPlacements[i].maxX);
                            overlayExtents.minY = Math.min(overlayExtents.minY, self.overlayPlacements[i].minY);
                            overlayExtents.maxY = Math.max(overlayExtents.maxY, self.overlayPlacements[i].maxY);
                        }
                    }

                    var lineWidth = parseFloat(self.paintStyleInUse.lineWidth || 1) / 2,
                        outlineWidth = parseFloat(self.paintStyleInUse.lineWidth || 0),
                        extents = {
                            xmin : Math.min(connector.bounds.minX - (lineWidth + outlineWidth), overlayExtents.minX),
                            ymin : Math.min(connector.bounds.minY - (lineWidth + outlineWidth), overlayExtents.minY),
                            xmax : Math.max(connector.bounds.maxX + (lineWidth + outlineWidth), overlayExtents.maxX),
                            ymax : Math.max(connector.bounds.maxY + (lineWidth + outlineWidth), overlayExtents.maxY)
                        };

                    // paint the connector.
                    connector.paint(self.paintStyleInUse, null, extents);  
                    // and then the overlays
                    for ( var i = 0; i < self.overlays.length; i++) {
                        var o = self.overlays[i];
                        if (o.isVisible()) {
                            o.paint(self.overlayPlacements[i], extents);    
                        }
                    }                  
                                                            
                }
                lastPaintedAt = timestamp;						
            }		
        };			

        /*
         * Function: repaint
         * Repaints the Connection. No parameters exposed to public API.
         */
        this.repaint = function(params) {
            params = params || {};
            var recalc = !(params.recalc === false);
            this.paint({ elId : this.sourceId, recalc : recalc, timestamp:params.timestamp, clearEdits:params.clearEdits });
        };
        
        // the very last thing we do is check to see if a 'type' was supplied in the params
        var _type = params.type || self.endpoints[0].connectionType || self.endpoints[1].connectionType;
        if (_type)
            self.addType(_type, params.data, _jsPlumb.isSuspendDrawing());
        
// END PAINTING    
    }; // END Connection class            
})();/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.4.1
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the default Connectors, Endpoint and Overlay definitions.
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */

;(function() {	
				
	/**
	 * 
	 * Helper class to consume unused mouse events by components that are DOM elements and
	 * are used by all of the different rendering modes.
	 * 
	 */
	jsPlumb.DOMElementComponent = function(params) {
		jsPlumb.jsPlumbUIComponent.apply(this, arguments);
		// when render mode is canvas, these functions may be called by the canvas mouse handler.  
		// this component is safe to pipe this stuff to /dev/null.
		this.mousemove = 
		this.dblclick  = 
		this.click = 
		this.mousedown = 
		this.mouseup = function(e) { };					
	};
	
	jsPlumb.Segments = {
        	
        /*
         * Class: AbstractSegment
         * A Connector is made up of 1..N Segments, each of which has a Type, such as 'Straight', 'Arc',
         * 'Bezier'. This is new from 1.4.1, and gives us a lot more flexibility when drawing connections: things such
         * as rounded corners for flowchart connectors, for example, or a straight line stub for Bezier connections, are
         * much easier to do now.
         *
         * A Segment is responsible for providing coordinates for painting it, and also must be able to report its length.
         * 
         */ 
        AbstractSegment : function(params) { 
            this.params = params;
            
            /**
            * Function: findClosestPointOnPath
            * Finds the closest point on this segment to the given [x, y], 
            * returning both the x and y of the point plus its distance from
            * the supplied point, and its location along the length of the
            * path inscribed by the segment.  This implementation returns
            * Infinity for distance and null values for everything else;
            * subclasses are expected to override.
            */
            this.findClosestPointOnPath = function(x, y) {
                return {
                    d:Infinity,
                    x:null,
                    y:null,
                    l:null
                };
            };

            this.getBounds = function() {
                return {
                    minX:Math.min(params.x1, params.x2),
                    minY:Math.min(params.y1, params.y2),
                    maxX:Math.max(params.x1, params.x2),
                    maxY:Math.max(params.y1, params.y2)
                };
            };
        },
        Straight : function(params) {
            var self = this,
                _super = jsPlumb.Segments.AbstractSegment.apply(this, arguments),
                length, m, m2, x1, x2, y1, y2,
                _recalc = function() {
                    length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    m = jsPlumbUtil.gradient({x:x1, y:y1}, {x:x2, y:y2});
                    m2 = -1 / m;                
                };
                
            this.type = "Straight";
            
            self.getLength = function() { return length; };
            self.getGradient = function() { return m; };
                
            this.getCoordinates = function() {
                return { x1:x1,y1:y1,x2:x2,y2:y2 };
            };
            this.setCoordinates = function(coords) {
                x1 = coords.x1; y1 = coords.y1; x2 = coords.x2; y2 = coords.y2;
                _recalc();
            };
            this.setCoordinates({x1:params.x1, y1:params.y1, x2:params.x2, y2:params.y2});

            this.getBounds = function() {
                return {
                    minX:Math.min(x1, x2),
                    minY:Math.min(y1, y2),
                    maxX:Math.max(x1, x2),
                    maxY:Math.max(y1, y2)
                };
            };
            
            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive. for the straight line segment this is simple maths.
             */
             this.pointOnPath = function(location, absolute) {
                if (location == 0 && !absolute)
                    return { x:x1, y:y1 };
                else if (location == 1 && !absolute)
                    return { x:x2, y:y2 };
                else {
                    var l = absolute ? location > 0 ? location : length + location : location * length;
                    return jsPlumbUtil.pointOnLine({x:x1, y:y1}, {x:x2, y:y2}, l);
                }
            };
            
            /**
             * returns the gradient of the segment at the given point - which for us is constant.
             */
            this.gradientAtPoint = function(_) {
                return m;
            };
            
            /**
             * returns the point on the segment's path that is 'distance' along the length of the path from 'location', where 
             * 'location' is a decimal from 0 to 1 inclusive, and 'distance' is a number of pixels.
             * this hands off to jsPlumbUtil to do the maths, supplying two points and the distance.
             */            
            this.pointAlongPathFrom = function(location, distance, absolute) {            
                var p = self.pointOnPath(location, absolute),
                    farAwayPoint = location == 1 ? {
                        x:x1 + ((x2 - x1) * 10),
                        y:y1 + ((y1 - y2) * 10)
                    } : distance <= 0 ? {x:x1, y:y1} : {x:x2, y:y2 };
    
                if (distance <= 0 && Math.abs(distance) > 1) distance *= -1;
    
                return jsPlumbUtil.pointOnLine(p, farAwayPoint, distance);
            };
            
            /**
                Function: findClosestPointOnPath
                Finds the closest point on this segment to [x,y]. See
                notes on this method in AbstractSegment.
            */
            this.findClosestPointOnPath = function(x, y) {
                if (m == 0) {
                    return {
                        x:x,
                        y:y1,
                        d:Math.abs(y - y1)
                    };
                }
                else if (m == Infinity || m == -Infinity) {
                    return {
                        x:x1,
                        y:y,
                        d:Math.abs(x - 1)
                    };
                }
                else {
                    // closest point lies on normal from given point to this line.  
                    var b = y1 - (m * x1),
                        b2 = y - (m2 * x),                    
                    // y1 = m.x1 + b and y1 = m2.x1 + b2
                    // so m.x1 + b = m2.x1 + b2
                    // x1(m - m2) = b2 - b
                    // x1 = (b2 - b) / (m - m2)
                        _x1 = (b2 -b) / (m - m2),
                        _y1 = (m * _x1) + b,
                        d = jsPlumbUtil.lineLength([ x, y ], [ _x1, _y1 ]),
                        fractionInSegment = jsPlumbUtil.lineLength([ _x1, _y1 ], [ x1, y1 ]);
                    
                    return { d:d, x:_x1, y:_y1, l:fractionInSegment / length};            
                }
            };
        },
	
        /*
            Arc Segment. You need to supply:
    
            r   -   radius
            cx  -   center x for the arc
            cy  -   center y for the arc
            ac  -   whether the arc is anticlockwise or not. default is clockwise.
    
            and then either:
    
            startAngle  -   startAngle for the arc.
            endAngle    -   endAngle for the arc.
    
            or:
    
            x1          -   x for start point
            y1          -   y for start point
            x2          -   x for end point
            y2          -   y for end point
    
        */
        Arc : function(params) {
            var self = this,
                _super = jsPlumb.Segments.AbstractSegment.apply(this, arguments),
                _calcAngle = function(_x, _y) {
                    return jsPlumbUtil.theta([params.cx, params.cy], [_x, _y]);    
                },
                _calcAngleForLocation = function(location) {
                    if (self.anticlockwise) {
                        var sa = self.startAngle < self.endAngle ? self.startAngle + TWO_PI : self.startAngle,
                            s = Math.abs(sa - self.endAngle);
                        return sa - (s * location);                    
                    }
                    else {
                        var ea = self.endAngle < self.startAngle ? self.endAngle + TWO_PI : self.endAngle,
                            s = Math.abs (ea - self.startAngle);
                    
                        return self.startAngle + (s * location);
                    }
                },
                TWO_PI = 2 * Math.PI;
            
            this.radius = params.r;
            this.anticlockwise = params.ac;			
            this.type = "Arc";
                
            if (params.startAngle && params.endAngle) {
                this.startAngle = params.startAngle;
                this.endAngle = params.endAngle;            
                this.x1 = params.cx + (self.radius * Math.cos(params.startAngle));     
                this.y1 = params.cy + (self.radius * Math.sin(params.startAngle));            
                this.x2 = params.cx + (self.radius * Math.cos(params.endAngle));     
                this.y2 = params.cy + (self.radius * Math.sin(params.endAngle));                        
            }
            else {
                this.startAngle = _calcAngle(params.x1, params.y1);
                this.endAngle = _calcAngle(params.x2, params.y2);            
                this.x1 = params.x1;
                this.y1 = params.y1;
                this.x2 = params.x2;
                this.y2 = params.y2;            
            }
            
            if (this.endAngle < 0) this.endAngle += TWO_PI;
            if (this.startAngle < 0) this.startAngle += TWO_PI;   

            // segment is used by vml     
            this.segment = jsPlumbUtil.segment([this.x1, this.y1], [this.x2, this.y2]);
            
            // we now have startAngle and endAngle as positive numbers, meaning the
            // absolute difference (|d|) between them is the sweep (s) of this arc, unless the
            // arc is 'anticlockwise' in which case 's' is given by 2PI - |d|.
            
            var ea = self.endAngle < self.startAngle ? self.endAngle + TWO_PI : self.endAngle;
            self.sweep = Math.abs (ea - self.startAngle);
            if (self.anticlockwise) self.sweep = TWO_PI - self.sweep;
            var circumference = 2 * Math.PI * self.radius,
                frac = self.sweep / TWO_PI,
                length = circumference * frac;
            
            this.getLength = function() {
                return length;
            };

            this.getBounds = function() {
                return {
                    minX:params.cx - params.r,
                    maxX:params.cx + params.r,
                    minY:params.cy - params.r,
                    maxY:params.cy + params.r
                }
            };
            
            var VERY_SMALL_VALUE = 0.0000000001,
                gentleRound = function(n) {
                    var f = Math.floor(n), r = Math.ceil(n);
                    if (n - f < VERY_SMALL_VALUE) 
                        return f;    
                    else if (r - n < VERY_SMALL_VALUE)
                        return r;
                    return n;
                };
            
            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive. 
             */
            this.pointOnPath = function(location, absolute) {            
                
                if (location == 0) {
                    return { x:self.x1, y:self.y1, theta:self.startAngle };    
                }
                else if (location == 1) {
                    return { x:self.x2, y:self.y2, theta:self.endAngle };                    
                }
                
                if (absolute) {
                    location = location / length;
                }
    
                var angle = _calcAngleForLocation(location),
                    _x = params.cx + (params.r * Math.cos(angle)),
                    _y  = params.cy + (params.r * Math.sin(angle));					
    
                return { x:gentleRound(_x), y:gentleRound(_y), theta:angle };
            };
            
            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function(location, absolute) {
                var p = self.pointOnPath(location, absolute);
                var m = jsPlumbUtil.normal( [ params.cx, params.cy ], [p.x, p.y ] );
                if (!self.anticlockwise && (m == Infinity || m == -Infinity)) m *= -1;
                return m;
            };	              
                    
            this.pointAlongPathFrom = function(location, distance, absolute) {
                var p = self.pointOnPath(location, absolute),
                    arcSpan = distance / circumference * 2 * Math.PI,
                    dir = self.anticlockwise ? -1 : 1,
                    startAngle = p.theta + (dir * arcSpan),				
                    startX = params.cx + (self.radius * Math.cos(startAngle)),
                    startY = params.cy + (self.radius * Math.sin(startAngle));	
    
                return {x:startX, y:startY};
            };	            
        },
	
        Bezier : function(params) {
            var self = this,
                _super = jsPlumb.Segments.AbstractSegment.apply(this, arguments),
                curve = [	
                    { x:params.x1, y:params.y1},
                    { x:params.cp1x, y:params.cp1y },
                    { x:params.cp2x, y:params.cp2y },
                    { x:params.x2, y:params.y2 }
                ],
                // although this is not a strictly rigorous determination of bounds
                // of a bezier curve, it works for the types of curves that this segment
                // type produces.
                bounds = {
                    minX:Math.min(params.x1, params.x2, params.cp1x, params.cp2x),
                    minY:Math.min(params.y1, params.y2, params.cp1y, params.cp2y),
                    maxX:Math.max(params.x1, params.x2, params.cp1x, params.cp2x),
                    maxY:Math.max(params.y1, params.y2, params.cp1y, params.cp2y)
                };
                
            this.type = "Bezier";            
            
            var _translateLocation = function(_curve, location, absolute) {
                if (absolute)
                    location = jsBezier.locationAlongCurveFrom(_curve, location > 0 ? 0 : 1, location);
    
                return location;
            };		
            
            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive. 
             */
            this.pointOnPath = function(location, absolute) {
                location = _translateLocation(curve, location, absolute);                
                return jsBezier.pointOnCurve(curve, location);
            };
            
            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function(location, absolute) {
                location = _translateLocation(curve, location, absolute);
                return jsBezier.gradientAtPoint(curve, location);        	
            };	              
            
            this.pointAlongPathFrom = function(location, distance, absolute) {
                location = _translateLocation(curve, location, absolute);
                return jsBezier.pointAlongCurveFrom(curve, location, distance);
            };
            
            this.getLength = function() {
                return jsBezier.getLength(curve);				
            };

            this.getBounds = function() {
                return bounds;
            };
        }
    };

    /*
        Class: AbstractComponent
        Superclass for AbstractConnector and AbstractEndpoint.
    */
    var AbstractComponent = function() {
        var self = this;
        self.resetBounds = function() {
            self.bounds = { minX:Infinity, minY:Infinity, maxX:-Infinity, maxY:-Infinity };
        };
        self.resetBounds();        
    };
	
	/*
	 * Class: AbstractConnector
	 * Superclass for all Connectors; here is where Segments are managed.  This is exposed on jsPlumb just so it
	 * can be accessed from other files. You should not try to instantiate one of these directly.
	 *
	 * When this class is asked for a pointOnPath, or gradient etc, it must first figure out which segment to dispatch
	 * that request to. This is done by keeping track of the total connector length as segments are added, and also
	 * their cumulative ratios to the total length.  Then when the right segment is found it is a simple case of dispatching
	 * the request to it (and adjusting 'location' so that it is relative to the beginning of that segment.)
	 */ 
	jsPlumb.Connectors.AbstractConnector = function(params) {
		
        AbstractComponent.apply(this, arguments);

		var self = this,
            segments = [],
            editing = false,
			totalLength = 0,
			segmentProportions = [],
			segmentProportionalLengths = [],        
            stub = params.stub || 0, 
            sourceStub = jsPlumbUtil.isArray(stub) ? stub[0] : stub,
            targetStub = jsPlumbUtil.isArray(stub) ? stub[1] : stub,
            gap = params.gap || 0,
            sourceGap = jsPlumbUtil.isArray(gap) ? gap[0] : gap,
            targetGap = jsPlumbUtil.isArray(gap) ? gap[1] : gap,
            userProvidedSegments = null,
            edited = false,
            paintInfo = null;            
        
        // subclasses should override.
        this.isEditable = function() { return false; };                
        
        this.setEdited = function(ed) {
            edited = ed;
        };

        // to be overridden by subclasses.
        this.getPath = function() { };
        this.setPath = function(path) { };
        
        /**
        * Function: findSegmentForPoint
        * Returns the segment that is closest to the given [x,y],
        * null if nothing found.  This function returns a JS 
        * object with:
        *
        *   d   -   distance from segment
        *   l   -   proportional location in segment
        *   x   -   x point on the segment
        *   y   -   y point on the segment
        *   s   -   the segment itself.
        */ 
        this.findSegmentForPoint = function(x, y) {
            var out = { d:Infinity, s:null, x:null, y:null, l:null };
            for (var i = 0; i < segments.length; i++) {
                var _s = segments[i].findClosestPointOnPath(x, y);
                if (_s.d < out.d) {
                    out.d = _s.d; 
                    out.l = _s.l; 
                    out.x = _s.x;
                    out.y = _s.y; 
                    out.s = segments[i];
                }
            }
            
            return out;                
        };
			
		var _updateSegmentProportions = function() {
                var curLoc = 0;
                for (var i = 0; i < segments.length; i++) {
                    var sl = segments[i].getLength();
                    segmentProportionalLengths[i] = sl / totalLength;
                    segmentProportions[i] = [curLoc, (curLoc += (sl / totalLength)) ];
                }
            },
		
            /**
             * returns [segment, proportion of travel in segment, segment index] for the segment 
             * that contains the point which is 'location' distance along the entire path, where 
             * 'location' is a decimal between 0 and 1 inclusive. in this connector type, paths 
             * are made up of a list of segments, each of which contributes some fraction to
             * the total length. 
             * From 1.3.10 this also supports the 'absolute' property, which lets us specify a location
             * as the absolute distance in pixels, rather than a proportion of the total path. 
             */
            _findSegmentForLocation = function(location, absolute) {
                if (absolute) {
                    location = location > 0 ? location / totalLength : (totalLength + location) / totalLength;
                }
    
                var idx = segmentProportions.length - 1, inSegmentProportion = 1;
                //if (location < 1) {
                    for (var i = 0; i < segmentProportions.length; i++) {
                        if (segmentProportions[i][1] >= location) {
                            idx = i;
                            // todo is this correct for all connector path types?
                            inSegmentProportion = location == 1 ? 1 : location == 0 ? 0 : (location - segmentProportions[i][0]) / segmentProportionalLengths[i];                    
                            break;
                        }
                    }
                //}
                return { segment:segments[idx], proportion:inSegmentProportion, index:idx };
            },		
            _addSegment = function(type, params) {
                var s = new jsPlumb.Segments[type](params);
                segments.push(s);
                totalLength += s.getLength();	
                self.updateBounds(s);	                
            },					
            _clearSegments = function() {
                totalLength = 0;
                segments.splice(0, segments.length);
                segmentProportions.splice(0, segmentProportions.length);
                segmentProportionalLengths.splice(0, segmentProportionalLengths.length);
            };
        
        this.setSegments = function(_segs) {
            userProvidedSegments = [];
            totalLength = 0;
            for (var i = 0; i < _segs.length; i++) {      
                userProvidedSegments.push(_segs[i]);
                totalLength += _segs[i].getLength();			            
            }            
        };  
        
        var _prepareCompute = function(params) {
            self.lineWidth = params.lineWidth;
            var segment = jsPlumbUtil.segment(params.sourcePos, params.targetPos),
                swapX = params.targetPos[0] < params.sourcePos[0],
                swapY = params.targetPos[1] < params.sourcePos[1],
                lw = params.lineWidth || 1,       
                so = params.sourceEndpoint.anchor.orientation || params.sourceEndpoint.anchor.getOrientation(params.sourceEndpoint), 
                to = params.targetEndpoint.anchor.orientation || params.targetEndpoint.anchor.getOrientation(params.targetEndpoint),
                x = swapX ? params.targetPos[0] : params.sourcePos[0], 
                y = swapY ? params.targetPos[1] : params.sourcePos[1],
                w = Math.abs(params.targetPos[0] - params.sourcePos[0]),
                h = Math.abs(params.targetPos[1] - params.sourcePos[1]);
            
            // if either anchor does not have an orientation set, we derive one from their relative
            // positions.  we fix the axis to be the one in which the two elements are further apart, and
            // point each anchor at the other element.  this is also used when dragging a new connection.
            if (so[0] == 0 && so[1] == 0 || to[0] == 0 && to[1] == 0) {
                var index = w > h ? 0 : 1, oIndex = [1,0][index];
                so = []; to = [];
                so[index] = params.sourcePos[index] > params.targetPos[index] ? -1 : 1;
                to[index] = params.sourcePos[index] > params.targetPos[index] ? 1 : -1;
                so[oIndex] = 0; to[oIndex] = 0;
            }                    
            
            var sx = swapX ? w + (sourceGap * so[0])  : sourceGap * so[0], 
                sy = swapY ? h + (sourceGap * so[1])  : sourceGap * so[1], 
                tx = swapX ? targetGap * to[0] : w + (targetGap * to[0]),
                ty = swapY ? targetGap * to[1] : h + (targetGap * to[1]),
                oProduct = ((so[0] * to[0]) + (so[1] * to[1]));        
            
            var result = {
                sx:sx, sy:sy, tx:tx, ty:ty, lw:lw, 
                xSpan:Math.abs(tx - sx),
                ySpan:Math.abs(ty - sy),                
                mx:(sx + tx) / 2,
                my:(sy + ty) / 2,                
                so:so, to:to, x:x, y:y, w:w, h:h,
                segment : segment,
                startStubX : sx + (so[0] * sourceStub), 
                startStubY : sy + (so[1] * sourceStub),
                endStubX : tx + (to[0] * targetStub), 
                endStubY : ty + (to[1] * targetStub),
                isXGreaterThanStubTimes2 : Math.abs(sx - tx) > (sourceStub + targetStub),
                isYGreaterThanStubTimes2 : Math.abs(sy - ty) > (sourceStub + targetStub),
                opposite:oProduct == -1,
                perpendicular:oProduct == 0,
                orthogonal:oProduct == 1,
                sourceAxis : so[0] == 0 ? "y" : "x",
                points:[x, y, w, h, sx, sy, tx, ty ]
            };
            result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
            return result;
        };
		
		this.getSegments = function() { return segments; };

        self.updateBounds = function(segment) {
            var segBounds = segment.getBounds();
            self.bounds.minX = Math.min(self.bounds.minX, segBounds.minX);
            self.bounds.maxX = Math.max(self.bounds.maxX, segBounds.maxX);
            self.bounds.minY = Math.min(self.bounds.minY, segBounds.minY);
            self.bounds.maxY = Math.max(self.bounds.maxY, segBounds.maxY);              
        };
        
        var dumpSegmentsToConsole = function() {
            console.log("SEGMENTS:");
            for (var i = 0; i < segments.length; i++) {
                console.log(segments[i].type, segments[i].getLength(), segmentProportions[i]);
            }
        };
		
		this.pointOnPath = function(location, absolute) {
            //console.log("point on path", location);
			var seg = _findSegmentForLocation(location, absolute);		
            //console.log("point on path", location, seg);	
			return seg.segment.pointOnPath(seg.proportion, absolute);
		};
		
		this.gradientAtPoint = function(location) {
			var seg = _findSegmentForLocation(location, absolute);			
			return seg.segment.gradientAtPoint(seg.proportion, absolute);
		};
		
		this.pointAlongPathFrom = function(location, distance, absolute) {
			var seg = _findSegmentForLocation(location, absolute);
			// TODO what happens if this crosses to the next segment?
			return seg.segment.pointAlongPathFrom(seg.proportion, distance, false);
		};
		
		this.compute = function(params)  {
            if (!edited)
                paintInfo = _prepareCompute(params);
            
            _clearSegments();
            this._compute(paintInfo, params);
            self.x = paintInfo.points[0];
            self.y = paintInfo.points[1];
            self.w = paintInfo.points[2];
            self.h = paintInfo.points[3];               
            self.segment = paintInfo.segment;         
            _updateSegmentProportions();            
		};
		
		return {
			addSegment:_addSegment,
            prepareCompute:_prepareCompute,
            sourceStub:sourceStub,
            targetStub:targetStub,
            maxStub:Math.max(sourceStub, targetStub),            
            sourceGap:sourceGap,
            targetGap:targetGap,
            maxGap:Math.max(sourceGap, targetGap)
		};		
	};
	
    /**
     * Class: Connectors.Straight
     * The Straight connector draws a simple straight line between the two anchor points.  It does not have any constructor parameters.
     */
    jsPlumb.Connectors.Straight = function() {
    	this.type = "Straight";
		var _super =  jsPlumb.Connectors.AbstractConnector.apply(this, arguments);		

        this._compute = function(paintInfo, _) {                        
            _super.addSegment("Straight", {x1:paintInfo.sx, y1:paintInfo.sy, x2:paintInfo.startStubX, y2:paintInfo.startStubY});                                                
            _super.addSegment("Straight", {x1:paintInfo.startStubX, y1:paintInfo.startStubY, x2:paintInfo.endStubX, y2:paintInfo.endStubY});                        
            _super.addSegment("Straight", {x1:paintInfo.endStubX, y1:paintInfo.endStubY, x2:paintInfo.tx, y2:paintInfo.ty});                                    
        };                    
    };
                    
    /**
     * Class:Connectors.Bezier
     * This Connector draws a Bezier curve with two control points.  You can provide a 'curviness' value which gets applied to jsPlumb's
     * internal voodoo machine and ends up generating locations for the two control points.  See the constructor documentation below.
     */
    /**
     * Function:Constructor
     * 
     * Parameters:
     * 	curviness - How 'curvy' you want the curve to be! This is a directive for the placement of control points, not endpoints of the curve, so your curve does not 
     * actually touch the given point, but it has the tendency to lean towards it.  The larger this value, the greater the curve is pulled from a straight line.
     * Optional; defaults to 150.
     * stub - optional value for a distance to travel from the connector's endpoint before beginning the Bezier curve. defaults to 0.
     * 
     */
    jsPlumb.Connectors.Bezier = function(params) {
        params = params || {};

    	var self = this,
			_super =  jsPlumb.Connectors.AbstractConnector.apply(this, arguments),
            stub = params.stub || 50,
            majorAnchor = params.curviness || 150,
            minorAnchor = 10;            

        this.type = "Bezier";	
        this.getCurviness = function() { return majorAnchor; };	
        
        this._findControlPoint = function(point, sourceAnchorPosition, targetAnchorPosition, sourceEndpoint, targetEndpoint) {
        	// determine if the two anchors are perpendicular to each other in their orientation.  we swap the control 
        	// points around if so (code could be tightened up)
        	var soo = sourceEndpoint.anchor.getOrientation(sourceEndpoint), 
        		too = targetEndpoint.anchor.getOrientation(targetEndpoint),
        		perpendicular = soo[0] != too[0] || soo[1] == too[1],
            	p = [];                
            	
            if (!perpendicular) {
                if (soo[0] == 0) // X
                    p.push(sourceAnchorPosition[0] < targetAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                else p.push(point[0] - (majorAnchor * soo[0]));
                                 
                if (soo[1] == 0) // Y
                	p.push(sourceAnchorPosition[1] < targetAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                else p.push(point[1] + (majorAnchor * too[1]));
            }
             else {
                if (too[0] == 0) // X
                	p.push(targetAnchorPosition[0] < sourceAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                else p.push(point[0] + (majorAnchor * too[0]));
                
                if (too[1] == 0) // Y
                	p.push(targetAnchorPosition[1] < sourceAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                else p.push(point[1] + (majorAnchor * soo[1]));
             }

            return p;                
        };        

        this._compute = function(paintInfo, p) {                                
			var sp = p.sourcePos,
				tp = p.targetPos,				
                _w = Math.abs(sp[0] - tp[0]),
                _h = Math.abs(sp[1] - tp[1]),            
                _sx = sp[0] < tp[0] ? _w : 0,
                _sy = sp[1] < tp[1] ? _h : 0,
                _tx = sp[0] < tp[0] ? 0 : _w,
                _ty = sp[1] < tp[1] ? 0 : _h,
                _CP = self._findControlPoint([_sx, _sy], sp, tp, p.sourceEndpoint, p.targetEndpoint),
                _CP2 = self._findControlPoint([_tx, _ty], tp, sp, p.targetEndpoint, p.sourceEndpoint);

			_super.addSegment("Bezier", {
				x1:_sx, y1:_sy, x2:_tx, y2:_ty,
				cp1x:_CP[0], cp1y:_CP[1], cp2x:_CP2[0], cp2y:_CP2[1]
			});                    
        };               
    };        
    
 // ********************************* END OF CONNECTOR TYPES *******************************************************************
    
 // ********************************* ENDPOINT TYPES *******************************************************************
    
    jsPlumb.Endpoints.AbstractEndpoint = function(params) {
        AbstractComponent.apply(this, arguments);
        var self = this;    
        this.compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {    
            var out = self._compute.apply(self, arguments);
            self.x = out[0];
            self.y = out[1];
            self.w = out[2];
            self.h = out[3];
            self.bounds.minX = self.x;
            self.bounds.minY = self.y;
            self.bounds.maxX = self.x + self.w;
            self.bounds.maxY = self.y + self.h;
            return out;
        };
        return {
            compute:self.compute,
            cssClass:params.cssClass
        };
    };
    
    /**
     * Class: Endpoints.Dot
     * A round endpoint, with default radius 10 pixels.
     */    	
    	
	/**
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	radius	-	radius of the endpoint.  defaults to 10 pixels.
	 */
	jsPlumb.Endpoints.Dot = function(params) {        
		this.type = "Dot";
		var self = this,
            _super = jsPlumb.Endpoints.AbstractEndpoint.apply(this, arguments);
		params = params || {};				
		this.radius = params.radius || 10;
		this.defaultOffset = 0.5 * this.radius;
		this.defaultInnerRadius = this.radius / 3;			
		
		this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			self.radius = endpointStyle.radius || self.radius;
			var	x = anchorPoint[0] - self.radius,
				y = anchorPoint[1] - self.radius,
                w = self.radius * 2,
                h = self.radius * 2;

            if (endpointStyle.strokeStyle) {
                var lw = endpointStyle.lineWidth || 1;
                x -= lw;
                y -= lw;
                w += (lw * 2);
                h += (lw * 2);
            }
			return [ x, y, w, h, self.radius ];
		};
	};
	
	/**
	 * Class: Endpoints.Rectangle
	 * A Rectangular Endpoint, with default size 20x20.
	 */
	/**
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	width	- width of the endpoint. defaults to 20 pixels.
	 * 	height	- height of the endpoint. defaults to 20 pixels.	
	 */
	jsPlumb.Endpoints.Rectangle = function(params) {
		this.type = "Rectangle";
		var self = this,
            _super = jsPlumb.Endpoints.AbstractEndpoint.apply(this, arguments);
		params = params || {};
		this.width = params.width || 20;
		this.height = params.height || 20;
		
		this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			var width = endpointStyle.width || self.width,
				height = endpointStyle.height || self.height,
				x = anchorPoint[0] - (width/2),
				y = anchorPoint[1] - (height/2);
                
			return [ x, y, width, height];
		};
	};
	

    var DOMElementEndpoint = function(params) {
        jsPlumb.DOMElementComponent.apply(this, arguments);
        var self = this;

        var displayElements = [  ];
        this.getDisplayElements = function() { 
            return displayElements; 
        };
        
        this.appendDisplayElement = function(el) {
            displayElements.push(el);
        };            
    };
	/**
	 * Class: Endpoints.Image
	 * Draws an image as the Endpoint.
	 */
	/**
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	src	-	location of the image to use.
	 */
	jsPlumb.Endpoints.Image = function(params) {
				
		this.type = "Image";
		DOMElementEndpoint.apply(this, arguments);
		
		var self = this,
            _super = jsPlumb.Endpoints.AbstractEndpoint.apply(this, arguments), 
			initialized = false,
			deleted = false,
			widthToUse = params.width,
			heightToUse = params.height,
            _onload = null,
            _endpoint = params.endpoint;
			
		this.img = new Image();
		self.ready = false;

		this.img.onload = function() {
			self.ready = true;
			widthToUse = widthToUse || self.img.width;
			heightToUse = heightToUse || self.img.height;
            if (_onload) {
                _onload(self);
            }
		};

        /*
            Function: setImage
            Sets the Image to use in this Endpoint.  

            Parameters:
            img         -   may be a URL or an Image object
            onload      -   optional; a callback to execute once the image has loaded.
        */
        _endpoint.setImage = function(img, onload) {
            var s = img.constructor == String ? img : img.src;
            _onload = onload;
            self.img.src = img;

            if (self.canvas != null)
                self.canvas.setAttribute("src", img);
        };

        _endpoint.setImage(params.src || params.url, params.onload);

		this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			self.anchorPoint = anchorPoint;
			if (self.ready) return [anchorPoint[0] - widthToUse / 2, anchorPoint[1] - heightToUse / 2, 
									widthToUse, heightToUse];
			else return [0,0,0,0];
		};
		
		self.canvas = document.createElement("img"), initialized = false;
		self.canvas.style["margin"] = 0;
		self.canvas.style["padding"] = 0;
		self.canvas.style["outline"] = 0;
		self.canvas.style["position"] = "absolute";
		var clazz = params.cssClass ? " " + params.cssClass : "";
		self.canvas.className = jsPlumb.endpointClass + clazz;
		if (widthToUse) self.canvas.setAttribute("width", widthToUse);
		if (heightToUse) self.canvas.setAttribute("height", heightToUse);		
		jsPlumb.appendElement(self.canvas, params.parent);
		self.attachListeners(self.canvas, self);
		
		self.cleanup = function() {
			deleted = true;
		};
		
		var actuallyPaint = function(d, style, anchor) {
			if (!deleted) {
				if (!initialized) {
					self.canvas.setAttribute("src", self.img.src);
					self.appendDisplayElement(self.canvas);
					initialized = true;
				}
				var x = self.anchorPoint[0] - (widthToUse / 2),
					y = self.anchorPoint[1] - (heightToUse / 2);
				jsPlumb.sizeCanvas(self.canvas, x, y, widthToUse, heightToUse);
			}
		};
		
		this.paint = function(style, anchor) {
			if (self.ready) {
    			actuallyPaint(style, anchor);
			}
			else { 
				window.setTimeout(function() {    					
					self.paint(style, anchor);
				}, 200);
			}
		};				
	};
	
	/*
	 * Class: Endpoints.Blank
	 * An Endpoint that paints nothing (visible) on the screen.  Supports cssClass and hoverClass parameters like all Endpoints.
	 */
	jsPlumb.Endpoints.Blank = function(params) {
		var self = this,
            _super = jsPlumb.Endpoints.AbstractEndpoint.apply(this, arguments);
		this.type = "Blank";
		DOMElementEndpoint.apply(this, arguments);		
		this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			return [anchorPoint[0], anchorPoint[1],10,0];
		};
		
		self.canvas = document.createElement("div");
		self.canvas.style.display = "block";
		self.canvas.style.width = "1px";
		self.canvas.style.height = "1px";
		self.canvas.style.background = "transparent";
		self.canvas.style.position = "absolute";
		self.canvas.className = self._jsPlumb.endpointClass;
		jsPlumb.appendElement(self.canvas, params.parent);
		
		this.paint = function(style, anchor) {
			jsPlumb.sizeCanvas(self.canvas, self.x, self.y, self.w, self.h);	
		};
	};
	
	/*
	 * Class: Endpoints.Triangle
	 * A triangular Endpoint.  
	 */
	/*
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	width	-	width of the triangle's base.  defaults to 55 pixels.
	 * 	height	-	height of the triangle from base to apex.  defaults to 55 pixels.
	 */
	jsPlumb.Endpoints.Triangle = function(params) {        
		this.type = "Triangle";
        var self = this,
            _super = jsPlumb.Endpoints.AbstractEndpoint.apply(this, arguments);
		params = params || {  };
		params.width = params.width || 55;
		params.height = params.height || 55;
		this.width = params.width;
		this.height = params.height;
		this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
			var width = endpointStyle.width || self.width,
			height = endpointStyle.height || self.height,
			x = anchorPoint[0] - (width/2),
			y = anchorPoint[1] - (height/2);
			return [ x, y, width, height ];
		};
	};
// ********************************* END OF ENDPOINT TYPES *******************************************************************
	

// ********************************* OVERLAY DEFINITIONS ***********************************************************************    

	var AbstractOverlay = jsPlumb.Overlays.AbstractOverlay = function(params) {
		var visible = true, self = this;
        this.isAppendedAtTopLevel = true;
		this.component = params.component;
		this.loc = params.location == null ? 0.5 : params.location;
        this.endpointLoc = params.endpointLocation == null ? [ 0.5, 0.5] : params.endpointLocation;
		this.setVisible = function(val) { 
			visible = val;
			self.component.repaint();
		};
    	this.isVisible = function() { return visible; };
    	this.hide = function() { self.setVisible(false); };
    	this.show = function() { self.setVisible(true); };
    	
    	this.incrementLocation = function(amount) {
    		self.loc += amount;
    		self.component.repaint();
    	};
    	this.setLocation = function(l) {
    		self.loc = l;
    		self.component.repaint();
    	};
    	this.getLocation = function() {
    		return self.loc;
    	};
	};
	
	
	/*
	 * Class: Overlays.Arrow
	 * 
	 * An arrow overlay, defined by four points: the head, the two sides of the tail, and a 'foldback' point at some distance along the length
	 * of the arrow that lines from each tail point converge into.  The foldback point is defined using a decimal that indicates some fraction
	 * of the length of the arrow and has a default value of 0.623.  A foldback point value of 1 would mean that the arrow had a straight line
	 * across the tail.  
	 */
	/*
	 * Function: Constructor
	 * 
	 * Parameters:
	 * 
	 * 	length - distance in pixels from head to tail baseline. default 20.
	 * 	width - width in pixels of the tail baseline. default 20.
	 * 	fillStyle - style to use when filling the arrow.  defaults to "black".
	 * 	strokeStyle - style to use when stroking the arrow. defaults to null, which means the arrow is not stroked.
	 * 	lineWidth - line width to use when stroking the arrow. defaults to 1, but only used if strokeStyle is not null.
	 * 	foldback - distance (as a decimal from 0 to 1 inclusive) along the length of the arrow marking the point the tail points should fold back to.  defaults to 0.623.
	 * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the arrow should sit on the connector. defaults to 0.5.
	 * 	direction - indicates the direction the arrow points in. valid values are -1 and 1; 1 is default.
	 */
	jsPlumb.Overlays.Arrow = function(params) {
		this.type = "Arrow";
		AbstractOverlay.apply(this, arguments);
        this.isAppendedAtTopLevel = false;
		params = params || {};
		var self = this, _ju = jsPlumbUtil;
		
    	this.length = params.length || 20;
    	this.width = params.width || 20;
    	this.id = params.id;
    	var direction = (params.direction || 1) < 0 ? -1 : 1,
    	    paintStyle = params.paintStyle || { lineWidth:1 },
    	    // how far along the arrow the lines folding back in come to. default is 62.3%.
    	    foldback = params.foldback || 0.623;
    	    	
    	this.computeMaxSize = function() { return self.width * 1.5; };    	
    	this.cleanup = function() { };  // nothing to clean up for Arrows    
    	this.draw = function(component, currentConnectionPaintStyle) {

            var hxy, mid, txy, tail, cxy;
            if (component.pointAlongPathFrom) {

                if (_ju.isString(self.loc) || self.loc > 1 || self.loc < 0) {                    
                    var l = parseInt(self.loc);
                    hxy = component.pointAlongPathFrom(l, direction * self.length / 2, true),
                    mid = component.pointOnPath(l, true),
                    txy = _ju.pointOnLine(hxy, mid, self.length);
                }
                else if (self.loc == 1) {                
					hxy = component.pointOnPath(self.loc);					           
                    mid = component.pointAlongPathFrom(self.loc, -(self.length));
					txy = _ju.pointOnLine(hxy, mid, self.length);
					
					if (direction == -1) {
						var _ = txy;
						txy = hxy;
						hxy = _;
					}
                }
                else if (self.loc == 0) {					                    
					txy = component.pointOnPath(self.loc);                    
					mid = component.pointAlongPathFrom(self.loc, self.length);                    
					hxy = _ju.pointOnLine(txy, mid, self.length);                    
					if (direction == -1) {
						var _ = txy;
						txy = hxy;
						hxy = _;
					}
                }
                else {                    
    			    hxy = component.pointAlongPathFrom(self.loc, direction * self.length / 2),
                    mid = component.pointOnPath(self.loc),
                    txy = _ju.pointOnLine(hxy, mid, self.length);
                }

                tail = _ju.perpendicularLineTo(hxy, txy, self.width);
                cxy = _ju.pointOnLine(hxy, txy, foldback * self.length);    			
    			
    			var d = { hxy:hxy, tail:tail, cxy:cxy },
    			    strokeStyle = paintStyle.strokeStyle || currentConnectionPaintStyle.strokeStyle,
    			    fillStyle = paintStyle.fillStyle || currentConnectionPaintStyle.strokeStyle,
    			    lineWidth = paintStyle.lineWidth || currentConnectionPaintStyle.lineWidth,
                    info = {
                        component:component, 
                        d:d, 
                        lineWidth:lineWidth, 
                        strokeStyle:strokeStyle, 
                        fillStyle:fillStyle,
                        minX:Math.min(hxy.x, tail[0].x, tail[1].x),
                        maxX:Math.max(hxy.x, tail[0].x, tail[1].x),
                        minY:Math.min(hxy.y, tail[0].y, tail[1].y),
                        maxY:Math.max(hxy.y, tail[0].y, tail[1].y)
                    };    			
						    
                return info;
            }
            else return {component:component, minX:0,maxX:0,minY:0,maxY:0};
    	};
    };          
    
    /*
     * Class: Overlays.PlainArrow
	 * 
	 * A basic arrow.  This is in fact just one instance of the more generic case in which the tail folds back on itself to some
	 * point along the length of the arrow: in this case, that foldback point is the full length of the arrow.  so it just does
	 * a 'call' to Arrow with foldback set appropriately.       
	 */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    jsPlumb.Overlays.PlainArrow = function(params) {
    	params = params || {};    	
    	var p = jsPlumb.extend(params, {foldback:1});
    	jsPlumb.Overlays.Arrow.call(this, p);
    	this.type = "PlainArrow";
    };
        
    /*
     * Class: Overlays.Diamond
     * 
	 * A diamond. Like PlainArrow, this is a concrete case of the more generic case of the tail points converging on some point...it just
	 * happens that in this case, that point is greater than the length of the the arrow.    
	 * 
	 *      this could probably do with some help with positioning...due to the way it reuses the Arrow paint code, what Arrow thinks is the
	 *      center is actually 1/4 of the way along for this guy.  but we don't have any knowledge of pixels at this point, so we're kind of
	 *      stuck when it comes to helping out the Arrow class. possibly we could pass in a 'transpose' parameter or something. the value
	 *      would be -l/4 in this case - move along one quarter of the total length.
	 */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    jsPlumb.Overlays.Diamond = function(params) {
    	params = params || {};    	
    	var l = params.length || 40,
    	    p = jsPlumb.extend(params, {length:l/2, foldback:2});
    	jsPlumb.Overlays.Arrow.call(this, p);
    	this.type = "Diamond";
    };
    
	
	// abstract superclass for overlays that add an element to the DOM.
    var AbstractDOMOverlay = function(params) {
		jsPlumb.DOMElementComponent.apply(this, arguments);
    	AbstractOverlay.apply(this, arguments);
		
		var self = this, initialised = false, jpcl = jsPlumb.CurrentLibrary;
		params = params || {};
		this.id = params.id;
		var div;
		
		var makeDiv = function() {
			div = params.create(params.component);
			div = jpcl.getDOMElement(div);
			div.style["position"] 	= 	"absolute";    	
			var clazz = params["_jsPlumb"].overlayClass + " " + 
				(self.cssClass ? self.cssClass : 
				params.cssClass ? params.cssClass : "");    	
			div.className =	clazz;
			params["_jsPlumb"].appendElement(div, params.component.parent);
			params["_jsPlumb"].getId(div);		
	    	self.attachListeners(div, self);
	    	self.canvas = div;
		};
		
		this.getElement = function() {
			if (div == null) {
				makeDiv();
			}
    		return div;
    	};
		
		this.getDimensions = function() {
    		return jpcl.getSize(jpcl.getElementObject(self.getElement()));
    	};
		
		var cachedDimensions = null,
			_getDimensions = function(component) {
				if (cachedDimensions == null)
					cachedDimensions = self.getDimensions();
				return cachedDimensions;
			};
		
		/*
		 * Function: clearCachedDimensions
		 * Clears the cached dimensions for the label. As a performance enhancement, label dimensions are
		 * cached from 1.3.12 onwards. The cache is cleared when you change the label text, of course, but
		 * there are other reasons why the text dimensions might change - if you make a change through CSS, for
		 * example, you might change the font size.  in that case you should explicitly call this method.
		 */
		this.clearCachedDimensions = function() {
			cachedDimensions = null;
		};
		
		this.computeMaxSize = function() {
    		var td = _getDimensions();
			return Math.max(td[0], td[1]);
    	}; 
		
		//override setVisible
    	var osv = self.setVisible;
    	self.setVisible = function(state) {
    		osv(state); // call superclass
    		div.style.display = state ? "block" : "none";
    	};
		
		this.cleanup = function() {
    		if (div != null) jpcl.removeElement(div);
    	};
		
		this.paint = function(params, containerExtents) {
			if (!initialised) {
				self.getElement();
				params.component.appendDisplayElement(div);
				self.attachListeners(div, params.component);
				initialised = true;
			}
			div.style.left = (params.component.x + params.d.minx) + "px";
			div.style.top = (params.component.y + params.d.miny) + "px";			
    	};
				
		this.draw = function(component, currentConnectionPaintStyle) {
	    	var td = _getDimensions();
	    	if (td != null && td.length == 2) {
				var cxy = {x:0,y:0};
                if (component.pointOnPath) {
                    var loc = self.loc, absolute = false;
                    if (jsPlumbUtil.isString(self.loc) || self.loc < 0 || self.loc > 1) {
                        loc = parseInt(self.loc);
                        absolute = true;
                    }
                    cxy = component.pointOnPath(loc, absolute);  // a connection
                }
                else {
                    var locToUse = self.loc.constructor == Array ? self.loc : self.endpointLoc;
                    cxy = { x:locToUse[0] * component.w,
                            y:locToUse[1] * component.h };      
                } 
                           
				var minx = cxy.x - (td[0] / 2),
				    miny = cxy.y - (td[1] / 2);

                return {
                    component:component, 
                    d:{ minx:minx, miny:miny, td:td, cxy:cxy },
                    minX:minx, 
                    maxX:minx + td[0], 
                    minY:miny, 
                    maxY:miny + td[1]
                };								
        	}
	    	else return {minX:0,maxX:0,minY:0,maxY:0};
	    };
	    
	    this.reattachListeners = function(connector) {
	    	if (div) {
	    		self.reattachListenersForElement(div, self, connector);
	    	}
	    };
		
	};
	
	/*
     * Class: Overlays.Custom
     * A Custom overlay. You supply a 'create' function which returns some DOM element, and jsPlumb positions it.
     * The 'create' function is passed a Connection or Endpoint.
     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * 	create - function for jsPlumb to call that returns a DOM element.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * 	id - optional id to use for later retrieval of this overlay.
     * 	
     */
    jsPlumb.Overlays.Custom = function(params) {
    	this.type = "Custom";    	
    	AbstractDOMOverlay.apply(this, arguments);		    	        		    	    		
    };

    jsPlumb.Overlays.GuideLines = function() {
        var self = this;
        self.length = 50;
        self.lineWidth = 5;
        this.type = "GuideLines";
        AbstractOverlay.apply(this, arguments);
        jsPlumb.jsPlumbUIComponent.apply(this, arguments);
        this.draw = function(connector, currentConnectionPaintStyle) {

            var head = connector.pointAlongPathFrom(self.loc, self.length / 2),
                mid = connector.pointOnPath(self.loc),
                tail = jsPlumbUtil.pointOnLine(head, mid, self.length),
                tailLine = jsPlumbUtil.perpendicularLineTo(head, tail, 40),
                headLine = jsPlumbUtil.perpendicularLineTo(tail, head, 20);

            return {
                connector:connector,
                head:head,
                tail:tail,
                headLine:headLine,
                tailLine:tailLine,                
                minX:Math.min(head.x, tail.x, headLine[0].x, headLine[1].x), 
                minY:Math.min(head.y, tail.y, headLine[0].y, headLine[1].y), 
                maxX:Math.max(head.x, tail.x, headLine[0].x, headLine[1].x), 
                maxY:Math.max(head.y, tail.y, headLine[0].y, headLine[1].y)
            };
        };

        this.cleanup = function() { };  // nothing to clean up for GuideLines
    };
    
    /*
     * Class: Overlays.Label
     * A Label overlay. For all different renderer types (SVG/Canvas/VML), jsPlumb draws a Label overlay as a styled DIV.  Version 1.3.0 of jsPlumb
     * introduced the ability to set css classes on the label; this is now the preferred way for you to style a label.  The 'labelStyle' parameter
     * is still supported in 1.3.0 but its usage is deprecated.  Under the hood, jsPlumb just turns that object into a bunch of CSS directive that it 
     * puts on the Label's 'style' attribute, so the end result is the same. 
     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * 	cssClass - optional css class string to append to css class. This string is appended "as-is", so you can of course have multiple classes
     *             defined.  This parameter is preferred to using labelStyle, borderWidth and borderStyle.
     * 	label - the label to paint.  May be a string or a function that returns a string.  Nothing will be painted if your label is null or your
     *         label function returns null.  empty strings _will_ be painted.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * 	id - optional id to use for later retrieval of this overlay.
     * 	
     */
    jsPlumb.Overlays.Label = function(params) {
		var self = this;    	
		this.labelStyle = params.labelStyle || jsPlumb.Defaults.LabelStyle;
		this.cssClass = this.labelStyle != null ? this.labelStyle.cssClass : null;
		params.create = function() {
			return document.createElement("div");
		};
    	jsPlumb.Overlays.Custom.apply(this, arguments);
		this.type = "Label";
    	
        var label = params.label || "",
            self = this,    	    
            labelText = null;
    	
    	/*
    	 * Function: setLabel
    	 * sets the label's, um, label.  you would think i'd call this function
    	 * 'setText', but you can pass either a Function or a String to this, so
    	 * it makes more sense as 'setLabel'. This uses innerHTML on the label div, so keep
         * that in mind if you need escaped HTML.
    	 */
    	this.setLabel = function(l) {
    		label = l;
    		labelText = null;
			self.clearCachedDimensions();
			_update();
    		self.component.repaint();
    	};
    	
		var _update = function() {
			if (typeof label == "function") {
    			var lt = label(self);
    			self.getElement().innerHTML = lt.replace(/\r\n/g, "<br/>");
    		}
    		else {
    			if (labelText == null) {
    				labelText = label;
    				self.getElement().innerHTML = labelText.replace(/\r\n/g, "<br/>");
    			}
    		}
		};
		
    	this.getLabel = function() {
    		return label;
    	};
    	
		var superGD = this.getDimensions;		
		this.getDimensions = function() {				
    		_update();
			return superGD();
    	};
		
    };
		

 // ********************************* END OF OVERLAY DEFINITIONS ***********************************************************************
    
})();/*
 * jsPlumb
 *
 * Title:jsPlumb 1.4.1
 *
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.
 *
 * This file contains the state machine connectors.
 *
 * Thanks to Brainstorm Mobile Solutions for supporting the development of these.
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (simon.porritt@gmail.com)
 *
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */

;(function() {

	var Line = function(x1, y1, x2, y2) {

		this.m = (y2 - y1) / (x2 - x1);
		this.b = -1 * ((this.m * x1) - y1);
	
		this.rectIntersect = function(x,y,w,h) {
			var results = [];
		
			// 	try top face
			// 	the equation of the top face is y = (0 * x) + b; y = b.
			var xInt = (y - this.b) / this.m;
			// test that the X value is in the line's range.
			if (xInt >= x && xInt <= (x + w)) results.push([ xInt, (this.m * xInt) + this.b ]);
		
			// try right face
			var yInt = (this.m * (x + w)) + this.b;
			if (yInt >= y && yInt <= (y + h)) results.push([ (yInt - this.b) / this.m, yInt ]);
		
			// 	bottom face
			var xInt = ((y + h) - this.b) / this.m;
			// test that the X value is in the line's range.
			if (xInt >= x && xInt <= (x + w)) results.push([ xInt, (this.m * xInt) + this.b ]);
		
			// try left face
			var yInt = (this.m * x) + this.b;
			if (yInt >= y && yInt <= (y + h)) results.push([ (yInt - this.b) / this.m, yInt ]);

			if (results.length == 2) {
				var midx = (results[0][0] + results[1][0]) / 2, midy = (results[0][1] + results[1][1]) / 2;
				results.push([ midx,midy ]);
				// now calculate the segment inside the rectangle where the midpoint lies.
				var xseg = midx <= x + (w / 2) ? -1 : 1,
					yseg = midy <= y + (h / 2) ? -1 : 1;
				results.push([xseg, yseg]);
				return results;
			}
		
			return null;

		};
	},
	_segment = function(x1, y1, x2, y2) {
		if (x1 <= x2 && y2 <= y1) return 1;
		else if (x1 <= x2 && y1 <= y2) return 2;
		else if (x2 <= x1 && y2 >= y1) return 3;
		return 4;
	},
		
		// the control point we will use depends on the faces to which each end of the connection is assigned, specifically whether or not the
		// two faces are parallel or perpendicular.  if they are parallel then the control point lies on the midpoint of the axis in which they
		// are parellel and varies only in the other axis; this variation is proportional to the distance that the anchor points lie from the
		// center of that face.  if the two faces are perpendicular then the control point is at some distance from both the midpoints; the amount and
		// direction are dependent on the orientation of the two elements. 'seg', passed in to this method, tells you which segment the target element
		// lies in with respect to the source: 1 is top right, 2 is bottom right, 3 is bottom left, 4 is top left.
		//
		// sourcePos and targetPos are arrays of info about where on the source and target each anchor is located.  their contents are:
		//
		// 0 - absolute x
		// 1 - absolute y
		// 2 - proportional x in element (0 is left edge, 1 is right edge)
		// 3 - proportional y in element (0 is top edge, 1 is bottom edge)
		// 	
	_findControlPoint = function(midx, midy, segment, sourceEdge, targetEdge, dx, dy, distance, proximityLimit) {
        // TODO (maybe)
        // - if anchor pos is 0.5, make the control point take into account the relative position of the elements.
        if (distance <= proximityLimit) return [midx, midy];

        if (segment === 1) {
            if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
            else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
            else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
        }
        else if (segment === 2) {
            if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
            else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
            else return [ midx + (1 * dx) , midy + (-1 * dy) ];
        }
        else if (segment === 3) {
            if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
            else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
            else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
        }
        else if (segment === 4) {
            if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
            else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
            else return [ midx + (1 * dx) , midy + (-1 * dy) ];
        }

	};	
	
	/**
     * Class: Connectors.StateMachine
     * Provides 'state machine' connectors.
     */
	/*
	 * Function: Constructor
	 * 
	 * Parameters:
	 * curviness -	measure of how "curvy" the connectors will be.  this is translated as the distance that the
     *                Bezier curve's control point is from the midpoint of the straight line connecting the two
     *              endpoints, and does not mean that the connector is this wide.  The Bezier curve never reaches
     *              its control points; they act as gravitational masses. defaults to 10.
	 * margin	-	distance from element to start and end connectors, in pixels.  defaults to 5.
	 * proximityLimit  -   sets the distance beneath which the elements are consider too close together to bother
	 *						with fancy curves. by default this is 80 pixels.
	 * loopbackRadius	-	the radius of a loopback connector.  optional; defaults to 25.
	 * showLoopback   -   If set to false this tells the connector that it is ok to paint connections whose source and target is the same element with a connector running through the element. The default value for this is true; the connector always makes a loopback connection loop around the element rather than passing through it.
	*/
	jsPlumb.Connectors.StateMachine = function(params) {
		params = params || {};
		this.type = "StateMachine";

		var self = this,
			_super =  jsPlumb.Connectors.AbstractConnector.apply(this, arguments),
			curviness = params.curviness || 10,
			margin = params.margin || 5,
			proximityLimit = params.proximityLimit || 80,
			clockwise = params.orientation && params.orientation === "clockwise",
			loopbackRadius = params.loopbackRadius || 25,
			showLoopback = params.showLoopback !== false;
		
		this._compute = function(paintInfo, params) {
			var w = Math.abs(params.sourcePos[0] - params.targetPos[0]),
				h = Math.abs(params.sourcePos[1] - params.targetPos[1]),
				x = Math.min(params.sourcePos[0], params.targetPos[0]),
				y = Math.min(params.sourcePos[1], params.targetPos[1]);				
		
			if (!showLoopback || (params.sourceEndpoint.elementId !== params.targetEndpoint.elementId)) {                            
				var _sx = params.sourcePos[0] < params.targetPos[0] ? 0  : w,
					_sy = params.sourcePos[1] < params.targetPos[1] ? 0:h,
					_tx = params.sourcePos[0] < params.targetPos[0] ? w : 0,
					_ty = params.sourcePos[1] < params.targetPos[1] ? h : 0;
            
				// now adjust for the margin
				if (params.sourcePos[2] === 0) _sx -= margin;
            	if (params.sourcePos[2] === 1) _sx += margin;
            	if (params.sourcePos[3] === 0) _sy -= margin;
            	if (params.sourcePos[3] === 1) _sy += margin;
            	if (params.targetPos[2] === 0) _tx -= margin;
            	if (params.targetPos[2] === 1) _tx += margin;
            	if (params.targetPos[3] === 0) _ty -= margin;
            	if (params.targetPos[3] === 1) _ty += margin;

            	//
	            // these connectors are quadratic bezier curves, having a single control point. if both anchors 
    	        // are located at 0.5 on their respective faces, the control point is set to the midpoint and you
        	    // get a straight line.  this is also the case if the two anchors are within 'proximityLimit', since
           	 	// it seems to make good aesthetic sense to do that. outside of that, the control point is positioned 
           	 	// at 'curviness' pixels away along the normal to the straight line connecting the two anchors.
	            // 
   	        	// there may be two improvements to this.  firstly, we might actually support the notion of avoiding nodes
            	// in the UI, or at least making a good effort at doing so.  if a connection would pass underneath some node,
            	// for example, we might increase the distance the control point is away from the midpoint in a bid to
            	// steer it around that node.  this will work within limits, but i think those limits would also be the likely
            	// limits for, once again, aesthetic good sense in the layout of a chart using these connectors.
            	//
            	// the second possible change is actually two possible changes: firstly, it is possible we should gradually
            	// decrease the 'curviness' as the distance between the anchors decreases; start tailing it off to 0 at some
            	// point (which should be configurable).  secondly, we might slightly increase the 'curviness' for connectors
            	// with respect to how far their anchor is from the center of its respective face. this could either look cool,
            	// or stupid, and may indeed work only in a way that is so subtle as to have been a waste of time.
            	//

				var _midx = (_sx + _tx) / 2, _midy = (_sy + _ty) / 2, 
            	    m2 = (-1 * _midx) / _midy, theta2 = Math.atan(m2),
            	    dy =  (m2 == Infinity || m2 == -Infinity) ? 0 : Math.abs(curviness / 2 * Math.sin(theta2)),
				    dx =  (m2 == Infinity || m2 == -Infinity) ? 0 : Math.abs(curviness / 2 * Math.cos(theta2)),
				    segment = _segment(_sx, _sy, _tx, _ty),
				    distance = Math.sqrt(Math.pow(_tx - _sx, 2) + Math.pow(_ty - _sy, 2)),			
	            	// calculate the control point.  this code will be where we'll put in a rudimentary element avoidance scheme; it
	            	// will work by extending the control point to force the curve to be, um, curvier.
					_controlPoint = _findControlPoint(_midx,
                                                  _midy,
                                                  segment,
                                                  params.sourcePos,
                                                  params.targetPos,
                                                  curviness, curviness,
                                                  distance,
                                                  proximityLimit);

				_super.addSegment("Bezier", {
					x1:_tx, y1:_ty, x2:_sx, y2:_sy,
					cp1x:_controlPoint[0], cp1y:_controlPoint[1],
					cp2x:_controlPoint[0], cp2y:_controlPoint[1]
				});				
            }
            else {
            	// a loopback connector.  draw an arc from one anchor to the other.            	
        		var x1 = params.sourcePos[0], x2 = params.sourcePos[0], y1 = params.sourcePos[1] - margin, y2 = params.sourcePos[1] - margin, 				
					cx = x1, cy = y1 - loopbackRadius;
				
					// canvas sizing stuff, to ensure the whole painted area is visible.
					w = 2 * loopbackRadius, 
					h = 2 * loopbackRadius,
					x = cx - loopbackRadius, 
					y = cy - loopbackRadius;

				paintInfo.points[0] = x;
				paintInfo.points[1] = y;
				paintInfo.points[2] = w;
				paintInfo.points[3] = h;
				
				// ADD AN ARC SEGMENT.
				_super.addSegment("Arc", {
					x1:(x1-x) + 4,
					y1:y1-y,
					startAngle:0,
					endAngle: 2 * Math.PI,
					r:loopbackRadius,
					ac:!clockwise,
					x2:(x1-x) - 4,
					y2:y1-y,
					cx:cx-x,
					cy:cy-y
				});
            }                           
        };                        
	};
})();

/*
    	// a possible rudimentary avoidance scheme, old now, perhaps not useful.
        //      if (avoidSelector) {
		//		    var testLine = new Line(sourcePos[0] + _sx,sourcePos[1] + _sy,sourcePos[0] + _tx,sourcePos[1] + _ty);
		//		    var sel = jsPlumb.getSelector(avoidSelector);
		//		    for (var i = 0; i < sel.length; i++) {
		//			    var id = jsPlumb.getId(sel[i]);
		//			    if (id != sourceEndpoint.elementId && id != targetEndpoint.elementId) {
		//				    o = jsPlumb.getOffset(id), s = jsPlumb.getSize(id);
//
//						    if (o && s) {
//							    var collision = testLine.rectIntersect(o.left,o.top,s[0],s[1]);
//							    if (collision) {
								    // set the control point to be a certain distance from the midpoint of the two points that
								    // the line crosses on the rectangle.
								    // TODO where will this 75 number come from?
					//			    _controlX = collision[2][0] + (75 * collision[3][0]);
				//	/			    _controlY = collision[2][1] + (75 * collision[3][1]);
//							    }
//						    }
					//  }
	//			    }
              //}
    *//*
 * jsPlumb
 * 
 * Title:jsPlumb 1.4.1
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the 'flowchart' connectors, consisting of vertical and horizontal line segments.
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (simon.porritt@gmail.com)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {
   
    /**
     * Function: Constructor
     * 
     * Parameters:
     * 	stub - minimum length for the stub at each end of the connector. This can be an integer, giving a value for both ends of the connections, 
     * or an array of two integers, giving separate values for each end. The default is an integer with value 30 (pixels). 
     *  gap  - gap to leave between the end of the connector and the element on which the endpoint resides. if you make this larger than stub then you will see some odd looking behaviour.  
                Like stub, this can be an array or a single value. defaults to 0 pixels for each end.     
     * cornerRadius - optional, defines the radius of corners between segments. defaults to 0 (hard edged corners).
     * alwaysRespectStubs - defaults to false. whether or not the connectors should always draw the stub, or, if the two elements
                            are in close proximity to each other (closer than the sum of the two stubs), to adjust the stubs.
     */
    jsPlumb.Connectors.Flowchart = function(params) {
        this.type = "Flowchart";
        params = params || {};
        params.stub = params.stub || 30;
        var self = this,
            _super =  jsPlumb.Connectors.AbstractConnector.apply(this, arguments),		
            midpoint = params.midpoint || 0.5,
            points = [], segments = [],
            grid = params.grid,
            alwaysRespectStubs = params.alwaysRespectStubs,
            userSuppliedSegments = null,
            lastx = null, lasty = null, lastOrientation,	
            cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0,	
            sgn = function(n) { return n < 0 ? -1 : n == 0 ? 0 : 1; },            
            /**
             * helper method to add a segment.
             */
            addSegment = function(segments, x, y, paintInfo) {
                if (lastx == x && lasty == y) return;
                var lx = lastx == null ? paintInfo.sx : lastx,
                    ly = lasty == null ? paintInfo.sy : lasty,
                    o = lx == x ? "v" : "h",
                    sgnx = sgn(x - lx),
                    sgny = sgn(y - ly);
                    
                lastx = x;
                lasty = y;				    		                
                segments.push([lx, ly, x, y, o, sgnx, sgny]);
            },
            segLength = function(s) {
                return Math.sqrt(Math.pow(s[0] - s[2], 2) + Math.pow(s[1] - s[3], 2));    
            },
            _cloneArray = function(a) { var _a = []; _a.push.apply(_a, a); return _a;},
            updateMinMax = function(a1) {
                self.bounds.minX = Math.min(self.bounds.minX, a1[2]);
                self.bounds.maxX = Math.max(self.bounds.maxX, a1[2]);
                self.bounds.minY = Math.min(self.bounds.minY, a1[3]);
                self.bounds.maxY = Math.max(self.bounds.maxY, a1[3]);    
            },
            writeSegments = function(segments, paintInfo) {
                var current, next;                
                for (var i = 0; i < segments.length - 1; i++) {
                    
                    current = current || _cloneArray(segments[i]);
                    next = _cloneArray(segments[i + 1]);
                    if (cornerRadius > 0 && current[4] != next[4]) {
                        var radiusToUse = Math.min(cornerRadius, segLength(current), segLength(next));
                        // right angle. adjust current segment's end point, and next segment's start point.
                        current[2] -= current[5] * radiusToUse;
                        current[3] -= current[6] * radiusToUse;
                        next[0] += next[5] * radiusToUse;
                        next[1] += next[6] * radiusToUse;														                         			
                        var ac = (current[6] == next[5] && next[5] == 1) ||
                                 ((current[6] == next[5] && next[5] == 0) && current[5] != next[6]) ||
                                 (current[6] == next[5] && next[5] == -1),
                            sgny = next[1] > current[3] ? 1 : -1,
                            sgnx = next[0] > current[2] ? 1 : -1,
                            sgnEqual = sgny == sgnx,
                            cx = (sgnEqual && ac || (!sgnEqual && !ac)) ? next[0] : current[2],
                            cy = (sgnEqual && ac || (!sgnEqual && !ac)) ? current[3] : next[1];                                                        
                        
                        _super.addSegment("Straight", {
                            x1:current[0], y1:current[1], x2:current[2], y2:current[3]
                        });
                            
                        _super.addSegment("Arc", {
                            r:radiusToUse, 
                            x1:current[2], 
                            y1:current[3], 
                            x2:next[0], 
                            y2:next[1],
                            cx:cx,
                            cy:cy,
                            ac:ac
                        });	                                            
                    }
                    else {                 
                        // dx + dy are used to adjust for line width.
                        var dx = (current[2] == current[0]) ? 0 : (current[2] > current[0]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2),
                            dy = (current[3] == current[1]) ? 0 : (current[3] > current[1]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2);
                        _super.addSegment("Straight", {
                            x1:current[0]- dx, y1:current[1]-dy, x2:current[2] + dx, y2:current[3] + dy
                        });
                    }                    
                    current = next;
                }
                // last segment
                _super.addSegment("Straight", {
                    x1:next[0], y1:next[1], x2:next[2], y2:next[3]
                });                             
            };
        
        this.setSegments = function(s) {
            userSuppliedSegments = s;
        };
        
        this.isEditable = function() { return true; };
        
        /*
            Function: getOriginalSegments
            Gets the segments before the addition of rounded corners. This is used by the flowchart
            connector editor, since it only wants to concern itself with the original segments.
        */
        this.getOriginalSegments = function() {
            return userSuppliedSegments || segments;
        };
        
        this._compute = function(paintInfo, params) {
            
            if (params.clearEdits)
                userSuppliedSegments = null;
            
            if (userSuppliedSegments != null) {
                writeSegments(userSuppliedSegments, paintInfo);                
                return;
            }
            
            segments = [];
            lastx = null; lasty = null;
            lastOrientation = null;          
            
            var midx = paintInfo.startStubX + ((paintInfo.endStubX - paintInfo.startStubX) * midpoint),
                midy = paintInfo.startStubY + ((paintInfo.endStubY - paintInfo.startStubY) * midpoint);                                                                                                    
    
            var findClearedLine = function(start, mult, anchorPos, dimension) {
                    return start + (mult * (( 1 - anchorPos) * dimension) + _super.maxStub);
                },
                orientations = { x:[ 0, 1 ], y:[ 1, 0 ] },
                commonStubCalculator = function(axis) {
                    return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];                    
                },
                stubCalculators = {
                    perpendicular:commonStubCalculator,
                    orthogonal:commonStubCalculator,
                    opposite:function(axis) {  
                        var pi = paintInfo,
                            idx = axis == "x" ? 0 : 1, 
                            areInProximity = {
                                "x":function() {                                    
                                    return ( (pi.so[idx] == 1 && ( 
                                        ( (pi.startStubX > pi.endStubX) && (pi.tx > pi.startStubX) ) ||
                                        ( (pi.sx > pi.endStubX) && (pi.tx > pi.sx))))) ||

                                        ( (pi.so[idx] == -1 && ( 
                                            ( (pi.startStubX < pi.endStubX) && (pi.tx < pi.startStubX) ) ||
                                            ( (pi.sx < pi.endStubX) && (pi.tx < pi.sx)))));
                                },
                                "y":function() {                                     
                                    return ( (pi.so[idx] == 1 && ( 
                                        ( (pi.startStubY > pi.endStubY) && (pi.ty > pi.startStubY) ) ||
                                        ( (pi.sy > pi.endStubY) && (pi.ty > pi.sy))))) ||

                                        ( (pi.so[idx] == -1 && ( 
                                        ( (pi.startStubY < pi.endStubY) && (pi.ty < pi.startStubY) ) ||
                                        ( (pi.sy < pi.endStubY) && (pi.ty < pi.sy)))));
                                }
                            };

                        if (!alwaysRespectStubs && areInProximity[axis]()) {                   
                            return {
                                "x":[(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY],
                                "y":[paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]
                            }[axis];
                        }
                        else {
                            return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];   
                        }
                    }
                },
                lineCalculators = {
                    perpendicular : function(axis, ss, oss, es, oes) {
                        with (paintInfo) {
                            var sis = {
                                x:[ [ [ 1,2,3,4 ], null, [ 2,1,4,3 ] ], null, [ [ 4,3,2,1 ], null, [ 3,4,1,2 ] ] ],
                                y:[ [ [ 3,2,1,4 ], null, [ 2,3,4,1 ] ], null, [ [ 4,1,2,3 ], null, [ 1,4,3,2 ] ] ]
                            },
                            stubs = { 
                                x:[ [ startStubX, endStubX ] , null, [ endStubX, startStubX ] ],
                                y:[ [ startStubY, endStubY ] , null, [ endStubY, startStubY ] ]
                            },
                            midLines = {
                                x:[ [ midx, startStubY ], [ midx, endStubY ] ],
                                y:[ [ startStubX, midy ], [ endStubX, midy ] ]
                            },
                            linesToEnd = {
                                x:[ [ endStubX, startStubY ] ],
                                y:[ [ startStubX, endStubY ] ]
                            },
                            startToEnd = {
                                x:[ [ startStubX, endStubY ], [ endStubX, endStubY ] ],        
                                y:[ [ endStubX, startStubY ], [ endStubX, endStubY ] ]
                            },
                            startToMidToEnd = {
                                x:[ [ startStubX, midy ], [ endStubX, midy ], [ endStubX, endStubY ] ],
                                y:[ [ midx, startStubY ], [ midx, endStubY ], [ endStubX, endStubY ] ]
                            },
                            otherStubs = {
                                x:[ startStubY, endStubY ],
                                y:[ startStubX, endStubX ]                                    
                            },
                                        
                            soIdx = orientations[axis][0], toIdx = orientations[axis][1],
                            _so = so[soIdx] + 1,
                            _to = to[toIdx] + 1,
                            otherFlipped = (to[toIdx] == -1 && (otherStubs[axis][1] < otherStubs[axis][0])) || (to[toIdx] == 1 && (otherStubs[axis][1] > otherStubs[axis][0])),
                            stub1 = stubs[axis][_so][0],
                            stub2 = stubs[axis][_so][1],
                            segmentIndexes = sis[axis][_so][_to];
                            
                            if (segment == segmentIndexes[3] || (segment == segmentIndexes[2] && otherFlipped)) {
                                return midLines[axis];       
                            }
                            else if (segment == segmentIndexes[2] && stub2 < stub1) {
                                return linesToEnd[axis];
                            }
                            else if ((segment == segmentIndexes[2] && stub2 >= stub1) || (segment == segmentIndexes[1] && !otherFlipped)) {
                                return startToMidToEnd[axis];
                            }
                            else if (segment == segmentIndexes[0] || (segment == segmentIndexes[1] && otherFlipped)) {
                                return startToEnd[axis];  
                            }                                
                        }                                
                    },
                    orthogonal : function(axis, startStub, otherStartStub, endStub, otherEndStub) {                    
                        var pi = paintInfo,                                            
                            extent = {
                                "x":pi.so[0] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),
                                "y":pi.so[1] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)
                            }[axis];
                                                
                        return {
                            "x":[ [ extent, otherStartStub ],[ extent, otherEndStub ], [ endStub, otherEndStub ] ],
                            "y":[ [ otherStartStub, extent ], [ otherEndStub, extent ], [ otherEndStub, endStub ] ]
                        }[axis];                    
                    },
                    opposite : function(axis, ss, oss, es, oes) {                                                
                        var pi = paintInfo,
                            otherAxis = {"x":"y","y":"x"}[axis], 
                            dim = {"x":"height","y":"width"}[axis],
                            comparator = pi["is" + axis.toUpperCase() + "GreaterThanStubTimes2"];

                        if (params.sourceEndpoint.elementId == params.targetEndpoint.elementId) {
                            var _val = oss + ((1 - params.sourceEndpoint.anchor[otherAxis]) * params.sourceInfo[dim]) + _super.maxStub;
                            return {
                                "x":[ [ ss, _val ], [ es, _val ] ],
                                "y":[ [ _val, ss ], [ _val, es ] ]
                            }[axis];
                            
                        }                                                        
                        else if (!comparator || (pi.so[idx] == 1 && ss > es)
                           || (pi.so[idx] == -1 && ss < es)) {                                            
                            return {
                                "x":[[ ss, midy ], [ es, midy ]],
                                "y":[[ midx, ss ], [ midx, es ]]
                            }[axis];
                        }
                        else if ((pi.so[idx] == 1 && ss < es) || (pi.so[idx] == -1 && ss > es)) {
                            return {
                                "x":[[ midx, pi.sy ], [ midx, pi.ty ]],
                                "y":[[ pi.sx, midy ], [ pi.tx, midy ]]
                            }[axis];
                        }                        
                    }
                };

            var stubs = stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis),
                idx = paintInfo.sourceAxis == "x" ? 0 : 1,
                oidx = paintInfo.sourceAxis == "x" ? 1 : 0,                            
                ss = stubs[idx],
                oss = stubs[oidx],
                es = stubs[idx + 2],
                oes = stubs[oidx + 2];

            // add the start stub segment.
            addSegment(segments, stubs[0], stubs[1], paintInfo);           

            // compute the rest of the line
            var p = lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis, ss, oss, es, oes);            
            if (p) {
                for (var i = 0; i < p.length; i++) {                	
                    addSegment(segments, p[i][0], p[i][1], paintInfo);
                }
            }          
            
            // line to end stub
            addSegment(segments, stubs[2], stubs[3], paintInfo);
    
            // end stub to end
            addSegment(segments, paintInfo.tx, paintInfo.ty, paintInfo);               
            
            writeSegments(segments, paintInfo);                            
        };	

        this.getPath = function() {
            var _last = null, _lastAxis = null, s = [], segs = userSuppliedSegments || segments;
            for (var i = 0; i < segs.length; i++) {
                var seg = segs[i], axis = seg[4], axisIndex = (axis == "v" ? 3 : 2);
                if (_last != null && _lastAxis === axis) {
                    _last[axisIndex] = seg[axisIndex];                            
                }
                else {
                    if (seg[0] != seg[2] || seg[1] != seg[3]) {
                        s.push({
                            start:[ seg[0], seg[1] ],
                            end:[ seg[2], seg[3] ]
                        });                    
                        _last = seg;
                        _lastAxis = seg[4];
                    }
                }
            }
            return s;
        };	

        this.setPath = function(path) {
            userSuppliedSegments = [];
            for (var i = 0; i < path.length; i++) {
                 var lx = path[i].start[0],
                    ly = path[i].start[1],
                    x = path[i].end[0],
                    y = path[i].end[1],
                    o = lx == x ? "v" : "h",
                    sgnx = sgn(x - lx),
                    sgny = sgn(y - ly);

                userSuppliedSegments.push([lx, ly, x, y, o, sgnx, sgny]);
            }
        };
    };
})();/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.4.1
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the VML renderers.
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */

;(function() {
	
	// http://ajaxian.com/archives/the-vml-changes-in-ie-8
	// http://www.nczonline.net/blog/2010/01/19/internet-explorer-8-document-and-browser-modes/
	// http://www.louisremi.com/2009/03/30/changes-in-vml-for-ie8-or-what-feature-can-the-ie-dev-team-break-for-you-today/
	
	var vmlAttributeMap = {
		"stroke-linejoin":"joinstyle",
		"joinstyle":"joinstyle",		
		"endcap":"endcap",
		"miterlimit":"miterlimit"
	},
	jsPlumbStylesheet = null;
	
	if (document.createStyleSheet && document.namespaces) {			
		
		var ruleClasses = [
				".jsplumb_vml", "jsplumb\\:textbox", "jsplumb\\:oval", "jsplumb\\:rect", 
				"jsplumb\\:stroke", "jsplumb\\:shape", "jsplumb\\:group"
			],
			rule = "behavior:url(#default#VML);position:absolute;";

		jsPlumbStylesheet = document.createStyleSheet();

		for (var i = 0; i < ruleClasses.length; i++)
			jsPlumbStylesheet.addRule(ruleClasses[i], rule);

		// in this page it is also mentioned that IE requires the extra arg to the namespace
		// http://www.louisremi.com/2009/03/30/changes-in-vml-for-ie8-or-what-feature-can-the-ie-dev-team-break-for-you-today/
		// but someone commented saying they didn't need it, and it seems jsPlumb doesnt need it either.
		// var iev = document.documentMode;
		//if (!iev || iev < 8)
			document.namespaces.add("jsplumb", "urn:schemas-microsoft-com:vml");
		//else
		//	document.namespaces.add("jsplumb", "urn:schemas-microsoft-com:vml", "#default#VML");
	}
	
	jsPlumb.vml = {};
	
	var scale = 1000,

    _groupMap = {},
    _getGroup = function(container, connectorClass) {
        var id = jsPlumb.getId(container),
            g = _groupMap[id];
        if(!g) {
            g = _node("group", [0,0,scale, scale], {"class":connectorClass});
            //g.style.position=absolute;
            //g["coordsize"] = "1000,1000";
            g.style.backgroundColor="red";
            _groupMap[id] = g;
            jsPlumb.appendElement(g, container);  // todo if this gets reinstated, remember to use the current jsplumb instance.
            //document.body.appendChild(g);
        }
        return g;
    },
	_atts = function(o, atts) {
		for (var i in atts) { 
			// IE8 fix: setattribute does not work after an element has been added to the dom!
			// http://www.louisremi.com/2009/03/30/changes-in-vml-for-ie8-or-what-feature-can-the-ie-dev-team-break-for-you-today/
			//o.setAttribute(i, atts[i]);

			/*There is an additional problem when accessing VML elements by using get/setAttribute. The simple solution is following:

			if (document.documentMode==8) {
			ele.opacity=1;
			} else {
			ele.setAttribute(‘opacity’,1);
			}
			*/

			o[i] = atts[i];
		}
	},
	_node = function(name, d, atts, parent, _jsPlumb, deferToJsPlumbContainer) {
		atts = atts || {};
		var o = document.createElement("jsplumb:" + name);
		if (deferToJsPlumbContainer)
			_jsPlumb.appendElement(o, parent);
		else
			jsPlumb.CurrentLibrary.appendElement(o, parent);
		o.className = (atts["class"] ? atts["class"] + " " : "") + "jsplumb_vml";
		_pos(o, d);
		_atts(o, atts);
		return o;
	},
	_pos = function(o,d, zIndex) {
		o.style.left = d[0] + "px";		
		o.style.top =  d[1] + "px";
		o.style.width= d[2] + "px";
		o.style.height= d[3] + "px";
		o.style.position = "absolute";
		if (zIndex)
			o.style.zIndex = zIndex;
	},
	_conv = jsPlumb.vml.convertValue = function(v) {
		return Math.floor(v * scale);
	},	
	// tests if the given style is "transparent" and then sets the appropriate opacity node to 0 if so,
	// or 1 if not.  TODO in the future, support variable opacity.
	_maybeSetOpacity = function(styleToWrite, styleToCheck, type, component) {
		if ("transparent" === styleToCheck)
			component.setOpacity(type, "0.0");
		else
			component.setOpacity(type, "1.0");
	},
	_applyStyles = function(node, style, component, _jsPlumb) {
		var styleToWrite = {};
		if (style.strokeStyle) {
			styleToWrite["stroked"] = "true";
			var strokeColor = jsPlumbUtil.convertStyle(style.strokeStyle, true);
			styleToWrite["strokecolor"] = strokeColor;
			_maybeSetOpacity(styleToWrite, strokeColor, "stroke", component);
			styleToWrite["strokeweight"] = style.lineWidth + "px";
		}
		else styleToWrite["stroked"] = "false";
		
		if (style.fillStyle) {
			styleToWrite["filled"] = "true";
			var fillColor = jsPlumbUtil.convertStyle(style.fillStyle, true);
			styleToWrite["fillcolor"] = fillColor;
			_maybeSetOpacity(styleToWrite, fillColor, "fill", component);
		}
		else styleToWrite["filled"] = "false";
		
		if(style["dashstyle"]) {
			if (component.strokeNode == null) {
				component.strokeNode = _node("stroke", [0,0,0,0], { dashstyle:style["dashstyle"] }, node, _jsPlumb);				
			}
			else
				component.strokeNode.dashstyle = style["dashstyle"];
		}					
		else if (style["stroke-dasharray"] && style["lineWidth"]) {
			var sep = style["stroke-dasharray"].indexOf(",") == -1 ? " " : ",",
			parts = style["stroke-dasharray"].split(sep),
			styleToUse = "";
			for(var i = 0; i < parts.length; i++) {
				styleToUse += (Math.floor(parts[i] / style.lineWidth) + sep);
			}
			if (component.strokeNode == null) {
				component.strokeNode = _node("stroke", [0,0,0,0], { dashstyle:styleToUse }, node, _jsPlumb);				
			}
			else
				component.strokeNode.dashstyle = styleToUse;
		}
		
		_atts(node, styleToWrite);
	},
	/*
	 * Base class for Vml endpoints and connectors. Extends jsPlumbUIComponent. 
	 */
	VmlComponent = function() {				
		var self = this, renderer = {};
		jsPlumb.jsPlumbUIComponent.apply(this, arguments);	




		this.opacityNodes = {
			"stroke":null,
			"fill":null
		};
		this.initOpacityNodes = function(vml) {
			self.opacityNodes["stroke"] = _node("stroke", [0,0,1,1], {opacity:"0.0"}, vml, self._jsPlumb);
			self.opacityNodes["fill"] = _node("fill", [0,0,1,1], {opacity:"0.0"}, vml, self._jsPlumb);							
		};
		this.setOpacity = function(type, value) {
			var node = self.opacityNodes[type];
			if (node) node["opacity"] = "" + value;
		};
		var displayElements = [ ];
		this.getDisplayElements = function() { 
			return displayElements; 
		};
		
		this.appendDisplayElement = function(el, doNotAppendToCanvas) {
			if (!doNotAppendToCanvas) self.canvas.parentNode.appendChild(el);
			displayElements.push(el);
		};
	},	
	/*
	 * Base class for Vml connectors. extends VmlComponent.
	 */
	VmlConnector = jsPlumb.ConnectorRenderers.vml = function(params) {
		var self = this;
		self.strokeNode = null;
		self.canvas = null;
		var _super = VmlComponent.apply(this, arguments);
		var clazz = self._jsPlumb.connectorClass + (params.cssClass ? (" " + params.cssClass) : "");
		this.paint = function(style) {		
			if (style !== null) {				
				var segments = self.getSegments(), p = { "path":"" },
                    d = [self.x,self.y,self.w,self.h];
				
				// create path from segments.	
				for (var i = 0; i < segments.length; i++) {
					p.path += jsPlumb.Segments.vml.SegmentRenderer.getPath(segments[i]);
					p.path += " ";
				}

                //*
				if (style.outlineColor) {
					var outlineWidth = style.outlineWidth || 1,
					outlineStrokeWidth = style.lineWidth + (2 * outlineWidth),
					outlineStyle = {
						strokeStyle : jsPlumbUtil.convertStyle(style.outlineColor),
						lineWidth : outlineStrokeWidth
					};
					for (var aa in vmlAttributeMap) outlineStyle[aa] = style[aa];
					
					if (self.bgCanvas == null) {						
						p["class"] = clazz;
						p["coordsize"] = (d[2] * scale) + "," + (d[3] * scale);
						self.bgCanvas = _node("shape", d, p, params.parent, self._jsPlumb, true);						
						_pos(self.bgCanvas, d);
						self.appendDisplayElement(self.bgCanvas, true);	
						self.attachListeners(self.bgCanvas, self);					
						self.initOpacityNodes(self.bgCanvas, ["stroke"]);		
					}
					else {
						p["coordsize"] = (d[2] * scale) + "," + (d[3] * scale);
						_pos(self.bgCanvas, d);
						_atts(self.bgCanvas, p);
					}
					
					_applyStyles(self.bgCanvas, outlineStyle, self);
				}
				//*/
				
				if (self.canvas == null) {										
					p["class"] = clazz;
					p["coordsize"] = (d[2] * scale) + "," + (d[3] * scale);					
					self.canvas = _node("shape", d, p, params.parent, self._jsPlumb, true);					                
                    //var group = _getGroup(params.parent);                   // test of append everything to a group
                    //group.appendChild(self.canvas);                           // sort of works but not exactly;
					//params["_jsPlumb"].appendElement(self.canvas, params.parent);    //before introduction of groups

					self.appendDisplayElement(self.canvas, true);										
					self.attachListeners(self.canvas, self);					
					self.initOpacityNodes(self.canvas, ["stroke"]);		
				}
				else {
					p["coordsize"] = (d[2] * scale) + "," + (d[3] * scale);
					_pos(self.canvas, d);
					_atts(self.canvas, p);
				}
				
				_applyStyles(self.canvas, style, self, self._jsPlumb);
			}
		};	
		
		this.reattachListeners = function() {
			if (self.canvas) self.reattachListenersForElement(self.canvas, self);
		};
	},		
	
	/*
	 * 
	 * Base class for Vml Endpoints. extends VmlComponent.
	 * 
	 */
	VmlEndpoint = window.VmlEndpoint = function(params) {
		VmlComponent.apply(this, arguments);
		var vml = null, self = this, opacityStrokeNode = null, opacityFillNode = null;
		self.canvas = document.createElement("div");
		self.canvas.style["position"] = "absolute";

		var clazz = self._jsPlumb.endpointClass + (params.cssClass ? (" " + params.cssClass) : "");

		// TODO vml endpoint adds class to VML at constructor time.  but the addClass method adds VML
		// to the enclosing DIV. what to do?  seems like it would be better to just target the div.
		// HOWEVER...vml connection has no containing div.  why not? it feels like it should.

		//var group = _getGroup(params.parent);
        //group.appendChild(self.canvas);
		params["_jsPlumb"].appendElement(self.canvas, params.parent);

		this.paint = function(style, anchor) {
			var p = { };					
			
			jsPlumb.sizeCanvas(self.canvas, self.x, self.y, self.w, self.h);
			if (vml == null) {
				p["class"] = clazz;
				vml = self.getVml([0,0, self.w, self.h], p, anchor, self.canvas, self._jsPlumb);				
				self.attachListeners(vml, self);

				self.appendDisplayElement(vml, true);
				self.appendDisplayElement(self.canvas, true);
				
				self.initOpacityNodes(vml, ["fill"]);			
			}
			else {				
				_pos(vml, [0,0, self.w, self.h]);
				_atts(vml, p);
			}
			
			_applyStyles(vml, style, self);
		};
		
		this.reattachListeners = function() {
			if (vml) self.reattachListenersForElement(vml, self);
		};
	};
	
// ******************************* vml segments *****************************************************	
		
	jsPlumb.Segments.vml = {
		SegmentRenderer : {		
			getPath : function(segment) {
				return ({
					"Straight":function(segment) {
						var d = segment.params;
						return "m" + _conv(d.x1) + "," + _conv(d.y1) + " l" + _conv(d.x2) + "," + _conv(d.y2) + " e";
					},
					"Bezier":function(segment) {
						var d = segment.params;
						return "m" + _conv(d.x1) + "," + _conv(d.y1) + 
				   			" c" + _conv(d.cp1x) + "," + _conv(d.cp1y) + "," + _conv(d.cp2x) + "," + _conv(d.cp2y) + "," + _conv(d.x2) + "," + _conv(d.y2) + " e";
					},
					"Arc":function(segment) {					
						var d = segment.params,
							xmin = Math.min(d.x1, d.x2),
							xmax = Math.max(d.x1, d.x2),
							ymin = Math.min(d.y1, d.y2),
							ymax = Math.max(d.y1, d.y2),														
							sf = segment.anticlockwise ? 1 : 0,
							pathType = (segment.anticlockwise ? "at " : "wa "),
							makePosString = function() {
								var xy = [
										null,
										[ function() { return [xmin, ymin ];}, function() { return [xmin - d.r, ymin - d.r ];}],
										[ function() { return [xmin - d.r, ymin ];}, function() { return [xmin, ymin - d.r ];}],
										[ function() { return [xmin - d.r, ymin - d.r ];}, function() { return [xmin, ymin ];}],
										[ function() { return [xmin, ymin - d.r ];}, function() { return [xmin - d.r, ymin ];}]
									][segment.segment][sf]();

								return _conv(xy[0]) + "," + _conv(xy[1]) + "," + _conv(xy[0] + (2*d.r)) + "," + _conv(xy[1] + (2*d.r));
							};

						
						return pathType + makePosString() + "," + _conv(d.x1) + ","
								+ _conv(d.y1) + "," + _conv(d.x2) + "," + _conv(d.y2) + " e";						
					}
						
				})[segment.type](segment);	
			}
		}
	};
	
// ******************************* /vml segments *****************************************************	

// ******************************* vml endpoints *****************************************************
	
	jsPlumb.Endpoints.vml.Dot = function() {
		jsPlumb.Endpoints.Dot.apply(this, arguments);
		VmlEndpoint.apply(this, arguments);
		this.getVml = function(d, atts, anchor, parent, _jsPlumb) { return _node("oval", d, atts, parent, _jsPlumb); };
	};
	
	jsPlumb.Endpoints.vml.Rectangle = function() {
		jsPlumb.Endpoints.Rectangle.apply(this, arguments);
		VmlEndpoint.apply(this, arguments);
		this.getVml = function(d, atts, anchor, parent, _jsPlumb) { return _node("rect", d, atts, parent, _jsPlumb); };
	};
	
	/*
	 * VML Image Endpoint is the same as the default image endpoint.
	 */
	jsPlumb.Endpoints.vml.Image = jsPlumb.Endpoints.Image;
	
	/**
	 * placeholder for Blank endpoint in vml renderer.
	 */
	jsPlumb.Endpoints.vml.Blank = jsPlumb.Endpoints.Blank;
	
// ******************************* /vml endpoints *****************************************************	

// ******************************* vml overlays *****************************************************
	
	/**
	 * VML Label renderer. uses the default label renderer (which adds an element to the DOM)
	 */
	jsPlumb.Overlays.vml.Label  = jsPlumb.Overlays.Label;
	
	/**
	 * VML Custom renderer. uses the default Custom renderer (which adds an element to the DOM)
	 */
	jsPlumb.Overlays.vml.Custom = jsPlumb.Overlays.Custom;
	
	/**
	 * Abstract VML arrow superclass
	 */
	var AbstractVmlArrowOverlay = function(superclass, originalArgs) {
    	superclass.apply(this, originalArgs);
    	VmlComponent.apply(this, originalArgs);
    	var self = this, path = null;
    	self.canvas = null; 
    	self.isAppendedAtTopLevel = true;
    	var getPath = function(d) {    		
    		return "m " + _conv(d.hxy.x) + "," + _conv(d.hxy.y) +
    		       " l " + _conv(d.tail[0].x) + "," + _conv(d.tail[0].y) + 
    		       " " + _conv(d.cxy.x) + "," + _conv(d.cxy.y) + 
    		       " " + _conv(d.tail[1].x) + "," + _conv(d.tail[1].y) + 
    		       " x e";
    	};
    	this.paint = function(params, containerExtents) {
    		var p = {}, d = params.d, connector = params.component;
			if (params.strokeStyle) {
				p["stroked"] = "true";
				p["strokecolor"] = jsPlumbUtil.convertStyle(params.strokeStyle, true);    				
			}
			if (params.lineWidth) p["strokeweight"] = params.lineWidth + "px";
			if (params.fillStyle) {
				p["filled"] = "true";
				p["fillcolor"] = params.fillStyle;
			}
			var xmin = Math.min(d.hxy.x, d.tail[0].x, d.tail[1].x, d.cxy.x),
				ymin = Math.min(d.hxy.y, d.tail[0].y, d.tail[1].y, d.cxy.y),
				xmax = Math.max(d.hxy.x, d.tail[0].x, d.tail[1].x, d.cxy.x),
				ymax = Math.max(d.hxy.y, d.tail[0].y, d.tail[1].y, d.cxy.y),
				w = Math.abs(xmax - xmin),
				h = Math.abs(ymax - ymin),
				dim = [xmin, ymin, w, h];
			
			// for VML, we create overlays using shapes that have the same dimensions and
			// coordsize as their connector - overlays calculate themselves relative to the
			// connector (it's how it's been done since the original canvas implementation, because
			// for canvas that makes sense).
			p["path"] = getPath(d);
			p["coordsize"] = (connector.w * scale) + "," + (connector.h * scale);
			
			dim[0] = connector.x;
			dim[1] = connector.y;
			dim[2] = connector.w;
			dim[3] = connector.h;
			
    		if (self.canvas == null) {
    			var overlayClass = connector._jsPlumb.overlayClass || "";
    			var clazz = originalArgs && (originalArgs.length == 1) ? (originalArgs[0].cssClass || "") : "";
    			p["class"] = clazz + " " + overlayClass;
				self.canvas = _node("shape", dim, p, connector.canvas.parentNode, connector._jsPlumb, true);								
				connector.appendDisplayElement(self.canvas, true);
				self.attachListeners(self.canvas, connector);
				self.attachListeners(self.canvas, self);
			}
			else {				
				_pos(self.canvas, dim);
				_atts(self.canvas, p);
			}    		
    	};
    	
    	this.reattachListeners = function() {
			if (self.canvas) self.reattachListenersForElement(self.canvas, self);
		};

		this.cleanup = function() {
    		if (self.canvas != null) jsPlumb.CurrentLibrary.removeElement(self.canvas);
    	};
    };
	
	jsPlumb.Overlays.vml.Arrow = function() {
    	AbstractVmlArrowOverlay.apply(this, [jsPlumb.Overlays.Arrow, arguments]);    	
    };
    
    jsPlumb.Overlays.vml.PlainArrow = function() {
    	AbstractVmlArrowOverlay.apply(this, [jsPlumb.Overlays.PlainArrow, arguments]);    	
    };
    
    jsPlumb.Overlays.vml.Diamond = function() {
    	AbstractVmlArrowOverlay.apply(this, [jsPlumb.Overlays.Diamond, arguments]);    	
    };
    
// ******************************* /vml overlays *****************************************************    
    
})();/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.4.1
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the SVG renderers.
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */

/**
 * SVG support for jsPlumb.
 * 
 * things to investigate:
 * 
 * gradients:  https://developer.mozilla.org/en/svg_in_html_introduction
 * css:http://tutorials.jenkov.com/svg/svg-and-css.html
 * text on a path: http://www.w3.org/TR/SVG/text.html#TextOnAPath
 * pointer events: https://developer.mozilla.org/en/css/pointer-events
 *
 * IE9 hover jquery: http://forum.jquery.com/topic/1-6-2-broke-svg-hover-events
 *
 */
;(function() {
	
// ************************** SVG utility methods ********************************************	
	
	var svgAttributeMap = {
		"joinstyle":"stroke-linejoin",
		"stroke-linejoin":"stroke-linejoin",		
		"stroke-dashoffset":"stroke-dashoffset",
		"stroke-linecap":"stroke-linecap"
	},
	STROKE_DASHARRAY = "stroke-dasharray",
	DASHSTYLE = "dashstyle",
	LINEAR_GRADIENT = "linearGradient",
	RADIAL_GRADIENT = "radialGradient",
	FILL = "fill",
	STOP = "stop",
	STROKE = "stroke",
	STROKE_WIDTH = "stroke-width",
	STYLE = "style",
	NONE = "none",
	JSPLUMB_GRADIENT = "jsplumb_gradient_",
	LINE_WIDTH = "lineWidth",
	ns = {
		svg:"http://www.w3.org/2000/svg",
		xhtml:"http://www.w3.org/1999/xhtml"
	},
	_attr = function(node, attributes) {
		for (var i in attributes)
			node.setAttribute(i, "" + attributes[i]);
	},	
	_node = function(name, attributes) {
		var n = document.createElementNS(ns.svg, name);
		attributes = attributes || {};
		attributes["version"] = "1.1";
		attributes["xmlns"] = ns.xhtml;
		_attr(n, attributes);
		return n;
	},
	_pos = function(d) { return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px"; },	
	_clearGradient = function(parent) {
		for (var i = 0; i < parent.childNodes.length; i++) {
			if (parent.childNodes[i].tagName == LINEAR_GRADIENT || parent.childNodes[i].tagName == RADIAL_GRADIENT)
				parent.removeChild(parent.childNodes[i]);
		}
	},		
	_updateGradient = function(parent, node, style, dimensions, uiComponent) {
		var id = JSPLUMB_GRADIENT + uiComponent._jsPlumb.idstamp();
		// first clear out any existing gradient
		_clearGradient(parent);
		// this checks for an 'offset' property in the gradient, and in the absence of it, assumes
		// we want a linear gradient. if it's there, we create a radial gradient.
		// it is possible that a more explicit means of defining the gradient type would be
		// better. relying on 'offset' means that we can never have a radial gradient that uses
		// some default offset, for instance.
		// issue 244 suggested the 'gradientUnits' attribute; without this, straight/flowchart connectors with gradients would
		// not show gradients when the line was perfectly horizontal or vertical.
		var g;
		if (!style.gradient.offset) {
			g = _node(LINEAR_GRADIENT, {id:id, gradientUnits:"userSpaceOnUse"});
		}
		else {
			g = _node(RADIAL_GRADIENT, {
				id:id
			});			
		}
		
		parent.appendChild(g);
		
		// the svg radial gradient seems to treat stops in the reverse 
		// order to how canvas does it.  so we want to keep all the maths the same, but
		// iterate the actual style declarations in reverse order, if the x indexes are not in order.
		for (var i = 0; i < style.gradient.stops.length; i++) {
			var styleToUse = uiComponent.segment == 1 ||  uiComponent.segment == 2 ? i: style.gradient.stops.length - 1 - i,			
				stopColor = jsPlumbUtil.convertStyle(style.gradient.stops[styleToUse][1], true),
				s = _node(STOP, {"offset":Math.floor(style.gradient.stops[i][0] * 100) + "%", "stop-color":stopColor});

			g.appendChild(s);
		}
		var applyGradientTo = style.strokeStyle ? STROKE : FILL;
		node.setAttribute(STYLE, applyGradientTo + ":url(#" + id + ")");
	},
	_applyStyles = function(parent, node, style, dimensions, uiComponent) {
		
		if (style.gradient) {
			_updateGradient(parent, node, style, dimensions, uiComponent);			
		}
		else {
			// make sure we clear any existing gradient
			_clearGradient(parent);
			node.setAttribute(STYLE, "");
		}
		
		node.setAttribute(FILL, style.fillStyle ? jsPlumbUtil.convertStyle(style.fillStyle, true) : NONE);
		node.setAttribute(STROKE, style.strokeStyle ? jsPlumbUtil.convertStyle(style.strokeStyle, true) : NONE);		
		if (style.lineWidth) {
			node.setAttribute(STROKE_WIDTH, style.lineWidth);
		}
	
		// in SVG there is a stroke-dasharray attribute we can set, and its syntax looks like
		// the syntax in VML but is actually kind of nasty: values are given in the pixel
		// coordinate space, whereas in VML they are multiples of the width of the stroked
		// line, which makes a lot more sense.  for that reason, jsPlumb is supporting both
		// the native svg 'stroke-dasharray' attribute, and also the 'dashstyle' concept from
		// VML, which will be the preferred method.  the code below this converts a dashstyle
		// attribute given in terms of stroke width into a pixel representation, by using the
		// stroke's lineWidth. 
		if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
			var sep = style[DASHSTYLE].indexOf(",") == -1 ? " " : ",",
			parts = style[DASHSTYLE].split(sep),
			styleToUse = "";
			parts.forEach(function(p) {
				styleToUse += (Math.floor(p * style.lineWidth) + sep);
			});
			node.setAttribute(STROKE_DASHARRAY, styleToUse);
		}		
		else if(style[STROKE_DASHARRAY]) {
			node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
		}
		
		// extra attributes such as join type, dash offset.
		for (var i in svgAttributeMap) {
			if (style[i]) {
				node.setAttribute(svgAttributeMap[i], style[i]);
			}
		}
	},
	_decodeFont = function(f) {
		var r = /([0-9].)(p[xt])\s(.*)/, 
			bits = f.match(r);

		return {size:bits[1] + bits[2], font:bits[3]};		
	},
	_classManip = function(el, add, clazz) {
		var classesToAddOrRemove = clazz.split(" "),
			className = el.className,
			curClasses = className.baseVal.split(" ");
			
		for (var i = 0; i < classesToAddOrRemove.length; i++) {
			if (add) {
				if (curClasses.indexOf(classesToAddOrRemove[i]) == -1)
					curClasses.push(classesToAddOrRemove[i]);
			}
			else {
				var idx = curClasses.indexOf(classesToAddOrRemove[i]);
				if (idx != -1)
					curClasses.splice(idx, 1);
			}
		}
		
		el.className.baseVal = curClasses.join(" ");
	},
	_addClass = function(el, clazz) { _classManip(el, true, clazz); },
	_removeClass = function(el, clazz) { _classManip(el, false, clazz); },
	_appendAtIndex = function(svg, path, idx) {
		if (svg.childNodes.length > idx) {
			svg.insertBefore(path, svg.childNodes[idx]);
		}
		else svg.appendChild(path);
	};
	
	/**
		utility methods for other objects to use.
	*/
	jsPlumbUtil.svg = {
		addClass:_addClass,
		removeClass:_removeClass,
		node:_node,
		attr:_attr,
		pos:_pos
	};
	
 // ************************** / SVG utility methods ********************************************	
	
	/*
	 * Base class for SVG components.
	 */	
	var SvgComponent = function(params) {
		var self = this,
			pointerEventsSpec = params.pointerEventsSpec || "all",
			renderer = {};
			
		jsPlumb.jsPlumbUIComponent.apply(this, params.originalArgs);
		self.canvas = null, self.path = null, self.svg = null; 
	
		var clazz = params.cssClass + " " + (params.originalArgs[0].cssClass || ""),		
			svgParams = {
				"style":"",
				"width":0,
				"height":0,
				"pointer-events":pointerEventsSpec,
				"position":"absolute"
			};				
		self.svg = _node("svg", svgParams);
		if (params.useDivWrapper) {
			self.canvas = document.createElement("div");
			self.canvas.style["position"] = "absolute";
			jsPlumb.sizeCanvas(self.canvas,0,0,1,1);
			self.canvas.className = clazz;
		}
		else {
			_attr(self.svg, { "class":clazz });
			self.canvas = self.svg;
		}
			
		params._jsPlumb.appendElement(self.canvas, params.originalArgs[0]["parent"]);
		if (params.useDivWrapper) self.canvas.appendChild(self.svg);
		
		// TODO this displayElement stuff is common between all components, across all
		// renderers.  would be best moved to jsPlumbUIComponent.
		var displayElements = [ self.canvas ];
		this.getDisplayElements = function() { 
			return displayElements; 
		};
		
		this.appendDisplayElement = function(el) {
			displayElements.push(el);
		};	
		
		this.paint = function(style, anchor, extents) {	   			
			if (style != null) {
				
				var xy = [ self.x, self.y ], wh = [ self.w, self.h ], p;
				if (extents != null) {
					if (extents.xmin < 0) xy[0] += extents.xmin;
					if (extents.ymin < 0) xy[1] += extents.ymin;
					wh[0] = extents.xmax + ((extents.xmin < 0) ? -extents.xmin : 0);
					wh[1] = extents.ymax + ((extents.ymin < 0) ? -extents.ymin : 0);
				}

				if (params.useDivWrapper) {					
					jsPlumb.sizeCanvas(self.canvas, xy[0], xy[1], wh[0], wh[1]);
					xy[0] = 0, xy[1] = 0;
					p = _pos([ 0, 0 ]);
				}
				else
					p = _pos([ xy[0], xy[1] ]);
                
                renderer.paint.apply(this, arguments);		    			    	
                
		    	_attr(self.svg, {
	    			"style":p,
	    			"width": wh[0],
	    			"height": wh[1]
	    		});		    		    		    	
			}
	    };
		
		return {
			renderer:renderer
		};
	};
	
	/*
	 * Base class for SVG connectors.
	 */ 
	var SvgConnector = jsPlumb.ConnectorRenderers.svg = function(params) {
		var self = this,
			_super = SvgComponent.apply(this, [ { 
				cssClass:params["_jsPlumb"].connectorClass, 
				originalArgs:arguments, 
				pointerEventsSpec:"none", 
				_jsPlumb:params["_jsPlumb"] 
			} ]);				

		_super.renderer.paint = function(style, anchor, extents) {
			
			var segments = self.getSegments(), p = "", offset = [0,0];			
			if (extents.xmin < 0) offset[0] = -extents.xmin;
			if (extents.ymin < 0) offset[1] = -extents.ymin;			
			
			// create path from segments.	
			for (var i = 0; i < segments.length; i++) {
				p += jsPlumb.Segments.svg.SegmentRenderer.getPath(segments[i]);
				p += " ";
			}			
			
			var a = { 
					d:p,
					transform:"translate(" + offset[0] + "," + offset[1] + ")",
					"pointer-events":params["pointer-events"] || "visibleStroke"
				}, 
                outlineStyle = null,
                d = [self.x,self.y,self.w,self.h];						
			
			// outline style.  actually means drawing an svg object underneath the main one.
			if (style.outlineColor) {
				var outlineWidth = style.outlineWidth || 1,
				outlineStrokeWidth = style.lineWidth + (2 * outlineWidth),
				outlineStyle = jsPlumb.CurrentLibrary.extend({}, style);
				outlineStyle.strokeStyle = jsPlumbUtil.convertStyle(style.outlineColor);
				outlineStyle.lineWidth = outlineStrokeWidth;
				
				if (self.bgPath == null) {
					self.bgPath = _node("path", a);
			    	_appendAtIndex(self.svg, self.bgPath, 0);
		    		self.attachListeners(self.bgPath, self);
				}
				else {
					_attr(self.bgPath, a);
				}
				
				_applyStyles(self.svg, self.bgPath, outlineStyle, d, self);
			}			
			
	    	if (self.path == null) {
		    	self.path = _node("path", a);
		    	_appendAtIndex(self.svg, self.path, style.outlineColor ? 1 : 0);
	    		self.attachListeners(self.path, self);	    		    		
	    	}
	    	else {
	    		_attr(self.path, a);
	    	}
	    		    	
	    	_applyStyles(self.svg, self.path, style, d, self);
		};
		
		this.reattachListeners = function() {
			if (self.bgPath) self.reattachListenersForElement(self.bgPath, self);
			if (self.path) self.reattachListenersForElement(self.path, self);
		};
	};
		
// ******************************* svg segment renderer *****************************************************	
		
	jsPlumb.Segments.svg = {
		SegmentRenderer : {		
			getPath : function(segment) {
				return ({
					"Straight":function() {
						var d = segment.getCoordinates();
						return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;	
					},
					"Bezier":function() {
						var d = segment.params;
						return "M " + d.x1 + " " + d.y1 + 
							" C " + d.cp1x + " " + d.cp1y + " " + d.cp2x + " " + d.cp2y + " " + d.x2 + " " + d.y2;			
					},
					"Arc":function() {
						var d = segment.params,
							laf = segment.sweep > Math.PI ? 1 : 0,
							sf = segment.anticlockwise ? 0 : 1;			

						return "M" + segment.x1 + " " + segment.y1 + " A " + segment.radius + " " + d.r + " 0 " + laf + "," + sf + " " + segment.x2 + " " + segment.y2;
					}
				})[segment.type]();	
			}
		}
	};
	
// ******************************* /svg segments *****************************************************
   
    /*
	 * Base class for SVG endpoints.
	 */
	var SvgEndpoint = window.SvgEndpoint = function(params) {
		var self = this,
			_super = SvgComponent.apply(this, [ {
				cssClass:params["_jsPlumb"].endpointClass, 
				originalArgs:arguments, 
				pointerEventsSpec:"all",
				useDivWrapper:true,
				_jsPlumb:params["_jsPlumb"]
			} ]);
			
		_super.renderer.paint = function(style) {
			var s = jsPlumb.extend({}, style);
			if (s.outlineColor) {
				s.strokeWidth = s.outlineWidth;
				s.strokeStyle = jsPlumbUtil.convertStyle(s.outlineColor, true);
			}
			
			if (self.node == null) {
				self.node = self.makeNode(s);
				self.svg.appendChild(self.node);
				self.attachListeners(self.node, self);
			}
			else if (self.updateNode != null) {
				self.updateNode(self.node);
			}
			_applyStyles(self.svg, self.node, s, [ self.x, self.y, self.w, self.h ], self);
			_pos(self.node, [ self.x, self.y ]);
		};
		
		this.reattachListeners = function() {
			if (self.node) self.reattachListenersForElement(self.node, self);
		};
	};
	
	/*
	 * SVG Dot Endpoint
	 */
	jsPlumb.Endpoints.svg.Dot = function() {
		jsPlumb.Endpoints.Dot.apply(this, arguments);
		SvgEndpoint.apply(this, arguments);		
		this.makeNode = function(style) { 
			return _node("circle", {
                "cx"	:	this.w / 2,
                "cy"	:	this.h / 2,
                "r"		:	this.radius
            });			
		};
		this.updateNode = function(node) {
			_attr(node, {
				"cx":this.w / 2,
				"cy":this.h  / 2,
				"r":this.radius
			});
		};
	};
	
	/*
	 * SVG Rectangle Endpoint 
	 */
	jsPlumb.Endpoints.svg.Rectangle = function() {
		jsPlumb.Endpoints.Rectangle.apply(this, arguments);
		SvgEndpoint.apply(this, arguments);		
		this.makeNode = function(style) {
			return _node("rect", {
				"width"     :   this.w,
				"height"    :   this.h
			});
		};
		this.updateNode = function(node) {
			_attr(node, {
				"width":this.w,
				"height":this.h
			});
		};			
	};		
	
	/*
	 * SVG Image Endpoint is the default image endpoint.
	 */
	jsPlumb.Endpoints.svg.Image = jsPlumb.Endpoints.Image;
	/*
	 * Blank endpoint in svg renderer is the default Blank endpoint.
	 */
	jsPlumb.Endpoints.svg.Blank = jsPlumb.Endpoints.Blank;	
	/*
	 * Label overlay in svg renderer is the default Label overlay.
	 */
	jsPlumb.Overlays.svg.Label = jsPlumb.Overlays.Label;
	/*
	 * Custom overlay in svg renderer is the default Custom overlay.
	 */
	jsPlumb.Overlays.svg.Custom = jsPlumb.Overlays.Custom;
		
	var AbstractSvgArrowOverlay = function(superclass, originalArgs) {
    	superclass.apply(this, originalArgs);
    	jsPlumb.jsPlumbUIComponent.apply(this, originalArgs);
        this.isAppendedAtTopLevel = false;
    	var self = this, path = null;
    	this.paint = function(params, containerExtents) {
    		// only draws on connections, not endpoints.
    		if (params.component.svg && containerExtents) {
	    		if (path == null) {
	    			path = _node("path", {
	    				"pointer-events":"all"	
	    			});
	    			params.component.svg.appendChild(path);
	    			
	    			self.attachListeners(path, params.component);
	    			self.attachListeners(path, self);
	    		}
	    		var clazz = originalArgs && (originalArgs.length == 1) ? (originalArgs[0].cssClass || "") : "",
	    			offset = [0,0];

	    		if (containerExtents.xmin < 0) offset[0] = -containerExtents.xmin;
	    		if (containerExtents.ymin < 0) offset[1] = -containerExtents.ymin;
	    		
	    		_attr(path, { 
	    			"d"			:	makePath(params.d),
	    			"class" 	:	clazz,
	    			stroke 		: 	params.strokeStyle ? params.strokeStyle : null,
	    			fill 		: 	params.fillStyle ? params.fillStyle : null,
	    			transform	: 	"translate(" + offset[0] + "," + offset[1] + ")"
	    		});    		
	    	}
    	};
    	var makePath = function(d) {
    		return "M" + d.hxy.x + "," + d.hxy.y +
    				" L" + d.tail[0].x + "," + d.tail[0].y + 
    				" L" + d.cxy.x + "," + d.cxy.y + 
    				" L" + d.tail[1].x + "," + d.tail[1].y + 
    				" L" + d.hxy.x + "," + d.hxy.y;
    	};
    	this.reattachListeners = function() {
			if (path) self.reattachListenersForElement(path, self);
		};
		this.cleanup = function() {
    		if (path != null) jsPlumb.CurrentLibrary.removeElement(path);
    	};
    };
    
    jsPlumb.Overlays.svg.Arrow = function() {
    	AbstractSvgArrowOverlay.apply(this, [jsPlumb.Overlays.Arrow, arguments]);    	
    };
    
    jsPlumb.Overlays.svg.PlainArrow = function() {
    	AbstractSvgArrowOverlay.apply(this, [jsPlumb.Overlays.PlainArrow, arguments]);    	
    };
    
    jsPlumb.Overlays.svg.Diamond = function() {
    	AbstractSvgArrowOverlay.apply(this, [jsPlumb.Overlays.Diamond, arguments]);    	
    };

    // a test
    jsPlumb.Overlays.svg.GuideLines = function() {
        var path = null, self = this, p1_1, p1_2;        
        jsPlumb.Overlays.GuideLines.apply(this, arguments);
        this.paint = function(params, containerExtents) {
    		if (path == null) {
    			path = _node("path");
    			params.connector.svg.appendChild(path);
    			self.attachListeners(path, params.connector);
    			self.attachListeners(path, self);

                p1_1 = _node("path");
    			params.connector.svg.appendChild(p1_1);
    			self.attachListeners(p1_1, params.connector);
    			self.attachListeners(p1_1, self);

                p1_2 = _node("path");
    			params.connector.svg.appendChild(p1_2);
    			self.attachListeners(p1_2, params.connector);
    			self.attachListeners(p1_2, self);
    		}

    		var offset =[0,0];
    		if (containerExtents.xmin < 0) offset[0] = -containerExtents.xmin;
    		if (containerExtents.ymin < 0) offset[1] = -containerExtents.ymin;

    		_attr(path, {
    			"d"		:	makePath(params.head, params.tail),
    			stroke 	: 	"red",
    			fill 	: 	null,
    			transform:"translate(" + offset[0] + "," + offset[1] + ")"
    		});

            _attr(p1_1, {
    			"d"		:	makePath(params.tailLine[0], params.tailLine[1]),
    			stroke 	: 	"blue",
    			fill 	: 	null,
    			transform:"translate(" + offset[0] + "," + offset[1] + ")"
    		});

            _attr(p1_2, {
    			"d"		:	makePath(params.headLine[0], params.headLine[1]),
    			stroke 	: 	"green",
    			fill 	: 	null,
    			transform:"translate(" + offset[0] + "," + offset[1] + ")"
    		});
    	};

        var makePath = function(d1, d2) {
            return "M " + d1.x + "," + d1.y +
                   " L" + d2.x + "," + d2.y;
        };        

    };
})();/*
 * jsPlumb
 * 
 * Title:jsPlumb 1.4.1
 * 
 * Provides a way to visually connect elements on an HTML page, using either SVG, Canvas
 * elements, or VML.  
 * 
 * This file contains the jQuery adapter.
 *
 * Copyright (c) 2010 - 2013 Simon Porritt (http://jsplumb.org)
 * 
 * http://jsplumb.org
 * http://github.com/sporritt/jsplumb
 * http://code.google.com/p/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */ 
/* 
 * the library specific functions, such as find offset, get id, get attribute, extend etc.  
 * the full list is:
 * 
 * addClass				adds a class to the given element
 * animate				calls the underlying library's animate functionality
 * appendElement		appends a child element to a parent element.
 * bind					binds some event to an element
 * dragEvents			a dictionary of event names
 * extend				extend some js object with another.  probably not overly necessary; jsPlumb could just do this internally.
 * getAttribute			gets some attribute from an element
 * getDragObject		gets the object that is being dragged, by extracting it from the arguments passed to a drag callback
 * getDragScope			gets the drag scope for a given element.
 * getDropScope			gets the drop scope for a given element.
 * getElementObject		turns an id or dom element into an element object of the underlying library's type.
 * getOffset			gets an element's offset
 * getOriginalEvent     gets the original browser event from some wrapper event
 * getPageXY			gets the page event's xy location.
 * getParent			gets the parent of some element.
 * getScrollLeft		gets an element's scroll left.  TODO: is this actually used?  will it be?
 * getScrollTop			gets an element's scroll top.  TODO: is this actually used?  will it be?
 * getSize				gets an element's size.
 * getUIPosition		gets the position of some element that is currently being dragged, by extracting it from the arguments passed to a drag callback.
 * hasClass				returns whether or not the given element has the given class.
 * initDraggable		initializes an element to be draggable 
 * initDroppable		initializes an element to be droppable
 * isDragSupported		returns whether or not drag is supported for some element.
 * isDropSupported		returns whether or not drop is supported for some element.
 * removeClass			removes a class from a given element.
 * removeElement		removes some element completely from the DOM.
 * setAttribute			sets an attribute on some element.
 * setDragFilter		sets a filter for some element that indicates areas of the element that should not respond to dragging.
 * setDraggable			sets whether or not some element should be draggable.
 * setDragScope			sets the drag scope for a given element.
 * setOffset			sets the offset of some element.
 * trigger				triggers some event on an element.
 * unbind				unbinds some listener from some element.
 */
(function($) {	
	
	//var getBoundingClientRectSupported = "getBoundingClientRect" in document.documentElement;

	var _getElementObject = function(el) {			
		return typeof(el) == "string" ? $("#" + el) : $(el);
	};

	jsPlumb.CurrentLibrary = {					        
		
		/**
		 * adds the given class to the element object.
		 */
		addClass : function(el, clazz) {
			el = _getElementObject(el);
			try {
				if (el[0].className.constructor == SVGAnimatedString) {
					jsPlumbUtil.svg.addClass(el[0], clazz);                    
				}
			}
			catch (e) {
				// SVGAnimatedString not supported; no problem.
			}
            try {                
                el.addClass(clazz);
            }
            catch (e) {
                // you probably have jQuery 1.9 and Firefox.  
            }
		},
		
		/**
		 * animates the given element.
		 */
		animate : function(el, properties, options) {
			el.animate(properties, options);
		},				
		
		/**
		 * appends the given child to the given parent.
		 */
		appendElement : function(child, parent) {
			_getElementObject(parent).append(child);			
		},   

		/**
		* executes an ajax call.
		*/
		ajax : function(params) {
			params = params || {};
			params.type = params.type || "get";
			$.ajax(params);
		},
		
		/**
		 * event binding wrapper.  it just so happens that jQuery uses 'bind' also.  yui3, for example,
		 * uses 'on'.
		 */
		bind : function(el, event, callback) {
			el = _getElementObject(el);
			el.bind(event, callback);
		},
		
		/**
         * mapping of drag events for jQuery
         */
		dragEvents : {
			'start':'start', 'stop':'stop', 'drag':'drag', 'step':'step',
			'over':'over', 'out':'out', 'drop':'drop', 'complete':'complete'
		},
				
		/**
		 * wrapper around the library's 'extend' functionality (which it hopefully has.
		 * otherwise you'll have to do it yourself). perhaps jsPlumb could do this for you
		 * instead.  it's not like its hard.
		 */
		extend : function(o1, o2) {
			return $.extend(o1, o2);
		},
		
		/**
		 * gets the named attribute from the given element object.  
		 */
		getAttribute : function(el, attName) {
			return el.attr(attName);
		},
		
		getClientXY : function(eventObject) {
			return [eventObject.clientX, eventObject.clientY];
		},
		
		/**
		 * takes the args passed to an event function and returns you an object representing that which is being dragged.
		 */
		getDragObject : function(eventArgs) {
			return eventArgs[1].draggable || eventArgs[1].helper;
		},
		
		getDragScope : function(el) {
			return el.draggable("option", "scope");
		},

		getDropEvent : function(args) {
			return args[0];
		},
		
		getDropScope : function(el) {
			return el.droppable("option", "scope");		
		},

		/**
		* gets a DOM element from the given input, which might be a string (in which case we just do document.getElementById),
		* a selector (in which case we return el[0]), or a DOM element already (we assume this if it's not either of the other
		* two cases).  this is the opposite of getElementObject below.
		*/
		getDOMElement : function(el) {
			if (typeof(el) == "string") return document.getElementById(el);
			else if (el.context || el.length != null) return el[0];
			else return el;
		},
	
		/**
		 * gets an "element object" from the given input.  this means an object that is used by the
		 * underlying library on which jsPlumb is running.  'el' may already be one of these objects,
		 * in which case it is returned as-is.  otherwise, 'el' is a String, the library's lookup 
		 * function is used to find the element, using the given String as the element's id.
		 * 
		 */		
		getElementObject : _getElementObject,
		
		/**
		  * gets the offset for the element object.  this should return a js object like this:
		  *
		  * { left:xxx, top: xxx }
		 */
		getOffset : function(el) {
			return el.offset();
		},

		getOriginalEvent : function(e) {
			return e.originalEvent;
		},
		
		getPageXY : function(eventObject) {
			return [eventObject.pageX, eventObject.pageY];
		},
		
		getParent : function(el) {
			return _getElementObject(el).parent();
		},
														
		getScrollLeft : function(el) {
			return el.scrollLeft();
		},
		
		getScrollTop : function(el) {
			return el.scrollTop();
		},
		
		getSelector : function(context, spec) {
            if (arguments.length == 2)
                return _getElementObject(context).find(spec);
            else
                return $(context);
		},
		
		/**
		 * gets the size for the element object, in an array : [ width, height ].
		 */
		getSize : function(el) {
			return [el.outerWidth(), el.outerHeight()];
		},

        getTagName : function(el) {
            var e = _getElementObject(el);
            return e.length > 0 ? e[0].tagName : null;
        },
		
		/**
		 * takes the args passed to an event function and returns you an object that gives the
		 * position of the object being moved, as a js object with the same params as the result of
		 * getOffset, ie: { left: xxx, top: xxx }.
		 * 
		 * different libraries have different signatures for their event callbacks.  
		 * see getDragObject as well
		 */
		getUIPosition : function(eventArgs, zoom) {
			
			zoom = zoom || 1;
			// this code is a workaround for the case that the element being dragged has a margin set on it. jquery UI passes
			// in the wrong offset if the element has a margin (it doesn't take the margin into account).  the getBoundingClientRect
			// method, which is in pretty much all browsers now, reports the right numbers.  but it introduces a noticeable lag, which
			// i don't like.
            
			/*if ( getBoundingClientRectSupported ) {
				var r = eventArgs[1].helper[0].getBoundingClientRect();
				return { left : r.left, top: r.top };
			} else {*/
			if (eventArgs.length == 1) {
				ret = { left: eventArgs[0].pageX, top:eventArgs[0].pageY };
			}
			else {
				var ui = eventArgs[1],
				  _offset = ui.offset;
				  
				ret = _offset || ui.absolutePosition;
				
				// adjust ui position to account for zoom, because jquery ui does not do this.
				ui.position.left /= zoom;
				ui.position.top /= zoom;
			}
            return { left:ret.left / zoom, top: ret.top / zoom };
		},		
		
		hasClass : function(el, clazz) {
			return el.hasClass(clazz);
		},
		
		/**
		 * initialises the given element to be draggable.
		 */
		initDraggable : function(el, options, isPlumbedComponent, _jsPlumb) {
			options = options || {};

/*
			// css3 transforms
			// http://gungfoo.wordpress.com/2013/02/15/jquery-ui-resizabledraggable-with-transform-scale-set/
			options.start = _jsPlumb.wrap(options["start"], function(e, ui) {
				// TODO why is this 0?				
			    ui.position.left = 0;
			    ui.position.top = 0;
			});

			options.drag = _jsPlumb.wrap(options["drag"], function(e, ui) {

				console.log("original", ui.originalPosition.left, ui.originalPosition.top);
				console.log("current", ui.position.left, ui.position.top);

				//var changeLeft = ui.position.left - ui.originalPosition.left; // find change in left
			    //var newLeft = ui.originalPosition.left + (changeLeft * _jsPlumb.getZoom()); // adjust new left by our zoomScale
			 
			    //var changeTop = ui.position.top - ui.originalPosition.top; // find change in top
			    //var newTop = ui.originalPosition.top + (changeTop * _jsPlumb.getZoom()); // adjust new top by our zoomScale
			 
			    //ui.position.left = newLeft;
			    //ui.position.top = newTop;

			    ui.position.left *= _jsPlumb.getZoom();
			    ui.position.top *= _jsPlumb.getZoom();

			});
*/


			// remove helper directive if present and no override
			if (!options.doNotRemoveHelper)
				options.helper = null;
			if (isPlumbedComponent)
				options['scope'] = options['scope'] || jsPlumb.Defaults.Scope;
			el.draggable(options);
		},
		
		/**
		 * initialises the given element to be droppable.
		 */
		initDroppable : function(el, options) {
			options['scope'] = options['scope'] || jsPlumb.Defaults.Scope;
			el.droppable(options);
		},
		
		isAlreadyDraggable : function(el) {
			return _getElementObject(el).hasClass("ui-draggable");
		},
		
		/**
		 * returns whether or not drag is supported (by the library, not whether or not it is disabled) for the given element.
		 */
		isDragSupported : function(el, options) {
			return el.draggable;
		},				
						
		/**
		 * returns whether or not drop is supported (by the library, not whether or not it is disabled) for the given element.
		 */
		isDropSupported : function(el, options) {
			return el.droppable;
		},							
		
		/**
		 * removes the given class from the element object.
		 */
		removeClass : function(el, clazz) {
			el = _getElementObject(el);
			try {
				if (el[0].className.constructor == SVGAnimatedString) {
					jsPlumbUtil.svg.removeClass(el[0], clazz);
                    return;
				}
			}
			catch (e) {
				// SVGAnimatedString not supported; no problem.
			}
			el.removeClass(clazz);
		},
		
		removeElement : function(element) {			
			_getElementObject(element).remove();
		},
		
		setAttribute : function(el, attName, attValue) {
			el.attr(attName, attValue);
		},

		setDragFilter : function(el, filter) {
			if (jsPlumb.CurrentLibrary.isAlreadyDraggable(el))
				el.draggable("option", "cancel", filter);
		},
		
		setDraggable : function(el, draggable) {
			el.draggable("option", "disabled", !draggable);
		},
		
		setDragScope : function(el, scope) {
			el.draggable("option", "scope", scope);
		},
		
		setOffset : function(el, o) {
			_getElementObject(el).offset(o);
		},
		
		/**
		 * note that jquery ignores the name of the event you wanted to trigger, and figures it out for itself.
		 * the other libraries do not.  yui, in fact, cannot even pass an original event.  we have to pull out stuff
		 * from the originalEvent to put in an options object for YUI. 
		 * @param el
		 * @param event
		 * @param originalEvent
		 */
		trigger : function(el, event, originalEvent) {
			var h = jQuery._data(_getElementObject(el)[0], "handle");
            h(originalEvent);
		},
		
		unbind : function(el, event, callback) {
			el = _getElementObject(el);
			el.unbind(event, callback);
		}
	};
	
	$(document).ready(jsPlumb.init);
	
})(jQuery);

(function(){"undefined"==typeof Math.sgn&&(Math.sgn=function(a){return 0==a?0:0<a?1:-1});var q={subtract:function(a,b){return{x:a.x-b.x,y:a.y-b.y}},dotProduct:function(a,b){return a.x*b.x+a.y*b.y},square:function(a){return Math.sqrt(a.x*a.x+a.y*a.y)},scale:function(a,b){return{x:a.x*b,y:a.y*b}}},B=Math.pow(2,-65),x=function(a,b){for(var f=[],d=b.length-1,g=2*d-1,h=[],e=[],m=[],k=[],l=[[1,0.6,0.3,0.1],[0.4,0.6,0.6,0.4],[0.1,0.3,0.6,1]],c=0;c<=d;c++)h[c]=q.subtract(b[c],a);for(c=0;c<=d-1;c++)e[c]=q.subtract(b[c+
1],b[c]),e[c]=q.scale(e[c],3);for(c=0;c<=d-1;c++)for(var n=0;n<=d;n++)m[c]||(m[c]=[]),m[c][n]=q.dotProduct(e[c],h[n]);for(c=0;c<=g;c++)k[c]||(k[c]=[]),k[c].y=0,k[c].x=parseFloat(c)/g;g=d-1;for(h=0;h<=d+g;h++){c=Math.max(0,h-g);for(e=Math.min(h,d);c<=e;c++)j=h-c,k[c+j].y+=m[j][c]*l[j][c]}d=b.length-1;k=u(k,2*d-1,f,0);g=q.subtract(a,b[0]);m=q.square(g);for(c=l=0;c<k;c++)g=q.subtract(a,v(b,d,f[c],null,null)),g=q.square(g),g<m&&(m=g,l=f[c]);g=q.subtract(a,b[d]);g=q.square(g);g<m&&(m=g,l=1);return{location:l,
distance:m}},u=function(a,b,f,d){var g=[],h=[],e=[],m=[],k=0,l,c;c=Math.sgn(a[0].y);for(var n=1;n<=b;n++)l=Math.sgn(a[n].y),l!=c&&k++,c=l;switch(k){case 0:return 0;case 1:if(64<=d)return f[0]=(a[0].x+a[b].x)/2,1;var r,p,k=a[0].y-a[b].y;c=a[b].x-a[0].x;n=a[0].x*a[b].y-a[b].x*a[0].y;l=max_distance_below=0;for(r=1;r<b;r++)p=k*a[r].x+c*a[r].y+n,p>l?l=p:p<max_distance_below&&(max_distance_below=p);p=c;r=0*p-1*k;l=(1*(n-l)-0*p)*(1/r);p=c;c=n-max_distance_below;r=0*p-1*k;k=(1*c-0*p)*(1/r);c=Math.min(l,k);
if(Math.max(l,k)-c<B)return e=a[b].x-a[0].x,m=a[b].y-a[0].y,f[0]=0+1*(e*(a[0].y-0)-m*(a[0].x-0))*(1/(0*e-1*m)),1}v(a,b,0.5,g,h);a=u(g,b,e,d+1);b=u(h,b,m,d+1);for(d=0;d<a;d++)f[d]=e[d];for(d=0;d<b;d++)f[d+a]=m[d];return a+b},v=function(a,b,f,d,g){for(var h=[[]],e=0;e<=b;e++)h[0][e]=a[e];for(a=1;a<=b;a++)for(e=0;e<=b-a;e++)h[a]||(h[a]=[]),h[a][e]||(h[a][e]={}),h[a][e].x=(1-f)*h[a-1][e].x+f*h[a-1][e+1].x,h[a][e].y=(1-f)*h[a-1][e].y+f*h[a-1][e+1].y;if(null!=d)for(e=0;e<=b;e++)d[e]=h[e][0];if(null!=g)for(e=
0;e<=b;e++)g[e]=h[b-e][e];return h[b][0]},y={},s=function(a,b){var f,d=a.length-1;f=y[d];if(!f){f=[];var g=function(a){return function(){return a}},h=function(){return function(a){return a}},e=function(){return function(a){return 1-a}},m=function(a){return function(b){for(var c=1,d=0;d<a.length;d++)c*=a[d](b);return c}};f.push(new function(){return function(a){return Math.pow(a,d)}});for(var k=1;k<d;k++){for(var l=[new g(d)],c=0;c<d-k;c++)l.push(new h);for(c=0;c<k;c++)l.push(new e);f.push(new m(l))}f.push(new function(){return function(a){return Math.pow(1-
a,d)}});y[d]=f}for(e=h=g=0;e<a.length;e++)g+=a[e].x*f[e](b),h+=a[e].y*f[e](b);return{x:g,y:h}},z=function(a,b){return Math.sqrt(Math.pow(a.x-b.x,2)+Math.pow(a.y-b.y,2))},A=function(a){return a[0].x==a[1].x&&a[0].y==a[1].y},t=function(a,b,f){if(A(a))return{point:a[0],location:b};for(var d=s(a,b),g=0,h=0<f?1:-1,e=null;g<Math.abs(f);)b+=0.005*h,e=s(a,b),g+=z(e,d),d=e;return{point:e,location:b}},w=function(a,b){var f=s(a,b),d=s(a.slice(0,a.length-1),b),g=d.y-f.y,f=d.x-f.x;return 0==g?Infinity:Math.atan(g/
f)};window.jsBezier={distanceFromCurve:x,gradientAtPoint:w,gradientAtPointAlongCurveFrom:function(a,b,f){b=t(a,b,f);1<b.location&&(b.location=1);0>b.location&&(b.location=0);return w(a,b.location)},nearestPointOnCurve:function(a,b){var f=x(a,b);return{point:v(b,b.length-1,f.location,null,null),location:f.location}},pointOnCurve:s,pointAlongCurveFrom:function(a,b,f){return t(a,b,f).point},perpendicularToCurveAt:function(a,b,f,d){b=t(a,b,null==d?0:d);a=w(a,b.location);d=Math.atan(-1/a);a=f/2*Math.sin(d);
f=f/2*Math.cos(d);return[{x:b.point.x+f,y:b.point.y+a},{x:b.point.x-f,y:b.point.y-a}]},locationAlongCurveFrom:function(a,b,f){return t(a,b,f).location},getLength:function(a){if(A(a))return 0;for(var b=s(a,0),f=0,d=0,g=null;1>d;)d+=0.005,g=s(a,d),f+=z(g,b),b=g;return f}}})();


/**
 * .disableTextSelect - Disable Text Select Plugin
 *
 * Version: 1.1
 * Updated: 2007-11-28
 *
 * Used to stop users from selecting text
 *
 * Copyright (c) 2007 James Dempster (letssurf@gmail.com, http://www.jdempster.com/category/jquery/disabletextselect/)
 *
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 **/

/**
 * Requirements:
 * - jQuery (John Resig, http://www.jquery.com/)
 **/
(function($) {
    if ($.browser.mozilla) {
        $.fn.disableTextSelect = function() {
            return this.each(function() {
                $(this).css({
                    'MozUserSelect' : 'none'
                });
            });
        };
        $.fn.enableTextSelect = function() {
            return this.each(function() {
                $(this).css({
                    'MozUserSelect' : ''
                });
            });
        };
    } else if ($.browser.msie) {
        $.fn.disableTextSelect = function() {
            return this.each(function() {
                $(this).bind('selectstart.disableTextSelect', function() {
                    return false;
                });
            });
        };
        $.fn.enableTextSelect = function() {
            return this.each(function() {
                $(this).unbind('selectstart.disableTextSelect');
            });
        };
    } else {
        $.fn.disableTextSelect = function() {
            return this.each(function() {
                $(this).bind('mousedown.disableTextSelect', function() {
                    return false;
                });
            });
        };
        $.fn.enableTextSelect = function() {
            return this.each(function() {
                $(this).unbind('mousedown.disableTextSelect');
            });
        };
    }
})(jQuery);


/*
* Author: Sangeetha Jeganathan
* Email: sangeetha.jeganathan@gmail.com
* This plugin is used to create a miniview of the supplied nodes within the wrapper. Also provides functionality to rearrange based on drag of the nodes.
* Copyright © 2012 SangeethaJ. All rights reserved.
**/
(function($){
    $.fn.miniview = function (nodes, size, elementStyleSet) {
	    var parentDom = this, container, miniViewContainer, collapse, port, width, height, x, y, l, t, w, h, eventMove, eventUp, flag = false;
	    miniViewContainer = $('#miniview');
        miniViewContainer.width(size);
	    miniViewContainer.height(size);
	    container = $("<div></div>").addClass("miniView-container");
	    miniViewContainer.append(container);
		width = container.width();
		height = container.height();
		port = $('<div></div>').addClass("port").css('z-index', 1);
		container.append(port);
		collapse = $("<div></div>").addClass("miniView-collapse").css('z-index', 2);
		miniViewContainer.append(collapse);
		synchronize();
		parentDom.bind("resize", function () { synchronize(); });
		//parentDom.bind("drag", init);
		parentDom.bind("scroll", function () { synchronize(); });
		container.bind("mousedown", down);
		container.bind("touchstart", down);
		container.bind("touchmove", function (e) {
			e.preventDefault();
		});
		parentDom.bind("redraw", function (e) {
		    if (e != null && e.nodes != null) {
		        nodes = e.nodes;
		        init();
		    }
		    synchronize(e != null ? e.fullredraw : false, e.elementStyleSet);
		});
		$(document).mouseup(function (e) {
		    flag = false;
		    port.removeClass('miniview-move');
		});
        $(".miniView-collapse").live("click", function() {
            if (miniViewContainer.hasClass("miniview-button")) {
                miniViewContainer.width(size);
                miniViewContainer.height(size);
                miniViewContainer.removeClass("miniview-button");
            } else {
                miniViewContainer.width(22);
                miniViewContainer.height(22);
                miniViewContainer.addClass("miniview-button");
            }
        });

        function positionInParent(element, parent) {
		    var el = $(element);
		    if (parent == null) parent = el.parent();
		    var offset = el.offset();
		    var parentOffset = parent.offset();
		    var left = (offset.left - parentOffset.left);
		    var top = (offset.top - parentOffset.top);
		    return { left: left, top: top };
		}

        function parentDomSize() {
            return {
                width: parentDom[0].scrollWidth - parseInt(parentDom.css("margin-left")) - parseInt(parentDom.css("margin-right")) - parseInt(parentDom.css("padding-left")) - parseInt(parentDom.css("padding-right")),
                height: parentDom[0].scrollHeight - parseInt(parentDom.css("margin-top")) - parseInt(parentDom.css("margin-bottom")) - parseInt(parentDom.css("padding-top")) - parseInt(parentDom.css("padding-bottom"))
            };
        }

        function down(e) {
			flag = true;
			port.addClass('miniview-move');
			var pos = $(container).offset();

			x = Math.round(pos.left + l + w/2);
			y = Math.round(pos.top + t + h/2);
			move(e);
			
			if (e.type == "touchstart") {
				eventMove = "touchmove";
				eventUp = "touchend";
			} else {
				eventMove = "mousemove";
				eventUp = "mouseup";
			}
			container.bind(eventMove, move);
			container.bind(eventUp, up);
		}

		function move(e){
		    if (!flag) { return; }

			e.preventDefault();
		    var event;
		    if (e.type.match(/touch/)) {
				if (e.touches.length > 1) { return; }
		        event = e.touches[0];
		    } else {
		        event = e;
		    }

		    var dx = $(window).scrollLeft() + event.clientX - x;
		    var dy = $(window).scrollTop() + event.clientY - y;
			if (l + dx < 0) { dx = -l; }
			if (t + dy < 0) { dy = -t; }
			if (l + w + dx > width) { dx = width - l - w; }
			if (t + h + dy > height) { dy = height - t - h; }
			
			
			x += dx;
			y += dy;
			
			l += dx;
			t += dy;

		    var parentDomS = parentDomSize();
		    var coefX = width / parentDomS.width;
		    var coefY = height / parentDomS.height;
			var left = l / coefX;
			var top = t / coefY;

		    parentDom[0].scrollLeft = Math.round(left);
		    parentDom[0].scrollTop = Math.round(top);

		    redraw();
		}

		function up(e){
			flag = false;
			container.css('cursor', 'default');
		}

		function synchronize(fullredraw) {
		    var parentDomS = parentDomSize();
			var dims = [parentDom.width(), parentDom.height()];
		    var scroll = [parentDom.scrollLeft(), parentDom.scrollTop()];
		    var scale = parentDom[0].scrollWidth > parentDom[0].scrollHeight
		        ? size / parentDomS.width
		        : size / parentDomS.height;
		    width = (parentDom[0].scrollWidth - parseInt(parentDom.css("margin-left")) - parseInt(parentDom.css("margin-right")) - parseInt(parentDom.css("padding-left")) - parseInt(parentDom.css("padding-right"))) * scale;
		    height = (parentDom[0].scrollHeight - parseInt(parentDom.css("margin-top")) - parseInt(parentDom.css("margin-bottom")) - parseInt(parentDom.css("padding-top")) - parseInt(parentDom.css("padding-bottom"))) * scale;

			var lW = dims[0] * scale;
			var lH = dims[1] * scale;
			var lX = scroll[0] * scale;
			var lY = scroll[1] * scale;
			
			w = Math.round(lW);
			h = Math.round(lH);
			l = Math.round(lX);
			t = Math.round(lY);
			//set the mini viewport dimesions
			redraw(fullredraw);
		}

		function redraw(fullredraw) {
		    container.width(Math.round(width));
		    container.height(Math.round(height));
		    container.css('left', Math.round((size - container.width()) / 2) + 'px');
		    container.css('top', Math.round((size - container.height()) / 2) + 'px');
			port.css('width', w + "px");
			port.css('height', h + "px");
			port.css('left', l + "px");
			port.css('top', t + "px");

			if (fullredraw) {
			    nodes.each(function () {
			        setNode(this.miniviewNode);
			    });
			}
		}

		function init() {
            container.find('.mini').remove();
			//creating mini version of the supplied nodes
            nodes.each(function () {
			    var mini = $('<div></div>').addClass("mini");
			    container.append(mini);
			    mini[0].target = this;
			    this.miniviewNode = mini[0];
                setNode(mini[0]);
            });
			return this; // to maintain chainability
		}

		function setNode(mini) {
		    var node = mini.target;

            var ratioX = width / parentDom[0].scrollWidth;
            var ratioY = height / parentDom[0].scrollHeight;

            var wM = $(node).width() * ratioX;
            var hM = $(node).height() * ratioY;
            var xM = (($(node).offset().left - $(parentDom).offset().left) + parentDom.scrollLeft()) * ratioX;
            var yM = (($(node).offset().top - $(parentDom).offset().top) + parentDom.scrollTop()) * ratioY;

            $(mini).css('width', Math.round(wM) + "px");
            $(mini).css('height', Math.round(hM) + "px");
            $(mini).css('left', Math.round(xM) + "px");
            $(mini).css('top', Math.round(yM) + "px");

            if ($.isFunction(elementStyleSet)) {
                elementStyleSet(mini);
            }
        }

		init();

	}
})(jQuery);


// Generated by CoffeeScript 1.3.1
/*
  Endless Scroll plugin for jQuery

  v1.8.0

  Copyright (c) 2008-2012 Fred Wu

  Dual licensed under the MIT and GPL licenses:
    http://www.opensource.org/licenses/mit-license.php
    http://www.gnu.org/licenses/gpl.html
*/

/*
  Usage:

  // using default options
  $(window).endlessScroll();

  // using some custom options
  $("#images").endlessScroll({
    fireOnce: false,
    fireDelay: false,
    loader: '<div class="loading"><div>',
    callback: function(){
      alert('test');
    }
  });

  Configuration options:

  pagesToKeep       integer         the number of 'pages' to keep before either end of the scrolling content are discarded,
                                    by default (value set to `null`) no content will be discarded
  inflowPixels      integer         the number of pixels from the boundary of the element that triggers the event
  fireOnce          boolean         only fire once until the execution of the current event is completed
  fireDelay         integer         delay the subsequent firing, in milliseconds, 0 or false to disable delay
  loader            string          the HTML to be displayed during loading
  content           string|function Plain HTML content to insert after each call, can be either a string or a function
                                    that returns a string, when passed as a function it accepts three arguments:
                                      <fireSequence> the number of times the event triggered during the current page session
                                      <pageSequence> a positive or negative value that represents the scroll direction sequence
                                      <scrollDirection> a string of either 'prev' or 'next'
  insertBefore      string          jQuery selector syntax: where to put the loader as well as the plain HTML data
  insertAfter       string          jQuery selector syntax: where to put the loader as well as the plain HTML data
  intervalFrequency integer         set the frequency of the scroll event checking, the larger the frequency number,
                                    the less memory it consumes - but also the less sensitive the event trigger becomes
  ceaseFireOnEmpty  boolean         ceases fire automatically when the content is empty, set it to `false` if you are using
                                    `callback` instead of `content` for loading content
  resetCounter      function        resets the fire sequence counter if the function returns true, this function
                                    could also perform hook actions since it is applied at the start of the event
  callback          function        callback function, accepts three arguments:
                                      <fireSequence> the number of times the event triggered during the current page session
                                      <pageSequence> a positive or negative value that represents the scroll direction sequence
                                      <scrollDirection> a string of either 'prev' or 'next'
  ceaseFire         function        stops the event (no more endless scrolling) if the function returns true,
                                    accepts three arguments:
                                      <fireSequence> the number of times the event triggered during the current page session
                                      <pageSequence> a positive or negative value that represents the scroll direction sequence
                                      <scrollDirection> a string of either 'prev' or 'next'
*/

var EndlessScroll;

EndlessScroll = (function() {
  var defaults;

  EndlessScroll.name = 'EndlessScroll';

  defaults = {
    pagesToKeep: null,
    inflowPixels: 50,
    fireOnce: true,
    fireDelay: 150,
    loader: 'Loading...',
    content: '',
    insertBefore: null,
    insertAfter: null,
    intervalFrequency: 250,
    ceaseFireOnEmpty: true,
    resetCounter: function() {
      return false;
    },
    callback: function() {
      return true;
    },
    ceaseFire: function() {
      return false;
    }
  };

  function EndlessScroll(scope, options) {
    var _this = this;
    this.options = $.extend({}, defaults, options);
    this.pagesStack = [0];
    this.scrollDirection = 'next';
    this.firing = true;
    this.fired = false;
    this.fireSequence = 0;
    this.pageSequence = 0;
    this.nextSequence = 1;
    this.prevSequence = -1;
    this.lastScrollTop = 0;
    this.insertLocation = this.options.insertAfter;
    this.didScroll = false;
    this.isScrollable = true;
    this.target = scope;
    this.targetId = '';
    this.content = '';
    this.lastContent = 'dummy';
    this.innerWrap = $('.endless_scroll_inner_wrap', this.target);
    this.handleDeprecatedOptions();
    this.setInsertPositionsWhenNecessary();
    $(scope).scroll(function() {
      _this.detectTarget(scope);
      return _this.detectScrollDirection();
    });
  }

  EndlessScroll.prototype.run = function() {
    var _this = this;
    return setInterval((function() {
      if (!_this.shouldTryFiring()) {
        return;
      }
      if (_this.ceaseFireWhenNecessary()) {
        return;
      }
      if (!_this.shouldBeFiring()) {
        return;
      }
      _this.resetFireSequenceWhenNecessary();
      _this.acknowledgeFiring();
      _this.insertLoader();
      if (_this.hasContent()) {
        _this.showContent();
        _this.fireCallback();
        _this.cleanUpPagesWhenNecessary();
        _this.delayFiringWhenNecessary();
      }
      _this.removeLoader();
      return _this.lastContent = _this.content;
    }), this.options.intervalFrequency);
  };

  EndlessScroll.prototype.handleDeprecatedOptions = function() {
    if (this.options.data) {
      this.options.content = this.options.data;
    }
    if (this.options.bottomPixels) {
      return this.options.inflowPixels = this.options.bottomPixels;
    }
  };

  EndlessScroll.prototype.setInsertPositionsWhenNecessary = function() {
    var container;
    container = "" + this.target.selector + " div.endless_scroll_inner_wrap";
    if (this.options.insertBefore === null) {
      this.options.insertBefore = "" + container + " div:first";
    }
    if (this.options.insertAfter === null) {
      return this.options.insertAfter = "" + container + " div:last";
    }
  };

  EndlessScroll.prototype.detectTarget = function(scope) {
    this.target = scope;
    return this.targetId = $(this.target).attr('id');
  };

  EndlessScroll.prototype.detectScrollDirection = function() {
    var currentScrollTop;
    this.didScroll = true;
    currentScrollTop = $(this.target).scrollTop();
    if (currentScrollTop >= this.lastScrollTop) {
      this.scrollDirection = 'next';
    } else {
      this.scrollDirection = 'prev';
    }
    return this.lastScrollTop = currentScrollTop;
  };

  EndlessScroll.prototype.shouldTryFiring = function() {
    var shouldTryOrNot;
    shouldTryOrNot = this.didScroll && this.firing === true;
    if (shouldTryOrNot) {
      this.didScroll = false;
    }
    return shouldTryOrNot;
  };

  EndlessScroll.prototype.ceaseFireWhenNecessary = function() {
	if (this.options.ceaseFireOnEmpty === true && this.lastContent === '' || this.options.ceaseFire.apply(this.target, [this.fireSequence, this.pageSequence, this.scrollDirection])) {
      return true;
    } else {
      return false;
    }
  };

  EndlessScroll.prototype.wrapContainer = function(target) {
    if (this.innerWrap.length === 0) {
      return this.innerWrap = $(target).wrapInner('<div class="endless_scroll_content" data-page="0" />').wrapInner('<div class="endless_scroll_inner_wrap" />').find('.endless_scroll_inner_wrap');
    }
  };

  EndlessScroll.prototype.scrollableAreaMargin = function(innerWrap, target) {
    var margin;
    switch (this.scrollDirection) {
      case 'next':
        margin = innerWrap.height() - $(target).height() <= $(target).scrollTop() + this.options.inflowPixels;
        if (margin) {
          target.scrollTop(innerWrap.height() - $(target).height() - this.options.inflowPixels);
        }
        break;
      case 'prev':
        margin = $(target).scrollTop() <= this.options.inflowPixels;
        if (margin) {
          target.scrollTop(this.options.inflowPixels);
        }
    }
    return margin;
  };

  EndlessScroll.prototype.calculateScrollableCanvas = function() {
    if (this.target[0] === document || this.target[0] === window) {
      this.wrapContainer("body");
      return this.isScrollable = this.scrollableAreaMargin($(document), $(window));
    } else {
      this.wrapContainer(this.target);
      return this.isScrollable = this.innerWrap.length > 0 && this.scrollableAreaMargin(this.innerWrap, this.target);
    }
  };

  EndlessScroll.prototype.shouldBeFiring = function() {
    this.calculateScrollableCanvas();
    return this.isScrollable && (this.options.fireOnce === false || (this.options.fireOnce === true && this.fired !== true));
  };

  EndlessScroll.prototype.resetFireSequenceWhenNecessary = function() {
    if (this.options.resetCounter.apply(this.target) === true) {
      return this.fireSequence = 0;
    }
  };

  EndlessScroll.prototype.acknowledgeFiring = function() {
    this.fired = true;
    this.fireSequence++;
    switch (this.scrollDirection) {
      case 'next':
        return this.pageSequence = this.nextSequence++;
      case 'prev':
        return this.pageSequence = this.prevSequence--;
    }
  };

  EndlessScroll.prototype.insertContent = function(content) {
    switch (this.scrollDirection) {
      case 'next':
        return $(this.options.insertAfter).after(content);
      case 'prev':
        return $(this.options.insertBefore).before(content);
    }
  };

  EndlessScroll.prototype.insertLoader = function() {
    return this.insertContent("<div class=\"endless_scroll_loader_" + this.targetId + "      endless_scroll_loader\">" + this.options.loader + "</div>");
  };

  EndlessScroll.prototype.removeLoader = function() {
    return $('.endless_scroll_loader_' + this.targetId).fadeOut(function() {
      return $(this).remove();
    });
  };

  EndlessScroll.prototype.hasContent = function() {
    if (typeof this.options.content === 'function') {
      this.content = this.options.content.apply(this.target, [this.fireSequence, this.pageSequence, this.scrollDirection]);
    } else {
      this.content = this.options.content;
    }
    return this.content !== false;
  };

  EndlessScroll.prototype.showContent = function() {
    $('#endless_scroll_content_current').removeAttr('id');
    return this.insertContent("<div id=\"endless_scroll_content_current\"      class=\"endless_scroll_content\" data-page=\"" + this.pageSequence + "\">" + this.content + "</div>");
  };

  EndlessScroll.prototype.fireCallback = function() {
    return this.options.callback.apply(this.target, [this.fireSequence, this.pageSequence, this.scrollDirection]);
  };

  EndlessScroll.prototype.cleanUpPagesWhenNecessary = function() {
    var pageToRemove;
    if (!(this.options.pagesToKeep >= 1)) {
      return;
    }
    switch (this.scrollDirection) {
      case 'next':
        this.pagesStack.push(this.pageSequence);
        break;
      case 'prev':
        this.pagesStack.unshift(this.pageSequence);
    }
    if (this.pagesStack.length > this.options.pagesToKeep) {
      switch (this.scrollDirection) {
        case 'next':
          pageToRemove = this.prevSequence = this.pagesStack.shift();
          break;
        case 'prev':
          pageToRemove = this.nextSequence = this.pagesStack.pop();
      }
    }
    this.removePage(pageToRemove);
    return this.calculateScrollableCanvas();
  };

  EndlessScroll.prototype.removePage = function(page) {
    return $(".endless_scroll_content[data-page='" + page + "']", this.target).remove();
  };

  EndlessScroll.prototype.delayFiringWhenNecessary = function() {
    var _this = this;
    if (this.options.fireDelay > 0) {
      $('body').after('<div id="endless_scroll_marker"></div>');
      return $('#endless_scroll_marker').fadeTo(this.options.fireDelay, 1, function() {
        $('#endless_scroll_marker').remove();
        return _this.fired = false;
      });
    } else {
      return this.fired = false;
    }
  };

  return EndlessScroll;

})();

(function($) {
  return $.fn.endlessScroll = function(options) {
    return new EndlessScroll(this, options).run();
  };
})(jQuery);



jQuery.extend(jQuery.validator.messages, {
    required: SR.T("Это поле обязательное."),
    remote: SR.T("Пожалуйста, исправьте это значение."),
    email: SR.T("Пожалуйста, введите правильный email адрес."),
    url: SR.T("Пожалуйста, введите правильный URL."),
    date: SR.T("Пожалуйста, введите правильную дату."),
    dateISO: SR.T("Пожалуйста, введите правильную дату в формате ISO."),
    number: SR.T("Пожалуйста, введите число."),
    digits: SR.T("Пожалуйста, введите число."),
    creditcard: SR.T("Пожалуйста, введите верный номер кредитной карты."),
    equalTo: SR.T("Пожалуйста, введите такое же значение."),
    accept: SR.T("Пожалуйста, введите значение с верным расширением."),
    maxlength: $.format(SR.T("Пожалуйста, введите не больше чем {0} символов.")),
    minlength: $.format(SR.T("Пожалуйста, введите не меньше чем {0} символов.")),
    rangelength: $.format(SR.T("Пожалуйста, введите значение длиной в промежутке от {0} до {1} символов.")),
    range: $.format(SR.T("Пожалуйста, введите значение от {0} до {1}.")),
    max: $.format(SR.T("Пожалуйста, введите значение меньшее чем {0}.")),
    min: $.format(SR.T("Пожалуйста, введите значение большее чем {0}.")),
    fileFormat: $.format(SR.T("Не верный формат файла."))
});

validatorInit = jQuery.validator.prototype.init;
validatorShowErrors = jQuery.validator.prototype.showErrors;

jQuery.extend(jQuery.validator.prototype, {
    baseInit: validatorInit,

    init: function () {
        this.baseInit();
        $(this.currentForm).bind("invalid-form.validate", this.invalidForm);
    },

    invalidForm: function (form, validator) {
        if (validator.errorList.length > 0) {
            var invalidElement = $(validator.findLastActive() || validator.errorList.length && validator.errorList[0].element || []);
            if (invalidElement.is(':hidden')) {
                var item = $(invalidElement);
                while (item.length) {
                    var showScript = item.attr('showScript');
                    if (showScript !== undefined) {
                        (function () { eval(showScript); }).call(item);
                    }
                    item = item.parent();
                }
            }
        }
    },

    baseShowErrors: validatorShowErrors,

    showErrors: function (errors) {
        this.baseShowErrors(errors);
        elma.InitTranslationContainer();
    }
});

function isEmpty(value) {
    if (value === "" || jQuery.trim(value) === "" ||  
    value === undefined ||
    value === null ||
    value === NaN
    )
        return true;
    return false;
}

$(function () {
    jQuery.validator.addMethod("rangedatevalidator", function (value, element, params) {
        if (isEmpty(value))
            return true;
        return true; /*
        var val = Date.parseDate(value, Date.patterns.ShortDate + ' ' + Date.patterns.ShortTime);
        if (
               (params.min == null || val >= Date.parseDate(params.min, Date.patterns.ShortDate + ' ' + Date.patterns.ShortTime))
            && (params.max == null || val <= Date.parseDate(params.max, Date.patterns.ShortDate + ' ' + Date.patterns.ShortTime))
         ) {
            return true;
        }

        return false;*/
    });
});

//$(function () {
//    jQuery.validator.addMethod("relativedatevalidator", function (value, element, params) {
//        if (isEmpty(value))
//            return true;
//        alert('!');
//        return false;
//    });
//});

$(function () {
    jQuery.validator.addMethod("rangevalidator", function (value, element, params) {
        if (isEmpty(value))
            return true;
        var textBoxData = $("#" + element.id).data("tTextBox");
        var separator = (textBoxData) ? textBoxData.separator : jQuery.telerik.cultureInfo.numericdecimalseparator;
        var val = Number(value.replace(separator, '.'));
        if ((params.min == null || val >= params.min) && (params.max == null || val <= params.max))
            return true;
        return false;
    });
});
$(function () {
    jQuery.validator.addMethod("fileFormat", function (value, element, params) {
        if (isEmpty(params) || isEmpty(value))
            return true;
        var reg = "(?:" + params.replace(/,/g, "|") + ")$";
        if (value.match(new RegExp(reg, "i")))
            return true;
        return false;
    });
});

$(function () {
    jQuery.validator.addMethod("regularexp", function (value, element, params) {
        if (value.match(params.pattern)) {
            return true;
        }
        return false;
    });
});

$(function () {
    jQuery.validator.addMethod("reqfield", function (value, element, params) {
        if (!!element && element.type == 'radio') {
            value = $("input:radio[name='" + element.name + "']:checked").val();
        }
        if (!isEmpty(value) && (!params.emptyValue || value != params.emptyValue)) {
            if (!!params.emptyRegExp && value.match(params.emptyRegExp)) {
                return false;
            }
            return true;
        }

        return false;
    });
});

$(function () {
    jQuery.validator.addMethod("reqfieldTablePart", function (value, element, params) {
        // пометим ячейку блока с пустым значением
        var spansForEmptyValue = $(element).parent().find('span.grid-empty-value');
        spansForEmptyValue.parent().closest('td').addClass('grid-empty-cell');
        var lng1 = spansForEmptyValue.length;
        // пометим вложенный блок, имеющий пустые значения
        var spansForEmptyValues = $(element).parent().find('span.grid-has-empty-values');
        spansForEmptyValues.parent().closest('td').addClass('grid-empty-cell');
        var lng2 = spansForEmptyValues.length;
        return (!lng1 || lng1 == 0) && (!lng2 || lng2 == 0);
    });
});

$(function () {
    jQuery.validator.addMethod("reqfieldEntireTablePart", function (value, element, params) {
        var gridElement = $(element).parent().find('>div.t-grid');
        var grid = gridElement.data('tGrid');
        if (!grid) return true;
        return !grid.emptyDataPage;
    });
});

$(function () {
    jQuery.validator.addMethod("needCompleteGridEditing", function (value, element, a, b, c, d) {
        var gird = $(element).parent().find('>div.t-grid');
        if (!gird.data('tGrid'))
            return true;
        if (gird.data('tGrid').$tbody.find('>.t-grid-edit-row').length == 0)
            return true;
        gird.addClass('validtionError');
        this.errorList.push({
            element: gird.data('tGrid').$tbody.find('>.t-grid-edit-row').find('input')[0]
        });
        return false;
    });
});

$(function () {
    jQuery.validator.addMethod("stringrangelength", function (value, element, params) {
        if (isEmpty(value))
            return true;
        var len = value.split(/\r\n|\r|\n/).join("\r\n").length; // different browsers use different line separators, but on the POST send \r\n
        return (len >= params.min && (params.max == null || len <= params.max));
    });
});

$(function () {
    jQuery.validator.addMethod("greaterThen", function (value, element, param) {
        var target = $(param).unbind(".validate-greaterThen").bind("blur.validate-greaterThen", function () {
            $(element).valid();
        });
        return value >= target.val();
    });
});

$(function () {
    jQuery.validator.addMethod("lessThen", function (value, element, param) {
        var target = $(param).unbind(".validate-lessThen").bind("blur.validate-lessThen", function () {
            $(element).valid();
        });
        return value <= target.val();
    });
});

$(function () {
    jQuery.validator.addMethod("greaterTodayDate", function (value, element, params) {
        if (value == null || $.trim(value) == '')
            return false;
        if ($(element).attr('enableLessOldValue') == '1' && $(element).attr('oldValue') == $(element).val())
            return true;

        var today = new Date();
        today.setHours(0, 0, 0, 0);
        var format = jQuery.telerik.cultureInfo.shortDate + " " + jQuery.telerik.cultureInfo.longTime;
        var val = jQuery.telerik.datetime.parse({ value: value, format: format }).value;
        return val >= today;
    });
});

$(function () {
    jQuery.validator.addMethod("greaterTodayDateTime", function (value, element, params) {
        if (value == null || $.trim(value) == '')
            return true;
        if ($(element).attr('enableLessOldValue') == '1' && $(element).attr('oldValue') == $(element).val())
            return true;

        var now = new Date();
        var damperChecked = $('#' + element.id + '_damper') == null || $('#' + element.id + '_damper').is(':checked');
        if (!damperChecked) {
            now.setHours(0, 0, 0, 0);
        }
        var format = jQuery.telerik.cultureInfo.shortDate + " " + jQuery.telerik.cultureInfo.longTime;
        var val = jQuery.telerik.datetime.parse({ value: value, format: format }).value;
        return val >= now;
    });
});

$(function () {
    jQuery.validator.addMethod("greaterThenDate", function (value, element, param) {
        var target = $(param).unbind(".validate-greaterThenDate").bind("blur.validate-greaterThenDate", function () {
            $(element).valid();
        });
        if (value == null || value == "" || target.val() == null || target.val() == "")
            return true;
        var format = jQuery.telerik.cultureInfo.shortDate + " " + jQuery.telerik.cultureInfo.shortTime;
        var val = jQuery.telerik.datetime.parse({ value: value, format: format }).value; //Date.parseDate(value, Date.patterns.ShortDate + ' ' + Date.patterns.ShortTime);
        var targetVal = jQuery.telerik.datetime.parse({ value: target.val(), format: format }); //Date.parseDate(target.val(), Date.patterns.ShortDate + ' ' + Date.patterns.ShortTime);
        var valTime = jQuery.telerik.datetime.parse({ value: value, format: jQuery.telerik.cultureInfo.shortTime });
        if (!valTime)
            val = new Date(val).addDays(1).addMilliseconds(-1);
        return targetVal == null || val >= targetVal.value;
    });
});

$(function () {
    jQuery.validator.addMethod("lessThenDate", function (value, element, param) {
        var target = $(param).unbind(".validate-lessThenDate").bind("blur.validate-lessThenDate", function () {
            $(element).valid();
        });
        if (value == null || value == "" || target.val() == null || target.val() == "")
            return true;
        var format = jQuery.telerik.cultureInfo.shortDate + " " + jQuery.telerik.cultureInfo.shortTime;
        var val = jQuery.telerik.datetime.parse({ value: value, format: format }).value; //Date.parseDate(value, Date.patterns.ShortDate + ' ' + Date.patterns.ShortTime);
        var targetVal = jQuery.telerik.datetime.parse({ value: target.val(), format: format }).value; //Date.parseDate(target.val(), Date.patterns.ShortDate + ' ' + Date.patterns.ShortTime);
        return val <= targetVal;
    });
});

$(function () {
    jQuery.validator.addMethod("validateAttachmentRequired", function (value, element, param) {
        var form = $(element).parents("form");
        var name = element.name;
        if (~name.lastIndexOf("_validate")) {
            name = element.name.substring(0, element.name.length - "_validate".length);
        }
        var fileInputBin = form.find("input[name='" + name + ".Uid']");
        var fileInputAttach = form.find("input[name='" + name + ".File.Uid']");
        if ((fileInputBin && fileInputBin.val()) || (fileInputAttach && fileInputAttach.val())) {
            return true;
        }
        var inputIdBin = form.find("input[name='" + name + ".Id']");
        var inputIdAttach = form.find("input[name='" + name + ".File.Id']");
        if (inputIdBin.val() || inputIdAttach.val()) {
            return true;
        }
        return false;
    });
});

$(function () {
    jQuery.validator.addMethod("validateAttachmentSetRequired", function (value, element, param) {

        var form = $(element).parents("form");
        var name = element.name;

        if (~name.lastIndexOf("_validate")) {
            name = element.name.substring(0, element.name.length - "_validate".length);
        }

        var reNew = new RegExp(name.replace(".", "\\.") + "\\[[0-9]+\\]\\.File.Uid");
        var reDb = new RegExp(name.replace(".", "\\.") + "\\[[0-9]+\\]\\.File.Id");

        var conditionNew = form.find("input").filter(function () {
            var valueAttr = this.getAttribute("value");
            var val1 = this.name.match(reNew) && (valueAttr && valueAttr.length > 0);
            var val2 = this.name.match(reDb) && (valueAttr && valueAttr.length > 0);
            return (val1 || val2) && $(this).val();
        });

        return conditionNew.length > 0;
    });
});

// валидатор для пользовательского скрипта
$(function () {
    jQuery.validator.addMethod("scriptvalidator", function (value, element, param) {
        return false;
    });
});

elmaValidation = function() {

};

elmaValidation.Manager = function () {
    var forms = new Object();

    return {
        removeRule: function (form, rule)
        {
            if (form == null || form.length === 0) {
                return;
            }
            var lastForm = forms[form[0].id];
            if (!lastForm || !lastForm.copyRules)
                return;
            if (lastForm.copyRules[rule]) {
                delete lastForm.copyRules[rule];
            }
        },
        addRule: function (form, id, rule)
        {
            if (form == null || form.length === 0) {
                return;
            }
            var lastForm = forms[form[0].id];
            if (!lastForm || !lastForm.copyRules)
                return;
            lastForm.copyRules[id] = rule;            
        },        
        disableValidate: function (form, disableArr, repairDeletedRules) {
            
            if (form == null || form.length === 0) {
                return;
            }

            var lastForm = forms[form[0].id];
            if (lastForm && lastForm.wasCopy) {
                //первоначальные поля валидации должны быть в неизменном виде
                if (repairDeletedRules) {
                    form.validate().settings.rules = jQuery.extend(true, form.validate().settings.rules, lastForm.deletedRules);
                } else {
                    form.validate().settings.rules = lastForm.copyRules;
                }
            }

            //в rules находятся все поля, которые валидируются
            var rules = form.validate().settings.rules;
            forms[form[0].id] =  {
                copyRules : jQuery.extend(true, {}, rules),
                wasCopy: true,
                deletedRules: {}
            }

            //удаляем валидацию, если необходимо
            for (var i = 0; i < disableArr.length; i++) {
                var prefix = disableArr[i];
                var regex = String.format(':input[name^=\'{0}\']', prefix);

                var contextFields = form.find(regex);
                if (contextFields) {
                    contextFields.each(function () {
                        var rule = rules[this.name];
                        if (rule) {
                            forms[form[0].id].deletedRules[this.name] = rules[this.name];
                            delete rules[this.name];
                        }
                    });
                }
            }
        }
    };
}();

//Таймаут ожидания создания валидатора для формы.
//Применим для случаев, когда добавляются правила валидации через 
//elma.ValidationRulesManager.addRule или вызывается валидация через valid() во время когда валидатор для объекта еще не создан.

elmaTimeout = function () { };

elmaTimeout.waitUntilValidatorReady = function (elementId, execute, createError) {
    if (elementId == null || !jQuery.isFunction(execute))
        return;

    var elementFind = $('#' + elementId);

    if (!elementFind)
        return;
    if (elementFind.length == 0)
        return;

    var elementForm = elementFind[0];
    if (!$("div").is("form")) {
        elementForm = (elementFind[0]).form;
    }

    if (!elementForm)
        return;

    var findValidator = function (elementForm) {
        var formValidatorExists = false;
        try {
            var formValidator = $.data(elementForm, 'validator');
            if (formValidator) {
                formValidatorExists = true;
            }
        } catch (e) {
            return null;
        }
        return formValidatorExists;
    }

    var cycleCount = 0;
    var wait = 10;
    var repeat = function () {
        var findValidatorResult = findValidator(elementForm);
        if (findValidatorResult == true) {
            execute();
            return;
        }

        if (findValidatorResult == null) {
            if (createError) {
                console.error("[elmaTimeout.waitUntilValidatorReady] Error: Validator not found " + elementId);
            }
            if (jQuery.isFunction(execute)) {
                execute();
            }
            return;
        }

        if (cycleCount > 10000) {
            if (createError) {
                console.error("[elmaTimeout.waitUntilValidatorReady] Timeout: Validator not found " + elementId);
            }
            if (jQuery.isFunction(execute)) {
                execute();
            }
            return;
        }

        if (cycleCount >= 200)
            wait = 100;
        if (cycleCount >= 1000)
            wait = 500;
        if (cycleCount >= 5000)
            wait = 1000;

        cycleCount = cycleCount + wait;
        window.setTimeout(repeat, wait);

    };
    repeat();
};

function submit_ignore_validate(form) {
    form.validate().settings.ignore = '*';
    for (var i = 0; i < formsvalid.length; i++) {
        try {
            var f = formsvalid[i];
            f.settings.ignore = 'input, select, textarea';

        } catch (e) {
            var s = e;
        }
    }
    form.AddAntiForgeryToken().submit();
    form.validate().settings.ignore = '';
}

function checkAndSubmit(form, outputCancel) {
    if (outputCancel) {
        submit_ignore_validate(form);
    } else {
        form.AddAntiForgeryToken().submit();
    }
}



if (!Object.keys) {
    Object.keys = function (obj) {
        var keys = [];

        for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
                keys.push(i);
            }
        }

        return keys;
    };
}
if (!Object.create) {
    Object.create = function (o, properties) {
        if (typeof o !== 'object' && typeof o !== 'function')
            throw new TypeError('Object prototype may only be an Object: ' + o);
        else if (o === null)
            throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");

        if (typeof properties != 'undefined')
            throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");

        function F() { }

        F.prototype = o;

        return new F();
    };
}

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (prefix) {
        return (this.substr(0, prefix.length) === prefix);
    }
}

if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (suffix) {
        return (this.substr(this.length - suffix.length) === suffix);
    }
}

elma = function () { };

elma.ShowCalendarWeekNumber = false;

elma.isIE = function () {
    var ua = navigator.userAgent;
    return ua.indexOf("IE") != -1 || ua.indexOf("Trident/7.0") != -1 && ua.indexOf("rv:11.0") != -1;
}

elma.isFirefox = function () {
    var ua = navigator.userAgent;
    return ua.indexOf("Firefox") != -1;
}

elma.rn2br = function(string) {
    return string.replace("<", "&lt;").replace(">", "&gt;").replace(/\r\n/g, "<br />").replace(/\n/g, "<br />");
};

elma.logout = function () {
    document.location = "/Security/Account/LogOn";
}

elma.LockManager = function () {
    var functionLock = {};
    var lockedFunctions = {};
    return {
        execute: function (key, func) {
            if (functionLock[key] == undefined) {
                functionLock[key] = false;
                lockedFunctions[key] = new Array();
            }
            if (functionLock[key]) {
                lockedFunctions[key].push(func);
            }
            else {
                functionLock[key] = true;
                lockedFunctions[key].push(func);
                while (lockedFunctions[key].length) {
                    var thisCallback = lockedFunctions[key].pop();
                    thisCallback();
                }
                functionLock[key] = false;
            }
        }
    }
} ();

elma.ValidationRulesManager = function () {
    var moveValidateRulesIds = [];
    var rules = [];
    var startupValidation = [];
    var disableStartupValidation = [];
    return {
        add: function (id) {
            if (!this.hasInRules(id)) {
                moveValidateRulesIds.push({ id: id, removed: false });
            } else {
                for (var i = 0; i < moveValidateRulesIds.length; i++) {
                    if (moveValidateRulesIds[i].id == id) {
                        moveValidateRulesIds[i].removed = false;
                    }
                }
            }
        },
        addRule: function (inputid, rulename, rule) {
            if ($('#' + inputid).length == 0 || $('#' + inputid)[0].form == null)
                return;
            if ($('#' + inputid).length > 0 && $.data($('#' + inputid)[0].form, 'validator')) {
                $('#' + inputid).rules(rulename, rule);
            } else {
                rules.push({ inputid: inputid, rulename: rulename, rule: rule });
            }
        },
        hasInRules: function (id) {
            for (var i = 0; i < moveValidateRulesIds.length; i++) {
                if (moveValidateRulesIds[i].id == id) {
                    return true;
                }
            }
            return false;
        },
        disible: function (id, entityId) {
            var form = $("#" + id).closest("form");
            var FormId = $(form).attr("id");
            var name = $("#" + id).attr("name");
            var entityName = null;
            if (entityId != undefined) {
                entityName = $("#" + entityId).attr("name");
            }
            if (!removeValidateRules(id, entityId)) {
                var disableStartupValidationItem = disableStartupValidation[FormId];
                if (disableStartupValidationItem != undefined) {
                    for (var i = 0; i < disableStartupValidationItem.length; i++) {
                        if (disableStartupValidationItem[i].id == id)
                            return;
                    }
                    disableStartupValidationItem.push({ id: id, entityId: entityId, name: name, entityName: entityName });
                    disableStartupValidation[FormId] = disableStartupValidationItem;
                }
            }
            var data = disableStartupValidation[FormId];
            if (data == undefined) {
                data = new Array();
            }
            for (var i = 0; i < data.length; i++) {
                if (data[i].id == id)
                    return;
            }
            data.push({ id: id, entityId: entityId, name: name, entityName: entityName });
            disableStartupValidation[FormId] = data;
            $(form).data("disableStartupValidation", data);
        },
        disibleAll: function (form) {
            for (var i = 0; i < moveValidateRulesIds.length; i++) {
                moveValidateRulesIds[i].removed = true;
                this.disible(moveValidateRulesIds[i].id);
            }
            var FormId = $(form).attr("id");
            disableStartupValidation[FormId] = null;
        },
        enable: function (id, entityId) {
            var form = $("#" + id).closest("form");
            var FormId = $(form).attr("id");
            var disableStartupValidationItem = this.getFormDisableValidation(FormId);
            if (disableStartupValidationItem != undefined) {
                for (var i = 0; i < disableStartupValidationItem.length; i++) {
                    if (disableStartupValidationItem[i].id == id) {
                        disableStartupValidationItem.splice(i, 1);
                        break;
                    }
                }
                disableStartupValidation[FormId] = disableStartupValidationItem;
                $(form).data("disableStartupValidation", disableStartupValidationItem);
            }
            addValidateRules(id, entityId);
        },
        remove: function (id) {
            for (var i = 0; i < moveValidateRulesIds.length; i++) {
                if (moveValidateRulesIds[i].id == id) {
                    moveValidateRulesIds[i].removed = true;
                    break;
                }
            }
        },
        reset: function () {
        },
        executeMove: function () {
            elma.LockManager.execute('elma.ValidationRulesManager.executeMove', function () {
                elma.ValidationRulesManager.executeMoveWork();
            });
        },
        executeMoveWork: function () {
            var i;
            for (i = 0; i < moveValidateRulesIds.length; i++) {
                if (!moveValidateRulesIds[i].removed) {
                    moveValidateRulesIds[i].removed = true;
                    elmaTimeout.waitUntilValidatorReady(moveValidateRulesIds[i].id, function () {
                        moveValidateRules(moveValidateRulesIds[i].id);
                    });
                }
            }
            this.executeRules();
            if (disableStartupValidation != null) {
                for (i = 0; i < disableStartupValidation.length; i++) {
                    var element = disableStartupValidation[i];
                    for (var j = 0; j < element.length; j++) {
                        this.disible(element[i].id, element[i].entityId);
                    }
                }
            }
        },
        executeRules: function () {
            for (var i = 0; i < rules.length; i++) {
                if ($('#' + rules[i].inputid).length > 0 && $.data($('#' + rules[i].inputid)[0].form, 'validator')) {
                    $('#' + rules[i].inputid).rules(rules[i].rulename, rules[i].rule);
                }
            }
        },
        pushStartupValidation: function (validationContext) {
            for (var i in startupValidation) {
                var item = startupValidation[i];
                if (item.FormId == validationContext.FormId) {
                    startupValidation[i] = validationContext;
                    return;
                }
            }
            startupValidation.push(validationContext);
        },
        getStartupValidation: function () {
            return startupValidation;
        },
        getFormStartupValidation: function (formId) {
            var data = $("#" + formId).data("formStartupValidation");
            if (!!data) {
                return data;
            }
            var startupValidationItem = null;
            if (startupValidation) {
                for (var i in startupValidation) {
                    var item = startupValidation[i];
                    if (item.FormId == formId) {
                        startupValidationItem = item;
                        break;
                    }
                }
            }
            return startupValidationItem;
        },
        setFormStartupValidation: function (formId, data) {
            $("#" + formId).data("formStartupValidation", data);
        },
        getFormDisableValidation: function(formId) {
            var data = $("#" + formId).data("disableStartupValidation");
            if (data != undefined) {
                return data;
            }
            var disableStartupValidationItem = null;
            if (disableStartupValidation) {
                for (var i in disableStartupValidation) {
                    var item = disableStartupValidation[i];
                    if (item.FormId == formId) {
                        disableStartupValidationItem = item;
                        break;
                    }
                }
            }
            return disableStartupValidationItem;
        }
    };
} ();

elma.onAjaxStop = function () {
    elma.InitTranslation();
    elma.bindAjaxForms();
    elma.dynamics.bind();
    chargeValidation();
    $("input.autocompliteValidateField").each(function () {
        moveValidateRules(this.id);
    });
    $("input.validationMoveField").each(function () {
        moveValidateRules(this.id);
    });
    elma.initQTip();
    bindButtons();
    elma.bindSwitch();
    elma.fixPagers();

        $.ajaxSetup({
            headers: {
                "Elma-RegisteredContent": elma.getRegisteredScripts(),
                "__RequestVerificationToken": AntiForgeryToken.Generate()
            }
        });
};
elma.onAjaxStart = function() {
    elma.ValidationRulesManager.reset();
};
elma.display = function (elementId, visibility, animation) {   
    if (visibility)
        $('#' + elementId).show(animation);
    else
        $('#' + elementId).hide(animation);
};
elma.displaySelector = function (selector, visibility, animation) {
    if (visibility)
        $(selector).show(animation);
    else
        $(selector).hide(animation);
};

elma.onCheckerStateChange = function (sender, blocks, revert) {
    var v = sender != null && sender != undefined && sender.value != undefined ? sender.value : sender;
    var showBlock = v.toLowerCase() == "true";
    if (typeof (revert) != 'undefined' && revert)
        showBlock = !showBlock;

    var arrayBlock = blocks.split(",");
    for (var i = 0; i < arrayBlock.length; i++) {
        elma.display(arrayBlock[i], !showBlock);
    }
};

elma._registeredScripts = [];

elma.getRegisteredScripts = function () {
    return elma._registeredScripts.join(",");
};
elma.addRegisteredScripts = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (!!arguments[i] && jQuery.inArray(arguments[i], elma._registeredScripts) == -1) {
            elma._registeredScripts.push(arguments[i]);
        }
    }
};
elma.removeRegisteredScript = function(key) {
    for (var i = 0; i < elma._registeredScripts.length; i++) {
        if (elma._registeredScripts[i] == key) {
            elma._registeredScripts.splice(i, 1);
            break;
        }
    }
}
elma.showBlockerDiv = function () {
    var overlay = $('body > .t-overlay');
    if (overlay.length == 0) {
        overlay = $('<div class="t-overlay" />').toggle(false).appendTo(document.body);
        var $doc = $(document);
        if ($.browser.msie && $.browser.version < 7)
            overlay.css({
                width: $doc.width() - 21,
                height: $doc.height(),
                position: 'absolute'
            });
    } else {
        var activeWindows = $(".t-window:visible");
        if (activeWindows.length > 0) {
            var zIndex = 0;
            var topWindow = null;
            activeWindows.each(function () {
                if ($(this).css("z-index") != undefined && $(this).css("z-index") != "" && parseInt($(this).css("z-index")) > zIndex) {
                    zIndex = parseInt($(this).css("z-index"));
                    topWindow = $(this);
                }
            });
            if (topWindow == null) {
                topWindow = $(activeWindows.get(0));
            }
            overlay.css("z-index", parseInt($(topWindow).css("z-index")) + 1);
        } else {
            overlay.css("z-index", 9999);
        }
    }
    if (!overlay.is(":visible"))
        overlay.show().animate({ opacity: 0.5 }, 'fast');
    return overlay;
};
elma.hideBlockerDiv = function() {
    var overlay = $('body > .t-overlay:visible');
    if (overlay.length > 0){
        var activeWindows = $(".t-window:visible");
        if (activeWindows.length > 0) {
            var zIndex = 0;
            var topWindow = null;
            activeWindows.each(function () {
                if ($(this).css("z-index") != undefined && $(this).css("z-index") != "" && parseInt($(this).css("z-index")) > zIndex) {
                    zIndex = parseInt($(this).css("z-index"));
                    topWindow = $(this);
                }
            });
            if (topWindow == null) {
                topWindow = $(activeWindows.get(0));
            }
            overlay.css("z-index", parseInt($(topWindow).css("z-index")) - 1);
        } else {
            overlay.hide().animate({ opacity: 0 }, 'fast');
        }
    }
    return overlay;
};
elma.openPleaseWait = function (showBlocker /* опционально. true, чтобы показать серый блокер поверх всей страницы */,
								text /* опционально. текст, который нужно вывести вместо сообщения 'Пожалуйста подождите...' */) {
    var wait = $('body > #overlay-wait');
    if (wait.length == 0)
        wait = $('<div id="overlay-wait">' + (text ? text : SR.T('Пожалуйста подождите...')) + '</div>').toggle(false).appendTo(document.body);
    if (!!text) 
        wait.text(text);
    wait.show();
    var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
    if (translationMode)
        elma.ProcessTranslationHtmlElement(wait);
    if (showBlocker != undefined && showBlocker != null && showBlocker) {
        elma.showBlockerDiv();
        var activeElement = document.activeElement;
        if (!isEmpty(activeElement)) {
            activeElement.blur();
            activeElement.setAttribute('returnFocus', 'true');
        }
    }
    return wait;
};
elma.closePleaseWait = function (hideBlocker /* опционально. true, чтобы скрыть серый блокер открытый ранее в функции elma.openPleaseWait */) {
    var wait = $('body > #overlay-wait:visible');
    wait.hide();
    if (hideBlocker != undefined && hideBlocker != null && hideBlocker) {
        elma.hideBlockerDiv();
        var element = $('[returnFocus = true]')[0];
        if (!isEmpty(element)) {
            element.focus();
            element.removeAttribute('returnFocus');
        }
    }
    return wait;
};
///Устаревшее не использовать!
elma.eval = function (script, obj) {
    if (window.execScript) {
        window.execScript(script); // execScript doesn’t return anything
    }
    else {
        if (obj != undefined && obj != null){
            with(obj){
                eval(script);
            }
        } else {
            eval(script);
        }
    }   
};
elma.ToggleCollor = function (idSelector, idElement, showColor, hideColor) {
    var selector = '#' + idSelector;
    var element = '#' + idElement;
    if ($(selector).is(':visible')) {
        $(element).css("color", showColor);
    } else {
        $(element).css("color", hideColor);
    }
};
elma.ToggleDiv = function (id, opnepic, closepic) {
    var selector = '#' + id;
    var selectoropen = '#' + opnepic;
    var selectorclose = '#' + closepic;
    if ($(selector).is(':visible')) {
        $(selector).hide();
        $(selectorclose).hide();
        $(selectoropen).show();
    }
    else {
        $(selector).show();
        $(selectorclose).show();
        $(selectoropen).hide();
    }
};
elma.htmlDecode = function (value) {
    if (!value) return '';
    return $('<div/>').html(value).text();
};
elma.htmlEncode = function (value) {
    if (!value) return '';
    return $('<div/>').text(value).html();
}
elma.repString = function (str, oname, obj, decodeFalse) {
    var nstr = str;
    var rg = "({((sender)(\\.(\\w)+)*)(\\[(('(\\w)+')|([\\d\\w])+|({((sender)(\\.(\\w)+)*)}))\\])*})";
    var sr = rg.replace("sender", oname);
    sr = new RegExp(sr);
    var ms = str.match(sr);
    while (ms && ms.length > 0) {
        try {
            var match = ms[0], omatch = ms[0];
            match = match.replace("{", "");
            match = match.replace("}", "");
            match = match.replace(oname, "obj");
            var em = eval(match);
            if (typeof em != 'undefined')
                if (!decodeFalse) {
                    nstr = nstr.replace(omatch, elma.htmlDecode(em));
                } else {
                    nstr = nstr.replace(omatch, em);
                }
                else
                    nstr = nstr.replace(omatch, "");
        } catch (ex) { }
        ms = nstr.match(sr);
    }
    return nstr;
};
elma.closeAllMenu = function() {
    $("ul.t-menu").each(function(){
        var menu = $(this).data("tMenu");
        if (menu != undefined && menu != null){
            $("> li", menu.element).each(function (){
                menu.close(this);
            });
        }
    });
};
elma.encodeObj = function (obj) {
    if (typeof obj == 'undefined')
        return '';
    if (typeof obj != 'object')
        return obj.toString();
    return Ext.util.JSON.encode(obj);
};
elma.AjaxError = function () {
    var counter = 0;
    return {
        show: function (text) {
            var errorBlock = $('body > #overlay-message');
            if (!text) text = SR.T('Произошла ошибка при общении с сервером...');
            if (errorBlock.length == 0) {
                errorBlock = $('<div id="overlay-message">' + text + '</div>').toggle(false).appendTo(document.body);
            }
            if (!errorBlock.is(":visible")) {
                errorBlock.text(text);
                errorBlock.fadeIn(200, function () {
                    var self = $(this);
                    var fadeOutSelf = function () {
                        if (counter-- <= 0) {
                            self.fadeOut(200);
                            return;
                        }
                        setTimeout(fadeOutSelf, 2000);
                    };
                    setTimeout(fadeOutSelf, 2000);
                });
            } else {
                counter++;
                errorBlock.text(errorBlock.text() + '\n\n' + text);
            }
        }
    };
} ();
elma.AjaxMessage = function () {
    var counter = 0;
    var messageDelay;
    return {
        show: function (text, delay) {
            var messageBlock = $('body > #overlay-message-info');
            if (!text) return;
            messageDelay = (!delay) ? 1000 : delay;
            if (messageBlock.length == 0) {
                messageBlock = $('<div id="overlay-message-info">' + text + '</div>').toggle(false).appendTo(document.body);
            }
            if (!messageBlock.is(":visible")) {
                messageBlock.text(text);
                messageBlock.fadeIn(200, function () {
                    var self = $(this);
                    var fadeOutSelf = function () {
                        if (counter-- <= 0) {
                            self.fadeOut(200);
                            return;
                        }
                        setTimeout(fadeOutSelf, messageDelay);
                    };
                    setTimeout(fadeOutSelf, messageDelay);
                });
            } else {
                counter++;
                messageBlock.text(messageBlock.text() + '\n\n' + text);
            }
        }
    };
} ();
elma.showajaxerror = function (x, e) {
    elma.closePleaseWait(true);

    if (x.status == 0) {
        elma.AjaxError.show(SR.T('Ошибка связи.\nПроверьте работоспособность вашей сети.'));
    } else if (x.status == 404) {
        elma.AjaxError.show(SR.T('Запрашиваемый ресурс не найден.'));
    } else if (x.status == 403) {
        elma.AjaxError.show(SR.T('Ошибка доступа.'));
    } else if (x.status == 500) {
        elma.AjaxError.show(SR.T('Внутренняя ошибка сервера.'));
    } else if (e == 'parsererror') {
        elma.AjaxError.show(SR.T('Ошибка.\nParsing JSON Request failed.'));
    } else if (e == 'timeout') {
        elma.AjaxError.show(SR.T('Время запроса истекло.'));
    } else {
        elma.AjaxError.show(SR.T('Неизвестная ошибка.\n') + x.responseText);
    }
};
elma.showMessageInformation = function(information) {
    var messagestd = $('#messages');
    messagestd.parent().show();
    messagestd.children('div')
        .append($('<table class="messagePanel-Information" style="width: 100%;"><tr>' +
                  '<td style="padding:5px;"><img src="/Content/Images/x16/info_message.png" style="border-width:0px;" alt="' + SR.T('Информация') + '" /></td>' +
                  '<td style="font-weight:bold;width:100%;padding:5px;">' + information + '</td>' +
                  '</tr></table>'));
}

elma.replaceUrlParam = function (url, paramName, paramValue) {
    var pattern = new RegExp('(\\?|\\&)(' + paramName + '=).*?(&|$)');
    var newUrl = url;
    if (url.search(pattern) >= 0) {
        newUrl = url.replace(pattern, '$1$2' + paramValue + '$3');
    }
    else {
        newUrl = newUrl + (newUrl.indexOf('?') > 0 ? '&' : '?') + paramName + '=' + paramValue;
    }
    return newUrl;
}

elma.isInnerHyperlink = function (e, _this)
{
    e = e || window.event; var targ = e.target || e.srcElement; if (targ.nodeType == 3) targ = targ.parentNode;
    return targ.tagName == 'A' && targ != _this;
}

$(document).ready(function () {
    var el = $.fn['show'];
    $.fn['show'] = function () {
        var res = el.apply(this, arguments);
        this.trigger('show');
        return res;
    };

    $(".ShowHideBlock").click(function () {
        $(this).toggleClass("ShowHideBlockActive").next().toggle();
    });

    $.ajaxSetup({
        error: function(x, e) {
            elma.showajaxerror(x, e);
        },
        headers: {
            "Elma-RegisteredContent": elma.getRegisteredScripts(),
            "__RequestVerificationToken": AntiForgeryToken.Generate()
        }
    });

    $("body").ajaxStop(elma.onAjaxStop);
    $("body").ajaxStart(elma.onAjaxStart);

    elma.bindAjaxDepartmentList();
});

/* For Entity History */

$(document).ready(function () {
    $("body").delegate('.audit-header .history-switch', 'click', function () {
        var wallId = $(this).data("wallid");
        var subclass = $(this).data("typeclass");
        var wall = $('#' + wallId);
        wall.find(".history-item").show();
        wall.find(".history-type-" + subclass).toggle();
        wall.find(".history-item:not(:has(.history-item-ext:visible))").hide();
        $(this).toggleClass("selected");
        return false;
    });
    $("body").delegate('.history-wall div.history-type-action .history-action-editvalues div.history-action-arrow.up', 'click', function () {
        var self = this;
        $(this).parent().find('.history-action-all-values, .history-action-short-values').slideToggle('slow', function () {
            $(self).hide();
            $(self).parent().find('div.history-action-arrow.down').show();
        });
    });
    $("body").delegate('.history-wall div.history-type-action .history-action-editvalues div.history-action-arrow.down', 'click', function () {
        var self = this;
        $(this).parent().find('.history-action-all-values, .history-action-short-values').slideToggle('slow', function () {
            $(self).hide();
            var divDown = $(self).parent().find('div.history-action-arrow.down');
            var functionCallBack = divDown.attr('CallBack');
            if (functionCallBack != null) eval(functionCallBack);
            $(self).parent().find('div.history-action-arrow.up').show();
        });
    });
    $("body").delegate('.history-wall div.history-type-comment .history-action-editvalues div.history-action-arrow.up', 'click', function () {
        var self = this;
        $(this).parent().find('.history-action-all-values, .history-action-short-values').slideToggle('slow', function () {
            $(self).hide();
            $(self).parent().find('div.history-action-arrow.down').show();
        });
    });
    $("body").delegate('.history-wall div.history-type-comment .history-action-editvalues div.history-action-arrow.down', 'click', function () {
        var self = this;
        $(this).parent().find('.history-action-all-values, .history-action-short-values').slideToggle('slow', function () {
            $(self).hide();
            var divDown = $(self).parent().find('div.history-action-arrow.down');
            var functionCallBack = divDown.attr('CallBack');
            if (functionCallBack != null) eval(functionCallBack);
            $(self).parent().find('div.history-action-arrow.up').show();
        });
    });
});
/* End For Entity History */

elma.bindAjaxDepartmentList = function () {
    $('.usertasks-wall').delegate('div.usertasks .usertasks-item', 'click', function (event) {
        var evt_tg = event.target;
        if (evt_tg.nodeName == "A")
            return;
        var self = this;
        var corner = $(self).parent().find('.usertasks-tasks-corner');
        $(corner).addClass('expanded');
        $(corner).find("[id=task_link]").text("Свернуть");
        $(corner).find("[id=task_arrow_expand]").css('display', 'none');
        $(corner).find("[id=task_arrow_collapse]").css('display', '');
        $(self).addClass('expanded');
        $(this).parent().find('.usertasks-tasks-slider').slideToggle('slow', function () {
            var usertasks = $(self).parent().find('.usertasks-tasks-action.tasks');
            if (usertasks.is(':hidden')) {
                elma.dynamics.loadOnce(usertasks[0].id, null, function () {
                    $(self).parent().find('.usertasks-tasks-action').slideToggle('slow');
                });
            }
        });
    });
    $('.usertasks-wall').delegate('div.usertasks-item.expanded', 'click', function (event) {
        var evt_tg = event.target;
        if (evt_tg.nodeName == "A")
            return;
        var self = this;
        var corner = $(self).parent().find('.usertasks-tasks-corner.expanded');
        $(corner).find("[id=task_link]").text("Подробнее");
        $(corner).find("[id=task_arrow_expand]").css('display', '');
        $(corner).find("[id=task_arrow_collapse]").css('display', 'none');
        $(corner).removeClass('expanded');
        $(self).removeClass('expanded');
    });
    $('.usertasks-wall').delegate('div.usertasks .usertasks-tasks-corner', 'click', function () {
        var self = this;
        var usertasks_item = $(self).parent().find('.usertasks-item');
        $(self).find("[id=task_link]").text("Свернуть");
        $(self).find("[id=task_arrow_expand]").css('display', 'none');
        $(self).find("[id=task_arrow_collapse]").css('display', '');
        $(usertasks_item).addClass('expanded');
        $(self).addClass('expanded');
        $(this).parent().find('.usertasks-tasks-slider').slideToggle('slow', function () {
            var usertasks = $(self).parent().find('.usertasks-tasks-action.tasks');
            if (usertasks.is(':hidden')) {
                elma.dynamics.loadOnce(usertasks[0].id, null, function () {
                    $(self).parent().find('.usertasks-tasks-action').slideToggle('slow');
                });
            }
        });
    });
    $('.usertasks-wall').delegate('div.usertasks-tasks-corner.expanded', 'click', function () {
        var self = this;
        var usertasks_item = $(self).parent().find('.usertasks-item.expanded');
        $(self).find("[id=task_link]").text("Подробнее");
        $(self).find("[id=task_arrow_expand]").css('display', '');
        $(self).find("[id=task_arrow_collapse]").css('display', 'none');
        $(usertasks_item).removeClass('expanded');
        $(self).removeClass('expanded');
    });
};

/* Default input */

elma.setDefaultInput = function (root) {
    var el = root || document;
    var attrTexts = $(el).find('input[type=text][focusset]:visible, input[type=password][focusset]:visible, textarea[focusset]:visible').not(':input[readonly=""]');
    var focusSet = false;
    attrTexts.each(function (i, a) {
        focusSet = elma.doSetDefaultInput(i, a, focusSet);
    });
    if (!focusSet) {
        var focusContainers = $(el).find('div[focusset]:visible, table[focusset]:visible');
        if (focusContainers.length > 0) {
            var conTexts = $(focusContainers).find('input[type=text]:visible, textarea:visible').not(':input[readonly=""]');
            conTexts.each(function (i, a) {
                focusSet = elma.doSetDefaultInput(i, a, focusSet);
            });
        }
        if (!focusSet) {
            var texts = $(el).find('input[type=text]:visible, input[type=password]:visible, textarea:visible').not(':input[readonly=""]');
            texts.each(function(i, a) {
                focusSet = elma.doSetDefaultInput(i, a, focusSet);
            });
        }
    }
};

elma.doSetDefaultInput = function (i, a, focusSet) {
    if (!focusSet && $(a).parents("div[id^='portlet_']").length == 0 && $(a).parents("div[autoFocus='false']").length == 0) {
        $(a).focus();
        focusSet = true;
    };
    return focusSet;
};

elma.newGuid = function(str, oname, obj) {
    var s = [], itoh = '0123456789ABCDEF';
    var i;
    for (i = 0; i < 36; i++) s[i] = Math.floor(Math.random() * 0x10);
    s[14] = 4; // Set 4 high bits of time_high field to version
    s[19] = (s[19] & 0x3) | 0x8;
    for (i = 0; i < 36; i++) s[i] = itoh[s[i]];
    s[8] = s[13] = s[18] = s[23] = '-';
    return s.join('');
};

elma.serializeFormToArray = function (form, formSelector) {
    var formJQ = $(form);
    var formId = formJQ.length ? formJQ[0].id : '';
    var rselectTextarea = /^(?:select|textarea)/i;
    var rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i;
    var rCRLF = /\r?\n/g;
    return formJQ.map(function () {
        var elems = this.elements;
        if (!elems) {
            elems = $(this).find("input,textarea,select");
        }
        return elems ? jQuery.makeArray(elems) : this;
    })
    .filter(function () {
        if (!formSelector) {
            formSelector = 'form';
        }
        var f = $(this).closest(formSelector);
        if (f.length && f[0].id != formId) { // Fix for IE, because "form.elements" in IE contains internal forms elements
            return false;
        }
        return this.name && !this.disabled &&
            (this.checked || rselectTextarea.test(this.nodeName) ||
            rinput.test(this.type));
    })
    .map(function (i, elem) {
        var val = jQuery(this).val();

        return val == null ?
            null :
            jQuery.isArray(val) ?
                jQuery.map(val, function (value) {
                    return { name: elem.name, value: value.replace(rCRLF, "\r\n") };
                }) :
                { name: elem.name, value: val.replace(rCRLF, "\r\n") };
    }).get();
        };

elma.allowOneClick = function (button, allButtons) {
    var buttonAttribute = "allowOneClickPost";
    if ($(button).attr(buttonAttribute) == null) {
        $(button).attr(buttonAttribute, true);
        if (allButtons) {
            var aaa = $(button).parent().find("input[type=button],input[type=submit]");
            aaa.attr(buttonAttribute, true);
        }
        return true;
    }
    return false;
};
elma.allowOneClickClear = function (buttonsPanel) {
    var buttonAttribute = "allowOneClickPost";
    if (buttonsPanel == null)
        return;
    var aaa = $(buttonsPanel).find("input[type=button],input[type=submit]");
    aaa.removeAttr(buttonAttribute);
};

elma.AddToStackRun = function (key, func) {
    if (!elma.FunctionsStack)
        elma.FunctionsStack = new Array();
    elma.FunctionsStack.push({ key: key, func: func, executed: false });
    return key;
};

elma.SetFunctionsStackStatus = function (key, status) {
    for (var i = 0; i < elma.FunctionsStack.length; i++) {
        if (elma.FunctionsStack[i].key == key) {
            elma.FunctionsStack[i].executed = status;
            break;
        }
    }
};

elma.ExecuteFunctionInStack = function(i) {
    elma.FunctionsStack[i].func.apply();
};

elma.ExecuteFunctionsStack = function() {
    if (!elma.FunctionsStack || elma.FunctionsStack.length == 0)
        return;
    var currenIndex = 0;
    elma.ExecuteFunctionInStack(currenIndex);
    var timerId = setInterval(
        function() {
            if (elma.FunctionsStack[currenIndex].executed) {
                currenIndex++;
                if (currenIndex < elma.FunctionsStack.length) {
                    elma.ExecuteFunctionInStack(currenIndex);
                } else {
                    clearInterval(timerId);
                }
            }
        }, 500);
};

elma.DownloadBinaryFile = function (fileUid, preparedFileUid, uniquePreviewGlobalPrefix) {
    var hasPreviewUrl = '/SDK.Action/BinaryFiles/HasPreview/' + fileUid;
    elma.openPleaseWait(true);
    $.ajax({
            global: true,
            cache: false,
            type: 'GET',
            url: hasPreviewUrl,
            success: function (data) {
                elma.closePleaseWait(true);
                if (data.result) {
                    if (data.hideSelector) {
                        var previewPopupUrl = '/SDK.Action/BinaryFiles/PreviewPopup/' + fileUid + '?uniqueGlobalPrefix=' + uniquePreviewGlobalPrefix;
                        refreshPopup('PreviewPopup', previewPopupUrl, null, data.fileName ? data.fileName : SR.T("Предпросмотр"), 'PreviewAjaxBinding("' + data.renderer + '", "' + uniquePreviewGlobalPrefix + preparedFileUid + '")', null, null, true, true);
                    } else {
                        var selectorUrl = '/SDK.Action/BinaryFiles/DownloadPreviewSelectorPopup/' + fileUid;
                        refreshPopup('DownloadPreviewSelector', selectorUrl, null, data.fileName ? data.fileName : SR.T("Выберите действие"), null, null, null, true, true);
                    }
                }
                else if (data.errorMessage) {
                    jAlert(data.errorMessage, SR.T('Ошибка доступа'));
                } else {
                    location.href = '/SDK.Action/BinaryFiles/Download/' + fileUid;
                }
            }
        });
    };

elma.callScript = function(scriptName, options) {
    elma.getScript(scriptName)(options);
}

elma.getScript = function (scriptName) {
    var names = scriptName.split(".");
    var f = window[names[0]];
    for (var i = 1; i < names.length; i++) {
        f = f[names[i]];
    }
    return f;
}

elma.testGuid = function (guid) {
    if (!guid || guid == '')
        return false;
    var re = /([a-f0-9]{8}(?:-[a-f0-9]{4}){3}-[a-f0-9]{12})/i;
    var match = re.exec(guid);
    return match && match[1] != null;
}

elma.fixPagers = function() {
    $('.t-grid-pager').each(function (i, a) {
        var width = 0;
        $(a).children('div:visible').each(function (j, k) {
            width += $(k).outerWidth();
        });
        var text = $(a).find('.pager_extra_text');
        var total = $(a).find('.t-status-text');
        if (text.is(':hidden')) {
            width += text.outerWidth();
        }
        if (total.is(':hidden')) {
            width += $(a).find('.t-pager-total').outerWidth();
        }
        if (width > $(a).outerWidth()) {
            text.hide();
            total.hide();
        } else {
            text.show();
            total.show();
        }
    });
}

elma.createSanitizedId = function (originalString, invalidCharReplacement) {
    if (!invalidCharReplacement)
        invalidCharReplacement = "_";
    var regex = new RegExp("[^A-Za-z0-9:_-]");
    return originalString.replace(regex, invalidCharReplacement);
}

elma.checkTimeZone = function () {
    // Получить куки часового пояса пользователя
    var userTimeZoneOffsetCookie = $.cookie("ElmaUserTimeZoneOffset");
    var blockedTimeZoneOffsetCookie = $.cookie("ElmaBlockedTimeZoneOffset");

    if (userTimeZoneOffsetCookie != undefined) {

        // Получить смещение часового пояса пользователя
        var userTimeZoneOffset = parseInt(userTimeZoneOffsetCookie);

        // Получить блокированное смещение часового пояса
        var blockedTimeZoneOffset = null;
        if (blockedTimeZoneOffsetCookie != undefined) {
            blockedTimeZoneOffset = parseInt(blockedTimeZoneOffsetCookie);
        }

        // Получить IANA TimeZone Id и смещение часового пояса
        var currentIanaTimeZoneId = null;
        try {
            currentIanaTimeZoneId = jstz.determine().name();
        } catch (e) {
            // ignored
        } 

        var date = (new Date()).toBrowserDateTimeFromClient();
        var currentTimeZoneOffset = -date.getTimezoneOffset(); // getTimezoneOffset() возвращает смещение с противоположным знаком

        if (currentTimeZoneOffset !== userTimeZoneOffset && currentTimeZoneOffset !== blockedTimeZoneOffset) {
            elma.openPleaseWait();

            // Удалить cookies часовых поясов - cookies обновятся и будут актуальными даже в том случае если пользователь не захотел менять часовой пояс
            $.cookie("ElmaBlockedTimeZoneOffset", null, { path: '/' });
            $.cookie("ElmaUserTimeZoneOffset", null, { path: '/' });

            // Получить часовой пояс по идентификатору IANA или ближайший по смещению
            $.ajax({
                url: "/Security/TimeZone/GetTimeZone",
                type: "GET",
                dataType: "json",
                data: { currentIanaTimeZoneId: currentIanaTimeZoneId, currentTimeZoneOffset: currentTimeZoneOffset },
                cache: false,
                success: function (data) {
                    elma.closePleaseWait();
                    if (data != undefined ||
                        data.Error ||
                        data.TargetTzId == undefined ||
                        data.TargetTzId === "" ||
                        data.TargetTzDisplayName == undefined ||
                        data.TargetTzDisplayName === "" ||
                        data.UserTzDisplayName == undefined ||
                        data.UserTzDisplayName === "") {
                        jConfirm(SR.T("Текущее время устройства отлично от вашего времени ELMA.\nИзменить ваш часовой пояс {0} на {1}?", data.UserTzDisplayName, data.TargetTzDisplayName), SR.T("Проверка часового пояса"), function (r) {
                            $.ajax({
                                url: "/Security/TimeZone/ChangeTimeZone",
                                type: "GET",
                                data: { timeZoneId: data.TargetTzId, currentTimeZoneOffset: currentTimeZoneOffset, userDecision: r },
                                cache: false,
                                success: function (data) {
                                    // Удалить cookies часовых поясов - cookies обновятся в зависимости от решения пользователя о смене часового пояса
                                    $.cookie("ElmaBlockedTimeZoneOffset", null, { path: '/' });
                                    $.cookie("ElmaUserTimeZoneOffset", null, { path: '/' });

                                    if (data != undefined && !data.Blocked) {
                                        if (data.Error ||
                                            data.DisplayName == undefined ||
                                            data.DisplayName === "") {
                                            jAlert(SR.T("Не удалось установить часовой пояс. Попытайтесь установить часовой пояс посредством редактирования своего профиля"), SR.T("Ошибка"));
                                        } else {
                                            jAlert(SR.T("Часовой пояс {0} установлен. Текущая страница будет перезагружена.", data.DisplayName), SR.T("Сообщение"), function () { location.reload(); });
                                        }
                                    }
                                }
                            });
                        });
                    } else {
                        jAlert(SR.T("Текущее время устройства отлично от вашего времени ELMA.\nНе удалось определить приоритетный часовой пояс.\nПопытайтесь установить часовой пояс путем редактирования своего профиля"), SR.T("Проверка часового пояса"));
                    }
                }
            });
        }
    }
}

elma.timeZone = function () {
    var getTimeZoneOffsetFromCookie = function(key) {
        var matches = document.cookie.match(new RegExp("(?:^|; )" + key.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"));
        return matches ? parseInt(decodeURIComponent(matches[1])) : undefined;
    }

    return {
        getUserOffset: function () { return getTimeZoneOffsetFromCookie("ElmaUserTimeZoneOffset"); },
        getRuntimeOffset: function () { return getTimeZoneOffsetFromCookie("ElmaRuntimeTimeZoneOffset"); },
        getServerOffset: function () { return getTimeZoneOffsetFromCookie("ElmaServerTimeZoneOffset"); },
        getBrowserOffset: function (date) { return -(date == null ? new Date() : date).getTimezoneOffset(); }
    };
}();

elma.getURLParameter = function(name) {
    return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.search) || [, ""])[1].replace(/\+/g, '%20')) || '';
}

elma.isLocalStorageEnabled = function() {
    try {
        return ('localStorage' in window && window['localStorage'] !== null && localStorage);
    } catch (e) {
        return false;
    }
};

elma.localStorageSet = function (key, obj) {
    if (!this.isLocalStorageEnabled())
        return;
    localStorage.setItem(key, JSON.stringify(obj));
}

elma.localStorageGet = function (key) {
    if (!this.isLocalStorageEnabled())
        return null;
    try {
        return JSON.parse(localStorage.getItem(key));
    } catch (err) {
        return null;
    }
}

$(document).ready(function () {
    elma.setDefaultInput();
    elma.checkTimeZone();
    elma.fixPagers();
});

$(window).resize(function () {
    elma.fixPagers();
});

/* End of Default input */

;(function($) {
  
$.fn.AddAntiForgeryToken = function () {
    if (this.find("input[name=__RequestVerificationToken]").length == 0) {
        $("<input type='hidden'>")
            .attr("name", "__RequestVerificationToken")
            .attr("value", AntiForgeryToken.Generate())
            .prependTo(this);
    }
    return this;
};

})(jQuery);



/* Functions for toolbar */

elma.toolbar = { };
elma.toolbar.button = function (id) {
    return {
        button: $('#toolbar_btn_' + id.toLowerCase()),
        showOrHide: function (show) {
            elma.toolbar.showOrHideButton(this.button, show);
        },
        show: function () {
            elma.toolbar.showButton(this.button);
        },
        hide: function () {
            elma.toolbar.hideButton(this.button);
        }
    };
};
elma.toolbar.showOrHideButton = function (button, show) {
    var a = $(button);
    var li = a.parent();
    li.css('display', show ? '' : 'none');
    var ul = li.parent();
    var items = ul.children('li').filter(function (index) {
        return $(this).css('display') != 'none';
    });
    items.each(function (index, value) {
        if (index == 0) {
            $(value).addClass('t-first');
        } else {
            $(value).removeClass('t-first');
        }
    });
};
elma.toolbar.showButton = function (button) {
    elma.toolbar.showOrHideButton(button, true);
};
elma.toolbar.hideButton = function (button) {
    elma.toolbar.showOrHideButton(button, false);
};

elma.toolbar.hideGroup = function(group) {
    var a = $('#' + group);
    a.hide();
};

elma.toolbar.showGroup = function (group) {
    var a = $('#' + group);
    a.show();
};


function bindPortlet() {
    /*$(".portlet").addClass("ui-widget ui-widget-content ui-helper-clearfix ui-corner-all")
			.find(".portlet-header")
				.addClass("ui-widget-header ui-corner-all")
				.prepend("<span class='ui-icon ui-icon-minusthick'></span>")
				.end()
			.find(".portlet-content");

    $(".portlet-header .ui-icon").click(function () {
        $(this).toggleClass("ui-icon-minusthick").toggleClass("ui-icon-plusthick");
        $(this).parents(".portlet:first").find(".portlet-content").toggle();
    });*/
    $(".portlet .portlet-header .ui-icon-collapse, .portlet .portlet-header .ui-icon-expand").click(function () {
        $(this).toggleClass("ui-icon-collapse").toggleClass("ui-icon-expand");
        $(this).parents(".portlet:first").find(".portlet-content").toggle();
        var id = $(this).parents(".portlet:first").attr("instanceId");
        var collapse = $(this).parents(".portlet:first").find(".portlet-content").is(':hidden');
        var self = this;

        var callback = function () {

            var collapsed = $(self).parents(".portlet:first").find(".portlet-content").is(':hidden');

            $.ajax({
                global: false,
                cache: false,
                type: "GET",
                data: {
                    'instanceId': id,
                    'path': $('#personalpath').val(),
                    'collapse': collapsed,
                    'scope': $('#personalscope').val()
                },
                success: function () {
                    window.showOverlay = true;
                },
                url: window.BaseUrl + 'SDK.Action/Personalization/Set/'
            });
        };

        //загрузка, если контент не загружен
        if (!collapse) {
            var containerToLoad = $(this).parents(".portlet:first").find(".portlet-content").children("[dynamicurl]").get(0);
            $(containerToLoad).show();
            LoadPortletContent(containerToLoad, callback);
        }
        else {
            callback();
        }
    });
    $(".portlet .portlet-header .ui-icon-update").click(function () {
        var portletEl = $(this).parents(".portlet:first").get(0);
        //загрузка
        UpdatePortletContent(portletEl);
    });
    $(".portlet .portlet-header .ui-icon-delete").click(function () {
        var id = $(this).parents(".portlet:first").attr("instanceId");
        jConfirm(SR.T("Удалить портлет со страницы?"), SR.T("Подтверждение"), function (r) {
            if (r) {
                elma.openPleaseWait(true);
                $.ajax({
                    cache: false,
                    type: "POST",
                    data: {
                        'instanceId': id,
                        'path': $('#personalpath').val(),
                        'closed': true,
                        'scope': $('#personalscope').val()
                    },
                    url: window.BaseUrl + 'SDK.Action/Personalization/Set/',
                    success: function () {
                        $("[instanceId=" + id + "]").trigger("deletePortlet", [id]);
                        $("[instanceId=" + id + "]").remove();
                        elma.closePleaseWait(true);
                    }
                });
            }
        });
    });
    $(".portlet .portlet-header .ui-icon-settings").click(function () {
        var portlet = $(this).parents(".portlet:first");
        var id = portlet.attr("id").replace("portlet_", "");
        var instanceId = portlet.attr("instanceId");
        var p = $('#PortletSettings').find('> .t-window-content').get(0);
        $(p).css("width", 'auto');
        $(p).css("min-width", '600px');
        refreshPopup("PortletSettings", window.BaseUrl + 'SDK.Action/Personalization/PortletSettings?portletId=' + id + "&instanceId=" + instanceId + "&path=" + $('#personalpath').val() + '&scope=' + $('#personalscope').val());
    });

    $(".dynamic:visible").each(function () {
        LoadPortletContent(this);
    });
}

function LoadPortletContent(div, callback) {
    var url = $(div).attr("dynamicUrl");
    if (url != undefined && url != "" && $(div).attr("loaded") == undefined) {
        $(div).attr("loaded", "1");
        $(div).load($(div).attr("dynamicUrl"), null, callback);
    }else if(typeof callback == 'function') {
        callback();
    }
}

function UpdatePortletContent(portletEl) {
    var div = $(portletEl).find(".portlet-content").children("[dynamicurl]").get(0);
    var url = $(div).attr("dynamicUrl") + "&path=" + $('#personalpath').val();
    elma.openPleaseWait(true);
    $(div).load(url, null, function () {
        elma.closePleaseWait(true);
    });
}

function SavePortletsPossition() {
    elma.openPleaseWait(true);
    $.ajax({
        cache: false,
        type: "POST",
        data: {
            'path': $('#personalpath').val(),
            'portalPositionsData': $('#portalPositionsData').val(),
            'scope': $('#personalscope').val()
        },
        url: window.BaseUrl + 'SDK.Action/Personalization/SavePositions/',
        success: function () {
            elma.closePleaseWait(true);
        }
    });
}

function ResetPersonalization() {
    jConfirm(SR.T("Сбросить все персональные настройки на странице?"), SR.T("Подтверждение"), function (r) {
        if (r) {
            elma.openPleaseWait(true);
            $.ajax({
                cache: false,
                type: "POST",
                data: {
                    'path': $('#personalpath').val(),
                    'scope': 'User'
                },
                url: window.BaseUrl + 'SDK.Action/Personalization/ResetPersonalization/',
                success: function () {
                    elma.closePleaseWait(true);
                    location.reload(true);
                }
            });
        }
    });
}


function ZoneSelectorExpr(zoneName) {
    return '[zone=' + zoneName + ']';
}

function GetPortletsPossitionData(zones) {
    var json = {};
    json.PersonalPath = $('#personalpath').val();
    json.Zones = [];
    for (var i = 0; i < zones.length; i++) {
        if ($(ZoneSelectorExpr(zones[i])).hasClass("ui-sortable")) {
            var zone = {};
            zone.Name = zones[i];
            zone.Instnaces = [];
            $(ZoneSelectorExpr(zones[i]) + " .portlet").each(function (k) {
                zone.Instnaces[k] = $(this).attr("instanceId");
            });
            json.Zones[json.Zones.length] = zone;
        }
    }
    return json;
}
function UpdatePortletsPossition(zones, hiddenField) {
    $('#' + hiddenField).val($.toJSON(GetPortletsPossitionData(zones)));
}

// appendType: 'append', 'prepend'
function AddPortlet(id, zone, callback, appendType) {
    $.getJSON(window.BaseUrl + 'SDK.Action/Personalization/AddPortlet', { 'path': $('#personalpath').val(), 'portletId': id, 'zone': zone, 'scope': $('#personalscope').val(), 'appendType': appendType }, function (json) {
        if (json.error != undefined && json.error.length > 0) {
            jAlert(json.error, SR.T("Ошибка"));
        } else {
            if (callback != undefined && callback != null) {
                callback(json);
            } else {
                if (!!json.portletZone && !!json.portletId) {
                    $.ajax({
                        cache: false,
                        type: "GET",
                        data: {
                            'path': $('#personalpath').val(),
                            'portletId': json.portletId,
                            'instanceId': json.instanceId,
                            'scope': $('#personalscope').val()
                        },
                        url: window.BaseUrl + 'SDK.Action/Personalization/EditPortlet',
                        success: function (html) {
                            if (html != '') {
                                var zone = $(ZoneSelectorExpr(json.portletZone));
                                if (zone.length == 0) {
                                    jAlert(SR.T("Неправильный id зоны {0}", json.portletZone), SR.T("Ошибка"));
                                }
                                if (appendType == 'append')
                                    zone.append(html);
                                else
                                    zone.prepend(html);
                                closeWindow("AddPortlets", false);
                                bindPortlet();
                            } else {
                                jAlert(SR.T("Ошибка получения портлета, перезагрузите страницу."), SR.T("Ошибка"));
                            }
                        }
                    });
                } else {
                    location.reload(true);
                }
            }
        }
    });
}
function LoadPortletSettings(popupId, uid){
    refreshPopup(popupId, window.BaseUrl + 'SDK.Action/Personalization/PortletSettings?newPortlet=True&portletId=' + uid + "&path=" + $('#personalpath').val() + '&scope=' + $('#personalscope').val());
}
function PortletSettingsLoading(uid, inPopup) {
    /*if (inPopup) {
        var popupId = getWindowId($('#form_' + uid));
        if (popupId != null) {
            resizeWindowContent(popupId)
            $("#" + popupId).data('tWindow').center();
        }
    }*/
    $("#btnPortletSettingsSave_" + uid).unbind("click");
    $("#btnPortletSettingsSave_" + uid).bind("click", function (e) {
        PortletSettingsSave(uid, inPopup, true);
    });
    $("#btnPortletSettingsSaveAndContinue_" + uid).unbind("click");
    $("#btnPortletSettingsSaveAndContinue_" + uid).bind("click", function (e) {
        PortletSettingsSave(uid, inPopup, false);
    });
}

function PortletSettingsSave(uid, inPopup, close) {
    var form = $('#form_' + uid);
    form.validate();
    if (!form.is(".ajax-submit") || form.attr("action") == undefined || form.attr("action") == "" || !form.valid()) {
        return;
    }
    //var portledUid = $("#uid_" + uid).val();
    if (!$("#path_" + uid)) {
        // есть вероятность что это присваивание не нужно 
        $("#path_" + uid).val($('#personalpath').val());
    }
    var options = {
        dataType: "json",
        beforeSubmit: function () {
            elma.openPleaseWait(true);
        },
        success: function (json) {
            elma.closePleaseWait(true);
            if (json.error == undefined || json.error == "") {
                if (inPopup && close) {
                    closeWindow(getWindowId($('#form_' + uid)));
                    location.reload(true);
                }
                if (form.attr("callback") != undefined) {
                    elma.eval(form.attr("callback"));
                }
            } else {
                jAlert(json.error, SR.T("Ошибка"));
            }
        }
    };
    $('#form_' + uid).ajaxSubmit(options);
}

function GetAddPortletConfig(portletId, callback) {
    elma.openPleaseWait(true);
    $.ajax({
        cache: false,
        type: "GET",
        data: {
            'portletId': portletId
        },
        url: window.BaseUrl + 'SDK.Action/Personalization/PortletSettings',
        success: function (html) {
            elma.closePleaseWait(true);
            callback(html);
        }
    });
}

function bindMenu(menuId,menuModel) {
    $(menuId).contextMenu(menuModel); 
   
}


elma.bindAjaxForms = function (containerId) {
    var parent = containerId ? $('#' + containerId).find('form[type="ajaxForm"]') : $('form[type="ajaxForm"]');
    parent.each(function (i, a) {
        if ($(a).attr("ajaxFormBinding") != "true") {
            $(a).ajaxForm(elma.getAjaxFormOptions(a));
            $(a).attr("ajaxFormBinding", "true");
        }
    });
};
elma.getAjaxFormOptions = function (form) {
    var callback = $(form).attr('callback');
    var callbackFunc = $(form).attr('callbackFunc');
    var imageSubmit = false;
    if ($(form).attr('imageSubmit')) {
        imageSubmit = $(form).attr('imageSubmit').toUpperCase() == 'TRUE';
    }
    var options = {};
    if (!callback && !callbackFunc) {
        options = {
            dataType: 'json',
            semantic: (imageSubmit ? true : false),
            beforeSubmit: function (arr, $form, options) {
                $form.validate();
                var valid = $form.valid();
                if (valid) {
                    elma.openPleaseWait(true);
                }
                return valid;
            },
            success: function (data) {
                elma.closePleaseWait(true);
            }
        };
    }
    else {
        options = {
            dataType: 'json',
            semantic: (imageSubmit ? true : false),
            beforeSubmit: function (arr, $form, options) {
                $form.validate();
                var valid = $form.valid();
                if (valid) {
                    elma.openPleaseWait(true);
                }
                return valid;
            },
            success: function (data) {
                elma.closePleaseWait(true);
                if (callback)
                    eval(callback);
                else
                    window[callbackFunc](data);
            }
        };
    }
    return options;
};
elma.bindPleaseWait = function () {
    $('form[method="post"]').each(function (i, form) {
        if ($(form).attr("openPleaseWaitBinding") != "true") {
            $(form).AddAntiForgeryToken().submit(function () {
                if ($(this).valid()) {
                    elma.openPleaseWait(true);
                    $(form).attr("openPleaseWaitBinding", "true");
                }
            });
        }
    });

};
/*
Добавить элекмент в редактируемый список
Параметры:
value - значние (строка)
text - отображаемое значение (строка)
name - имя редактируемого списка
*/
elma.addEditableListItem = function (value, text, image, entityUrl, name, containerId) {
    var jsonInputName = name + "_value";
    var jsonInput = $("#" + jsonInputName);
    if (containerId) {
        jsonInput = $("#" + containerId).find('input[id=' + jsonInputName + ']');
    }
    if (jsonInput.val() == undefined) {
        return;
    }
    var values = $.evalJSON(jsonInput.val());
    if ($(values).filter(function (i) { return this.Value == value; }).length > 0) {
        return;
    }

    values.push({ 'Value': value, 'DisplayText': text });
    jsonInput.val($.toJSON(values));
    var deleteAction = function () {
        elma.deleteEditableListItem(value, text, name, true, containerId);
    };
    var img = '';
    if (typeof (image) != 'undefined' && image != '' && image != null) {
        img = '<img class="editablelist-img" src="' + image + '" alt="" />' + "\r\n";
    }
    if (!isEmpty(entityUrl)) {
        var id = $.evalJSON(value).Id;
        if (typeof id === 'undefined') {
            id = value;
        }
        text = '<a href="' + String.format(entityUrl, id) + '">' + text + '</a>';
    }
    var itemContent = '<img alt="Удалить" class="editablelist-delete-img" src="' + window.BaseUrl + 'Content/Images/x16/delete.png" title="Удалить">' + "\r\n" + img + text;

    var groupByProperty = $('#' + name).attr('groupBy');
    var rowTemplate = $('#' + name).attr('addTemplate');
    if (groupByProperty) {
        var templates = $.evalJSON(rowTemplate);
        var evalVal = $.evalJSON(value);
        rowTemplate = templates[evalVal[groupByProperty]];
    }
    if (rowTemplate == null || rowTemplate == '')
        rowTemplate = '<td>{0}</td>';
    var el = $('<tr class="editablelist-item">' + jQuery.validator.format(rowTemplate, itemContent) + '</tr>');

    el.attr('item', value);
    el.find('img.editablelist-delete-img').first().click(deleteAction);
    var editableList = $('#' + name);
    if (containerId)
        editableList = $('#' + containerId).find('div[name=' + name + ']');
    var tbody = editableList.find('table:first > tbody:last');
    el.appendTo(tbody);
    editableList.trigger('changed', values);
    return el;
};
/*
Удалить элемент из редактируемого списка
Параметры:
value - значние (строка)
text - отображаемое значение (строка)
name - имя редактируемого списка
confirm - показывать, не показывать диалог подтверждения удаления, по умолчанию true
*/
elma.deleteEditableListItem = function (value, text, name, confirm, containerId) {
    confirm = typeof (confirm) != 'undefined' ? confirm : true;

    var deleteAction = function () {
        var div = $("div[name=" + name + "]");
        if (containerId) {
            div = $('#' + containerId).find("div[name=" + name + "]");
        }
        div.find('tr').filter(function (i) { return $(this).attr('item') == value; }).remove();

        var jsonInputName = name + "_value";
        var jsonInput = $("#" + jsonInputName);
        if (containerId) {
            jsonInput = $('#' + containerId).find('input[id=' + jsonInputName + ']');
        }

        var values = $.evalJSON(jsonInput.val());
        var isJsonValue = elma.isJSON(value);
        if (isJsonValue) {
            value = $.evalJSON(value);
        }
        else {
            // Так проверять нельзя! Случай, если данные не являются JSON, нужно смотреть отдельно.
            value = value.replace(new RegExp("[}]+$", "g"), ""); // В случае, когда value является JSON, надо убрать закрывающую скобку, чтобы сравнить по началу данных
        }
        values = $(values).filter(function (i) {
            if (isJsonValue) {
                var valueJson = $.evalJSON(this.Value);
                return value.ObjectType != valueJson.ObjectType || value.Id != valueJson.Id;
            } else {
                // Так проверять нельзя! Случай, если данные не являются JSON, нужно смотреть отдельно.
                return this.Value.indexOf(value) != 0;
            }
        }).toArray();

        jsonInput.val($.toJSON(values));

        /*if (onChangeScript != undefined && onChangeScript != null && onChangeScript != '')
        eval(onChangeScript);*/
        div.trigger('changed', values);
    };
    if (confirm == true) {
        jConfirm(SR.T('Удалить "{0}" из списка', text), SR.T('Удаление'), function (r) {
            if (r == true) {
                deleteAction();
                return;
            }
        });
    }
    else
        deleteAction();
};
/*
Очистить редактируемый список
Параметры:
name - имя редактируемого списка
*/
elma.clearEditableListItem = function (name, containerId) {
    var clearAction = function () {
        var div = $("div[name=" + name + "]");
        if (containerId) {
            div = $('#' + containerId).find("div[name=" + name + "]");
        }
        div.find('tr').remove();

        var jsonInputName = name + "_value";
        var jsonInput = $("#" + jsonInputName);
        if (containerId) {
            jsonInput = $('#' + containerId).find('input[id=' + jsonInputName + ']');
        }

        var values = $.evalJSON(jsonInput.val());
        values = $(values).toArray();

        jsonInput.val('[]');
        
        div.trigger('changed', values);
    };
    clearAction();
};
/*
Назначть данные элементу редактируемого списка
Параметры:
value - значние (строка)
text - отображаемое значение (строка)
name - имя редактируемого списка
confirm - показывать, не показывать диалог подтверждения удаления, по умолчанию true
*/
elma.setEditableListItemData = function (value, data, name, containerId) {

    var jsonInputName = name + "_value";
    var jsonInput = $('#' + jsonInputName);
    if (containerId) {
        jsonInput = $('#' + containerId).find('input[id=' + jsonInputName + ']');
    }

    var values = $.evalJSON(jsonInput.val());
    $.each(values, function (i, v) { if (v.Value == value) v.Data = data; });

    jsonInput.val($.toJSON(values));
};


elma.bindPermissionForm = function (popupId, type, json, script) {

    var result = new Array();
    if (json != null && json != undefined && json != "") {
        var values = $.evalJSON(json);
        var image = $('#' + popupId).find('input[type=radio]').filter(function (i) { return $(this).attr('roleType') == type; }).first().attr('image');
        var entityUrl = $('#' + popupId).find('input[type=radio]').filter(function (i) { return $(this).attr('roleType') == type; }).first().attr('entityUrl');
        for (var i = 0; i < values.length; i++) {
            result[i] = { Id: values[i].id, Text: values[i].text, ObjectType: type, Image: image, EntityUrl: entityUrl, AccessType: (values[i].access != undefined ? values[i].access : 0) };
        }
    }
    if (script != undefined && script != "") {
        script.call(this, result);
        closeWindow(popupId);
    } else {
        $('<input type="hidden" name="json" id="' + popupId + '_json" value="" />').appendTo($("#" + popupId + "_form"));
        $("#" + popupId + "_json").val($.toJSON(result));
        $("#" + popupId).data("tWindow").loaded = false;
        $("#" + popupId + "_form").ajaxSubmit(elma.getAjaxFormOptions($("#" + popupId + "_form")));
    }
};
elma.appendFromPermissionPopup = function (name, onappend, containerId, clearList) {

    return function (r) {
        // если список данных пуст, то ничего не делаем
        if (r.length == 0) {
            return;
        }

        if (!!clearList) {
            elma.clearEditableListItem(name, containerId);
        }

        $(r).each(function (i, v) {
            var el = v.ObjectType == "887ddf0a-9ee1-42c8-877c-f30fb40eb03f"
                ? elma.addEditableListItem($.toJSON({ 'ObjectType': v.ObjectType, 'Id': v.Id }), v.Text, v.Image, v.EntityUrl, name, containerId)
                : elma.addEditableListItem($.toJSON({ 'ObjectType': v.ObjectType, 'Id': parseInt(v.Id) }), v.Text, v.Image, v.EntityUrl, name, containerId);
            if (!!onappend) {
                onappend(el);
            }
        });
    };
};
elma.setDependencyPermissions = function (el) {
    var input = $(el);
    var editablelist = $(input.parents('div.editablelist')[0]);
    var dependencies = $.evalJSON(editablelist.attr('dependencies'));
    //var dependencies = [{ 'id': 'view', 'dependencies': [] }, { 'id': 'edit', 'dependencies': ['view'] }, { 'id': 'full', 'dependencies': ['view', 'edit']}];

    var row = input.parents('.editablelist-item:first').first();
    var inputs = row.find('input[type=checkbox]');

    var permission = $(input).attr('name');
    if ($(input).is(':checked')) {
        // вкл.
        // включаем привилегии от которых зависит включенная привилегия
        var pd = $(dependencies).filter(function (i) { return this.id == permission; })[0].dependencies;

        $.each(pd, function (i, id) {
            inputs.filter(function (i) {
                return $(this).attr('name') == id;
            }).attr('checked', true);
        });

    } else {
        // выкл.
        // выключаем зависимые привилегии
        var depended = $.grep(dependencies, function (v) {
            return $.inArray(permission, v.dependencies) >= 0;
        });
        $.each(depended, function (i, v) {
            inputs.filter(function (i) {
                return $(this).attr('name') == v.id;
            }).attr('checked', false);
        });
    }

    // записываем выбранные привилегии в data
    var checkedPermissions = [];
    $.each(inputs, function (i, v) {
        if ($(v).is(':checked')) {
            checkedPermissions.push($(v).attr('name'));
        }
    });


    elma.setEditableListItemData($(row).attr('item'), $.toJSON(checkedPermissions), $(editablelist).attr('name'), $(input.parents('form')[0]).attr('id'));
};
elma.SelectPermissionType = function (divId) {
    $(".permission-popup-div").hide();
    $("#" + divId).show();
};
elma.SelectPermissionRadio = function (popupId, selectType) {
    if ($("#" + popupId + "RadioButtons input:checked").length > 0) {
        var input = $($("#" + popupId + "RadioButtons input[value='" + selectType + "']").get(0));
        input.click();
    }
};
elma.SelectPermissionValues = function (popupId, script, containerId) {
    if ($("#" + popupId + "RadioButtons input:checked").length > 0) {
        var input = $($("#" + popupId + "RadioButtons input:checked").get(0));
        var objectType = input.val();
        var jsonInputName = input.attr("valueInput");
        var jsonInput = $("#" + jsonInputName);
        if (containerId) {
            jsonInput = $('#' + containerId).find('input[id=' + jsonInputName + ']');
        }
        var jsonStr = jsonInputName != "" ? jsonInput.val() : $.toJSON([{ 'id': null, 'text': input.attr('text')}]);
        // далее следует костыль, который выдирает выбранных пользователей из автокомплита
        // наверное потому что не удалось подписаться на события автокомплита ...
        if (objectType == "2" || objectType == "ed43e50f-6085-47bd-9a28-e43246e476a8") {
            var selector = elma.EntitySelector.Manager.get(jsonInputName.replace("validate", "Id"));
            var selected = selector.getSelected();
            var resultArray = new Array();
            $.each(selected, function (i, e) {
                if (e.val != "") {
                    resultArray.push({ "id": e.val, "text": e.text });
                }
            });
            jsonStr = $.toJSON(resultArray);
        }

        if (objectType == "887ddf0a-9ee1-42c8-877c-f30fb40eb03f") {
            var resultPropertyArray = new Array();
            var values = jsonStr != "" ? $.evalJSON(jsonStr) : [];

            for (var i = 0; i < values.length; i++) {
                resultPropertyArray[i] = { id: values[i].Value, text: values[i].Text };
            }

            jsonStr = $.toJSON(resultPropertyArray);
        }

        elma.bindPermissionForm(popupId, objectType, jsonStr, script);
    }
};
elma.checkAutocompliteValue = function (inputId, inputAddName) {
    var idVal = $("#" + inputId + "-value").val();
    var id = parseInt(idVal);
    if (isNaN(id) || idVal != id || idVal.toString() != id.toString()) {
        $("#" + inputId + "-value").val("");
        if (inputAddName != undefined && inputAddName != "" && $("#" + inputId + "-input").val() != "") {
            $("#" + inputId + "-value").attr("name", inputAddName);
            $("#" + inputId + "-value").val($("#" + inputId + "-input").val());
        }
    }
};
elma.fixResetButtons = function () {

    $('form').each(function (i, form) {
        $(form).find('input:hidden').each(function (i, a) {
            $(a).attr('oldValue', $(a).val());
        });
        $(form).find('input[type=reset]').each(function (j, a) {
            $(a).click(function () {
                $(form).find('input:hidden').each(function (k, h) {
                    var defaultValue = $(h).attr('oldValue');
                    if (!defaultValue || defaultValue == null || $.trim(defaultValue).length == 0)
                        $(h).removeAttr('value');
                    else
                        $(h).val(defaultValue);
                });
            });
        });
    });
};

elma.SelectTemplatesValues = function () {
    var btn = $("#documentUsed");
    var fileSelected = (btn.attr("checked") != "undefined" && btn.attr("checked") == "checked");
    var value, data;
    var number = $("#itemsDiv").children().length;
    var div;
    if (fileSelected) {
        var format = 'Entity.Templates[$i].File';
        var fileId = 'Templates_file_upload' + number;
        var name = 'Entity.Templates[' + number + '].File';
        var style = 'position: absolute; top: -3000px; ';

        var fileDivId = 'File_' + number;
        var fileDivText = '<div id="' + fileDivId + '"></div>';
        $("#itemsDiv").append(fileDivText);
        div = $("#" + fileDivId);

        var clone = $('#File_file-upload').clone();
        clone.attr('id', fileId);
        clone.attr('format', format);
        clone.attr('name', name);
        clone.attr('style', style);
        clone.appendTo(div);

        value = "File_" + number;
        data = $('#File_file-upload').attr('value');
    } else {
        var documentControl = $("#Document_Id-input");
        value = "Document_" + number;
        data = documentControl.val();

        var documentDivId = 'Document_' + number;
        var documentDivText = '<div id="' + documentDivId + '"></div>';
        $("#itemsDiv").append(documentDivText);
        div = $("#" + documentDivId);

        var docIdName = 'Entity.Templates[' + number + '].DocumentId';
        var docIdInput = '<input type="hidden" id="DocumentID_' + number + '" name="' + docIdName + '" value="' + $("#Document_Id").val() + '" >';
        div.append(docIdInput);
    }

    elma.AddNameProperty(div, data, number);
    elma.DeleteClearTemplatesDiv(); 
    elma.addEditableListItem(value, data, null,  null, "TemplatesList");
};

elma.AddNameProperty = function (div, data, number) {
    var name = 'Entity.Templates[' + number + '].Name';
    var input = '<input type="hidden" id="DocumentName_' + number + '" name="' + name + '" value="' + data + '" >';
    div.append(input);
    
};

elma.DeleteClearTemplatesDiv = function () {
    var elementToDelete = $('#Entity_Templates_0__DocumentId');
    if (elementToDelete != undefined) {
        elementToDelete.remove();
    }
};

elma.isJSON = function isJSON(data) {
    var isJson = false;
    try {
        var json = $.parseJSON(data);
        isJson = typeof json === 'object';
    } catch(ex) {
    }
    return isJson;
};

$(document).ready(function () {
    elma.bindAjaxForms();
    elma.bindPleaseWait();
    elma.fixResetButtons();
});


function createAndLoadWindow(id, options, url, postdata) {
    var win = createWindow(id, options);
    if (url) {
        refreshPopup(id, url, postdata);
    }
    else {
        win.open();
    }
}

function createWindow(id, options) {
    var tw = getWindow(id);
    if (tw) {
        if (options != undefined) {
            if (options.title) tw.title(options.title);
            if (options.content) tw.content(options.content);
            if (options.width) $("#" + id).find('> .t-window-content').css("width", options.width);
            tw.center();
        }
        return tw;
    }
    var settings = {
        title: null,
        modal: true,
        resizable: false,
        draggable: true,
        width: 400,
        onOpen: onWindowOpen,
        onClose: onWindowClose,
        onActivate: onWindowActivate,
        onRefresh: onWindowRefresh,
        element: null
    };
    settings = $.extend(settings, options);
    settings.element = settings.element || $('<div id="' + id + '" class="t-widget t-window" style="display:none"></div>').appendTo(document.body)[0];
    $.telerik.window.create(settings.element, settings);
    delete settings.title;
    delete settings.content;
    jQuery('#' + id).tWindow(settings);
    tw = getWindow(id);
    if (settings.onOpenScript)
        $(tw.element).data("onOpenScript", settings.onOpenScript);
    if (settings.onCloseScript)
        $(tw.element).data("onCloseScript", settings.onCloseScript);
    return tw;
}

function getWindow(id) {
    var win = null;
    if (typeof (id) == "string") {
        win = $("#" + id).data("tWindow");
        if (!win) {
            win = $("#" + id).parents(".t-window").data("tWindow");
        }
    } else if (typeof (id) == "object") {
        win = $(id).data("tWindow");
        if (!win) {
            win = $(id).parents(".t-window").data("tWindow");
        }
    }
    return win;
}
function openWindow(id, onOpenScript, onCloseScript, useReferrer, title, closeOnClick, closeOnEsc) {
    var win = getWindow(id);
    if (win != undefined) {
        if (title != null) {
            win.title(title);
        }

        if (closeOnClick) {
            var prefix = "";
            if (!onCloseScript) {
                onCloseScript = "";
            }
            else {
                prefix = ";";
            }
            onCloseScript = onCloseScript + prefix + "$('body > .t-overlay').unbind('click', BindCloseOnClick);";
        }
        if (closeOnEsc) {
            var prefix = "";
            if (!onCloseScript) {
                onCloseScript = "";
            }
            else {
                prefix = ";";
            }
            onCloseScript = onCloseScript + prefix + "$(document).unbind('keyup', BindCloseOnEsc);";
        }

        var scriptReferrer;
        var isOnOpenFunc = onOpenScript != undefined && typeof onOpenScript == "function";
        if (useReferrer) {
            scriptReferrer = isOnOpenFunc
                ? function () { windowSetReferrer(id + ''); }
                : "windowSetReferrer('" + id + "');";
        } else {
            scriptReferrer = isOnOpenFunc
                ? function () { }
                : "";
        }
        var onOpenFunc = isOnOpenFunc
            ? function () {
                scriptReferrer();
                onOpenScript.apply(this, arguments);
            }
            : scriptReferrer + onOpenScript;
        $(win.element).data("onOpenScript", onOpenFunc);
        $(win.element).data("onCloseScript", onCloseScript);
        win.open();

        if (closeOnClick) {
            $('body > .t-overlay').unbind('click', BindCloseOnClick);
            $('body > .t-overlay').bind('click', { id: id }, BindCloseOnClick);
        }
        if (closeOnClick) {
            $(document).unbind('keyup', BindCloseOnEsc);
            $(document).bind('keyup', { id: id }, BindCloseOnEsc);
        }
    }
    return win;
}

function windowSetReferrer(id) {
    var form = $("#" + id).find("form");
    if (form.length == 0) {
        form = $("#" + id).parent("form");
    }
    if (form.length != 0) {
        var referrerId = "ReturnUrl";
        var referrer = form.find("#" + referrerId);
        var params = parseGetParams();
        var urlReferrer = params.ReturnUrl != null && params.ReturnUrl != "" ? unescape(params.ReturnUrl) : document.referrer;
        if (referrer.length == 0) {
            form.append('<input type="hidden" id="' + referrerId + '" name="' + referrerId + '" value="' + urlReferrer + '" />');
        } else if (referrer.val() == null || referrer.val() == "") {
            referrer.val(urlReferrer);
        }
    }
}

function parseGetParams() {
    var $_GET = {};
    var __GET = window.location.search.substring(1).split("&");
    for (var i = 0; i < __GET.length; i++) {
        var getVar = __GET[i].split("=");
        $_GET[getVar[0]] = typeof (getVar[1]) == "undefined" ? "" : getVar[1];
    }
    return $_GET;
}

function currentWindowId(self) {
    return $(self).parents('.t-window')[0].id;
}

function closeWindow(id, loaded, data) {
    var win = getWindow(id);
    if (win != null) {
        var onCloseScript = $(win.element).data("onCloseScript");
        if (onCloseScript != null && onCloseScript != undefined && onCloseScript != "" && data != undefined) {
            $(win.element).data("onCloseData", data);
        }
        win.close();
        if (loaded != undefined) {
            win.loaded = loaded;
        }
    }
}

function closeActiveWindow()
{
    var activeWins = $('.t-window:visible');
    if (activeWins.length == 0)
        return;
    var maxZIndex = 0;
    var activeWin = null;
    activeWins.each(function (i, a) {
        var idx = parseInt($(a).css('z-index'));
        if (idx > maxZIndex) {
            maxZIndex = idx;
            activeWin = $(a);
        }
    });
    closeWindow(activeWin.attr('id'));
}

function onWindowOpen(e) {
    var win = getWindow(this);
    if (win.effects === $.fn.tWindow.defaults.effects) {
        win.effects = $.extend(win.effects);
        win.effects.list[0] = $.extend(win.effects.list[0], { center: true });
    }
    bindFiles("#" + $(this).get()[0].id);
    elma.bindAjaxForms();
    elma.fixResetButtons();
    elma.InitTranslation();
    bindButtons();
    var onOpenScript = $(win.element).data("onOpenScript");
    if (onOpenScript != null && onOpenScript != undefined && onOpenScript != "") {
        if (typeof (onOpenScript) == 'string') {
            eval(onOpenScript);
        }
        else {
            onOpenScript(win);
        }
    }
    $(win.element).find('> .t-window-content > .elma-window-content .elma-window-content-autosize').css("max-height", document.body.clientHeight * 2 / 3);
    //alert("Open:" + e);
}

function onWindowClose(e) {
    var win = getWindow(this);
    var data = $(win.element).data("onCloseData");
    $(win.element).data("onCloseData", null);
    var onCloseScript = $(win.element).data("onCloseScript");
    if (onCloseScript != null && onCloseScript != undefined && onCloseScript != "") {
        if (typeof(onCloseScript) == 'string') {
        eval(onCloseScript);
        } else if (typeof (onCloseScript) == 'function') {
            if (data != undefined) {
                onCloseScript(data, win);
            }
        }
    }
}

function onWindowActivate(e) {
    //alert("Activate:" + e);
}
function onWindowRefresh(e) {
    var root = $(this).get()[0];
    bindFiles("#" + root.id);
    elma.setDefaultInput(root);

    var autosize = $(root).find('> .t-window-content > .elma-window-content .elma-window-content-autosize');
    autosize.each(function (i, element) {
        $(element).scrollTop(0);
    });
}

function refreshPopup(id, contentUrl, postData, title, onOpenScript, onCloseScript, useReferrer, closeOnClick, closeOnEsc) {
    var win = getWindow(id);

    /*if (title != null) {
        win.title(title);
    }*/

    //if (contentUrl.substr(window.BaseUrl.length, 21) == "SDK.Action/Popup/View")
    if (!!contentUrl)
        win.contentUrl = contentUrl;
    //else
    //    win.contentUrl = window.BaseUrl + "SDK.Action/Popup/View?actionRoute=" + encodeURIComponent(contentUrl);
    win.loaded = false;
    if (!!postData)
        win.postData = postData;

    openWindow(id, onOpenScript, onCloseScript, useReferrer, title, closeOnClick, closeOnEsc);
}

function BindCloseOnClick(e) {
    closeWindow(e.data.id);
}

function BindCloseOnEsc(e) {
    if (e.keyCode === 27) {
        closeWindow(e.data.id);
    }
}

function resizeWindowContent(id) {
    if (id == null)
        return;
    var resizeElement = $("#" + id).find('> .t-window-content');
    if (resizeElement == null)
        return;
    var childrenHeight = 0;
    resizeElement.children().each(function () {
        childrenHeight += $(this).outerHeight(true);
    });
    resizeElement.css({ height: childrenHeight });
}
function getWindowId(child) {
    if ($(child).parents(".t-window").length > 0) {
        return $(child).parents(".t-window").get(0).id;
    }
    return null;
}


elma.bind = function (containerId) {
    if (containerId) {
        $('#' + containerId).find(".t-menu").tMenu();
        bindFiles('#' + containerId);
    }
    else {
        $(".t-menu").tMenu({ orientation: 'vertical', openOnClick: true, effects: { list: [{ name: 'slide'}], openDuration: 0, closeDuration: 0} });
        bindFiles("body");
    }
};
jQuery(document).ready(function () {
    bindPortlet();
    elma.bind();
    bindButtons();
    try {
        if (document.activeElement) {
            $(document.activeElement).trigger('focusin');
        }
    }
    catch (e) { }
});


function setupStartEndDateTime(start, end) {
    if (!start || !end || $("#" + start).length == 0 || $("#" + end).length)
        return;
    
}

function convertJSONDate(data) {
    if (data == null || typeof data == 'undefined')
        return null;
    if (typeof data == 'object') {
        return data;
    }
    if (typeof data == 'number') {
        var dt = new Date(data * 1000);
        return dt.toClientDateTimeFromBrowser();
    }
    if (typeof data == 'string' && data !== "") {
        var dt = new Date(parseInt(data.replace(/\/Date\((-?\d+)((\+|-)\d+)?\)\//, '$1')));
        return dt.toClientDateTimeFromBrowser();
    }
    return null;
}

function convertDateJSON(date) {
    if (date == null)
        return "";
    return "/Date(" + date.getTime() + ")/";
}

function removeValidateRules(id, entityId) {
    var isInput = false;
    if (!entityId)
        isInput = true;

    var input = isInput ? $("#" + id) : $("#" + entityId);
    var form = input.closest("form");

    if (form && form.length > 0) {
        if ($(form).data("validator")) {
            var inp = isInput ? input : $("#" + id + "_validate");
            var has = false;
            for (var i in inp.rules()) {
                has = true;
                break;
            }
            if (has) {
                inp[0].rules = inp.rules();
                inp.rules("remove");
            }
            return true;
        } else {
            setTimeout(function () {
                removeValidateRules(id, entityId);
            }, 500);
            return;
        }
    }
    return false;
}

function addValidateRules(id, entityId) {
    var isInput = false;
    if (!entityId)
        isInput = true;

    var input = isInput ? $("#" + id) : $("#" + entityId);
    var form = input.closest("form");

    if (form && form.length > 0) {
        if ($(form).data("validator")) {
            //var messages = $.data(form.get(0), "validator").settings.messages[id.replace(/_/g, ".")];
            var inp = isInput ? input : $("#" + id + "_validate");
            if (inp.length == 0 || inp[0] == null) 
                return false;
            for (rule in inp[0].rules) {
                var o = new Object();
                o[rule] = inp[0].rules[rule];
                inp.rules("add", o);
            }
            return true;
        } else {
            setTimeout(function () {
                addValidateRules(id, entityId);
            }, 500);
            return;
        }
    }
    return false;
}

function moveValidateRules(id, skipCheck, inputId) {
    if (!id)
        return;
    
    var input = $("#" + id),
        form = input.closest("form"),
        skip = !!skipCheck;

    var moveTo = inputId ? inputId + "_validate" : input.attr("moveTo") || (id + "_validate");

    if (form && form.length > 0 && (skip || input.hasClass("deleted"))) {
        if ($(form).data('validator')) {
            var rules = $("#" + id).rules();
            var idInput = form.find("#" + id);
            var originalName;
            if (idInput.length != 0) {
                originalName = idInput[0].name;
            }
            if (originalName == null) {
                originalName = id.replace(/_/g, '.');
            }
            var messages = $.data(form.get(0), 'validator').settings.messages[originalName];
            for (var rule in rules) {
                if (rule) {
                    var newRule = {};
                    newRule[rule] = {};
                    newRule.messages = {};
                    newRule.messages[rule] = messages[rule];
                    $("#" + moveTo).rules('add', newRule);
                }
            }
            $("#" + id + "_validationMessage").attr("id", moveTo + "_validationMessage");
            $("#" + id).rules("remove");

            var moveInput = form.find("#" + moveTo);
            var moveName;
            if (moveInput.length != 0) {
                moveName = moveInput[0].name;
            }
            if (moveName == null) {
                moveName = moveTo.replace(/_/g, '.');
            }

            var formId = form[0].id;
            if (formId && elma && elma.ValidationRulesManager) {
                var startupValidationItem = elma.ValidationRulesManager.getFormStartupValidation(formId);
                if (startupValidationItem && startupValidationItem.Fields) {
                    for (var i in startupValidationItem.Fields) {
                        var item = startupValidationItem.Fields[i];
                        if (item && item.FieldName == originalName) {
                            item.FieldName = moveName;
                            item.ValidationMessageId = moveTo + "_validationMessage";
                        }
                    }
                }
            }

        }
        if(!skip) $("#" + id).remove();
    }
}

function validHiddenInput($input) {
    if ($input == null || $input.length == 0) return;
    if ($input.hasClass('input-validation-error') || $input.hasClass('valid')) $input.valid();
}

elma.extractComboBox = function (a) {
    return $(a).data("tComboBox") || $(a).data("tDropDownList") || $(a).data("tAutoComplete");
};
elma.GetComboBox = function (id) {
    var a = '#' + id;
    return elma.extractComboBox(a);
};
elma.getDependenceInputVal = function (a) {
    var comboBox = elma.extractComboBox(a);
    if (comboBox) {
        return comboBox.value();
    } else {
        return $(a).val();
    }
};
elma.calcEnabled = function (inputsId) {
    var enabled = true;
    for (itemId in inputsId) {
        var val = elma.getDependenceInputVal('#' + inputsId[itemId]);
        if (!val) {
            enabled = false;
        }
    }
    return enabled;
};
elma.initQuery = function (tObj, name, value, inputsId) {
    tObj.extendData[name] = value;
    var jsonData = {};
    if (tObj.extendData['queryparams']) {
        jsonData = jQuery.parseJSON(tObj.extendData['queryparams']);
    }
    var curJsonData = jQuery.parseJSON('{"' + name + '" : "' + value + '"}');
    jsonData = jQuery.extend(true, jsonData, curJsonData);

    if (elma.calcEnabled(inputsId)) {
        tObj.enable();
    }
    else {
        tObj.disable();
    }
    tObj.extendData['queryparams'] = JSON.stringify(jsonData);
   
};
elma.doDependenceInput = function doDependenceInput() {
    if (!elma.DependenceInputs)
        return;
    jQuery.each(elma.DependenceInputs, (function (i, a) {
        if (!elma.DependenceInputs[i].initComplete) {
            var inputId = a.input;
            var inputsId = a.inputs;
            var paramnames = a.params;
            var input = $('#' + inputId);
            var tObj = elma.extractComboBox(input);
            if (tObj == null)
                return;
            if (elma.calcEnabled(inputsId)) {
                tObj.enable();
            }
            else {
                tObj.disable();
            }
            var index = 0;
            for (id in inputsId) {
                var a = $('#' + inputsId[id]);
                var comboBox = elma.extractComboBox(a);
                if (comboBox) {
                    elma.initQuery(tObj, paramnames && paramnames[index] ? paramnames[index] : $(comboBox.element).attr('name'), comboBox.value(), inputsId);
                    if (!elma.IsOnChangeBind(inputsId[id])) {
                        $(a).bind('valueChange', function (e) {
                            /*var idx = jQuery.inArray(e.target.name.replace(/\./g, '_'), inputsId);
                            var pname = paramnames && idx > -1 && paramnames[idx] ? paramnames[idx] : e.target.name;
                            var value = e.value;
                            elma.initQuery(tObj, pname, value, inputsId);
                            tObj.value(null);*/
                            var currentId = e.target.name.replace(/[.\[\]]/g, '_');
                            var childs = elma.GetChildsDependenceInputs(currentId);
                            var value = e.value;
                            var idx = jQuery.inArray(e.target.name.replace(/[.\[\]]/g, '_'), inputsId);
                            var pname = paramnames && idx > -1 && paramnames[idx] ? paramnames[idx] : e.target.name;
                            jQuery.each(childs, function (i, a) {
                                var ch = elma.extractComboBox('#' + a);
                                var dep = elma.GetDependence(a);
                                elma.initQuery(ch, pname, value, dep.inputs);
                                ch.value(null);
                                ch.previousText = '';
                                ch.clearSelect();
                            });
                        });
                        elma.DependenceInputOnChangeStatus.push({ inputId: inputsId[id], status: true });
                    }
                }
                else {
                    if ($(a).val()) {
                        var pname = paramnames && paramnames[index] ? paramnames[index] : $(a).attr('name');
                        elma.initQuery(tObj, pname, $(a).val(), inputsId);
                    }
                }
                index++;
            }
            elma.DependenceInputs[i].initComplete = true;
        }
    }));

};

function removeDependenceInputOnChangeStatus(inputId) {
    if (elma.DependenceInputOnChangeStatus) {

        var grepResult = jQuery.grep(elma.DependenceInputOnChangeStatus, function (elem) {
            return elem['inputId'];
        });
        if (grepResult) {
            for (var i = 0; i < grepResult.length; i++) {
                var value = grepResult[i];
                var index = $.inArray(value, elma.DependenceInputOnChangeStatus);
                if (index != -1) {
                    elma.DependenceInputOnChangeStatus.splice(index, 1);
                }
            }
        }
    }
}

elma.IsOnChangeBind = function (inputId) {
    if (!elma.DependenceInputOnChangeStatus)
        elma.DependenceInputOnChangeStatus = new Array();
    for (var i = 0; i < elma.DependenceInputOnChangeStatus.length; i++) {
        var elem = elma.DependenceInputOnChangeStatus[i];
        if (elem.inputId == inputId && elem.status)
            return true;
    }
    return false;
};

elma.GetDependence = function(inputId) {
    for (var i = 0; i < elma.DependenceInputs.length; i++) {
        if (elma.DependenceInputs[i].input == inputId)
            return elma.DependenceInputs[i];
    }
    return null;
};

elma.GetChildsDependenceInputs = function(inputId) {
    if (!elma.DependenceInputs)
        elma.DependenceInputs = new Array();
    var res = new Array();
    for (var i = 0; i < elma.DependenceInputs.length; i++) {
        var has = false;
        for (var j = 0; j < elma.DependenceInputs[i].inputs.length; j++) {
            if (elma.DependenceInputs[i].inputs[j] == inputId) {
                has = true;
                break;
            }
        }
        if (has) {
            res.push(elma.DependenceInputs[i].input);
        }
    }
    return res;
};

function removeDependenceInput(inputId, inputsId, paramnames) {
    if (elma.DependenceInputs) {
        
        var grepResult = jQuery.grep(elma.DependenceInputs, function (elem) {
            return elem['input'] == inputId && elem['inputs'].toString() == inputsId.toString() && elem['params'] == paramnames;
        });
        if (grepResult) {
            for (var i = 0; i < grepResult.length; i++) {
                var value = grepResult[i];
                var index = $.inArray(value, elma.DependenceInputs);
                if (index != -1) {
                    elma.DependenceInputs.splice(index, 1);
                }
            }
        }
    }
}

function ResetDependencies() {
    elma.DependenceInputs = new Array();
    elma.DependenceInputOnChangeStatus = new Array();
}

function setDependenceInput(inputId,inputsId, paramnames) {
    if (!elma.DependenceInputs)
        elma.DependenceInputs = new Array();
    if (!elma.DependenceInputOnChangeStatus)
        elma.DependenceInputOnChangeStatus = new Array();
    elma.DependenceInputs.push({ input: inputId, inputs: inputsId, params: paramnames, initComplete: false });
    elma.doDependenceInput();
}

elma.SetDateTimeDependenceInputs = function (startId, endId, withoutDistance) {
    if (!elma.DependenceDateTimeInputs)
        elma.DependenceDateTimeInputs = new Array();
    elma.DependenceDateTimeInputs.push({
        startId: startId,
        endId: endId, 
        distance: 0, 
        withoutDistance: withoutDistance,
        runtime: false 
    });
    elma.doSetDateTimeDependenceInputs();
};
elma.GetDateTimeDependence = function (id) {
    if (!elma.DependenceDateTimeInputs)
        return null;
    for (var i = 0; i < elma.DependenceDateTimeInputs.length; i++) {
        if (elma.DependenceDateTimeInputs[i].startId + '_date' == id
            || elma.DependenceDateTimeInputs[i].endId + '_date' == id
            || elma.DependenceDateTimeInputs[i].startId + '_time' == id
            || elma.DependenceDateTimeInputs[i].endId + '_time' == id
            || elma.DependenceDateTimeInputs[i].startId + '_damper' == id
            || elma.DependenceDateTimeInputs[i].endId + '_damper' == id) {
            return elma.DependenceDateTimeInputs[i];
        }
    }
};
elma.GetDateTimeDependenceInputs = function (a) {
    var inputs = { startDateInput: null, endDateInput: null, startTimeInput: null, endTimeInput: null };
    if ($('#' + a.startId + '_date').length > 0 && $('#' + a.startId + '_date').data('tDatePicker')) {
        inputs.startDateInput = $('#' + a.startId + '_date').data('tDatePicker');
    }
    if ($('#' + a.endId + '_date').length > 0 && $('#' + a.endId + '_date').data('tDatePicker')) {
        inputs.endDateInput = $('#' + a.endId + '_date').data('tDatePicker');
    }
    if ($('#' + a.startId + '_time').length > 0 && $('#' + a.startId + '_time').data('tTimePicker')) {
        inputs.startTimeInput = $('#' + a.startId + '_time').data('tTimePicker');
    }
    if ($('#' + a.endId + '_time').length > 0 && $('#' + a.endId + '_time').data('tTimePicker')) {
        inputs.endTimeInput = $('#' + a.endId + '_time').data('tTimePicker');
    }
    if ($('#' + a.startId + '_damper').length > 0 && $('#' + a.startId + '_damper')) {
        inputs.startDamperInput = $('#' + a.startId + '_damper');
    }
    if ($('#' + a.endId + '_damper').length > 0 && $('#' + a.endId + '_damper')) {
        inputs.endDamperInput = $('#' + a.endId + '_damper');
    }
    return inputs;
};
elma.resetDateTimeDependenceInputs = function (input) {
    if (!elma.DependenceDateTimeInputs)
        return;
    jQuery.each(elma.DependenceDateTimeInputs, function (i, a) {
        if (!a.runtime)
            return;
        var inputs = elma.GetDateTimeDependenceInputs(a);
        if (inputs.startDateInput && inputs.startDateInput.element == input || inputs.endDateInput && inputs.endDateInput.element == input || inputs.startTimeInput && inputs.startTimeInput.element == input || inputs.endTimeInput && inputs.endTimeInput.element == input) {
            a.runtime = false;
        }
    });
}
elma.removeDateTimeDependenceInputs = function (startId, endId) {
    if (!elma.DependenceDateTimeInputs)
        return;

    var i = elma.DependenceDateTimeInputs.length;
    while (i--) {
        var a = elma.DependenceDateTimeInputs[i];
        if (a && a.startId == startId && a.endId == endId) {
            elma.DependenceDateTimeInputs.splice(i, 1);
        }
    }
}
elma.doSetDateTimeDependenceInputs = function () {
    if (!elma.DependenceDateTimeInputs)
        return;
    jQuery.each(elma.DependenceDateTimeInputs, function (i, a) {
        if (a.runtime)
            return;
        var inputs = elma.GetDateTimeDependenceInputs(a);
        if (inputs.startDateInput && inputs.endDateInput) {
            var startDateTime = reciveDateTime(inputs.startDateInput.value(), inputs.startDamperInput, inputs.startTimeInput ? inputs.startTimeInput.value() : null);
            var endDateTime = reciveDateTime(inputs.endDateInput.value(), inputs.endDamperInput, inputs.endTimeInput ? inputs.endTimeInput.value() : null);

            if (a.withoutDistance) {
                if (inputs.endDateInput) {
                    if (startDateTime)
                        inputs.endDateInput.dateView.minValue = startDateTime;
                    else
                        inputs.endDateInput.dateView.minValue = inputs.endDateInput.minValue;
                }
                if (inputs.startDateInput) {
                    if (endDateTime)
                        inputs.startDateInput.dateView.maxValue = endDateTime;
                    else
                        inputs.startDateInput.dateView.maxValue = inputs.startDateInput.maxValue;
                }
                if (inputs.endTimeInput) {
                    setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime, inputs.endDateInput.minValue);
                }
                if (inputs.startTimeInput) {
                    setStartTimeMaxValue(inputs.startTimeInput, startDateTime, endDateTime, inputs.endTimeInput ? inputs.endTimeInput.value() : null, inputs.endDamperInput, inputs.startDateInput.maxValue);
                }
            }
            else {
                inputs.endDateInput.dateView.minValue = startDateTime;
                if (inputs.endTimeInput && startDateTime && endDateTime) {
                    setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime);
                }
                if (endDateTime && startDateTime)
                    a.distance = endDateTime - startDateTime;
            }
            a.runtime = true;

            elma.ValidationRulesManager.addRule(a.endId, 'add', { greaterThenDate: "#" + a.startId, messages: { greaterThenDate: SR.T("Срок завершения должен быть позже Даты начала")} });
        }

    });
};

elma.FillDay = function(pEntityYear, pEntityMonth, pEntityDay) {
    var birthdateYear = $('#' + pEntityYear).val();
    var birthdateMonth = $('#' + pEntityMonth).val();
    var birthdateDay = $('#' + pEntityDay).val();

    var isLeapYear = birthdateYear == '' || birthdateYear % 4 == 0;
    var monthDays = new Array(31, 31, isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
    var numDays = monthDays[birthdateMonth == '' ? 0 : birthdateMonth];

    if (birthdateDay > numDays)
        birthdateDay = numDays;

    var dataSource = [{ Text: '', Value: '' }];
    for (var i = 1; i <= numDays; i++) {
        dataSource.push({ Text: '' + i, Value: '' + i });
    }

    var entityDay = $('#' + pEntityDay).data('tDropDownList');
    entityDay.dataBind(dataSource);
    entityDay.value(birthdateDay);
};

function onLoadDatePicker(e) {
    elma.resetDateTimeDependenceInputs(e.currentTarget);
    elma.doSetDateTimeDependenceInputs();
}

function onLoadTimePicker(e) {
    elma.resetDateTimeDependenceInputs(e.currentTarget);
    elma.doSetDateTimeDependenceInputs();
}

function setStartTimeMaxValue(control, startDate, endDate, endTimeValue, endDamperCopntrol, maxValue) {
    if (endDate && (!startDate || startDate.getFullYear() == endDate.getFullYear() && startDate.getMonth() == endDate.getMonth() && startDate.getDate() == endDate.getDate()))
        if ((!endDamperCopntrol || endDamperCopntrol.is(':checked')) && endTimeValue)
            control.max(new Date(endDate).addMinutes(-15));
        else
            control.max(new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 24, 0, 0));
    else
        control.max(new Date(maxValue.getFullYear(), maxValue.getMonth(), maxValue.getDate(), 24, 0, 0));
}

function setEndTimeMinValue(control, startDate, endDate, minValue) {
    if (!startDate && !minValue)
        return;
    if (startDate && (!endDate || startDate.getFullYear() == endDate.getFullYear() && startDate.getMonth() == endDate.getMonth() && startDate.getDate() == endDate.getDate())) {
        control.min(new Date(startDate).addMinutes(15));
    } else {
        control.min(startDate
            ? new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), 0, 0, 0)
            : new Date(minValue.getFullYear(), minValue.getMonth(), minValue.getDate(), 0, 0, 0));
    }
}

function reciveDateTime(dateValue, damperInput, timeValue) {
    var dateTime = null;
    if (dateValue) {
        dateTime = new Date();
        dateTime.setTime(dateValue.getTime());
        if (damperInput && !damperInput.is(':checked') && damperInput.attr('time')) {
            var damperTime = Date.parse(damperInput.attr('time'));
            dateTime.set({
                hour: damperTime.getHours(),
                minute: damperTime.getMinutes(),
                second: damperTime.getSeconds()
            });
        } else if ((!damperInput || damperInput.is(':checked')) && timeValue) {
            dateTime.set({
                hour: timeValue.getHours(),
                minute: timeValue.getMinutes(),
                second: 0
            });
        } else {
            dateTime.set({
                hour: 0,
                minute: 0,
                second: 0
            });
        }
    }
    return dateTime;
}

function attributeOnChange(e, data) {
    var id = e.currentTarget.id;
    var onchange = $('#' + id).data(data).$wrapper.attr("onchange");
    if (onchange)
        eval(onchange);
}

function setDateTime(hiddenInput, date) {
    var idhidden = '#' + hiddenInput[0].id;
    var format = '';
    if (date != null) {
        if ($(idhidden + "_date").length) {
            format = $.telerik.cultureInfo.shortDate;
            $(idhidden + "_date").data("tDatePicker").value(date);
        }
        if ($(idhidden + "_time").length) {
            if (format != '') {
                format += ' ';
            }
            format += $.telerik.cultureInfo.shortTime;
            $(idhidden + "_time").data("tTimePicker").value(date);
        }

        $(idhidden).val($.telerik.formatString('{0:' + format + '}', date));

        var damperId = idhidden + '_damper';
        if ($(damperId).length) {
            var damperValue = $(damperId).is(':checked');
            if ((date.getHours() == 23 && date.getMinutes() == 59 && date.getSeconds() == 50)
                || (date.getHours() == 00 && date.getMinutes() == 00 && date.getSeconds() == 10)) {
                if (damperValue) {
                    $(damperId).prop('checked', false);
                    $(damperId).triggerHandler('click');
                }
            } else {
                if (!damperValue) {
                    $(damperId).prop('checked', true);
                    $(damperId).triggerHandler('click');
                }
            }
        }
    }
}

function getDateTime(input) {
    return new Date(Date.parse(input[0].value));
}

function onChangeDatePicker(e) {
    if (elma.DependenceDateTimeInputs && !e.sender) {
        var a = elma.GetDateTimeDependence(e.target.id);
        if (a != null) {
            var inputs = elma.GetDateTimeDependenceInputs(a);
            var isStartDate = a.startId + '_date' == e.target.id;
            var isEndDate = a.endId + '_date' == e.target.id;

            var startDateTime = reciveDateTime(isStartDate ? e.value : inputs.startDateInput.value(), inputs.startDamperInput, inputs.startTimeInput ? inputs.startTimeInput.value() : null);
            var endDateTime = reciveDateTime(isEndDate ? e.value : inputs.endDateInput.value(), inputs.endDamperInput, inputs.endTimeInput ? inputs.endTimeInput.value() : null);

            if (a.withoutDistance) {
                if (startDateTime && endDateTime && startDateTime > endDateTime)
                    return false;
                if (isStartDate && inputs.endDateInput) {
                    if (startDateTime)
                        inputs.endDateInput.dateView.minValue = startDateTime;
                    else
                        inputs.endDateInput.dateView.minValue = inputs.endDateInput.minValue;
                }
                if (isEndDate && inputs.startDateInput) {
                    if (endDateTime)
                        inputs.startDateInput.dateView.maxValue = endDateTime;
                    else
                        inputs.startDateInput.dateView.maxValue = inputs.startDateInput.maxValue;
                }
                if (isStartDate) {
                    if (inputs.startTimeInput) {
                        setStartTimeMaxValue(inputs.startTimeInput, startDateTime, endDateTime, inputs.endTimeInput, inputs.endDamperInput, inputs.startDateInput.maxValue);
                    }
                    if (inputs.endTimeInput && (startDateTime <= endDateTime || !inputs.endTimeInput.value())) {
                        setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime, inputs.endDateInput.minValue);
                    }
                }
                if (isEndDate) {
                    if (inputs.endTimeInput) {
                        setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime, inputs.endDateInput.minValue);
                    }
                    if (inputs.startTimeInput && (startDateTime <= endDateTime || !inputs.endTimeInput.value())) {
                        setStartTimeMaxValue(inputs.startTimeInput, startDateTime, endDateTime, inputs.endTimeInput, inputs.endDamperInput, inputs.startDateInput.maxValue);
                    }
                }
            }
            else {
                if (isEndDate && endDateTime && startDateTime) {
                    var distance = (endDateTime.getTime() - startDateTime.getTime());
                    if (distance > 0)
                        a.distance = distance;
                    else
                        a.distance = 0;

                }
                if (isStartDate && startDateTime && inputs.endDateInput) {
                    inputs.endDateInput.minValue = startDateTime;
                    inputs.endDateInput.dateView.minValue = startDateTime;
                    var newDateEnd = new Date();
                    newDateEnd.setTime(startDateTime.getTime());
                    if (a.distance > 0) {
                        newDateEnd.addMilliseconds(a.distance);
                    } else {
                        newDateEnd.addMinutes(15);
                    }
                    inputs.endDateInput.value(newDateEnd);
                    triggerOnChangeDateTimePicker(inputs.endDateInput, a);
                    if ((!inputs.endDamperInput || inputs.endDamperInput.is(':checked')) && inputs.endTimeInput) {
                        $("#" + a.endId).val($.telerik.formatString('{0:' + $.telerik.cultureInfo.shortDate + '}', newDateEnd) + ' ' + $.telerik.formatString('{0:' + $.telerik.cultureInfo.shortTime + '}', newDateEnd));
                        setEndTimeMinValue(inputs.endTimeInput, startDateTime, newDateEnd);
                        inputs.endTimeInput.value(newDateEnd);
                    } else {
                        $("#" + a.endId).val($.telerik.formatString('{0:' + $.telerik.cultureInfo.shortDate + '}', newDateEnd) + (inputs.endDamperInput && inputs.endDamperInput.attr('time') ? ' ' + inputs.endDamperInput.attr('time') : ''));
                    }
                    endDateTime = newDateEnd;
                    validHiddenInput($('#' + a.endId));
                }
                if (inputs.endTimeInput) {
                    setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime);
                }
            }
        }
    }
    var idhidden = '#' + e.currentTarget.id.substring(0, e.currentTarget.id.length - 5);
    if ($(idhidden)) {
        var text = "";
        var val = e.value;
        if (!!val) {
            text = $.telerik.formatString('{0:' + $.telerik.cultureInfo.shortDate + '}', val);
            if ($(idhidden + "_time").length) {
                var damper = $(idhidden + "_damper");
                if (damper.length == 1 && !damper.is(':checked'))
                    text = text + (damper.attr('time') ? ' ' + damper.attr('time') : '');
                else
                    text = text + ' ' + $(idhidden + "_time").val();
            }
        } else if ($(idhidden + "_time").length) {
            $(idhidden + "_time").data('tTimePicker').value(null);
        }
        $(idhidden).trigger('change');
        $(idhidden).val(text);
        validHiddenInput($(idhidden));
    }
    attributeOnChange(e, 'tDatePicker');
}

function triggerOnChangeDateTimePicker(element, sender) {
    var event = jQuery.Event("valueChange");
    event.value = element.value();
    event.sender = sender;
    $(element.element).trigger(event);
}

function onChangeTimePicker(e) {
    if (elma.DependenceDateTimeInputs && !e.sender) {
        var a = elma.GetDateTimeDependence(e.target.id);
        if (a != null) {
            var inputs = elma.GetDateTimeDependenceInputs(a);
            var isStartTime = a.startId + '_time' == e.target.id;
            var isEndTime = a.endId + '_time' == e.target.id;

            var startTime = isStartTime ? e.value : inputs.startTimeInput ? inputs.startTimeInput.value() : null;
            var endTime = isEndTime ? e.value : inputs.endTimeInput ? inputs.endTimeInput.value() : null;

            var startDateTime = inputs.startDateInput == null
                ? startTime
                : reciveDateTime(inputs.startDateInput.value(), inputs.startDamperInput, startTime);
            var endDateTime = inputs.endDateInput == null
                ? endTime
                : reciveDateTime(inputs.endDateInput.value(), inputs.endDamperInput, endTime);

            if (e.value != null && e.value != undefined && e.value != "" && (isStartTime && !startDateTime || isEndTime && !endDateTime)) {
                var date = new Date();
                date.set({
                    hour: e.value.getHours(),
                    minute: e.value.getMinutes(),
                    second: 0
                });
                if (isStartTime) {
                    if (endDateTime && date >= endDateTime)
                        date.addDays(-1);
                    startDateTime = date;
                    inputs.startDateInput.value(startDateTime);
                    triggerOnChangeDateTimePicker(inputs.startDateInput, a);
                }
                if (isEndTime) {
                    if (startDateTime && startDateTime >= date)
                        date.addDays(1);
                    endDateTime = date;
                    inputs.endDateInput.value(endDateTime);
                    triggerOnChangeDateTimePicker(inputs.endDateInput, a);
                }
            }

            if (a.withoutDistance) {
                if (isStartTime) {
                    if (inputs.startTimeInput) {
                        setStartTimeMaxValue(inputs.startTimeInput, startDateTime, endDateTime, isEndTime ? e.value : inputs.endTimeInput ? inputs.endTimeInput.value() : null, inputs.endDamperInput, inputs.startDateInput != null ? inputs.startDateInput.maxValue : startDateTime);
                    }
                    if (inputs.endTimeInput && (startDateTime <= endDateTime || !inputs.endTimeInput.value())) {
                        setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime, inputs.endDateInput != null ? inputs.endDateInput.minValue : endDateTime);
                    }
                }
                if (isEndTime) {
                    if (inputs.endTimeInput) {
                        setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime, inputs.endDateInput != null ? inputs.endDateInput.minValue : endDateTime);
                    }
                    if (inputs.startTimeInput && (startDateTime <= endDateTime || !e.value)) {
                        setStartTimeMaxValue(inputs.startTimeInput, startDateTime, endDateTime, isEndTime ? e.value : inputs.endTimeInput ? inputs.endTimeInput.value() : null, inputs.endDamperInput, inputs.startDateInput != null ? inputs.startDateInput.maxValue : startDateTime);
                    }
                }
            }
            else {
                if ((isEndTime || isStartTime && inputs.endDamperInput && !inputs.endDamperInput.is(':checked')) && endDateTime && startDateTime) {
                    var distance = endDateTime.getTime() - startDateTime.getTime();
                    if (distance > 0)
                        a.distance = distance;
                    else
                        a.distance = 0;
                }
                if (isStartTime && startDateTime && inputs.endDateInput && (!inputs.endDamperInput || inputs.endDamperInput.is(':checked'))) {
                    inputs.endDateInput.minValue = startDateTime;
                    inputs.endDateInput.dateView.minValue = startDateTime;
                    var newDateEnd = new Date();
                    newDateEnd.setTime(startDateTime.getTime());
                    if (a.distance > 0) {
                        newDateEnd.addMilliseconds(a.distance);
                    } else {
                        newDateEnd.addMinutes(15);
                    }
                    inputs.endDateInput.value(newDateEnd);
                    triggerOnChangeDateTimePicker(inputs.endDateInput, a);
                    $("#" + a.endId).val($.telerik.formatString('{0:' + $.telerik.cultureInfo.shortDate + '}', newDateEnd) + ' ' + $.telerik.formatString('{0:' + $.telerik.cultureInfo.shortTime + '}', newDateEnd));
                    if (inputs.endTimeInput) {
                        setEndTimeMinValue(inputs.endTimeInput, startDateTime, newDateEnd);
                        inputs.endTimeInput.value(newDateEnd);
                    }
                    endDateTime = newDateEnd;
                    validHiddenInput($('#' + a.endId));
                }
                if (inputs.endTimeInput) {
                    setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime);
                }
            }
        }
    }
    var idhidden = '#' + e.currentTarget.id.substring(0, e.currentTarget.id.length - 5);
    if ($(idhidden)) {
        var text = '';
        var val = e.value;
        if (!!val) {
            if ($(idhidden + "_date").length) {
                var date = $(idhidden + "_date");
                text = date.val();
                if (!text.length) {
                    date.data('tDatePicker').value(new Date());
                    text = date.val();
                }
            }
            var damper = $(idhidden + "_damper");
            if (damper.length == 1 && !damper.is(':checked'))
                text = text + (damper.attr('time') ? ' ' + damper.attr('time') : '');
            else
                text = text + ' ' + $.telerik.formatString('{0:' + $.telerik.cultureInfo.shortTime + '}', val);
        } else if ($(idhidden + "_date").length)
            text = $(idhidden + "_date").val();
        $(idhidden).trigger('change');
        $(idhidden).val(text);
        validHiddenInput($(idhidden));
    }
    attributeOnChange(e, 'tTimePicker');
}

function onChangeDamper(chkbox) {
    var baseid = chkbox.id.substring(0, chkbox.id.length - 7);
    elma.display(baseid + '_timeDiv', chkbox.checked);
    var idtime = baseid + '_time';
    if (elma.DependenceDateTimeInputs) {
        var a = elma.GetDateTimeDependence(idtime);
        if (a != null) {
            var inputs = elma.GetDateTimeDependenceInputs(a);

            var startDateTime = reciveDateTime(inputs.startDateInput.value(), inputs.startDamperInput, inputs.startTimeInput ? inputs.startTimeInput.value() : null);
            var endDateTime = reciveDateTime(inputs.endDateInput.value(), inputs.endDamperInput, inputs.endTimeInput ? inputs.endTimeInput.value() : null);

            if (a.withoutDistance) {
                if (inputs.endTimeInput) {
                    setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime, inputs.endDateInput.minValue);
                }
                if (inputs.startTimeInput && (startDateTime <= endDateTime || !inputs.endTimeInput.value())) {
                    setStartTimeMaxValue(inputs.startTimeInput, startDateTime, endDateTime, inputs.endTimeInput ? inputs.endTimeInput.value() : null, inputs.endDamperInput, inputs.startDateInput.maxValue);
                }
            }
            else {
                if (endDateTime && startDateTime) {
                    var distance = endDateTime.getTime() - startDateTime.getTime();
                    if (distance > 0)
                        a.distance = distance;
                    else
                        a.distance = 0;
                }
                if (inputs.endTimeInput) {
                    setEndTimeMinValue(inputs.endTimeInput, startDateTime, endDateTime);
                }
            }
        }
    }
    var idhidden = '#' + baseid;
    if ($(idhidden)) {
        var text = $(idhidden + "_date").val();
        if (text != '') {
            if (!chkbox.checked)
                text = text + ($(chkbox).attr('time') ? ' ' + $(chkbox).attr('time') : '');
            else
                text = text + ' ' + $(idhidden + "_time").val();
        }
            
        $(idhidden).trigger('change');
        $(idhidden).val(text);
        validHiddenInput($(idhidden));
    }

    setCustomTimeZoneToDamper(baseid);
}

function setCustomTimeZoneToDamper(id, offset, remove)
{
    var div = $("#" + id + "_customTimeZoneDiv");
    if (div.length == 0)
        return;

    if (offset == null && (remove == null || !remove))
    {
        var strOffset = div.attr("offset");
        if (strOffset != "" && strOffset != null)
        {
            offset = parseInt(strOffset);
        }
    }

    div.attr("offset", offset);

    if (offset == null) {
        div.hide();
        return;
    }

    var chkbox = $("#" + id + "_damper");
    if (!chkbox.is(':checked')) {
        div.hide();
        return;
    }

    var userTimeZoneOffset = elma.timeZone.getUserOffset();

    var hasTime = $("#" + id + "_time").val();
    hasTime = hasTime != null && hasTime != "";

    if (offset == userTimeZoneOffset || !hasTime)
    {
        div.hide();
        return;
    }

    var dateControl = new Date(getDateTime($("#" + id)));
    var dateTime = (new Date(dateControl)).toBrowserDateTimeFromClient();
    var userDateTime = (new Date(dateTime)).toClientDateTimeFromBrowser(offset);

    var strDateTime = (dateControl.getDate() == userDateTime.getDate() ? "" : $.telerik.datetime.format(userDateTime, $.telerik.cultureInfo.shortDate) + " ") + $.telerik.datetime.format(userDateTime, $.telerik.cultureInfo.shortTime);
    div.html("<span class='note'>" + strDateTime + "</span>");
    div.show();
}

function onCloseTimePicker(e) {
}

function onCloseDatePicker(e) {
}

//Base combobox function
function defaultOnLoadComboBox(e) {
    elma.doDependenceInput();

    var combobox = $(e.currentTarget).data("tComboBox");
    elma.qtip(combobox.xElement, SR.T("Очистить поле"));
    elma.qtip(combobox.editElement, SR.T("Редактировать поле"));
}

function defaultOnChangeComboBox(e) {
    var id = e.currentTarget.id;
    var tComboBox = $(e.currentTarget).data("tComboBox");
    if (e.value == "") {
        tComboBox.selectedValue = "";
        $("#" + id).val("");
        $("." + id + "_json").val("");
        tComboBox.$wrapper.parents('table.t-entity-input-table').addClass("t-entity-input-empty");
    } else {
        var value = { Value: tComboBox.value(), Text: tComboBox.text(), ViewText: tComboBox.text(), Meta: {} };
        $("." + id + "_json").val($.toJSON(value));
        tComboBox.$wrapper.parents('table.t-entity-input-table').removeClass("t-entity-input-empty");
        tComboBox.xElement.show();
    }
    validHiddenInput($("." + id + "_json"));
}

function defaultDeleteOnClickComboBox(id) {
    var combobox = $('#' + id).data('tComboBox');
    if (combobox.dropDown.isOpened()) {
        combobox.trigger.close();
    }
    combobox.clearSelect();
    combobox.trigger.change();
    combobox.$text.focus();
}

//Combobox template mode function
function defaultOnLoadComboBoxTemplateMode(e) {
    var combobox = $(e.currentTarget).data("tComboBox");

    combobox.templateWrapper.show();
    combobox.templateWrapper
        .bind('click', function () { combobox.$text.focus(); })
        .mouseenter(function () { combobox.$wrapper.find('div:first-child').addClass('t-input-hover'); })
        .mouseleave(function () { combobox.$wrapper.find('div:first-child').removeClass('t-input-hover'); });

    if (combobox.editElement.length) {
        combobox.$wrapper.find('div:first-child')
            .mouseover(function() {
                if (!combobox.$text.is(':focus') && combobox.$element.val() != '') {
                    combobox.templateWrapper.addClass("combobox-template-wrapper-hover");
                    combobox.editElement.show();
                }
            })
            .mouseleave(function () {
                combobox.templateWrapper.removeClass("combobox-template-wrapper-hover");
                combobox.editElement.hide();
            });
    }

    combobox.$text
        .focusout(function () {
            if (combobox.$element.val() && combobox.templateWrapper.length) {
                combobox.templateWrapper.show();
            }
            combobox.$text.val('');

        })
        .focusin(function () {
            combobox.templateWrapper.hide();
            combobox.editElement.hide();
            combobox.templateWrapper.removeClass("combobox-template-wrapper-hover");
            if (combobox.$element.val()) {
                if (combobox.previousText != undefined && combobox.previousText != '') {
                    combobox.text(combobox.previousText);
                } else {
                    combobox.text(combobox.$wrapper.find('.combobox-template-text-element').text());
                }
                combobox.previousText = combobox.text;
            }
        });
}

function defaultEditOnClickComboBoxTemplateMode(id) {
    var combobox = $('#' + id).data('tComboBox');
    combobox.$text.focus();
}
//End combobox template mode function

function onHiddenInputChange(e) {
    validHiddenInput($(e.currentTarget));
}

function attributeOnChangeComboBox(e) {
    var id = e.currentTarget.id;
    var onchange = $('#' + id).get(0).getAttribute("onchange");
    if (onchange)
        eval(onchange);
}

function openEntitySelectPopup(id, url, prefix, aditionalPostData) {
    var jsonStr = $("." + id + "_json").val();
    var values = jsonStr != undefined && jsonStr != "" ? $.evalJSON(jsonStr) : new Array();
    if (!$.isArray(values)) values = [values];
    var postArray = new Array();
    for (var i = 0; i < values.length; i++) {
        postArray.push({ Value: values[i].Value, Text: values[i].Text });
    }
    var postData = { selected: $.toJSON(postArray) };
    if (aditionalPostData) {
        var apd = $.deparam(aditionalPostData, true);
        $.extend(postData, apd);
    }
    refreshPopup((prefix ? prefix : "EntityPopup") + id, url, postData);
    var combobox = $('#' + id).data("tComboBox");
    
    if (combobox) {
        if (combobox.isNativeComponent) {
            combobox.reload();
        } else {
            combobox.reload(function () { combobox.text(''); });
        }
    } 
}

function clearEntitySelector(id) {
    var combobox = elma.GetComboBox(id);
    if (!combobox) return;
    if (combobox.multiSelect) {
        var selector = elma.EntitySelector.Manager.get(id);
        selector.clearSelected();
    } else if (combobox.value() != '') {
        var previousValue = combobox.previousValue;
        combobox.previousValue = previousValue;
        combobox.clearSelect();
        combobox.trigger.change();
    }
}

function openCreateEntityPopup(value, addparams) {
    var params = value.split(":");
    refreshPopup(params[0], params[1], addparams, params[2]);
}

function createEntityCallback(data) {
    if (data) {
        if (data.error && data.error != '') {
            jAlert(data.error, SR.T("Ошибка"));
            return;
        }
        if (data.information && data.information != '') {
            elma.showMessageInformation(data.information);
        }
        var val = String(data.id);
        var combobox = $('#' + data.containerId).find('#' + data.inputId).data("tComboBox");
        combobox.reloadSelect(val);
        closeWindow(data.popupId);
        if (data.previosPopupId && data.previosPopupId != '') {
            closeWindow(data.previosPopupId);
        }
    }
}

function selectEntityInPopup(id, multiSelect) {
    var sv = $('#EntitySelector' + id + 'SelectedList').val();
    if(!!!multiSelect) {
    }
}

function onMultiSelectChange(e, comboNamePrefix, comboNameSuffix) {
    var needRender = true;
    var lastArrayNumber = 0;
    var id = e.currentTarget.id;
    var lastElement;
    $("." + e.currentTarget.id).each(function () {
        if ($(this).find("input[type='hidden']").val() == e.value) {
            needRender = false;
            $("#" + id).find("input").val("");
            return;
        }
        else {
            lastArrayNumber = parseInt($(this).data("arrayNumber")) + 1;
            lastElement = $(this);
        }
    });
    if (needRender) {

        var ds = $("#" + id).data("tComboBox").data;
        var text = "";
        var value = e.value;
        if (ds != undefined && ds.length != undefined) {
            for (var i = 0; i < ds.length; i++) {
                if (ds[i].Value == value) {
                    text = ds[i].Text;

                    var maxLength = 50;
                    var endLength = 12;
                    if (ds[i].Text.length > maxLength) {
                        ds[i].Text = ds[i].Text.substring(0, 20) + '...' + ds[i].Text.substring(ds[i].Text.length - endLength);
                    }

                    var defaultTemplate = (ds[i].EntityUrl === undefined || ds[i].EntityUrl == null || ds[i].EntityUrl == '') ? '<div style="float:left;">{item.Text}</div>' : '<a href=\"{item.EntityUrl}\" target=\"_blank\">{item.Text}</a>';
                    var selector = elma.EntitySelector.Manager.get(id);
                    var itemFormat = (selector && !!selector.initConfig && !!selector.initConfig.itemFormat) ? selector.initConfig.itemFormat : defaultTemplate;
                    var itemHtml = elma.repString(itemFormat, 'item', ds[i]);
                    
                    var element = $("<div></div>").attr("style", "float: left; padding: 2px 15px 0px 2px;").attr("id", "div-" + comboNamePrefix.replace(/\./g, '_') + "-" + lastArrayNumber).attr("class", id).data("arrayNumber", lastArrayNumber).data("modelId", id);
                    var valueElement = $(itemHtml);
                    var xElement = $("<div></div>")
                        .attr("style", "position: relative; float:right; top: 0; right: 0; width: 16px; height: 16px;")
                        .attr("class", "delete_middle")
                        .click(function () {
                            var pn = this.parentNode;
                             if ($('#ClearListPopup').length) {
                                 if (!$.event.props['clientResponse']) {
                                     $.event.props.push('clientResponse');
                                 } else {
                                     $.event.props['clientResponse'] = -1;
                                 }
                                 refreshPopup('ClearListPopup', null, null, SR.T("Удаление из списка"), elma.ClearListControl.Init("выбранный элемент из списка"), function () {
                                    if ($.event.props['clientResponse'] == 0) {
                                        onClearItem(pn, comboNamePrefix, comboNameSuffix, true);
                                    } else if ($.event.props['clientResponse'] == 1) {
                                        onClearInputList(pn, comboNamePrefix, comboNameSuffix, true);
                                    }
                                });
                            } else {
                                jConfirm(SR.T("Удалить выбранный элемент из списка?"), SR.T("Удаление из списка"), function (r) { if (r) { onClearItem(pn, comboNamePrefix, comboNameSuffix, true); } });
                            }
                        });
                    elma.qtip(xElement, SR.T("Удалить из списка"));
                    var inputElement = $("<input/>").attr("type", "hidden").val(value).attr("name", comboNamePrefix + "[" + lastArrayNumber + "]" + comboNameSuffix);
                    element.append(valueElement);
                    element.append(xElement);
                    element.append(inputElement);
                    if (lastElement != undefined)
                        lastElement.after(element);
                    else {
                        $("#div-" + id).append(element);
                    }
                    elma.initQTip("#div-" + id + " [tooltiptext]");
                    var jsonStr = $("." + id + "_json").val();
                    var values = jsonStr != undefined && jsonStr != "" ? $.evalJSON(jsonStr) : new Array();
                    if (!$.isArray(values)) values = [values];
                    values.push({ Value: value, Text: text });
                    $("." + id + "_json").val($.toJSON(values));
                }
            }
        }
        $("#" + id).find("input").val("");
        validHiddenInput($("." + id + "_json"));
        onHiddenInputChange(e);

        var selector = elma.EntitySelector.Manager.get(id);
        if (selector) {
            selector.afterChange();
        }
    }
}

//function addSelectedItem(comboNamePrefix, comboNameSuffix, text, value, currentTarget, inputId, item) {
//    var lastArrayNumber = 0;
//    var id = inputId;
//    var needRender = true;
//    var functionId = inputId.replace(/\_/g, 'x');
//    var lastElement;
//    $("." + id).each(function () {
//        if ($(this).find("input[type='hidden']").val() == value) {
//            needRender = false;
//            $("#" + id).find("input").val("");
//            return;
//        }
//        else {
//            lastArrayNumber = parseInt($(this).data("arrayNumber")) + 1;
//            lastElement = $(this);
//        }
//    });
    
//    var maxLength = 50;
//    var endLength = 12;
//    if (text.length > maxLength) {
//        text = text.substring(0, 20) + '...' + text.substring(text.length - endLength);
//    }

//    var selector = elma.EntitySelector.Manager.get(id);
//    var itemFormat = (selector && !!selector.initConfig && !!selector.initConfig.itemFormat) ? selector.initConfig.itemFormat : '<div style="float:left;">{text}</div>';
//    var itemHtml = (selector && !!selector.initConfig && !!selector.initConfig.itemFormat) ? elma.repString(itemFormat, 'item', item) : elma.repString(itemFormat, 'text', text);

//    var element = $("<div></div>").attr("style", "float: left; padding: 2px 15px 0px 2px;").attr("id", "div-" + comboNamePrefix.replace(/\./g, '_') + "-" + lastArrayNumber).attr("class", id).data("arrayNumber", lastArrayNumber).data("modelId", id);
//    var valueElement = $(itemHtml);
//    var xElement = $("<div></div>").attr("style", "position: relative; float:right; top: 0; right: 0; width: 16px; height: 16px;").attr("class", "delete_middle").click(function () {var pn = this.parentNode; jConfirm(SR.T("Удалить выбранный элемент из списка?"), SR.T("Удаление из списка"), function(r) {if (r) {$(pn).remove();/*onClearItem(pn, comboNamePrefix, comboNameSuffix, true);*/}});});
//    elma.qtip(xElement, SR.T("Удалить из списка"));
//    var inputElement = $("<input/>").attr("type", "hidden").val(value).attr("name", comboNamePrefix + "[" + lastArrayNumber + "]" + comboNameSuffix);
//    var textElement = $("<input/>").attr("type", "hidden").val(text).attr("id", functionId + '_' + value + '-titleInput');
//    element.append(valueElement);
//    element.append(xElement);
//    element.append(inputElement);
//    element.append(textElement);
//    if (lastElement != undefined)
//        lastElement.after(element);
//    else {
//        $("#div-" + id).append(element);
//    }
//    elma.initQTip("#div-" + id + " [tooltiptext]");
//    var jsonStr = $("." + id + "_json").val();
//    var values = jsonStr != undefined && jsonStr != "" ? $.evalJSON(jsonStr) : new Array();
//    if (!$.isArray(values)) values = [values];
//    values.push({ Value: value, Text: text });
//    $("." + id + "_json").val($.toJSON(values));
//}

function onClearItem(div, comboNamePrefix, comboNameSuffix, raiseEvent) {
    var i = $(div).data("arrayNumber");
    var modelId = $(div).data("modelId");
    var j = i;
    $("." + $(div).attr("class")).each(function() {
        if ($(this).data("arrayNumber") > i) {
            $(this).attr("id", "div-" + comboNamePrefix.replace(/\./g, '_') + "-" + j);
            $(this).data("arrayNumber", j);
            $(this).find("input[type='hidden'][name]").attr("name", comboNamePrefix + "[" + j + "]" + comboNameSuffix);
            j++;
        }
    });
    var jsonStr = $("." + $(div).attr('class') + "_json").val();
    var delId = $("input[type=hidden]", $(div)).val();
    if (delId && delId != "" && jsonStr && jsonStr != "") {
        var values = $.evalJSON(jsonStr);
        if (!$.isArray(values)) values = [values];
        var index = null;
        for (var i = 0; i < values.length; i++) {
            if (values[i].Value == delId) {
                index = i;
                break;
            }
        }
        if (index != null)
            values.splice(index, 1);
        $("." + $(div).attr('class') + "_json").val((values.length > 0 ? $.toJSON(values) : ""));
    }
    $(div).remove();
    
    if(!!raiseEvent && !!modelId) {
        var selector = elma.EntitySelector.Manager.get(modelId);
        if(!!selector) {
            selector.removeItem(delId);
        }
    }

    if (!!modelId) {
        var selector = elma.EntitySelector.Manager.get(modelId);
        if (selector) {
            selector.afterChange();
            validHiddenInput($("." + modelId + "_json"));
        }
    }
}

function onClearInputList(pn, comboNamePrefix, comboNameSuffix, raiseEvent) {
    var parentElement = $(pn).parent();
    $(parentElement).children().each(function (_, item) {
        onClearItem(item, comboNamePrefix, comboNameSuffix, raiseEvent);
    });
}

function ClearAutoCompleteItems(id) {
    $("#div-" + id).find("[id^='div-']").remove();
    $("." + id + "_json").val("");
}

function resetAutocompleteComboBox(id) {
    clearEntitySelector(id);
    validHiddenInput($("." + id + "_json"));
}

function onTimeSpanElementChanged(e) {
    var lastPointIndex = e.currentTarget.id.lastIndexOf("_");
    var idhidden = '#' + e.currentTarget.id.substring(0, lastPointIndex);
    if ($(idhidden)) {
        var idcurrent = '#' + e.currentTarget.id;
        var idDays = idhidden + '_days';
        var idHours = idhidden + '_hours';
        var idMinutes = idhidden + '_minutes';
        var vDays = idcurrent == idDays ? e.newValue : $(idDays).val();
        var vHours = idcurrent == idHours ? e.newValue : $(idHours).val();
        var vMinutes = idcurrent == idMinutes ? e.newValue : $(idMinutes).val();
        if (!vDays && !vHours && !vMinutes) {
            $(idhidden).val('');
        } else {
            var timeSpan =
                (vDays ? parseInt(vDays) : 0).toString() + '.' +
                (vHours ? parseInt(vHours) : 0).toString() + ':' +
                (vMinutes ? parseInt(vMinutes) : 0).toString();
            $(idhidden).val(timeSpan);
        }
        validHiddenInput($(idhidden));
    }
}

function onWorkTimeElementChanged(e) {
    var lastPointIndex = e.currentTarget.id.lastIndexOf("_");
    var idhidden = '#' + e.currentTarget.id.substring(0, lastPointIndex);
    if ($(idhidden)) {
        var idcurrent = '#' + e.currentTarget.id;
        var idHours = idhidden + '_hours';
        var idMinutes = idhidden + '_minutes';

        var vHours = idcurrent == idHours ? e.value : $(idHours).val();
        var vMinutes = idcurrent == idMinutes ? e.value : $(idMinutes).val();
        if (!vHours && !vMinutes) {
            $(idhidden).val('');
        } else {
            var timeSpan = ((vHours ? parseInt(vHours) : 0) * 60 + (vMinutes ? parseInt(vMinutes) : 0)).toString();
            if (timeSpan == 0) {
                $(idhidden).val('');
            }
            else {
                $(idhidden).val(timeSpan);
            }
        }
        validHiddenInput($(idhidden));
    }
}

applyInputBorders = function(inputWrapper, borderWrapper) {
    inputWrapper
        .focusin(function () {
            borderWrapper.addClass('t-input-active');
        })
        .focusout(function () {
            borderWrapper.removeClass('t-input-active');
        })
        .mouseenter(function () {
            borderWrapper.addClass('t-input-hover');
        })
        .mouseleave(function () {
            borderWrapper.removeClass('t-input-hover');
        });
                }

function bindButtons() {
    $('input[type=submit]').addClass('t-button');
    $('input[type=button]').addClass('t-button');
    $('input[type=reset]').addClass('t-button');

    // Modern Checkboxes & radiobuttons - tab stop & check on space key
    if (navigator.appName.indexOf("Internet Explorer") == -1 || navigator.appVersion.indexOf("MSIE 9") != -1 || navigator.appVersion.indexOf("MSIE 1") != -1) {
        $('label.input-label > input[type=checkbox], label.input-label > input[type=radio]').each(function (index, item) {
            var elem = $(item);
            if (elem.data('input-bound')) {
                return;
            }
            elem.data('input-bound', 1);
            var label = elem.parent();
            label.mousedown(function (e) {
                var input = $(e.target).parent().find("input");
                if (input.attr('type') == 'radio' && input.attr('nullable')) {
                    input.attr('previous-value', input.is(':checked'));
                }
            });
            var span = elem.parent().find('span');
            if (!span.attr('tabIndex')) {
                span.attr('tabindex', 0);
            }
            span.keydown(function (e) {
                if (e.keyCode == 32) {
                    e.preventDefault();
                    var input = $(e.target).parent().find("input");
                    var checked = input.is(':checked');
                    if (input.attr('type') == 'radio' && input.attr('nullable')) {
                        input.attr('previous-value', checked);
                        input.prop('checked', !checked);
                        elma.ToggleSelectedNullableRadioButton(input, true);
                    } else if (!checked || input.attr('type') != 'radio') {
                        input.prop('checked', !checked);
                        $(input).trigger('change');
                    }
                    return false; // return false to prevent space from being added
                }
                return true;
            });
            elem.click(function (e) {
                elma.ToggleSelectedNullableRadioButton($(e.target));
            });
        });
    } else {
        $('label.input-label > input[type=radio][nullable]').each(function (index, item) {
            var elem = $(item);
            if (elem.data('input-bound')) {
                return;
            }
            elem.data('input-bound', 1);
            var label = elem.parent();
            label.mousedown(function (e) {
                var input = $(e.target).parent().find("input");
                if (input.attr('type') == 'radio' && input.attr('nullable')) {
                    input.attr('previous-value', input.is(':checked'));
                }
            });
            elem.keydown(function (e) {
                if (e.type == 'keydown' && e.keyCode == 32) {
                    e.preventDefault();
                    var input = $(e.target);
                    var checked = input.is(':checked');
                    input.attr('previous-value', checked);
                    input.prop('checked', !checked);
                    elma.ToggleSelectedNullableRadioButton(input, false);
                    return false; // return false to prevent space from being added
                }
                return true;
            });
            elem.click(function (e) {
                elma.ToggleSelectedNullableRadioButton($(e.target));
            });
        });
    }

    // Focus & hover for inputs
    $('input,textarea').each(function (index, item) {
        var elem = $(item);
        if (elem.data('input-bound')) {
            return;
        }
        elem.data('input-bound', 1);
        var borderWrapper = elem;
        var parent = elem.parent();
        if (parent.hasClass('text-box')) {
            borderWrapper = borderWrapper.add(parent);
        }
        applyInputBorders(elem, borderWrapper);
    });
}

elma.ToggleSelectedNullableRadioButton = function (input, neetTrigger) {
    var prevValue = input.attr('previous-value');
    if (!prevValue)
        return;
    var nullableInput = input.closest('form').find('input[name="' + input.attr('name') + '"][type=hidden]:first');
    if (prevValue == 'true') {
        input.prop('checked', false);
        nullableInput.prop('disabled', false);
        if (neetTrigger !== false) {
            input.trigger('change');
        }
    } else {
        nullableInput.prop('disabled', true);
        if (neetTrigger === true) {
            input.trigger('change');
        }
    }
    input.removeAttr('previous-value');
}

elma.bindSwitch = function (){
    $(".cb-enable").click(function () {
        var parent = $(this).parents('.switch');
        $('.cb-disable', parent).removeClass('selected');
        $(this).addClass('selected');
        var enableLabel = $(this);
        $('input[type=hidden]', parent).each(function (i, a) {
            var value = enableLabel.attr('valueval');
            $(a).val(value);
            var target = $(a).attr('target');
            if (target && target != '') {
                $(target).val(value);
            }
        });
    });
    $(".cb-disable").click(function () {
        var parent = $(this).parents('.switch');
        $('.cb-enable', parent).removeClass('selected');
        $(this).addClass('selected');
        var disableLabel = $(this);
        $('input[type=hidden]', parent).each(function (i, a) {
            var value = disableLabel.attr('valueval');
            $(a).val(value);
            var target = $(a).attr('target');
            if (target && target != '') {
                $(target).val(value);
            }
        });
    });
};

$(document).ready(function () {
    elma.bindSwitch();
});



/* PersonalGroup scripts*/
function CheckButtonsPersonalGroup(id, value){
    var tComboBox = $("#" + id + "PersonalGroupSelector").data("tComboBox");
    var val = null;
    if (tComboBox.data && !isEmpty(value)) {
        for (var i = 0; i < tComboBox.data.length; i++) {
            if (tComboBox.data[i].Value == value) {
                val = tComboBox.data[i];
                break;
            }
        }
    }
    if (isEmpty(value) || val == null) {
        tComboBox.clearSelect();
        tComboBox.close();
        $("#" + id + "_ApplyBtn").css("visibility", "hidden");
        $("#" + id + "_DeleteBtn").css("visibility", "hidden");
    } else {
        $("#" + id + "_ApplyBtn").css("visibility", "visible");
        $("#" + id + "_DeleteBtn").css("visibility", "visible");
    }
}

function OnChangePersonalGroup(e) {
    var id = e.currentTarget.id.replace('PersonalGroupSelector', '');
    CheckButtonsPersonalGroup(id, e.value);
}

function ApplyPersonalGroup(id, checkReplacement, filterProviderUid, filterProviderData, valueWithType, needReset) {
        var tComboBox = $("#" + id + "PersonalGroupSelector").data("tComboBox");
        elma.openPleaseWait(true);
        $.ajax({
            cache: false,
            type: "GET",
            data: {
                'id': tComboBox.value(),
                'checkReplacement': checkReplacement,
                'filterProviderUid': filterProviderUid,
                'filterProviderData': filterProviderData,
                'valueWithType': valueWithType ? valueWithType : false
            },
            url: window.BaseUrl + 'Security/PersonalGroup/GetMembers',
            success: function (data) {
                if (needReset) resetAutocompleteComboBox(id);
                if (data.results && data.results.length > 0) {
                    var combobox = $("#" + id).data("tComboBox");

                    var selector = elma.EntitySelector.Manager.get(id);
                    if (selector) {
                        for (var i = 0; i < data.results.length; i++) {
                            var s = false;
                            combobox.select(function (d) {
                                return s = d.Value == data.results[i].Value;
                            });
                            if (!s) {
                                if (combobox.data == undefined)
                                    combobox.data = [];
                                combobox.data.push(data.results[i]);
                            }
                            selector.addItem(data.results[i].Value, data.results[i].ViewText);
                        }
                    }
                }
                elma.closePleaseWait(true);
            }
        });
        
}
function DeletePersonalGroup(id) {
    jConfirm(SR.T("Удалить выбранную пользовательскую группу?"), SR.T("Подтвердите действие"), function (r) {
        if (r) {
            var tComboBox = $("#" + id + "PersonalGroupSelector").data("tComboBox");
            elma.openPleaseWait(true);
            $.ajax({
                cache: false,
                type: "GET",
                data: {
                    'id': tComboBox.value()
                },
                url: window.BaseUrl + 'Security/PersonalGroup/Delete',
                success: function () {
                    CheckButtonsPersonalGroup(id, '');
                    tComboBox.reload();
                    elma.closePleaseWait(true);
                }
            });
        }
    });
}
function PostPersonalGroup(id, name) {
    var users = $("." + id + "_json").val();
    if (isEmpty(users))
        users = "[]";
    elma.openPleaseWait(true);
    $.ajax({
        cache: false,
        type: "POST",
        data: {
            'name': name,
            'users': users
        },
        url: window.BaseUrl + 'Security/PersonalGroup/SaveGroup',
        success: function () {
            var tComboBox = $("#" + id + "PersonalGroupSelector").data("tComboBox");
            tComboBox.reload();
            elma.closePleaseWait(true);
        }
    });
    
}
function SavePersonalGroup(id) {
    var name = $("#" + id + "PersonalGroupName").val();
    if (isEmpty(name)) {
        $("#" + id + "PersonalGroupNameNotValid").show();
    } else {
        $("#" + id + "PersonalGroupNameNotValid").hide();
        elma.openPleaseWait(true);
        $.ajax({
            cache: false,
            type: "GET",
            data: {
                'name': name
            },
            url: window.BaseUrl + 'Security/PersonalGroup/Exists',
            success: function (data) {
                if (data && data.exists){
                    elma.closePleaseWait(true);
                    jConfirm(SR.T("Пользовательская группа с таким именем уже существует. <br>Сохранить группу под этим именем?"), SR.T("Подтвердите действие"), function (r) {
                        if (r) {
                            closeWindow(id + "PersonalGroupNamePopup");
                            PostPersonalGroup(id, name);
                        }
                    });
                } else {
                    closeWindow(id + "PersonalGroupNamePopup");
                    PostPersonalGroup(id, name);
                }
            }
        });
    }
}
/* End PersonalGroup scripts*/

/* Reminder*/
function onAddReminderChange(e) {
    var timeInput = $("#reminderTime").data("tTextBox");
    var time = parseInt(e.newValue != undefined ? e.newValue : timeInput.value());
    if (isNaN(time) || time <= 0)
        return;
    var originalDate = $.telerik.datetime.parse({ value: $('#reminderDateResult').attr('originalDate'), format: jQuery.telerik.cultureInfo.generalDateTime });
    var typeInput = $('#reminderTimeType').data("tDropDownList");
    var type = typeInput.value();
    var minutes = 0;
    if (type == 1)
        minutes = time;
    else if (type == 2)
        minutes = time * 60;
    else if (type == 3)
        minutes = time * 60 * 24;
    else if (type == 4)
        minutes = time * 60 * 24 * 7;
    var remindDate = originalDate.value.addMinutes(-minutes);
    $('#reminderDateResult').text($.telerik.datetime.format(remindDate, jQuery.telerik.cultureInfo.shortDate + " " + jQuery.telerik.cultureInfo.shortTime));
}
function openReminderWindow(title, url) {
    $(".t-window-title", $("#reminderPopup")).text(title);
    refreshPopup("reminderPopup", url);
}
function refreshReminders(prefix) {
    refreshPopup("reminderPopup");
    elma.dynamics.update(prefix + "Reminders");
}
function deleteReminder(url, prefix) {
    elma.openPleaseWait(true);
    $.ajax({
        cache: false,
        type: "GET",
        url: url,
        success: function (data) {
            elma.closePleaseWait(true);
            if (data.error) {
                jAlert(data.error, SR.T("Ошибка"));
            } else {
                refreshReminders(prefix);
            }
        }
    });
}

function ClearForm(formId) {
    $($("#" + formId)).find(':input').each(function () {
        switch (this.type) {
            case 'hidden':
                var hdn = $(this);
                if (hdn.data != undefined && hdn.data("tComboBox") != null) {
                    var tComboBox = hdn.data("tComboBox");
                    tComboBox.value("");
                    var parentEntity = $(this).closest(".t-entity-input");
                    if (parentEntity.length > 0) {
                        parentEntity.find("#div-" + this.id).empty();
                    }
                }
                break;
            case 'password':
            case 'select-multiple':
            case 'select-one':
            case 'text':
                if ($(this).data != null && $(this).data("tDatePicker") != null) {
                    this.value = "";
                    if (this.id.length >= 5) {
                        var vId = this.id.substring(0, this.id.length - 5);
                        $("#" + formId).find("#" + vId).val("");
                    }
                    break;
                }
            case 'textarea':
                $(this).val('');
                break;
            case 'checkbox':
            case 'radio':
                this.checked = false;
        }
    });
}

function WorkTimeMinutesToHM(totalMinutes) {
    if (totalMinutes == null || isNaN(totalMinutes)) {
        totalMinutes = 0;
    }
    var hours = (totalMinutes / 60).toString().replace(".", ",").split(",")[0];
    var minutes = "0" + (totalMinutes - parseInt(hours) * 60);
    minutes = minutes.substring(minutes.length - 2, minutes.length);
    return hours + ":" + minutes;
}

function WorkTimeMinutesToString(totalMinutes) {
    var strMinutes = SR.T("мин");
    var strHours = SR.T("ч");
    var arr = WorkTimeMinutesToHM(totalMinutes).split(":");
    if (arr[0] == "0" && arr[1] == "00") {
        return "0" + " " + strMinutes;
    } else if (arr[0] == "0") {
        return parseInt(arr[1]) + " " + strMinutes;
    } else {
        var workTime = parseInt(arr[0]) + " " + strHours;
        if (parseInt(arr[1]) != 0) {
            workTime += " " + parseInt(arr[1]) + " " + strMinutes;
        }
        return workTime;
    }
}

function WorkTimeCompactInit(id) {
    var keyDownCode = null;
    var inputId = id + "_input";
    var input = $("#" + inputId);
    $("#" + id)[0].SetWorkTime = function (totalMinutes) {
        var convertTime = WorkTimeMinutesToHM(totalMinutes);
        $("#" + id).val(totalMinutes);
        input.val(convertTime);
    };
    input.focus(function () {
        keyDownCode = null;
    }
    );
    input.change(function () {
        var value = input.val().split(":");
        var totalMinutes = 0;
        if (value.length == 2) {
            totalMinutes = parseInt(value[1]);
            if (isNaN(totalMinutes)) totalMinutes = 0;
            var h = parseInt(value[0]);
            if (isNaN(h)) h = 0;
            totalMinutes += h * 60;
        }
        else if (value.length == 1) {
            totalMinutes = parseInt(value[0]) * 60;
            if (isNaN(totalMinutes)) totalMinutes = 0;
        }
        $("#" + id)[0].SetWorkTime(totalMinutes);
    });
    var conf;
    if (input.attr("mousetooltip") != null && input.attr("mousetooltip").toLowerCase() == "true") {
        conf = {
            content: {
                text: SR.T("Укажите время в формате <b>часы:минуты</b>.<br>Например: 2:05 (2 часа 5 минут).")
            },
            position: {
                my: 'top right',
                at: 'top left',
                target: 'mouse',
                adjust: { mouse: true, x: -5, y: 15 }
            }
        };
    } else {
        conf = {
            content: {
                text: SR.T("Укажите время в формате <b>часы:минуты</b>.<br>Например: 2:05 (2 часа 5 минут).")
            },
            position: {
                my: 'top left',
                at: 'bottom left',
                viewport: true
            },
            show: 'focus',
            hide: 'blur'
        };
    }
    input.qtip(conf);
    input.keydown(function (b) {
        var a = b.which;
        keyDownCode = a;
        switch (a) {
            case 37:    // стрелка влево
                if (b.shiftKey == false) {
                    if (input.caret().begin == input.val().indexOf(":") + 1) {
                        b.preventDefault();
                        if (input.val().indexOf(":") + 1 == input.val().length) {
                            input.val(input.val() + "00");
                        }
                        input.caret(0, input.val().indexOf(":"));
                    }
                    else {
                        if ((input.caret().begin == 0) && (input.caret().end == input.val().indexOf(":"))) {
                            b.preventDefault();
                            input.caret(input.caret().end - 1);
                        }
                    }
                }
                break;
            case 39:    // стрелка вправо
                if (b.shiftKey == false) {
                    if (input.caret().begin == input.val().indexOf(":")) {
                        b.preventDefault();
                        if (input.val().indexOf(":") == 0) {
                            input.val("0" + input.val());
                        }
                        input.caret(input.val().indexOf(":") + 1,  input.val().length);
                    }
                    else {
                        if ((input.caret().begin == input.val().indexOf(":") + 1) && (input.caret().end == input.val().length)) {
                            b.preventDefault();
                            input.caret(input.caret().begin + 1);
                        }
                        else {
                            if ((input.caret().begin == 0) && (input.caret().end == input.val().indexOf(":"))) {
                                b.preventDefault();
                                input.caret(input.val().indexOf(":") + 1, input.val().length);
                            }
                        }
                    }
                }
                break;
            case 38:    // стрелка вверх
                if (b.shiftKey == false) {
                    if ((input.caret().begin == input.val().indexOf(":") + 1) && (input.val().indexOf(":") + 1 == input.val().length)) {
                        b.preventDefault();
                        input.val(input.val() + "00");
                        input.caret(0);
                    }
                }
                break;
            case 40:    // стрелка вниз
                if (b.shiftKey == false) {
                    if ((input.caret().begin == input.val().indexOf(":")) && (input.val().indexOf(":") == 0)) {
                        b.preventDefault();
                        input.val("0" + input.val());
                        input.caret(input.val().length);
                    }
                }
                break;
            case 36:    // Home
                if (b.shiftKey == false) {
                    if (input.val().indexOf(":") + 1 == input.val().length) {
                        b.preventDefault();
                        input.val(input.val() + "00");
                    }
                    if (input.caret().begin >= input.val().indexOf(":")) {
                        b.preventDefault();
                        input.caret(0, input.val().indexOf(":"));
                    }
                }
                break;
            case 35:    // End
                if (b.shiftKey == false) {
                    if (input.val().indexOf(":") == 0) {
                        b.preventDefault();
                        input.val("0" + input.val());
                    }
                    if (input.caret().end <= input.val().indexOf(":") + 1) {
                        b.preventDefault();
                        input.caret(input.val().indexOf(":") + 1, input.val().length);
                    }
                }
                break;
            case 8:     // Backspace
                if ((input.val().indexOf(":") == input.caret().begin - 1) && (input.caret().begin == input.caret().end)) {
                    b.preventDefault();
                    if (input.val().indexOf(":") == input.val().length - 1) {
                        input.val(input.val() + "00");
                    }
                    input.caret(0, input.val().indexOf(":"));
                }
                else {
                    if ((input.caret().begin == 0) && (input.caret().end == input.val().length)) {
                        b.preventDefault();
                        input.val("0:00");
                        input.caret(0, 1);
                    }
                    else {
                        if ((input.caret().begin <= input.val().indexOf(":")) && (input.val().indexOf(":") < input.caret().end)) {
                            b.preventDefault();
                        }
                    }
                }
                break;
            case 46:    // Delete
                if ((input.val().indexOf(":") == input.caret().begin) && (input.caret().begin == input.caret().end)) {
                    b.preventDefault();
                    if (input.val().indexOf(":") == 0) {
                        input.val("0" + input.val());
                    }
                    input.caret(input.val().indexOf(":") + 1, input.val().length);
                }
                else {
                    if ((input.caret().begin == 0) && (input.caret().end == input.val().length)) {
                        b.preventDefault();
                        input.val("0:00");
                        input.caret(0, 1);
                    }
                    else {
                        if ((input.caret().begin <= input.val().indexOf(":")) && (input.val().indexOf(":") < input.caret().end)) {
                            b.preventDefault();
                        }
                    }
                }
                break;
            case 9:    // Tab
                if (b.shiftKey == false) {
                    if (((input.caret().end == 0) && (input.val().indexOf(":") != 0)) || ((input.caret().begin == 0) && (input.caret().end == input.val().length))) {
                        b.preventDefault();
                        input.caret(0, input.val().indexOf(":"));
                    }
                    else {
                        if ((input.caret().end <= input.val().indexOf(":") + 1) && (input.val().indexOf(":") + 1 != input.val().length)) {
                            b.preventDefault();
                            if (input.val().indexOf(":") == 0) {
                                input.val("0" + input.val());
                            }
                            input.caret(input.val().indexOf(":") + 1, input.val().length);
                        }
                    }
                }
                else {
                    if (b.shiftKey == true)    // shift+tab 
                    {
                        if ((input.caret().begin == input.val().length) && (input.val().indexOf(":") + 1 != input.val().length)) {
                            b.preventDefault();
                            input.caret(input.val().indexOf(":") + 1, input.val().length);
                        }
                        else {
                            if ((input.caret().begin >= input.val().indexOf(":")) && (input.val().indexOf(":") != 0)) {
                                b.preventDefault();
                                if (input.val().indexOf(":") + 1 == input.val().length) {
                                    input.val(input.val() + "00");
                                }
                                input.caret(0, input.val().indexOf(":"));
                            }
                        }
                    }
                }
                break;
        }
    });
    input.keyup(function (b) {
        keyDownCode = null;
        var a = b.which;
        if (a == 9)  // tab & shift+tab
        {
            if ((input.caret().begin == 0) && (input.caret().end == input.val().length)) {
                input.caret(0, input.val().indexOf(":"));
            }
        }
    });
    input.keypress(function (b) {
        if ((keyDownCode >= 37 && keyDownCode <= 40) || keyDownCode == 8)
            return;
        var c1 = /[0-9:\x25\x27\x24\x23]/;
        var a = b.which;
        var c = String.fromCharCode(a);
        if (c == ":") {
            var selectRange = $(b.target).selectionRange();
            if (selectRange.textAfter.indexOf(":") != -1 || selectRange.textBefore.indexOf(":") != -1) return false;
        }
        if ((input.caret().begin == 0) && (input.caret().end == input.val().length)) {
            input.val(":00");
            input.caret(0);
        }
        if (b.ctrlKey == true && b.altKey == false && b.shiftKey == false && a == 97) return true; // ctr+a
        if (b.ctrlKey == true && b.altKey == false && b.shiftKey == false && a == 118) return true; // ctr+v
        if (b.ctrlKey == true && b.altKey == false && b.shiftKey == false && a == 99) return true; // ctr+c
        if (b.ctrlKey == false && b.altKey == false && b.shiftKey == true && a == 45) return true; // shift+ins
        return !!(a == 0 || a == 8 || a == 9 || a == 13 || c.match(c1));
    });
    input.mousedown(function (b) {
        window.setTimeout(function () { // for chrome, т.к. не всегда правильно работает событие click для input, если курсор мыши в этот момент оказался над другим элементом (изменение размеров или скрытие чего-либо)
            var posDoter = input.val().indexOf(":");
            if (posDoter == -1)
                posDoter = input.val().length - 1;
            var caret = input.caret();
            var cursor = Math.max(caret.begin, caret.end);
            if (cursor <= posDoter) {
                input.caret(0, posDoter);
            } else {
                input.caret(posDoter + 1, input.val().length);
            }
            if ((input.caret().begin > input.val().indexOf(":")) && (input.val().indexOf(":") == 0)) {
                input.val("0" + input.val());
            }
            else {
                if ((input.caret().begin <= input.val().indexOf(":")) && (input.val().indexOf(":") + 1 == input.val().length)) {
                    input.val(input.val() + "00");
                }
            }
        }, 1);
    });
}

elma.CollapsiblePanel = new Object();
elma.CollapsiblePanel.ExpandForContent = function(el, allParents) {
    var panelId = $(el).parents("div[collapsiblepanelid]:first").attr("collapsiblepanelid");
    if (panelId == null || panelId == "")
        return;
    var panel = $("#" + panelId + ".collapsible-panel");
    if (panel.hasClass("collapsed"))
        panel.find("div:first").click();
    if (allParents) {
        elma.CollapsiblePanel.ExpandForContent(panel, allParents);
    };
};


/*
 ### jQuery Multiple File Upload Plugin v1.47 - 2010-03-26 ###
 * Home: http://www.fyneworks.com/jquery/multiple-file-upload/
 * Code: http://code.google.com/p/jquery-multifile-plugin/
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 ###
*/

/*# AVOID COLLISIONS #*/
;if (window.jQuery) (function ($) {
    /*# AVOID COLLISIONS #*/

    // plugin initialization
    $.fn.MultiFile = function (options) {
        if (this.length == 0) return this; // quick fail

        // Handle API methods
        if (typeof arguments[0] == 'string') {
            // Perform API methods on individual elements
            if (this.length > 1) {
                var args = arguments;
                return this.each(function () {
                    $.fn.MultiFile.apply($(this), args);
                });
            };
            // Invoke API method handler
            $.fn.MultiFile[arguments[0]].apply(this, $.makeArray(arguments).slice(1) || []);
            // Quick exit...
            return this;
        };

        // Initialize options for this call
        var options = $.extend(
			{}/* new object */,
			$.fn.MultiFile.options/* default options */,
			options || {} /* just-in-time options */
		);

        // Empty Element Fix!!!
        // this code will automatically intercept native form submissions
        // and disable empty file elements
        $('form')
		.not('MultiFile-intercepted')
		.addClass('MultiFile-intercepted')
		.submit($.fn.MultiFile.disableEmpty);

        //### http://plugins.jquery.com/node/1363
        // utility method to integrate this plugin with others...
        if ($.fn.MultiFile.options.autoIntercept) {
            $.fn.MultiFile.intercept($.fn.MultiFile.options.autoIntercept /* array of methods to intercept */);
            $.fn.MultiFile.options.autoIntercept = null; /* only run this once */
        };

        // loop through each matched element
        this
		 .not('.MultiFile-applied')
			.addClass('MultiFile-applied')
		.each(function () {
		    //#####################################################################
		    // MAIN PLUGIN FUNCTIONALITY - START
		    //#####################################################################

		    // BUG 1251 FIX: http://plugins.jquery.com/project/comments/add/1251
		    // variable group_count would repeat itself on multiple calls to the plugin.
		    // this would cause a conflict with multiple elements
		    // changes scope of variable to global so id will be unique over n calls
		    window.MultiFile = (window.MultiFile || 0) + 1;
		    var group_count = window.MultiFile;

		    // Copy parent attributes - Thanks to Jonas Wagner
		    // we will use this one to create new input elements
		    var MultiFile = { e: this, E: $(this), clone: $(this).clone() };

		    //===

		    //# USE CONFIGURATION
		    if (typeof options == 'number') options = { max: options };
		    var o = $.extend({},
        $.fn.MultiFile.options,
        options || {},
   					($.metadata ? MultiFile.E.metadata() : ($.meta ? MultiFile.E.data() : null)) || {}, /* metadata options */
								{} /* internals */
       );
		    // limit number of files that can be selected?
		    if (!(o.max > 0) /*IsNull(MultiFile.max)*/) {
		        o.max = MultiFile.E.attr('maxlength');
		        if (!(o.max > 0) /*IsNull(MultiFile.max)*/) {
		            o.max = (String(MultiFile.e.className.match(/\b(max|limit)\-([0-9]+)\b/gi) || ['']).match(/[0-9]+/gi) || [''])[0];
		            if (!(o.max > 0)) o.max = -1;
		            else o.max = String(o.max).match(/[0-9]+/gi)[0];
		        }
		    };
		    o.max = new Number(o.max);
		    // limit extensions?
		    o.accept = o.accept || MultiFile.E.attr('accept') || '';
		    if (!o.accept) {
		        o.accept = (MultiFile.e.className.match(/\b(accept\-[\w\|]+)\b/gi)) || '';
		        o.accept = new String(o.accept).replace(/^(accept|ext)\-/i, '');
		    };

		    // start from number?
		    o.initcount = o.initcount || MultiFile.E.attr('initcount') || 0;
		    o.initcount = new Number(o.initcount);
		    //===

		    // APPLY CONFIGURATION
		    $.extend(MultiFile, o || {});
		    MultiFile.STRING = $.extend({}, $.fn.MultiFile.options.STRING, MultiFile.STRING);

		    //===

		    //#########################################
		    // PRIVATE PROPERTIES/METHODS
		    $.extend(MultiFile, {
		        n: 0, // How many elements are currently selected?
		        slaves: [], files: [],
		        instanceKey: MultiFile.e.id || 'MultiFile' + String(group_count), // Instance Key?
		        generateID: function (z) { return MultiFile.instanceKey + (z > 0 ? '_F' + String(z) : ''); },
		        trigger: function (event, element) {
		            var handler = MultiFile[event], value = $(element).attr('value');
		            if (handler) {
		                var returnValue = handler(element, value, MultiFile);
		                if (returnValue != null) return returnValue;
		            }
		            return true;
		        }
		    });

		    //===

		    // Setup dynamic regular expression for extension validation
		    // - thanks to John-Paul Bader: http://smyck.de/2006/08/11/javascript-dynamic-regular-expresions/
		    if (String(MultiFile.accept).length > 1) {
		        MultiFile.accept = MultiFile.accept.replace(/\W+/g, '|').replace(/^\W|\W$/g, '');
		        MultiFile.rxAccept = new RegExp('\\.(' + (MultiFile.accept ? MultiFile.accept : '') + ')$', 'gi');
		    };

		    //===

		    // Create wrapper to hold our file list
		    MultiFile.wrapID = MultiFile.instanceKey + '_wrap'; // Wrapper ID?
		    MultiFile.E.wrap('<div class="MultiFile-wrap" id="' + MultiFile.wrapID + '"></div>');
		    MultiFile.wrapper = $(MultiFile.E).parents('#' + MultiFile.wrapID + '');

		    //===

		    // MultiFile MUST have a name - default: file1[], file2[], file3[]
		    MultiFile.e.name = MultiFile.e.name || 'file' + group_count + '[]';

		    //===

		    if (!MultiFile.list) {
		        // Create a wrapper for the list
		        // * OPERA BUG: NO_MODIFICATION_ALLOWED_ERR ('list' is a read-only property)
		        // this change allows us to keep the files in the order they were selected
		        MultiFile.wrapper.append('<div class="MultiFile-list" id="' + MultiFile.wrapID + '_list"></div>');
		        MultiFile.list = $(MultiFile.wrapper).find('#' + MultiFile.wrapID + '_list');
		    };
		    MultiFile.list = $(MultiFile.list);

		    //===

		    // Bind a new element
		    MultiFile.addSlave = function (slave, slave_count) {
		        //if(window.console) console.log('MultiFile.addSlave',slave_count);
		        MultiFile.slave_count = slave_count;
		        // Keep track of how many elements have been displayed
		        MultiFile.n++;
		        // Add reference to master element
		        slave.MultiFile = MultiFile;

		        // BUG FIX: http://plugins.jquery.com/node/1495
		        // Clear identifying properties from clones
		        if (slave_count > 0) slave.id = slave.name = '';

		        // Define element's ID and name (upload components need this!)
		        //slave.id = slave.id || MultiFile.generateID(slave_count);
		        if (slave_count > 0) slave.id = MultiFile.generateID(slave_count);
		        //FIX for: http://code.google.com/p/jquery-multifile-plugin/issues/detail?id=23

		        // 2008-Apr-29: New customizable naming convention (see url below)
		        // http://groups.google.com/group/jquery-dev/browse_frm/thread/765c73e41b34f924#
		        slave.name = String(MultiFile.namePattern
		        /*master name*/.replace(/\$name/gi, $(MultiFile.clone).attr('name'))
		        /*master id  */.replace(/\$id/gi, $(MultiFile.clone).attr('id'))
		        /*formatattribute*/.replace(/\$format/gi, $(MultiFile.clone).attr('format'))
		        /*group count*/.replace(/\$g/gi, group_count)//(group_count>0?group_count:''))
		        /*slave count*/.replace(/\$i/gi, slave_count)//(slave_count>0?slave_count:''))
        );

		        // If we've reached maximum number, disable input slave
		        if ((MultiFile.max > 0) && ((MultiFile.n - 1) > (MultiFile.max)))//{ // MultiFile.n Starts at 1, so subtract 1 to find true count
		            slave.disabled = true;
		        //};

		        // Remember most recent slave
		        MultiFile.current = MultiFile.slaves[slave_count] = slave;

		        // We'll use jQuery from now on
		        slave = $(slave);

		        // Clear value
		        slave.val('').attr('value', '')[0].value = '';

		        // Stop plugin initializing on slaves
		        slave.addClass('MultiFile-applied');

		        // Triggered when a file is selected
		        slave.change(function () {
		            //if(window.console) console.log('MultiFile.slave.change',slave_count);

		            // Lose focus to stop IE7 firing onchange again
		            $(this).blur();

		            //# Trigger Event! onFileSelect
		            if (!MultiFile.trigger('onFileSelect', this, MultiFile)) return false;
		            //# End Event!

		            //# Retrive value of selected file from element
		            var ERROR = '', v = String(this.value || ''/*.attr('value)*/);

		            // check extension
		            if (MultiFile.accept && v && !v.match(MultiFile.rxAccept))//{
		                ERROR = MultiFile.STRING.denied.replace('$ext', String(v.match(/\.\w{1,4}$/gi)));
		            //}
		            //};

		            // Disallow duplicates
		            for (var f in MultiFile.slaves)//{
		                if (MultiFile.slaves[f] && MultiFile.slaves[f] != this)//{
		                //console.log(MultiFile.slaves[f],MultiFile.slaves[f].value);
		                    if (MultiFile.slaves[f].value == v)//{
		                        ERROR = MultiFile.STRING.duplicate.replace('$file', v.match(/[^\/\\]+$/gi));
		            //};
		            //};
		            //};

		            // Create a new file input element
		            var newEle = $(MultiFile.clone).clone(); // Copy parent attributes - Thanks to Jonas Wagner
		            //# Let's remember which input we've generated so
		            // we can disable the empty ones before submission
		            // See: http://plugins.jquery.com/node/1495
		            newEle.addClass('MultiFile');

		            // Handle error
		            if (ERROR != '') {
		                // Handle error
		                MultiFile.error(ERROR);

		                // 2007-06-24: BUG FIX - Thanks to Adrian Wrуbel <adrian [dot] wrobel [at] gmail.com>
		                // Ditch the trouble maker and add a fresh new element
		                MultiFile.n--;
		                MultiFile.addSlave(newEle[0], MultiFile.slave_count);
		                slave.parent().prepend(newEle);
		                slave.remove();
		                return false;
		            };

		            // Hide this element (NB: display:none is evil!)
		            $(this).css({ position: 'absolute', top: '-3000px' });

		            // Add new element to the form
		            slave.after(newEle);

		            // Update list
		            MultiFile.addToList(this, MultiFile.slave_count);

		            // Bind functionality
		            MultiFile.addSlave(newEle[0], MultiFile.slave_count + 1);

		            //# Trigger Event! afterFileSelect
		            if (!MultiFile.trigger('afterFileSelect', this, MultiFile)) return false;
		            //# End Event!

		        }); // slave.change()

		        // Save control to element
		        $(slave).data('MultiFile', MultiFile);

		    }; // MultiFile.addSlave
		    // Bind a new element

		    // Add a new file to the list
		    MultiFile.addToList = function (slave, slave_count) {
		        //if(window.console) console.log('MultiFile.addToList',slave_count);

		        //# Trigger Event! onFileAppend
		        if (!MultiFile.trigger('onFileAppend', slave, MultiFile)) return false;
		        //# End Event!

		        // Create label elements
		        var 
         r = $('<div style="padding-right:10px;padding-left:10px;padding-top:5px;height:16px;" class="MultiFile-label"></div>'),
         v = String(slave.value || ''/*.attr('value)*/),
         a = $('<div style="float:left;" class="MultiFile-title" title="' + MultiFile.STRING.selected.replace('$file', v) + '">' + MultiFile.STRING.file.replace('$file', v.match(/[^\/\\]+$/gi)[0]) + '</div>'),
         b = $('<div style="float:left;width:16px;height:16px;" class="delete_small" href="#' + MultiFile.wrapID + '" slave="' + slave_count + '"></div>'),
         c = $('<div style="float:left;width:16px;height:16px;" class="attach"></div>');

		        // Insert label
		        MultiFile.list.append(
         r.append(c, a, ' ', b)
        );

		        b.click(function () {
		            //# Trigger Event! onFileRemove
		            if (!MultiFile.trigger('onFileRemove', slave, MultiFile)) return false;
		            //# End Event!

		            MultiFile.n--;
		            MultiFile.current.disabled = false;		            

		            var slv = $(this).attr('slave');
		            // Remove element, remove label, point to current
		            MultiFile.slaves[slv] = null;
		            $(slave).remove();
		            $(this).parent().remove(); 
		            MultiFile.slave_count--;

		            // Show most current element again (move into view) and clear selection
		            $(MultiFile.current).css({ position: '', top: '' });
		            $(MultiFile.current).reset().val('').attr('value', '')[0].value = '';
		            $('#' + MultiFile.wrapID).find('input[type=file][format]').each(function (i, a) {
		                var newName = $(a).attr('format').replace('$i', i);
		                $(a).attr('name', newName);
		            });

		            //# Trigger Event! afterFileRemove
		            if (!MultiFile.trigger('afterFileRemove', slave, MultiFile)) return false;
		            //# End Event!

		            return false;
		        });

		        //# Trigger Event! afterFileAppend
		        if (!MultiFile.trigger('afterFileAppend', slave, MultiFile)) return false;
		        //# End Event!

		    }; // MultiFile.addToList
		    // Add element to selected files list



		    // Bind functionality to the first element
		    if (!MultiFile.MultiFile) MultiFile.addSlave(MultiFile.e, MultiFile.initcount || 0);

		    // Increment control count
		    //MultiFile.I++; // using window.MultiFile
		    MultiFile.n++;

		    // Save control to element
		    MultiFile.E.data('MultiFile', MultiFile);


		    //#####################################################################
		    // MAIN PLUGIN FUNCTIONALITY - END
		    //#####################################################################
		}); // each element
    };

    /*--------------------------------------------------------*/

    /*
    ### Core functionality and API ###
    */
    $.extend($.fn.MultiFile, {
        /**
        * This method removes all selected files
        *
        * Returns a jQuery collection of all affected elements.
        *
        * @name reset
        * @type jQuery
        * @cat Plugins/MultiFile
        * @author Diego A. (http://www.fyneworks.com/)
        *
        * @example $.fn.MultiFile.reset();
        */
        reset: function () {
            var settings = $(this).data('MultiFile');
            //if(settings) settings.wrapper.find('a.MultiFile-remove').click();
            if (settings) settings.list.find('a.MultiFile-remove').click();
            return $(this);
        },


        /**
        * This utility makes it easy to disable all 'empty' file elements in the document before submitting a form.
        * It marks the affected elements so they can be easily re-enabled after the form submission or validation.
        *
        * Returns a jQuery collection of all affected elements.
        *
        * @name disableEmpty
        * @type jQuery
        * @cat Plugins/MultiFile
        * @author Diego A. (http://www.fyneworks.com/)
        *
        * @example $.fn.MultiFile.disableEmpty();
        * @param String class (optional) A string specifying a class to be applied to all affected elements - Default: 'mfD'.
        */
        disableEmpty: function (klass) {
            klass = (typeof (klass) == 'string' ? klass : '') || 'mfD';
            var o = [];
            $('input:file.MultiFile').each(function () { if ($(this).val() == '') o[o.length] = this; });
            return $(o).each(function () { this.disabled = true }).addClass(klass);
        },


        /**
        * This method re-enables 'empty' file elements that were disabled (and marked) with the $.fn.MultiFile.disableEmpty method.
        *
        * Returns a jQuery collection of all affected elements.
        *
        * @name reEnableEmpty
        * @type jQuery
        * @cat Plugins/MultiFile
        * @author Diego A. (http://www.fyneworks.com/)
        *
        * @example $.fn.MultiFile.reEnableEmpty();
        * @param String klass (optional) A string specifying the class that was used to mark affected elements - Default: 'mfD'.
        */
        reEnableEmpty: function (klass) {
            klass = (typeof (klass) == 'string' ? klass : '') || 'mfD';
            return $('input:file.' + klass).removeClass(klass).each(function () { this.disabled = false });
        },


        /**
        * This method will intercept other jQuery plugins and disable empty file input elements prior to form submission
        *
	
        * @name intercept
        * @cat Plugins/MultiFile
        * @author Diego A. (http://www.fyneworks.com/)
        *
        * @example $.fn.MultiFile.intercept();
        * @param Array methods (optional) Array of method names to be intercepted
        */
        intercepted: {},
        intercept: function (methods, context, args) {
            var method, value; args = args || [];
            if (args.constructor.toString().indexOf("Array") < 0) args = [args];
            if (typeof (methods) == 'function') {
                $.fn.MultiFile.disableEmpty();
                value = methods.apply(context || window, args);
                //SEE-http://code.google.com/p/jquery-multifile-plugin/issues/detail?id=27
                setTimeout(function () { $.fn.MultiFile.reEnableEmpty() }, 1000);
                return value;
            };
            if (methods.constructor.toString().indexOf("Array") < 0) methods = [methods];
            for (var i = 0; i < methods.length; i++) {
                method = methods[i] + ''; // make sure that we have a STRING
                if (method) (function (method) { // make sure that method is ISOLATED for the interception
                    $.fn.MultiFile.intercepted[method] = $.fn[method] || function () { };
                    $.fn[method] = function () {
                        $.fn.MultiFile.disableEmpty();
                        value = $.fn.MultiFile.intercepted[method].apply(this, arguments);
                        //SEE-http://code.google.com/p/jquery-multifile-plugin/issues/detail?id=27
                        setTimeout(function () { $.fn.MultiFile.reEnableEmpty() }, 1000);
                        return value;
                    }; // interception
                })(method); // MAKE SURE THAT method IS ISOLATED for the interception
            }; // for each method
        } // $.fn.MultiFile.intercept

    });

    /*--------------------------------------------------------*/

    /*
    ### Default Settings ###
    eg.: You can override default control like this:
    $.fn.MultiFile.options.accept = 'gif|jpg';
    */
    $.fn.MultiFile.options = { //$.extend($.fn.MultiFile, { options: {
        accept: '', // accepted file extensions
        max: -1,    // maximum number of selectable files

        // name to use for newly created elements
        namePattern: '$name', // same name by default (which creates an array)

        // STRING: collection lets you show messages in different languages
        STRING: {
            remove: 'x',
            denied: SR.T('Вы не можете выбрать файл $ext.\nПопробуйте еще раз...'),
            file: '$file',
            selected: SR.T('Выбран файл: $file'),
            duplicate: SR.T('Этот файл уже выбран:\n$file')
        },

        // name of methods that should be automcatically intercepted so the plugin can disable
        // extra file elements that are empty before execution and automatically re-enable them afterwards
        autoIntercept: ['submit', 'ajaxSubmit', 'ajaxForm', 'validate', 'valid' /* array of methods to intercept */],

        // error handling function
        error: function (s) {
            /*
            ERROR! blockUI is not currently working in IE
            if($.blockUI){
            $.blockUI({
            message: s.replace(/\n/gi,'<br/>'),
            css: { 
            border:'none', padding:'15px', size:'12.0pt',
            backgroundColor:'#900', color:'#fff',
            opacity:'.8','-webkit-border-radius': '10px','-moz-border-radius': '10px'
            }
            });
            window.setTimeout($.unblockUI, 2000);
            }
            else//{// save a byte!
            */
            alert(s);
            //}// save a byte!
        }
    }; //} });

    /*--------------------------------------------------------*/

    /*
    ### Additional Methods ###
    Required functionality outside the plugin's scope
    */

    // Native input reset method - because this alone doesn't always work: $(element).val('').attr('value', '')[0].value = '';
    $.fn.reset = function () { return this.each(function () { try { this.reset(); } catch (e) { } }); };

    /*--------------------------------------------------------*/

    /*
    ### Default implementation ###
    The plugin will attach itself to file inputs
    with the class 'multi' when the page loads
    */
    /*$(function(){
    //$("input:file.multi").MultiFile();
    $("input[type=file].multi").MultiFile();
    });*/



    /*# AVOID COLLISIONS #*/
})(jQuery);
/*# AVOID COLLISIONS #*/

function bindFiles(containerId) {
    $(containerId).find("input[type=file].multi").MultiFile({
            namePattern: '$format'
        });
}


(function ($) {
    $.extend({
        getGo: function (url, params) {
            document.location = url + '?' + $.param(params);
        },
        postGo: function (url, params) {
            var $form = $("<form>")
                .attr("method", "post")
                .attr("action", url);
            $.each(params, function (name, value) {
                $("<input type='hidden'>")
                    .attr("name", name)
                    .attr("value", value)
                    .appendTo($form);
            });
            $form.appendTo("body");
            $form.AddAntiForgeryToken().submit();
        }
    });
})(jQuery);

elma.dynamics = function () {
};
elma.dynamics.loadOnce = function (containerId, postData, callback, options) {
    var container = $("#" + containerId);
    if (container.attr('loaded') == '1') return;
    if (container.attr('loading') == '1') return;

    container.attr('loading', '1');

    elma.dynamics.update(containerId, postData, function (id) {
        $("#" + id).attr('loading', '');
        if (typeof callback == 'function') callback(containerId, postData);
    }, options);
};
elma.dynamics.serializeForm = function (form) {
    var postData = {};
    var data = $('#' + form).serializeArray();
    for (var i = 0; i < data.length; i++) {
        var dataItemName = data[i].name;
        var item = {};
        item[dataItemName] = data[i].value;
        postData = jQuery.extend(true, postData, item);
    }
    return postData;
};
elma.dynamics.GetInputValue = function (input) {
    if (input.is(':checkbox'))
        return input.is(':checked');
    if (input.is('[type=radio]'))
        return $('input[name="' + input.attr('name') + '"]:checked').val();
	if (input.is('textarea') && typeof tinymce == "object") {
	    var id = input.attr('id');
		for (var i = 0; i < tinymce.editors.length; i++) {
			if (tinymce.editors[i].id == id) {
				tinymce.editors[i].editorManager.triggerSave();
				break;
			}
		}
	}	
    return input.val();
};
elma.dynamics.PreGetPostDataFuncs = new Array();
elma.dynamics.getPostData = function (selector, postData, replaceExpKeyFrom, replaceExpKeyTo) {
    if (!postData) {
        postData = {};
    }
    for (var j = 0; j < elma.dynamics.PreGetPostDataFuncs.length; j++) {
        if (!elma.dynamics.PreGetPostDataFuncs[j].selector || elma.dynamics.PreGetPostDataFuncs[j].selector === selector)
            elma.dynamics.PreGetPostDataFuncs[j].func.call();
    }
    var dataInputs = $(selector).find("input:not(:disabled),textarea:not(:disabled),select:not(:disabled)");
    var checkboxes = {};
    for (var j = 0; j < dataInputs.length; j++) {
        if ($(dataInputs[j]).is(':checkbox')) {
            var chName = dataInputs[j].name;
            if (replaceExpKeyFrom && replaceExpKeyTo != null && replaceExpKeyFrom != '__RequestVerificationToken') {
                chName = chName.replace(replaceExpKeyFrom, replaceExpKeyTo);
            }
            checkboxes[chName] = dataInputs[j];
        }
    }
    for (var i = 0; i < dataInputs.length; i++) {
        if ($(dataInputs[i]).attr('notposted') || $(dataInputs[i]).hasClass('autocompliteValidateField'))
            continue;
        var item = {};
        var name = dataInputs[i].name;
        if (replaceExpKeyFrom && replaceExpKeyTo != null) {
            name = name.replace(replaceExpKeyFrom, replaceExpKeyTo);
        }
        if (!$(dataInputs[i]).is(':checkbox') && checkboxes[name])
            continue;
        item[name] = elma.dynamics.GetInputValue($(dataInputs[i]));
        postData = jQuery.extend(true, postData, item);
    }
    return postData;
};
elma.dynamics.postDataToHiddens = function (selector, target, clearTo, ignorRequestVerificationToken) {
    if ($(selector).length == 0 || $(target).length == 0)
        return;
    if (clearTo) {
        $(target).empty();
    }
    var postData = elma.dynamics.getPostData(selector);
    for (var key in postData) {
        if (ignorRequestVerificationToken && key === "__RequestVerificationToken") {
            continue;
        }
        var impt = $('<input/>').attr('name', key).attr('type', 'hidden').val(postData[key]);
        $(target).append(impt);
    }
};
elma.dynamics.update = function (containerId, postData, callback, options) {
    if (!postData) {
        postData = {};
    }
    if (!options) {
        options = { setFocus: true };
    }
    var container = $("#" + containerId);
    container.blur();
    var dataInputs = $("input[name^='" + containerId + ".']");
    for (var i = 0; i < dataInputs.length; i++) {
        var dataItemName = dataInputs[i].name.substr(containerId.length + 1);
        var item = {};
        item[dataItemName] = elma.dynamics.GetInputValue($('#' + dataInputs[i].id)); //dataInputs[i].value;
        postData = jQuery.extend(true, postData, item);
    }
    postData = jQuery.extend(true, postData, { ViewId: containerId });
    var form = container.attr("dataform");
    if (form && form.length > 0)
        postData = jQuery.extend(true, postData, elma.dynamics.serializeForm(form));
    var dynamicUrl = container.attr("dynamicUrl");
    var method = container.attr("method");
    var dynamicLoadComplete = container.attr("dynamicLoadComplete");
    var token = container.attr("requestVerificationToken");
    
    $.ajax({
        global: true,
        cache: false,
        type: method,
        url: dynamicUrl,
        data: postData,
        headers : { "__RequestVerificationToken":  token },
        dataType: 'html',
        success: function (data) {
            container.html(data);
            container.attr('loaded', '1');
            elma.bind(containerId);
            elma.bindAjaxForms(containerId);
            elma.InitTranslation(containerId);
            if (options.setFocus) {
                elma.setDefaultInput(container);
            }
            if (dynamicLoadComplete != null) eval(dynamicLoadComplete);
            if (typeof callback == 'function') callback(containerId, postData);
        },
        error: function (data) {
            container.html(SR.T("Не удалось загрузить данные: ") + data.statusText + " (" + data.status + ")");
        }
    });
};
elma.dynamics.bind = function () {
    $('div[dynamicLoadModePanel="1"][AjaxBind!="true"]').each(function (i, a) {
        $(a).attr("AjaxBind", "true");
        $(a).show();
        elma.dynamics.update($(a).attr('id'));
    });
    $('div[dynamicLoadModePanel="2"][AjaxBind!="true"]').each(function (i, a) {
        $(a).attr("AjaxBind", "true");
        $(a).hide();
    });
};

elma.dynamics.globalEvents = {
    onToggle: function (fn) {
        $(document).bind('elma_dynamics_toggle', fn);
    },
    toggleExecute: function () {
        $(document).trigger('elma_dynamics_toggle');
    },
    onPopupOpen: function (fn) {
        $(document).bind('elma_dynamics_popupOpen', fn);
    },
    popupOpenExecute: function () {
        $(document).trigger('elma_dynamics_popupOpen');
    }
};

elma.dynamics.toggle = function (id, imgclose, imgopen, headerTextId, textopen, textclose, callback, options) {
    if ($('#' + id).is(':hidden')) {
        $('#' + id).show();
        elma.dynamics.loadOnce(id, null, callback, options);
        if (imgclose) {
            $('#' + imgclose).show();
        }
        if (imgopen) {
            $('#' + imgopen).hide();
        }
        if (headerTextId && textclose && textopen) {
            $('#' + headerTextId).html(textclose);
        }
        elma.dynamics.globalEvents.toggleExecute();
        return true;
    }
    else {
        $('#' + id).hide();
        if (imgclose) {
            $('#' + imgclose).hide();
        }
        if (imgopen) {
            $('#' + imgopen).show();
        }
        if (headerTextId && textclose && textopen) {
            $('#' + headerTextId).html(textopen);
        }
        elma.dynamics.globalEvents.toggleExecute();
        return false;
    }
};
elma.dynamics.statictoggle = function (id, imgclose, imgopen) {
    if ($('#' + id).is(':hidden')) {
        $('#' + id).show();
        if (imgclose) {
            $('#' + imgclose).show();
        }
        if (imgopen) {
            $('#' + imgopen).hide();
        }
        elma.dynamics.globalEvents.toggleExecute();
        return true;
    }
    else {
        $('#' + id).hide();
        if (imgclose) {
            $('#' + imgclose).hide();
        }
        if (imgopen) {
            $('#' + imgopen).show();
        }
        elma.dynamics.globalEvents.toggleExecute();
        return false;
    }
};
elma.dynamics.staticToggleByClass = function (cls, imgclose, imgopen) {
    if ($('.' + cls + ':hidden').length > 0) {
        $('.' + cls).each(function (i, a) {
            $(a).show(); 
        });
        if (imgclose) {
            $('#' + imgclose).show();
        }
        if (imgopen) {
            $('#' + imgopen).hide();
        }
        return true;
    }
    else {
        $('.' + cls).each(function (i, a) {
            $(a).hide();
        });
        if (imgclose) {
            $('#' + imgclose).hide();
        }
        if (imgopen) {
            $('#' + imgopen).show();
        }
        return false;
    }
};
elma.dynamics.staticToggleColumnPanelViewItem = function (tr, e) {
    if (!e) e = window.event;
    if (e) {
        var tgt = e.target || e.srcElement;
        if (tgt.nodeName == 'A')
            return;
    }
    var collapsed = $(tr).attr('collapsed');
    var id = $(tr).attr('panelId');
    var saveState = $(tr).attr('saveState');
    $(tr).nextUntil('[panelId="' + id + '"]')
        .andSelf()
        .each(function () {
            if ($(tr)[0] == this) {
                if (collapsed == 1) {
                    $(this).attr('collapsed', 0);
                    $(this).find('.collapseImage[panelId="' + id + '"]').show();
                    $(this).find('.expandImage[panelId="' + id + '"]').hide();
                } else {
                    $(this).attr('collapsed', 1);
                    $(this).find('.collapseImage[panelId="' + id + '"]').hide();
                    $(this).find('.expandImage[panelId="' + id + '"]').show();
                }
                if (saveState == 1) {
                    elma.dynamics.saveState(id, collapsed == 1);
                }
            } else {
                var hideCount = $(this).attr('hideCount');
                if (hideCount === undefined)
                    hideCount = 0;
                if (collapsed == 1) {
                    if (hideCount > 0)
                        hideCount = hideCount / 1 - 1;
                    if (hideCount == 0)
                        $(this).removeClass('tr-hidden');
                } else {
                    if (hideCount == 0)
                        $(this).addClass('tr-hidden');
                    hideCount = hideCount / 1 + 1;
                }
                $(this).attr('hideCount', hideCount);
            }
        });
};
elma.dynamics.showColumnPanelViewItem = function (tr) {
    var hideCount = $(tr).attr('hideCount');
    if (hideCount === undefined || hideCount == 0)
        return;
    var item = $(tr).prev();
    while (item.length) {
        var collapsed = item.attr('collapsed');
        if (collapsed == 1) {
            elma.dynamics.staticToggleColumnPanelViewItem(item);
        }
        item = item.prev();
    }
};
elma.dynamics.showTabPanelViewItem = function(contentPanelDiv) {    
    var tabstrip = $(contentPanelDiv).parent().data("tTabStrip");
    var index = tabstrip.$contentElements.index($(contentPanelDiv));
    var item = $("li", tabstrip.element)[index];
    tabstrip.select(item);
};
elma.dynamics.saveState = function (panel, state) {
    $.ajax({
        global: false,
        dataType: 'json',
        type: 'GET',
        url:  window.BaseUrl + 'SDK.Action/Personalization/SaveCollapsiblePanelState?panel=' + panel + '&stateValue=' + state,
        success: function () { }
    });
};
$(document).ready(function () {
    elma.dynamics.bind();
});


elma.dynamicForms = function () {
};

elma.dynamicForms.afterUpdateActions = [];

elma.dynamicForms.bindParentFormData = function (data, form, prefix, parentFormIdValue, parentPropertyFieldIdValue) {
    var parentFormId = parentFormIdValue || form.find(':input[name=\'__DynamicFormSettings.ParentFormId\']').val();
    if (!!parentFormId && parentFormId != form[0].id) {
        var parentForm = $('#' + parentFormId);
        add_formsvalid(form);
        if (!!parentForm) {
            var modelPrefix = '';
            var parentPropertyFieldId = parentPropertyFieldIdValue || form.find(':input[name=\'__DynamicFormSettings.ParentPropertyFieldId\']').val();
            var jsonFieldName = null;
            if (!!parentPropertyFieldId) {
                jsonFieldName = $('#' + parentPropertyFieldId).attr('name');
                if (jsonFieldName) {
                    var lastIndex = jsonFieldName.lastIndexOf('.');
                    if (lastIndex > 0) {
                        jsonFieldName = jsonFieldName.substring(0, lastIndex);
                        var targetJsonState = parentForm.find(':input[name=\'' + jsonFieldName + '.__jsonState\']');
                        var parentDynamicForm = targetJsonState.parent();
                        modelPrefix = parentDynamicForm.find(':input[name=\'__DynamicFormSettings.HtmlPrefix\']').val();
                        if (jsonFieldName == modelPrefix) {
                            jsonFieldName = null;
                        }
                    } else {
                        jsonFieldName = null;
                    }
                }
            }

            elma.dynamicForms.bindFormData(data, parentForm, prefix + 'Parent.', jsonFieldName, modelPrefix);
        }
    }
}

elma.dynamicForms.bindFormData = function (data, form, prefix, acceptedModelPrefix, additionalModelPrefix) {
    var arr = elma.serializeFormToArray(form);
    add_formsvalid(form);
    var modelPrefix = !!acceptedModelPrefix ? acceptedModelPrefix : !!additionalModelPrefix ? additionalModelPrefix : form.find(':input[name=\'__DynamicFormSettings.HtmlPrefix\']').val();
    if (!!modelPrefix) {
        modelPrefix = modelPrefix + '.';
    } else {
        modelPrefix = '';
    }
    var values = {};
    var setValues = function (valueList) {
        for (var i = 0; i < valueList.length; i++) {
            var name = valueList[i].name;
            if (!name) {
                continue;
            }
            if (!!acceptedModelPrefix && name.indexOf(acceptedModelPrefix + '.') != 0) {
                continue;
            }
            if (!!modelPrefix && name.indexOf(modelPrefix) == 0) {
                name = name.substring(modelPrefix.length);
            }
            name = prefix + name;
            if (!values[name] || values[name] != 'true') {
                values[name] = valueList[i].value;
            }
        }
    }
    setValues(arr);    
 
    //достаем необходимую динамическую формы и забираем из неё данные
    if (!!additionalModelPrefix) {
        additionalModelPrefix = additionalModelPrefix + '.';
    } else {
        additionalModelPrefix = '';
    }
    var targetJsonState = form.find(':input[name=\'' + additionalModelPrefix + '__jsonState\']');
    var parentDynamicForm = $(targetJsonState[0]).parent();
    setValues(elma.serializeFormToArray(parentDynamicForm));

    var resultArr = $.map(values, function (value, key) { return { name: key, value: value }; });
    for (var i in resultArr) {
        data.push(resultArr[i]);
    }
    elma.dynamicForms.bindParentFormData(data, form, prefix);
}
var formsvalid = [];

function add_formsvalid(form) {
    try {
        var valid = form.validate();
        formsvalid.push(valid);
    } catch(e) {
    }
}

elma.dynamicForms.getForm = function (sender, selector) {
    var form = null;
    if (!!selector) {
        form = $(sender).closest(selector);
        if (form.length > 0) {
            return form;
        }
    }

    form = $(sender).closest('form');
    if (form.length == 0) {
        form = $(sender).closest('div[type=dynamicForm');
    }
    return form;
}

elma.dynamicForms.onChange = function (sender, propertyName, scriptName, form) {
    elma.dynamicForms.dynamicFormChange(sender, propertyName, scriptName, form, 'SDK.Action/DynamicForms/ProcessPropertyValueChanged/', false, false);
};

elma.dynamicForms.onClick = function (sender, propertyName, scriptName, form, controllerName, outputCancel, userFunc) {
    if (!!scriptName) {
        elma.dynamicForms.dynamicFormChange(sender, propertyName, scriptName, form, controllerName, true, outputCancel, userFunc);
    } else {
        checkAndSubmit($(form).closest('form'), outputCancel);
    }
};

elma.dynamicForms.dynamicFormChange = function (sender, propertyName, scriptName, form, controllerName, isConnectorScript, outputCancel, userFunc) {
    if ((!sender || !sender.target) && !form) {
        return;
    }
    if (sender && sender.target)
        $(sender.target).data("onChange", true);
    elma.openPleaseWait(true, SR.T('Обработка изменений'));
    var selector = 'div[type=dynamicForm]';
    if (form)
        form = $(form);
    else
        form = elma.dynamicForms.getForm(sender.target, selector);
    var mainForm = $(form).closest('form');
    add_formsvalid(mainForm);
    var postData = elma.serializeFormToArray(form, selector);

    //это поле лежит на главное форме, добавляем его отдельно
    var addJson = mainForm.find("input[name='__DynamicFormSettings.ViewTransformationAdditionalJson']").val();
    if (addJson) {
        postData.push({ name: "__DynamicFormSettings.ViewTransformationAdditionalJson", value: addJson });
    }

    postData.push({ name: "__DynamicFormSettings.ChangedPropertyName", value: propertyName });
    if (!!scriptName) {
        postData.push({ name: "__DynamicFormSettings.ScriptName", value: scriptName });
    }

    var htmlPrefix = form.find("input[name='__DynamicFormSettings.HtmlPrefix']").val();
    elma.dynamicForms.bindParentFormData(postData, form, htmlPrefix + '.');

    var editMode = form.data('EditMode');
    if (!!editMode) {
        postData.push({ name: "__DynamicFormSettings.FormEditMode", value: editMode });
    }
    if (!!$.telerik.grid.lastTemporaryId) {
        postData.push({ name: "__DynamicFormSettings.TablePartLastTemporaryId", value: $.telerik.grid.lastTemporaryId });
    }

    elma.dynamicForms.afterUpdateActions = [];
    var modelPrefix = '';
    if (!!sender && !!sender.target) {
        var parentDynamicForm = $(sender.target).closest(selector);
        modelPrefix = $(parentDynamicForm).find("input[name='__DynamicFormSettings.HtmlPrefix']").val();
    }

    $.ajax({
        global: true,
        cache: false,
        type: 'POST',
        url: window.BaseUrl + controllerName,
        data: postData,
        dataType: 'html',
        success: function (data) {
            var needClosePleaseWait = true;
            var hideBlocker = true;
            try {
                if (data) {
                    var jsonData = eval('(' + data + ')');
                    var res = elma.dynamicForms.processResults(form, jsonData, modelPrefix);
                    if (res) {
                        needClosePleaseWait = false;
                    }

                    elma.dynamicForms.renderNotifyMessages(mainForm, jsonData.NotifyMessages);

                    if (isConnectorScript) {
                        hideBlocker = jsonData.Error;
                        if (!hideBlocker) {
                            if (userFunc) {
                                userFunc();
                            } else {
                                checkAndSubmit(mainForm, outputCancel);
                            }
                            hideBlocker = !mainForm.valid();
                        }
                    }
                }
            } finally {
                if (needClosePleaseWait) {
                    elma.closePleaseWait(hideBlocker);
                }
                if (sender && sender.target) {
                    $(sender.target).data("onChange", null);
                    if ($(sender.target).data("onEnter")) {
                        $(sender.target).data("onEnter", null);
                        $(sender.target).closest('tr.t-grid-edit-row').find('.t-grid-update, .t-grid-insert').click();
                    }
                }
            }
        },
        error: function (data) {
            elma.closePleaseWait(true);
            if (sender && sender.target)
                $(sender.target).data("onChange", null);
        }
    });
};

elma.dynamicForms.processResults = function (form, jsonData, modelPrefix, rootForm) {
    // TablePart - LastTemporaryId
    add_formsvalid(form);
    if (jsonData.TablePartLastTemporaryId) {
        $.telerik.grid.setLastTemporaryId(jsonData.TablePartLastTemporaryId);
    }
    if (jsonData.ExtendedData && jsonData.ExtendedData.RedirectUrl) {
        document.location = jsonData.ExtendedData.RedirectUrl;
        return true;
    }

    rootForm = rootForm || form;
    // Entity state
    var htmlPrefix = !!modelPrefix ? modelPrefix : rootForm.find("input[name='__DynamicFormSettings.HtmlPrefix']").val();
    var jsonStateFieldName = htmlPrefix + (htmlPrefix ? "." : "") + "__jsonState";
    var jsonStateField = rootForm.find("input[name='" + jsonStateFieldName + "']");
    jsonStateField.val(jsonData.ModelJsonState);
    //динамическая форма, в которой лежит данное поле
    var parentDynamicForm = $(jsonStateField).parent();

    // View transformation
    //трансформацию нужно положить в именно в ту форму, из которой вызывылася скрипт
    parentDynamicForm.find("input[name='__DynamicFormSettings.ViewTransformationJson']").val(jsonData.ViewTransformation);
    //это же поле как забирлось из главной формы, так там и должно остаться
    form.find("input[name='__DynamicFormSettings.ViewTransformationAdditionalJson']").val("");
    // Value, caption & description
    if (jsonData && jsonData.Properties) {
        for (i in jsonData.Properties) {
            var p = jsonData.Properties[i];
            if (p.Value !== null) {
                if (typeof tinymce == 'object') {
                    var toremove = [];
                    for (var i = 0; i < tinymce.editors.length; i++) {
                        if ($('#' + p.Id + '_ValueContainer').find('textarea#' + tinymce.editors[i].id).length > 0) {
                            toremove.push(tinymce.editors[i]);
                        }
                    }
                    for (var i = 0; i < toremove.length; i++) {
                        tinymce.EditorManager.remove(toremove[i]);
                    }
                }
                $('#' + p.Id + '_ValueContainer').html(p.Value);
            }
            if (p.Caption !== null) $('#' + p.Id + '_CaptionContainer').html(p.Caption);
            if (p.Description !== null) $('#' + p.Id + '_DescriptionContainer').html(p.Description);
        }
    }
    // Visibility
    if (jsonData && jsonData.PropertiesVisibility) {
        for (id in jsonData.PropertiesVisibility) {
            $('#' + id + '_Container').css('display', jsonData.PropertiesVisibility[id] ? '' : 'none');
            $('#' + id + '_ValueContainer').css('display', jsonData.PropertiesVisibility[id] ? '' : 'none');
            $('#' + id + '_CaptionContainer').css('display', jsonData.PropertiesVisibility[id] ? '' : 'none');
            $('#' + id + '_DescriptionContainer').css('display', jsonData.PropertiesVisibility[id] ? '' : 'none');
        }
    }
    // Validation
    if (jsonData.ValidationMetadata) {
        // Merge startup validation with received validation metadata
        var validationContext = jsonData.ValidationMetadata;
        var formId = validationContext.FormId;
        var mergedFields = [];
        var startupValidationItem = elma.ValidationRulesManager.getFormStartupValidation(formId);
        if (startupValidationItem) {
            mergedFields = $.merge(mergedFields, startupValidationItem.Fields);
        }
        mergedFields = $.merge(mergedFields, validationContext.Fields);

        // Remove duplicates (use only last validation data for each field)
        var temp = {};
        for (var i = 0; i < mergedFields.length; i++) {
            var fieldName = mergedFields[i].FieldName;
            if (!!fieldName) {
                temp[fieldName] = mergedFields[i];
            }
        }
        mergedFields = [];
        var vPostfix = '_validate';
        for (var key in temp) {
            var vPostfixIndex = key.indexOf(vPostfix);
            var noPostfixLength = key.length - vPostfix.length;
            // Don't push field 'field1_validate' if field 'field1' exists
            if (noPostfixLength <= 0 || vPostfixIndex < noPostfixLength || !temp[key.substring(0, noPostfixLength)]) {
                mergedFields.push(temp[key]);
            }
        }

        if (startupValidationItem) {
            elma.ValidationRulesManager.setFormStartupValidation(formId, { FormId: formId, Fields: mergedFields });
        }
        var mergedMetadata = { FormId: formId, Fields: mergedFields };
        var theForm = $("#" + formId);
        add_formsvalid(theForm);
        if (theForm.length)
            theForm.removeValidator();
        __MVC_EnableClientValidation(mergedMetadata);
    }
    while (elma.dynamicForms.afterUpdateActions.length) {
        var f = elma.dynamicForms.afterUpdateActions.pop();
        f();
    }
    // Re-trigger validation of inputs changed by script
    if (jsonData && jsonData.PropertiesValidation) {
        setTimeout(function () {
            for (id in jsonData.PropertiesValidation) {
                var inputElement = $('#' + jsonData.PropertiesValidation[id]);
                var inputValidateElement = $('#' + jsonData.PropertiesValidation[id] + vPostfix);
                if (inputValidateElement.length) {
                    inputValidateElement.valid();
                }
                else if (inputElement.length) {
                    inputElement.valid();
                }
            }
        }, 50);
    }
};

elma.dynamicForms.renderNotifyMessages = function (form, messages) {
    var parentForm = form.parent().closest('form');
    if (parentForm.length !== 0) {
        form = parentForm;
    }

    var localMessages = form.find('#local-messages');
    if (localMessages.length === 0) {
         $(form).prepend("<table style='width: 100%;'><tr style='display: run-in'><td class='local-messages'><div id='local-messages'></div></td></tr></table>");
         localMessages = form.find('#local-messages');
    }

    localMessages.html(messages);
    var atts = localMessages.parent().parent()[0];
    if (atts) {
        var styleAttr = atts.attributes.getNamedItem('style');
        if (messages) {
            styleAttr.value = 'display: run-in';
        } else {
            styleAttr.value = 'display: none';
        }
    }
};



elma.changeTablePartPropertyDynamic = function (sender, propertyName, scriptName, settings) {
    elma.openPleaseWait(true, SR.T('Обработка изменений'));
    settings = JSON.parse(settings);
    var currentTarget = sender.currentTarget;
    var form = $(currentTarget).closest('div.t-grid-content');
    var targetName = currentTarget.name;
    elma.changeTablePartProperty(sender, settings.expression, settings.dataItemId);
    form = $(form);
    var mainForm = form.closest('form');
    var postData = elma.serializeFormToArray(form, 'div.t-grid-content');

    postData.push({ name: "Id", value: settings.dataItemId });
    postData.push({ name: "TypeUid", value: settings.typeUid });
    postData.push({ name: "__DynamicFormSettings.FormEditMode", value: "Column" });
    postData.push({ name: "__DynamicFormSettings.ScriptName", value: scriptName });
    postData.push({ name: "__DynamicFormSettings.ChangedPropertyName", value: propertyName });
    postData.push({ name: "__DynamicFormSettings.FormId", value: settings.formId });
    postData.push({ name: "__DynamicFormSettings.ParentPropertyFieldId", value: settings.parentPropertyFieldId });
    postData.push({ name: "__DynamicFormSettings.ViewItemUid", value: settings.viewItemUid });
    postData.push({ name: "__DynamicFormSettings.ParentFormId", value: settings.parentFormId });
    var addJson = mainForm.find("input[name='__DynamicFormSettings.ViewTransformationAdditionalJson']").val();
    if (addJson) {
        postData.push({ name: "__DynamicFormSettings.ViewTransformationAdditionalJson", value: addJson });
    }
    var viewItemId = mainForm.find("input[name='__DynamicFormSettings.ViewItemId']").val();
    if (viewItemId) {
        postData.push({ name: "__DynamicFormSettings.ViewItemId", value: viewItemId });
    }
    var viewProviderId = mainForm.find("input[name='__DynamicFormSettings.ViewProviderUid']").val();
    if (viewProviderId) {
        postData.push({ name: "__DynamicFormSettings.ViewProviderUid", value: viewProviderId });
    }
    var dynamicFormsProviderData = mainForm.find("input[name='__DynamicFormSettings.DynamicFormsProviderData']").val();
    if (dynamicFormsProviderData) {
        postData.push({ name: "__DynamicFormSettings.DynamicFormsProviderData", value: dynamicFormsProviderData });
    }
    var dynamicFormsProviderUid = mainForm.find("input[name='__DynamicFormSettings.DynamicFormsProviderUid']").val();
    if (dynamicFormsProviderUid) {
        postData.push({ name: "__DynamicFormSettings.DynamicFormsProviderUid", value: dynamicFormsProviderUid });
    }
    if (!!$.telerik.grid.lastTemporaryId) {
        postData.push({ name: "__DynamicFormSettings.TablePartLastTemporaryId", value: $.telerik.grid.lastTemporaryId });
    }

    elma.dynamicForms.bindParentFormData(postData, form, '', settings.parentFormId, settings.parentPropertyFieldId);

    var parentDynamicForm = $(sender.target).closest('div[type=dynamicForm]');
    var modelPrefix = $(parentDynamicForm).find("input[name='__DynamicFormSettings.HtmlPrefix']").val();
    var rootForm = $('#' + settings.parentFormId);

    $.ajax({
        global: true,
        cache: false,
        type: 'POST',
        url: window.BaseUrl + 'SDK.Action/DynamicForms/ProcessPropertyValueChanged',
        data: postData,
        dataType: 'html',
        success: function (data) {
            var needClosePleaseWait = true;
            try {
                if (data) {
                    var jsonData = eval('(' + data + ')');
                    var res = elma.dynamicForms.processResults(form, jsonData, modelPrefix, rootForm);
                    if (res) {
                        needClosePleaseWait = false;
                    }
                }
            } finally {
                if (needClosePleaseWait) {
                    elma.closePleaseWait(true);
                }
                if (sender && sender.target) {
                    $(sender.target).data("onChange", null);
                    if ($(sender.target).data("onEnter")) {
                        $(sender.target).data("onEnter", null);
                        $(sender.target).closest('tr.t-grid-edit-row').find('.t-grid-update, .t-grid-insert').click();
                    }
                }
            }
        },
        error: function (data) {
            elma.closePleaseWait(true);
            if (sender && sender.target)
                $(sender.target).data("onChange", null);
        }
    });
}

elma.changeTablePartProperty = function (e, expression, dataItemId) {
    var currentTarget = e.currentTarget;
    var requiredSpan = $("#" + currentTarget.id).closest('div[Id*="_ValueContainer"]').find('span.requiredField');
    var form = $(currentTarget).closest('div.t-grid-content');
    var grid = $(form).parent().data('tGrid');
    var blockInput = $('#' + grid.jsonDataHiddenFieldId);
    var gridJsonState = JSON.parse(blockInput.val());
    var targetType = getTargetType(currentTarget, expression);
    var value = getTargetValue(currentTarget, targetType);
    if (requiredSpan.length) {
        if (!isEmpty(value)) {
            requiredSpan.removeClass('grid-empty-value');
            requiredSpan.parent().closest('td').removeClass('grid-empty-cell');
        }
        else {
            requiredSpan.addClass('grid-empty-value');
        }
        blockInput.valid();
    }

    // сперва Id изменённого объекта ищем в добавленных
    var added = gridJsonState.Added;
    if (added !== undefined) {
        for (var i = 0; i < added.length; i++) {
            var addedObj = added[i];
            if (addedObj.Id == dataItemId) {
                // если нашли - обновляем список добавленных
                addedObj[expression] = value;
                blockInput.attr('value', JSON.stringify(gridJsonState));
                return;
            }
        }
    }

    // потом уже начинаем работать со списком изменённых
    var changed = gridJsonState.Changed;
    
    var o = {};
    if (changed != undefined) {
        var isInArray = false;
        for (var j = 0; j < changed.length; j++) {
            var changedObj = changed[j];
            if (changedObj.Id == dataItemId) {
                isInArray = true;
                changedObj[expression] = value;
            }
        }
        if (isInArray == false) {
            o["Id"] = dataItemId;
            o[expression] = value;
            changed.push(o);
        }
        blockInput.attr('value', JSON.stringify(gridJsonState));
    }
    else {
        o["Id"] = dataItemId;
        o[expression] = value;
        gridJsonState.Changed = new Array(o);
        blockInput.attr('value', JSON.stringify(gridJsonState));
    }
}

function getTargetType(currentTarget, expression) {
    var targetType = currentTarget.type;
    if (currentTarget.id.endsWith(expression + '_date') || currentTarget.id.endsWith(expression + '_time')) {
        targetType = "dateTime";
    }
    return targetType;
}

function getTargetValue(currentTarget, targetType) {
    switch (targetType) {
        case "checkbox":
            return currentTarget.checked;
        case "radio":
            if ($(currentTarget).attr("nullable") && !currentTarget.checked) {
                return "";
            } else {
                return currentTarget.value;
            }
        case "dateTime":
            var idhidden = '#' + currentTarget.id.substring(0, currentTarget.id.length - 5);
            if ($(idhidden)) {
                var dateObject = Date.parse($(idhidden).val());
                if (dateObject == null)
                    return "";
                var dateValue = $.telerik.formatString('{0:MM/dd/yyyy HH:mm:ss}', dateObject);
                return dateValue;
            }
            return "";
        default:
            var textBox = $(currentTarget).data('tTextBox');
            if (!!textBox) {
                var texBoxVal = textBox.value();
                return texBoxVal == null ? "" : texBoxVal.toString();
            }
            return currentTarget.value;
    }
}


function refreshGrid(id, callback) {
    if ($('#' + id).length == 0)
        return;
    var grid = $("#" + id).data("tGrid");
    if (callback) {
        grid.onDataBound = callback;
    }
    grid.ajaxRequest();
}

function refreshGrid(id, callback, additionalData) {
    if ($('#' + id).length == 0)
        return;
    var grid = $("#" + id).data("tGrid");
    if (callback) {
        grid.onDataBound = callback;
    }
    grid.ajaxRequest(additionalData);
}

function applyFilterGrid(id, form, callback, replaceFrom, replaceTo, noNavigate) {
    if ($('#' + id).length == 0)
        return;
    var grid = $("#" + id).data("tGrid");
    if (form == undefined || form == null)
        form = "FilteringGridForm";
    if (callback) {
        grid.onDataBound = callback;
    }
    grid.applyDataFilter(form, noNavigate, replaceFrom, replaceTo);
}

function dataBindGrid(id, data, total) {
    if (!$('#' + id).length)
        return;
    var grid = $("#" + id).data("tGrid");
    grid.total = total || 0;
    grid.dataBind(data || []);
}

function doCommandGridRows(id, commandName, ids, url, data, container) {
    if ($('#' + id).length == 0)
        return;
    var grid = $("#" + id).data("tGrid");
    var e = {
        page: grid.currentPage,
        sortedColumns: grid.sorted,        
        filteredColumns: $.grep(grid.columns, function (column) {
            return column.filters;
        })
    };

    if ($.telerik.trigger(grid.element, 'dataBinding', e))
        return;

    if (!grid.ajax && !grid.ws)
        return;

    grid.showBusy();

    var deleteData = $.extend({}, e.data, grid.dataFilter);
    deleteData = $.extend(deleteData, { CommandName: commandName, Ids: ids });

    if (data) {
        deleteData = $.extend(deleteData, data);
    }

    if (container) {
        var dataFilter = [];
        var fields = $(container).serializeArray();
        $.each(fields, $.proxy(function (_, field) {
            dataFilter[field.name] = field.value;
        }));
        deleteData = $.extend(deleteData, dataFilter);
    }

    deleteData = $.extend(deleteData, { gridId: id });
    $.ajax(grid.ajaxOptions({
        traditional: true,
        data: deleteData,
        url: url
    }));
}


function gridSettingsMoveFromTo(idleftvals, idrightvals, jsonleftid, jsonrightid, hideRemainingError) {
    var idleft = idleftvals + "List";
    var idright = idrightvals + "List";
    var leftselector = '#' + idleft;    
    var rightselector = '#' + idright;
    var selectedItems = $(leftselector + ' :selected');

    var selectedCount = $(leftselector).prop('length');
    if (selectedCount > 0) {
        var selectedRemaining = selectedCount - selectedItems.length;
        var leftparts = idleftvals.split('_');
        var leftname = leftparts[leftparts.length - 1];
        if (hideRemainingError !== true && leftname == 'SelectedColumns' && selectedRemaining < 1) {
            jAlert(SR.T("В выбранных полях должно быть не менее одной колонки"), SR.T("Ошибка"));
            return;
        }
    }
    
    if (jsonleftid && jsonrightid) {
        var dataLeft = JSON.parse($('#' + jsonleftid).val());
        var dataRight = JSON.parse($('#' + jsonrightid).val());
        selectedItems.each(function (j, a) {
            var toRemove = new Array();
            for (var i = 0; i < dataLeft.length; i++) {
                if (dataLeft[i].Value == $(a).attr('value')) {
                    dataRight.push(dataLeft[i]);
                    toRemove.push(dataLeft[i]);
                }
            }
            for (var k = 0; k < toRemove.length; k++) {
                for (var t = 0; t < dataLeft.length; t++) {
                    if (dataLeft[t] == toRemove[k]) {
                        dataLeft.splice(t, 1);
                        break;
                    }
                }
            }
        });
        $('#' + jsonleftid).val(JSON.stringify(dataLeft));
        $('#' + jsonrightid).val(JSON.stringify(dataRight));

    }
    $(rightselector).append(selectedItems);
    gridSettingsUpdateSelected(idleftvals, jsonleftid);
    gridSettingsUpdateSelected(idrightvals, jsonrightid);
}

function gridSettingsMoveUp(idvals, jsonId) {
    var id = idvals + "List";
    var selector = '#' + id;
    $(selector + ' :selected').each(function (i, a) {
        $(a).prev().before(a);
    });
    gridSettingsUpdateSelected(idvals, jsonId);
}

function gridSettingsMoveDown(idvals, jsonId) {
    var id = idvals + "List";
    var selector = '#' + id;
    $(selector + ' :selected').reverse().each(function (i, a) {
        $(a).next().after(a);
    });
    gridSettingsUpdateSelected(idvals, jsonId);
}

function gridSettingsUpdateSelected(id, jsonid) {
    var idvals = '#' + id + 'Values';
    var idsel = '#' + id + 'List';
    if ($(idsel).length > 0) {
        $(idvals).empty();
        var selname = $(idsel).attr('customname');
        if (selname.substr(0, 15) == 'Personalization')
            selname = selname.replace('List', '');
        else
            selname = id.replace(/_/g, '.');

        if (jsonid) {
            var oldVal = JSON.parse($('#' + jsonid).val());
            var newVal = [];

            $(idsel).find('option').each(function (i, a) {
                var uid = $(a).val();
                var newItem = $.grep(oldVal, function (e) { return e.Value == uid; })[0];
                if (newItem) newVal.push(newItem);
            });

            $(idvals).append('<input type="hidden" name="' + selname + '" />')
                .find('[name="' + selname + '"]')
                .val(JSON.stringify(newVal));
        }
        else {
            var options = $(idsel + ' option');
            options.each(function(i, a) {
                $(idvals).append('<input type="hidden" name="' + selname + '[' + i + '].Value" value="' + $(a).val() + '"/>');
                $(idvals).append('<input type="hidden" name="' + selname + '[' + i + '].Text" value="' + $(a).text() + '"/>');
            });
        }
    }
}

function gridSettingsViewTypeObject(avalId, jsonid, id) {
    var idsel = '#' + avalId;
    $(idsel).empty();
    var data = JSON.parse($('#' + jsonid).val());
    var dataSort = doSortSelectByValue(data, "sortIndex");

    //    if (id) {
    $(dataSort).each(function (i, a) {
        var sortIndex = $(a).attr('sortIndex');
        var value = $(a).attr('Value');
        var text = $(a).attr('Text');
        var metadataChildList = $(a).attr('metadataChildList');
        var typeUid = $(a).attr('typeUid');
        var sortable = $(a).attr('sortable');
        var option = '<option value="' + value + '" sortIndex="' + sortIndex + '" metadata="' + typeUid + '" metadataChild="' + metadataChildList + '"tooltip = "' + text + '" sortable="' + sortable + '" >' + text + '</option>'; //+ '" tooltiptext="' + text
        if (id) {
            if (metadataChildList != undefined && (metadataChildList.indexOf(id) != -1 || typeUid == id)) {
                $(idsel).append(option);
            }
        } else {
            $(idsel).append(option);
        }

    });
}


function doSortSelectByValue (data, attrSort) {

    var sortedVals = $(data).sort(function (a, b) {
        return $(a).attr(attrSort) > $(b).attr(attrSort) ? 1 : $(a).attr(attrSort) < $(b).attr(attrSort) ? -1 : 0;
    });

    return sortedVals;
}

function initQTipGridSettings(idSelect) {
    $("div[id*='ui-tooltip']").empty();
    
    if (idSelect == undefined) return;
    var items = $('#' + idSelect + ' option');

    items.each(function (i, a) {

        var text = $(a).attr('tooltip');
       
        var conf = {
            content: {
                text: text
            },
            position: {
                my: 'top left',  // Position my top left...
                at: 'bottom right',
                viewport: true,
                target: 'mouse',
                adjust: { mouse: true, x: 10, y: 20 }
            }
        };
        $(a).qtip(conf);
    });
}

elma.touchcrutch = function (containerId) {
    var grid = $("#" + containerId);
    setTimeout(function() {
        if (grid.find(".t-grid-content").css("overflow") === "hidden") {
            var currentWidth = grid.width();
            var newWidth = ($("table[id^=" + containerId).width() + grid.find("div.t-grid-pager-container").width()) || 0;
            if (newWidth > 0 && currentWidth > newWidth) {
                grid.width(newWidth);
            }
        }
    }, 100);
}



elma.List2list = function () {

}

elma.List2list.IsRequiredColumn = function (a) {
    return $(a).attr('columnRequired') == 'true';
}

elma.List2list.prototype.Init = function () {
    $('#' + this.selectedListId)
        .delegate(this.itemSelector, 'dblclick', $.proxy(function (e) { if (!elma.List2list.IsRequiredColumn(e.currentTarget)) { this.RemoveItems($(e.currentTarget), $('#' + this.selectedListId)); } }, this))
        .delegate(this.itemSelector + ' > i', 'click', $.proxy(function (e) { this.RemoveItems($(e.currentTarget).parent('li'), $('#' + this.selectedListId)); }, this))
        .delegate(this.itemSelector, 'click', $.proxy(function (e) { this._itemClick(e); $("#" + this.availableListId + ' li').removeClass('selected'); }, this))
        .delegate('', 'click', $.proxy(function (e) { $(e.target).find("li").removeClass('selected'); $("#" + this.availableListId + ' li').removeClass('selected'); }, this))
        .sortable({
            appendTo: "body",
            start: $.proxy(function (e, ui) {
                $('#' + this.selectedListId).sortable("refresh");
                $('#' + this.selectedListId).bind("sortout", $.proxy(function (e1, ui1) {
                    $(ui1.item).data('onSelectedList', false);
                    $('#' + this.selectedListId + " .ui-sortable-placeholder").hide();
                }, this));
            }, this),
            helper: $.proxy(function (e, item) {
                $("#" + this.availableListId + ' li').removeClass('selected');
                return this._createHelper(item, true);
            }, this),
            cursorAt: { top: 10, left: 5 },
            stop: $.proxy(function (e, ui) {
                this.StopSortable(e, ui);
            }, this),
            cancel: '.visible-pages-splitter, .visible-pages-hint',
            over: $.proxy(function (e, ui) {
                $(ui.item).data('onSelectedList', true);
                $('#' + this.selectedListId + " .ui-sortable-placeholder").show();
            }, this),
            beforeStop: $.proxy(function (e, ui) {
                $('#' + this.selectedListId).unbind("sortout");
            }, this),

        });
    $('#' + this.selectedListId + ', #' + this.availableListId + ', #' + this.selectedListId + ' *, #' + this.availableListId + ' *')
        .attr('unselectable', 'on');
    $('#' + this.selectedListId + ' ' + this.itemSelector)
        .each(function (i, a) {
            if ($(a).find('i.del').length < 1 && !elma.List2list.IsRequiredColumn(a)) {
                $(a).append('<i class="del">&nbsp;</i>');
            }
        });
}

elma.List2list.prototype._createHelper = function (item, saveMultidragAndRemove) {
    if (!item.hasClass('selected')) {
        item.addClass('selected').siblings().removeClass('selected');
    }
    var elements = item.parent().children('.selected:visible').clone();
    var indexes = [];
    if (item.parent().attr('id') == this.selectedListId) {
        item.parent().children('li').each(function (i, e) {
            if ($(e).hasClass('selected')) {
                indexes.push(i);
            }
        })
    }
    if (saveMultidragAndRemove) {
        item.data('multidrag', elements).siblings('.selected:visible').remove();
        item.data('indexes', indexes);
    }
    var helper = $('<div/>').append(elements);
    if (elements.length > 1) {
        elements.hide();
        var msg = SR.T('Выбрано элементов: {0}', elements.length);
        var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
        if (translationMode)
            msg = elma.ProcessTranslationHtmlElement(null, msg);
        helper.append('<li class="list2listItem count"><span>' + msg + '</span></li>');
    }
    return helper;
}

elma.List2list.prototype._itemClick = function (e) {
    if ($(e.target).is('i.del') || ($(e.target).is('li') && $(e.target).hasClass('disabled')) || $(e.target).parent('li').hasClass('disabled'))
        return;
    if (e.ctrlKey || e.metaKey) {
        $(e.currentTarget).toggleClass("selected");
    }
    else if (e.shiftKey) {
        var lastSelected = $(e.currentTarget).siblings(".selected.lastSelected");
        if (lastSelected.length) {
            $(e.currentTarget).addClass("selected").siblings().removeClass('selected');
            ($(e.currentTarget).nextAll(".lastSelected").length
                ? $(e.currentTarget)
                    .nextUntil(lastSelected)
                    .andSelf()
                    .add(lastSelected)
                : $(lastSelected)
                    .nextUntil(e.currentTarget)
                    .andSelf()
                    .add(e.currentTarget)).filter('li:not(.disabled)').filter('li:not(.visible-pages-splitter)')
                .addClass("selected");
        } else {
            $(e.currentTarget).addClass("selected").siblings().removeClass('selected');
        }
    } else {
        $(e.currentTarget).addClass("selected").siblings().removeClass('selected');
    }
    $(e.currentTarget).addClass("lastSelected").siblings().removeClass('lastSelected');

}

elma.List2list.prototype.SelectItems = function (items, availableList, indexes) {
    var selectedList = $('#' + this.selectedListId);
    items.each(function (i, a) {
        var li = $(a);
        var thisId = li.attr('objectid');
        if ($('.visible-pages-counter.hidden').length == 1 && selectedList.children.length == 2) {
            selectedList.find('li[objectid="' + thisId + '"]').remove();
            selectedList.prepend(li);
        }
        if (selectedList.find('li[objectid="' + thisId + '"]').length == 0) {
            if (indexes == undefined || indexes[i] >= selectedList.children('li').length)
                selectedList.append(li);
            else {
                selectedList.children('li').each(function(j, e) {
                    if (indexes[i] == j) {
                        $(e).before(li);
                    }
                });
            }
        }
        var tooltiptext = li.attr('tooltiptext');
        if (tooltiptext) {
            li.qtip('destroy');
            elma.qtip(li, tooltiptext);
        }
        availableList.find('li[objectid="' + thisId + '"]').addClass('disabled');
    });
    this.UpdateInputs(selectedList);
    this.UpdateInputs(availableList);
    var onChangeSelectedItems = selectedList.data('onChangeSelectedItems');
    if (this.onChangeSelectedItems)
        this.onChangeSelectedItems();
}

elma.List2list.prototype.RemoveItems = function (items, selectedList) {
    var availableList = $('#' + this.availableListId);
    items.each(function (i, a) {
        var li = $(a);
        var thisId = li.attr('objectid');
        availableList.find('li[objectid="' + thisId + '"]').removeClass('disabled');
        selectedList.find('li[objectid="' + thisId + '"]').remove();
    });
    this.UpdateInputs(selectedList);
    this.UpdateInputs(availableList);
    var onChangeSelectedItems = selectedList.data('onChangeSelectedItems');
    if (this.onChangeSelectedItems)
        this.onChangeSelectedItems();

}

elma.List2list.prototype.UpdateInputs = function (list) {
    var hiddenInputId = list.attr('hiddenInputId');
    if (hiddenInputId) {
        var hiddenContainerId = list.attr('hiddenContainerId');
        if (hiddenContainerId) {
            var hiddenContainer = $('#' + hiddenContainerId);
            hiddenContainer.empty();
            list.find(' li:not(.disabled)').each(function (i, a) {
                hiddenContainer.append('<input type="hidden" name="' + hiddenInputId + '[' + i + '].Value" value="' + $(a).attr('objectid') + '"/>');
                var text = $(a).attr('thisectText');
                if (text)
                    hiddenContainer.append('<input type="hidden" name="' + hiddenInputId + '[' + i + '].Text" value="' + text + '"/>');
            });
        } else {
            var hiddenInput = $('#' + hiddenInputId);
            var newVal = [];
            list.find(' li:not(.disabled)').each(function (i, a) {
                var value = { Value: $(a).attr('objectid') };
                var text = $(a).attr('thisectText');
                if (text)
                    $.extend(value, { Text: text });
                newVal.push(value);
            });
            hiddenInput.val(JSON.stringify(newVal));
        }
    }
}

elma.List2list.prototype.StopSortable = function (e, ui) {
    var multidrag = $(ui.item).data('multidrag');
    var availableDrop = $(ui.item).data('availableDrop');
    var indexes = $(ui.item).data('indexes');
    if (availableDrop && multidrag) {
        this.RemoveItems(multidrag, $('#' + this.selectedListId));
        $(ui.item).remove();
    } else {
        this.ReturnToSelected(multidrag, ui, indexes);
    }
}

elma.List2list.prototype.ReturnToSelected = function (multidrag, ui, indexes) {
    if (multidrag && !$(ui.item).data('onSelectedList'))
        $("#" + this.selectedListId + " li.selected").remove();
    var items = multidrag ? multidrag : $("#" + this.availableListId + " li.selected:visible").clone();
    items.show().find('.count').remove();
    ui.item.after(items).remove();
    this.SelectItems(items, $('#' + this.availableListId), indexes);
}


/* Для меню */

elma.List2listMenu = function (availableListId, selectedListId) {
    this.selectedListId = selectedListId;
    this.availableListId = availableListId;
    $('#' + this.selectedListId).closest('tr').find('.folderContent').attr('id', this.availableListId);
    this.explorer = $('#' + $('#' + availableListId).closest('.pagesExplorer').attr('id'));
    this.itemSelector = 'li.list2listItem';
}

elma.List2listMenu.prototype = Object.create(elma.List2list.prototype);

elma.List2listMenu.prototype.Init = function () {
    elma.List2list.prototype.Init.call(this);
    $('#' + this.availableListId).closest('table')
        .delegate('.numOfVisiblePages', 'keyup', $.proxy(function (e) { this.VisiblePagesCountChanged(); }, this))
        .delegate('.numOfVisiblePages', 'click', $.proxy(function (e) { this.VisiblePagesCountChanged(); }, this));
    this.reinit.call(this);
    this.UpdateInputs($('#' + this.selectedListId));
    this.UpdateInputs($('#' + this.availableListId));
}

elma.List2listMenu.prototype.reinit = function () {
    $('#' + this.selectedListId).closest('tr').find('.folderContent').attr('id', this.availableListId);
    $('#' + this.availableListId)
    .delegate(this.itemSelector, 'dblclick', $.proxy(function (e) { this.SelectItems($(e.currentTarget).removeClass('selected').clone(), $('#' + this.availableListId)); }, this))
    .delegate(this.itemSelector, 'click', $.proxy(function (e) { this._itemClick(e); $("#" + this.selectedListId + ' li').removeClass('selected').clone(); }, this))
    .delegate('', 'click', $.proxy(function (e) { $(e.target).find("li").removeClass('selected'); $("#" + this.selectedListId + ' li').removeClass('selected'); }, this))
    .delegate('.folder', 'click', $.proxy(function (e) { this.openPagesFolder($(e.currentTarget)) }, this))
    .delegate('.crumbs > a', 'click', $.proxy(function (e) { this.openPagesFolder($(e.currentTarget)) }, this))
    .droppable({
        hoverClass: "drop-hover",
        tolerance: "pointer",
        accept: '#' + this.selectedListId + ' ' + this.itemSelector,
        drop: function (e, ui) {
            var multidrag = $(ui.draggable).data('multidrag');
            if (multidrag) {
                $(ui.draggable).data('availableDrop', true);
            }

        }
    });
    $("#" + this.availableListId + ' ' + this.itemSelector)
    .draggable({
        cancel: ".disabled",
        appendTo: "body",
        helper: $.proxy(function (e) {
            $("#" + this.selectedListId + ' li').removeClass('selected');
            var item = $(e.currentTarget);
            return this._createHelper(item, false);
        }, this),
        stop: $.proxy(function (e, ui) {
            this.UpdateInputs($('#' + this.availableListId));
        }, this),
        cursorAt: { top: 10, left: 5 },
        connectToSortable: "#" + this.selectedListId
    });
    this.SetDisabled();
    $('#' + this.availableListId + ' ' + this.itemSelector)
        .each(function (i, a) {
            if ($(a).find('i.del').length < 1) {
                $(a).append('<i class="del">&nbsp;</i>');
            }
        });
}

elma.List2listMenu.prototype.RemoveItems = function (items, selectedList, ui, indexes) {
    var parametrs = [];
    var non_removable = items.filter('.non_removable');
    parametrs.push(items);
    parametrs.push(selectedList);
    if (non_removable.length > 0) {
        jAlert(SR.T("Выбраны страницы которые не могут быть удалены"), SR.T("Удаление"));
        if (ui)
            this.ReturnToSelected(items, ui, indexes);
    } else {
        jConfirm(SR.T("Вы действительно хотите удалить страницу из списка выбранных?"), SR.T("Удаление"), $.proxy(function (r) {
            if (r) {
                elma.List2list.prototype.RemoveItems.apply(this, parametrs);
                var disabledItems = this.explorer.data('disabledItems') > '' ? JSON.parse(this.explorer.data('disabledItems')) : [];
                for (var j = 0; j < items.length; j++) {
                    var objectId = parseInt($(items[j]).attr('objectid'));
                    disabledItems.forEach(function (disabledItem, i) {
                        if (disabledItem == objectId) {
                            disabledItems.splice(i, 1);
                            if (i > 0) { i-- };
                        }
                    });
                };
                this.explorer.data('disabledItems', JSON.stringify(disabledItems));
            }
            else {
                if (ui)
                    this.ReturnToSelected(items, ui, indexes);
            }
        }, this));
    }
}

elma.List2listMenu.prototype.SelectItems = function (items, availableList, indexes) {
    elma.List2list.prototype.SelectItems.call(this, items, availableList, indexes);
    var disabledItems = this.explorer.data('disabledItems') > '' ? JSON.parse(this.explorer.data('disabledItems')) : [];
    if ($.inArray(parseInt($(items[0]).attr('objectid')), disabledItems) != -1) { return; }
    for (var i = 0; i < items.length; i++) {
        disabledItems.push(parseInt($(items[i]).attr('objectid')));
    };
    this.explorer.data('disabledItems', JSON.stringify(disabledItems));
}

elma.List2listMenu.prototype.UpdateInputs = function (ul) {
    if ($(ul).attr('id') == this.selectedListId) {
        var vc_editor = $('#Pages_VisibleCount').data('tTextBox');
        var splitter_pos = this.GetSplitterPosition(ul);
        if ((splitter_pos <= ul.find('li.list2listItem').length) && vc_editor != undefined) {
            vc_editor.value(splitter_pos);
        }
    }
    ul.parent().find('.hiddenInputs').html('');
    var inputs = '';
    ul.find('li[objectId]').each(function (i, e) {
        var item = $(this);
        var visibleValue = i < splitter_pos ? "True" : "False";
        inputs += '<input type="hidden" id="Pages_' + i + '_Page" name="Pages[' + i + '].Page.Id" value="' + item.attr('objectId') + '" />';
        inputs += '<input type="hidden" id="Pages_' + i + '_Order" name="Pages[' + i + '].Order" value="' + i + '" />';
        inputs += '<input type="hidden" id="Pages_' + i + '_Visible" name="Pages[' + i + '].Visible" value="' + visibleValue + '" />';
    });
    ul.closest("td").find('.hiddenInputs').html(inputs);

    if (ul.find('li.list2listItem').length > 0 && !ul.hasClass('folderContent availableItems ui-droppable')) {
        $('.background-hint').addClass('hidden');
        $('.visible-pages-counter').removeClass('hidden');
        ul.find('li.visible-pages-splitter').show();
    }
    else if (ul.find('li.list2listItem').length == 0 && !ul.hasClass('folderContent availableItems ui-droppable')) {
        $('.background-hint').removeClass('hidden');
        $('.visible-pages-counter').addClass('hidden');
        ul.find('li.visible-pages-splitter').hide();
    }
}

elma.List2listMenu.prototype.GetSplitterPosition = function (ul) {
    var splitter_pos = 0;
    ul.find('li').each(function (i, e) {
        if ($(this).hasClass('visible-pages-splitter')) {
            splitter_pos = i;
            return false;
        }
    });
    return splitter_pos;
}

elma.List2listMenu.prototype.SetDisabled = function () {
    var items = this.explorer.data('disabledItems') > '' ? JSON.parse(this.explorer.data('disabledItems')) : [];
    this.explorer.find('ul.folderContent li.list2listItem.page').each(function (i, e) {
        if (items.indexOf(parseInt($(this).attr('objectId'))) > -1) {
            $(this).addClass('disabled');
        } else {
            $(this).removeClass('disabled');
        }
    })
}

elma.List2listMenu.prototype.StopSortable = function (e, ui) {
    var multidrag = $(ui.item).data('multidrag');
    var availableDrop = $(ui.item).data('availableDrop');
    var indexes = $(ui.item).data('indexes');
    if (availableDrop && multidrag) {
        this.RemoveItems(multidrag, $('#' + this.selectedListId), ui, indexes);
        $(ui.item).remove();
    } else {
        this.ReturnToSelected(multidrag, ui, indexes);
    }
}

elma.List2listMenu.prototype.VisiblePagesCountChanged = function (e) {
    var ul = $('#' + this.selectedListId);
    var pagecount = ul.find('li').length;
    $('#Pages_VisibleCount').data('tTextBox').maxValue = pagecount - 1;
    var splitter_pos = $('#' + this.selectedListId).closest('table').find('.numOfVisiblePages').children('div:first').html();
    if (pagecount > 0) {
        var splitter = ul.find('li.visible-pages-splitter');
        if (splitter_pos <= pagecount - 1) {
            var sp = $(splitter);
            splitter.remove();
            if (splitter_pos > 0) {
                ul.find('li[objectId]').each(function (i, _) {
                    if (i == (splitter_pos - 1)) {
                        $(this).after(sp);
                        return false;
                    }
                });
            }
            else {
                ul.find('li[objectId]:eq(0)').before(sp);
            }
            this.UpdateInputs(ul);
        }
    }
}

elma.List2listMenu.prototype.openPagesFolder = function (e) {
    var id = $(e).attr('objectId');
    var url = $(e).data("url");
    if (id > 0)
        url += '/' + id;
    url += '?height=' + $(e).data("height") + '&personal=' + $(e).data("personal");
    $.ajax({
        url: url,
        type: 'GET',
        dataType: 'html',
        cache: false,
        success: $.proxy(function (html) {
            var explorer = $(e).closest('.pagesExplorer');
            explorer.html(html);
            this.reinit();
        }, this)
    });
}

elma.List2listGrid = function (availableListId, selectedListId, availableId, selectedId) {
    this.availableListId = availableListId;
    this.selectedListId = selectedListId;
    this.selectedId = selectedId;
    this.availableId = availableId;
    this.itemSelector = 'li';
}

elma.List2listGrid.prototype.onChangeSelectedItems;


elma.List2listGrid.prototype = Object.create(elma.List2list.prototype);


elma.List2listGrid.prototype.Init = function () {
    elma.List2list.prototype.Init.apply(this);
    $('#' + this.availableListId)
    .delegate(this.itemSelector, 'dblclick', $.proxy(function (e) { this.SelectItems($(e.currentTarget).removeClass('selected').clone(), $('#' + this.availableListId)); }, this))
    .delegate(this.itemSelector, 'click', $.proxy(function (e) { this._itemClick(e); $("#" + this.selectedListId + ' li').removeClass('selected').clone(); }, this))
    .delegate('', 'click', $.proxy(function (e) { $(e.target).find("li").removeClass('selected'); $("#" + this.selectedListId + ' li').removeClass('selected'); }, this))
        .attr('selectedListId', this.selectedListId)
        .attr('hiddenInputId', this.availableId || null)
        .attr('hiddenContainerId', this.availableContainerId || null)
        .droppable({
            hoverClass: "drop-hover",
            accept: function (e, ui) {
                for (var j = 0; j < e.length; j++) {
                    if (elma.List2list.IsRequiredColumn(e[j])) {
                        return null;
                    }
                }
                return '#' + this.selectedListId + ' ' + this.itemSelector;
            },
            drop: function (e, ui) {
                for (var j = 0; j < ui.draggable.length; j++) {
                    if (!elma.List2list.IsRequiredColumn(ui.draggable[j])) {
                        var multidrag = $(ui.draggable).data('multidrag');
                        if (multidrag) {
                            $(ui.draggable).data('availableDrop', true);
                        }
                    }
                }
            }
        });

    $('#' + this.selectedListId)
        .attr('availableListId', this.availableListId)
        .attr('hiddenInputId', this.selectedId || null)
        .attr('hiddenContainerId', this.selectedContainerId || null)
        .data('onChangeSelectedItems', this.onChangeSelectedItems || null);

    $("#" + this.availableListId + ' ' + this.itemSelector)
        .draggable({
            cancel: ".disabled",
            appendTo: "body",
            helper: $.proxy(function (e) {
                $("#" + this.selectedListId + ' li').removeClass('selected');
                var item = $(e.currentTarget);
                return this._createHelper(item, false);
            }, this),
            cursorAt: { top: 10, left: 5 },
            connectToSortable: "#" + this.selectedListId
        });

    $('#' + this.availableListId + ' ' + this.itemSelector)
    .each(function (i, a) {
        if ($(a).find('i.del').length < 1) {
            $(a).append('<i class="del">&nbsp;</i>');
        }
    });
}

elma.List2listGridLazy = function (availableListId, selectedListId, availableId, selectedId, availableJson, template, pageSize, postDataFilter, fetchUrl) {
    this.availableListId = availableListId;
    this.selectedListId = selectedListId;
    this.selectedId = selectedId;
    this.availableId = availableId;
    this.itemSelector = 'li';
    this.newItemClass = 'newItem'
    this.availableJson = availableJson;
    this.template = template;
    this.pageSize = !!pageSize ? pageSize : 20;
    this.fetchUrl = fetchUrl;
    this.postDataFilter = postDataFilter;
}

elma.List2listGridLazy.prototype = Object.create(elma.List2listGrid.prototype);

elma.List2listGridLazy.prototype.Update = function () {
    var itemSelector = this.itemSelector;
    this.itemSelector = '.' + this.newItemClass;
    elma.List2listGrid.prototype.Init.apply(this);
    $("#" + this.availableListId + ' ' + this.itemSelector).removeClass(this.newItemClass);
    this.itemSelector = itemSelector;
    this.SetDisabled();
}

elma.List2listGridLazy.prototype.SetDisabled = function () {
    var items = $("#" + this.selectedListId + ' li');
    var vals = [];
    for (var i = 0; typeof (items[i]) != 'undefined'; i++) {
        vals.push($(items[i]).attr('objectId'))
    };
    $("#" + this.availableListId + ' li').each(function (i, e) {
        if (vals.indexOf($(this).attr('objectId')) > -1) {
            $(this).addClass('disabled');
        } else {
            $(this).removeClass('disabled');
        }
    })
}

elma.List2listGridLazy.prototype.Init = function () {
    var availableListId = this.availableListId;
    var availableList = $("#" + availableListId);
    var pageSize = this.pageSize;
    var itemTemplate = this.template;
    var availableItems = this.availableJson;
    var grid = this;
    var postData = this.postDataFilter;

    availableList.endlessScroll({
        fireOnce: false,
        fireDelay: false,
        insertBefore: "",
        insertAfter: "",
        intervalFrequency: 250,
        inflowPixels: 20,
        ceaseFireOnEmpty: false,
        ceaseFire: function (fireSeq, pageSeq, direction) {
            return direction == 'prev';
        },
        loader: "",
        callback: function (fireSeq, pageSeq, direction) {
            $("#" + availableListId + " .endless_scroll_inner_wrap").append('<div class="ajax-loader">Загрузка</div>');
            $.ajax({
                global: true,
                cache: false,
                type: 'POST',
                url: grid.fetchUrl,
                data: $.extend(postData, { pageNum: pageSeq, pageSize: pageSize }),
                success: function (json) {
                    $("#" + availableListId + " .ajax-loader").fadeOut(function () {
                        return $(this).remove();
                    });
                    if(!json || json.length == 0) {
                        return;
                    };
                    var items = json.reduce(function (a, b) {
                        return a + itemTemplate(b);
                    }, "");
                    var pageWrapper = $('<div/>', { id: 'endless_scroll_content_current', class: 'endless_scroll_content' });
                    items = pageWrapper.attr('data-page', pageSeq).html(items);
                    $("#" + availableListId + " .endless_scroll_inner_wrap").append(items);
                    grid.Update();
                }
            });
        }
    });

    var items = availableItems.reduce(function (a, b) {
        return a + itemTemplate(b);
    }, "");
    availableList.append(items);

    elma.List2listGrid.prototype.Init.apply(this);
}

elma.List2listGridLazy.prototype.ReinitAvailable = function (availableItems) {
    var availableList = $("#" + this.availableListId);
    availableList.unbind("scroll");
    availableList.endlessScroll = {};
    availableList.empty();
    this.availableJson = availableItems;
    this.loading = false;
    this.Init();
}

elma.ListLazy = function (availableListId, availableJson, template, onItemSelect, pageSize, postDataFilter, fetchUrl) {
    this.availableListId = availableListId;
    this.onItemSelect = onItemSelect;
    this.newItemClass = 'newItem'
    this.availableJson = availableJson;
    this.template = template;
    this.pageSize = !!pageSize ? pageSize : 20;
    this.fetchUrl = fetchUrl;
    this.postDataFilter = postDataFilter;
}

elma.ListLazy.prototype.Init = function () {
    elma.ListLazy.prototype.Fill.apply(this);

    var availableListId = this.availableListId;
    var onItemSelect = this.onItemSelect;
    $('#' + this.availableListId)
    .delegate('li', 'dblclick', onItemSelect)
    .delegate('', 'click', function (e) {
        $(e.target).find("li").removeClass('selected');
    })
    .delegate('li', 'click', function (e) {
        if (e.ctrlKey || e.metaKey) {
            $(e.currentTarget).toggleClass("selected");
        } else {
            $(e.currentTarget).addClass("selected");
        }
        $(e.currentTarget).siblings().removeClass('selected');
    });
    $('#' + availableListId, '#' + availableListId + ' *')
        .attr('unselectable', 'on');
}

elma.ListLazy.prototype.Fill = function () {
    var availableListId = this.availableListId;
    var availableList = $("#" + this.availableListId);
    var pageSize = this.pageSize;
    var itemTemplate = this.template;
    var availableItems = this.availableJson;
    var list = this;
    var postData = this.postDataFilter;

    availableList.endlessScroll({
        fireOnce: false,
        fireDelay: false,
        insertBefore: "",
        insertAfter: "",
        intervalFrequency: 250,
        inflowPixels: 20,
        ceaseFireOnEmpty: false,
        ceaseFire: function (fireSeq, pageSeq, direction) {
            return direction == 'prev';
        },
        loader: "",
        callback: function (fireSeq, pageSeq, direction) {
            $("#" + availableListId + " .endless_scroll_inner_wrap").append('<div class="ajax-loader">Загрузка</div>');
            $.ajax({
                global: true,
                cache: false,
                type: 'POST',
                url: list.fetchUrl,
                data: $.extend(postData, { pageNum: pageSeq, pageSize: pageSize }),
                success: function (json) {
                    $("#" + availableListId + " .ajax-loader").fadeOut(function () {
                        return $(this).remove();
                    });
                    if (!json || json.length == 0) {
                        return;
                    };
                    var items = json.reduce(function (a, b) {
                        return a + itemTemplate(b);
                    }, "");
                    var pageWrapper = $('<div/>', { id: 'endless_scroll_content_current', class: 'endless_scroll_content' });
                    items = pageWrapper.attr('data-page', pageSeq).html(items);
                    $("#" + availableListId + " .endless_scroll_inner_wrap").append(items);
                }
            });
        }
    });

    var items = availableItems.reduce(function (a, b) {
        return a + itemTemplate(b);
    }, "");
    availableList.append(items);
}

elma.ListLazy.prototype.ReinitAvailable = function (availableItems) {
    var availableList = $("#" + this.availableListId);
    availableList.unbind("scroll");
    availableList.endlessScroll = {};
    availableList.empty();
    this.availableJson = availableItems;
    this.Fill();
}


elma.tree = function() {
};

elma.tree.unCheckAll = function(treeId) {
    var treeView = $("#" + treeId).data("tTreeView");
    var allNodes = $("> ul > li", treeView.element);
    allNodes.each(function(i, node) {
        treeView.nodeCheck(node, false);
    });
    $("#" + treeId + "_checkedValues").val("");
};

elma.tree.unCheckAllNodes = function(treeId) {
    var treeView = $("#" + treeId).data("tTreeView");
    var allNodes = $("li", treeView.element);
    allNodes.each(function(i, node) {
        treeView.nodeCheck(node, false);
    });
    $("#" + treeId + "_checkedValues").val("");
};


elma.tree.expandAll = function(treeId) {
    var treeView = $("#" + treeId).data("tTreeView");
    var allNodes = $("li", treeView.element);
    treeView.expand(allNodes);
};

elma.tree.collapseAll = function(treeId) {
    var treeView = $("#" + treeId).data("tTreeView");
    var allNodes = $("li", treeView.element);
    treeView.collapse(allNodes);
};

elma.tree.onChecked = function(e) {
    var jsonStr = $('#' + e.target.id + '_checkedValues').val();
    var values = jsonStr != undefined && jsonStr != "" ? $.evalJSON(elma.htmlDecode(jsonStr)) : new Array();
    var treeView = $(this).data('tTreeView');
    if (e.checked) {
        values.push({ id: treeView.getItemValue(e.item), text: treeView.getItemText(e.item) });
    } else {
        var id = treeView.getItemValue(e.item);
        var index = null;
        for (var i = 0; i < values.length; i++) {
            if (values[i].id == id) {
                index = i;
                break;
            }
        }
        if (index != null)
            values.splice(index, 1);
    }
    $('#' + e.target.id + '_checkedValues').val($.toJSON(values));
};

elma.tree.onSingleChecked = function (e) {
    elma.tree.unCheckAllNodes(e.target.id);
    var treeView = $(this).data('tTreeView');
    $('#' + e.target.id + '_checkedValues').val($.toJSON(new Array({ id: treeView.getItemValue(e.item), text: treeView.getItemText(e.item) })));
};

elma.tree.onSelect = function(e) {
    var tin = $(e.item).find('.t-in');
    $('#' + e.target.id + '_selectedValue').val($(e.item).find(':input[name="itemValue"]').val() || tin.text());
    $('#' + e.target.id + '_selectedText').val(tin.find('.item-name').length > 0 ? tin.find('.item-name').text() : tin.text());
};

elma.tree.onCollapse = function(e) {
    if ($('#' + e.target.id + '_saveStateUrl') && $('#' + e.target.id + '_saveStateUrl').val() != "") {
        $.ajax({
            url: $('#' + e.target.id + '_saveStateUrl').val(),
            data: ({ treeId: e.target.id, nodeId: $(e.item).find(':input[name="itemValue"]').val() || $(e.item).find('.t-in').text(), expanded: false }),
            dataType: "json",
            success: function(data) {
            }
        });
    }
};

elma.tree.onExpand = function(e) {
    if ($('#' + e.target.id + '_saveStateUrl') && $('#' + e.target.id + '_saveStateUrl').val() != "") {
        $.ajax({
            url: $('#' + e.target.id + '_saveStateUrl').val(),
            data: ({ treeId: e.target.id, nodeId: $(e.item).find(':input[name="itemValue"]').val() || $(e.item).find('.t-in').text(), expanded: true }),
            dataType: "json",
            success: function(data) {
            }
        });
    }
};



elma.refreshActiveTab = function(tabcontrol) {
    var tabStrip = $("#" + tabcontrol).data("tTabStrip");
    var activeTab = $(tabStrip.element).find('li.t-state-active');
    tabStrip.reload(activeTab);
};

elma.refreshTab = function(tabcontrol, identification) {
    var tabStrip = $("#" + tabcontrol).data("tTabStrip");
    var activeTab = $(tabStrip.element).find('li[Identification="' + identification + '" ]');
    tabStrip.reload(activeTab);
};

elma.selectTab = function (tabcontrol, identification) {
    var tabStrip = $("#" + tabcontrol).data("tTabStrip");
    var tab = $(tabStrip.element).find('li[Identification="' + identification + '" ]');
    tabStrip.select(tab);
};

elma.selectTabByIndex = function (tabcontrol, index) {
    var tabStrip = $("#" + tabcontrol).data("tTabStrip");
    var tab = $(tabStrip.element).find(String.format('li:eq({0})', index));
    tabStrip.select(tab);
};

/*elma.bindTabs = function (parentId) {
    if (Ext.isEmpty(parentId)) {
        parentId = 'body';
    }
    $(parentId).find('div[type="TabPanel"]').each(function (i, a) {
        var containerId = $(a).attr('containerId');

        var vertical = $(a).attr('vertical');
        var tabPanel = null;

        if (Ext.isEmpty(vertical) || vertical == 'false') {
            tabPanel = new Ext.TabPanel({
                applyTo: a.id,
                id: 'tb_' + a.id,
                activeTab: !Ext.isEmpty($(a).attr('activeTab')) ? $(a).attr('activeTab') : 0,
                plain: true,
                width: $(containerId).width(),
                autoHeight: true,
                deferredRender: false,
                autoTabs: true,
                defaults: { autoScroll: false, autoHeight: true }
            });
        }
        else {
            tabPanel = new Ext.ux.VrTabPanel({
                applyTo: a.id,
                id: 'tb_' + a.id,
                activeTab: !Ext.isEmpty($(a).attr('activeTab')) ? $(a).attr('activeTab') : 0,
                plain: true,
                width: $(containerId).width(),
                autoHeight: true,
                tabWidth: 100,
                deferredRender: false,
                autoTabs: true,
                defaults: { autoScroll: false, autoHeight: true }
            });
        }


//        $(a).children('div[type="Tab"]').each(function (i, tab) {
//            var item = new Ext.Panel({
//                id: tab.id + '_tab',
//                title: $(tab).attr('title'),
//                hideMode: 'offsets', 
//                contentEl: !Ext.isEmpty($(tab).attr('contentEl')) ? $(tab).attr('contentEl') : null,
//                autoLoad: !Ext.isEmpty($(tab).attr('url')) ? {
//                    url: $(tab).attr('url'),
//                    scripts: true,
//                    callback: function () {
//                        elma.bind('#' + this.id + '_tab');
//                    },
//                    scope: tab
//                } : null
//            });
//            tabPanel.add(item);
//        });

        tabPanel.setActiveTab(0);
        //tabPanel.render(a.id);

        /*var resizeFunction = function (e) {
        $(this.containerId).unbind('resize');
        this.tab.setSize($(this.containerId).width(), $(this.containerId).height());
        //this.tab.setHeight($(this.a).height());
        //$(this.containerId).height(this.tab.getHeight());
        $(this.containerId).resize(resizeFunction.createDelegate({ tab: this.tab, containerId: this.containerId, a: this.a }));
        }

        var resizeAbsolute = function (e) {
        $(this.containerId).height($(this.a).height());
        }

        $(containerId).resize(resizeFunction.createDelegate({ tab: tabPanel, containerId: containerId, a: a }));

        $(a).resize(resizeAbsolute.createDelegate({ tab: tabPanel, containerId: containerId, a: a }));
        $(a).resize();*/

        /*tabPanel.on('tabchange', function (tab) {
        $(this.containerId).resize();
        }, { tab: tabPanel, containerId: containerId, a: a });*/
   /* });
}

//Ext.onReady(function () {
    //elma.bindTabs();
//});*/


elma.ElmaMenuMgr = function () {
    var registered = [];

    return {
        create: function (el, sender, config) {
            /*if (sender == undefined || sender == null) var sender = { };
            var menu = elma.ElmaMenuMgr.get(el);
            if (menu && menu.destroy) { try { menu.destroy(); } catch(ex) { console.log(ex) } }
            var o = {
            id: 'menu_' + el,
            enableScrolling: false,
            forceLayout: true,
            onItemMouseClick: function(item, e) {
            var snd_vr = item.getItemId() + ':' + elma.encodeObj(this.sender);
            if (item.handlerRep) item.handlerRep.defer(0, this, [this.sender, snd_vr, item]);
            return true;
            }
            };
            Ext.apply(o, config);*/
            var menu = elma.ElmaMenuMgr.get(el);
            if (menu && menu.destroy) { try { menu.destroy(); } catch (ex) { if (window.console && window.console.log) window.console.log(ex); } }
            return elma.ElmaMenuMgr.register(el, $.cmenu.get_menu(config));
        },
        init: function (el, sender, config, args) {
            var menu = elma.ElmaMenuMgr.create(el, sender, config);
            elma.ElmaMenuMgr.redraw(menu, sender, args);
        },
        redraw: function (menu, sender, args, afterRedrawFunc, noItemsFunc) {
            if (args && args.notvisibleurl) {
                $.ajax({
                    url: args.notvisibleurl,
                    type: 'POST',
                    dataType: 'text',
                    success: $.proxy(function (data, status, xhr) {
                        var notvisible = [];
                        try {
                            notvisible = eval('(' + data + ')');
                        } catch (e) {
                            // in case the result is not JSON raise the 'error' event
                            if (!$t.ajaxError(this.element, 'error', xhr, 'parseeror'))
                                alert('Error! The requested URL did not return JSON.');
                            return;
                        }
                        elma.ElmaMenuMgr.redrawWithNotVisible(menu, sender, notvisible, afterRedrawFunc, noItemsFunc);
                    })
                });
            } else if (args) {
                elma.ElmaMenuMgr.redrawWithNotVisible(menu, sender, args.notvisible, afterRedrawFunc, noItemsFunc);
            }
        },
        redrawWithNotVisible: function (menu, sender, notvisible, afterRedrawFunc, noItemsFunc) {
            menu.sender = sender;
            var hasItems = { result: false };
            $(menu.a).each($.proxy(
                function (i, a) {
                    elma.ElmaMenuMgr.itemsRefresh(a, i, sender, notvisible);
                    if (a.visible) { this.result = true; };
                }, hasItems));
            if (hasItems.result && afterRedrawFunc) {
                afterRedrawFunc();
            } else if (!hasItems.result && noItemsFunc) {
                noItemsFunc();
            }
        },
        // protected
        itemsRefresh: function (item, index, sender, notvisible) {
            item.sender = sender;
            //item.notvisible = notvisible;
            if ($.isArray(notvisible) && $.inArray(item.id, notvisible) > -1) item.visible = false;
            else {
                //if (typeof item.show == 'function') item.show();
                item.visible = true;
                if (item.hrefRep) item.href = elma.repString(item.hrefRep, 'sender', sender);
                /*if (item.href && item.href != '' && item.el && item.el.dom) item.el.dom.href = item.href;
                if (item.etip && item.etip != '') {
                var qt = new elma.qtip.ExtraTip(item.etip, item, { anchor: item.etipAnchor || 'left' });
                if (!item.el) item.on('afterrender', qt.draw, qt);
                else qt.draw();
                }
                if (typeof item.setHandler == 'function' && typeof menu.onItemMouseClick == 'function') item.setHandler(menu.onItemMouseClick, menu);
                if (item.items && item.items.length > 0) item.items.each(elma.ElmaMenuMgr.itemsRefresh, menu);
                if (item.menu && item.menu.items && item.menu.items.length > 0) item.menu.items.each(elma.ElmaMenuMgr.itemsRefresh, menu);*/
                if (item.submenu) {
                    $(item.submenu.a || item.submenu).each(function (i, a) { elma.ElmaMenuMgr.itemsRefresh(a, i, sender, notvisible); });
                }
            }
        },
        bind: function (el, sender, referrer, location, args) {
            var menu = elma.ElmaMenuMgr.get(el);
            $(referrer).bindMenu(menu);
        },
        show: function (el, sender, referrer, location, args, lock, position, paper) {
            if ($(referrer).data('noMenuItems')) {
                return;
            }
            if (lock == false) {
                $(referrer).lockHiding(lock);
            }
            if (position == null)
                position = 'right';
            var menu = elma.ElmaMenuMgr.get(el);
            elma.ElmaMenuMgr.redraw(menu, sender, args,
                function () { $(referrer).showPopup('mousedown', menu, position, paper); },
                function () {
                    $(referrer).children('img').each(function (i, a) { $(a).attr('title', ''); });
                    elma.qtip(referrer, SR.T("Нет доступных действий"), { show: { ready: true} });
                    $(referrer).data('noMenuItems', true);
                });
            if (lock || lock == false) {
                $(referrer).lockHiding(lock);
            }
        },
        register: function (el, menu) {
            registered[el] = menu;
            return elma.ElmaMenuMgr.get(el);
        },
        hideAll: function (referrer) {
            $(referrer).lockHiding(false);
            $(referrer).hideAll();
        },
        get: function (el) {
            return registered[el] || undefined;
        }
    };
} ();

$('#MainToolbarRow').live("mousedown", function (e) {
    try {
        elma.ElmaMenuMgr.hideAll();
    } catch (e) {

    }
});


//Функция для работы с выбором сущностей
elma.EntitySelector = function (config) {
    var self = this;

    var entityMultiSelector = function (cfg) {
        var valueArray = {};

        function getItem(val) {
            var item = null;

            $.each(valueArray, function () {
                if (this.val == val) {
                    item = this;
                    return false;
                }
            });

            return item;
        }

        function addItem(item) {
            var itemFound = getItem(item.val);
            if (itemFound) {
                removeItem(itemFound);
            }

            var storeItem = $.extend({
                val: null,
                text: null,
                view: null
            }, item);

            storeItem.stopEvent = false;

            valueArray[item.val.toString()] = storeItem;
        }

        function removeItem(item) {
            valueArray[item.val.toString()] = null;
            delete valueArray[item.val.toString()];
        }

        function clearItems() {
            delete valueArray;
            valueArray = {};
        }

        function getSelected() {
            var resultArray = [];
            $.each(valueArray, function () {
                if (this)
                    resultArray.push(this);
            });
            return resultArray;
        }

        $.extend(this, {
            _initialize: function () {
                this.onAddItem(function (evt, item) {
                    if (!!item) {
                        if (item.stopEvent) evt.stopPropagation();
                        if ($.isPlainObject(item)) {
                            if (getItem(item.val)) evt.stopPropagation();
                            addItem(item);
                        }
                        if ($.isArray(item) && item.length > 0) {
                            $.each(item, function () {
                                if (this.stopEvent) evt.stopPropagation();
                                addItem(this);
                            });
                        }
                    } else if (item == undefined || item == null) {
                        evt.stopPropagation();
                    }
                });
                this.onRemoveItem(function (evt, item) {
                    if (!!item) {
                        if (item.stopEvent) evt.stopPropagation();
                        if ($.isPlainObject(item)) {
                            removeItem(item);
                        }
                        if ($.isArray(item) && item.length > 0) {
                            $.each(item, function () {
                                if (this.stopEvent) evt.stopPropagation();
                                removeItem(this);
                            });
                        }
                    } else if (typeof item === "undefined" || item == null) {
                        evt.stopPropagation();
                    }
                });
            },

            //Получить элемент по значению
            getItem: function (val) {
                return getItem(val);
            },

            //Получить выбранные элементы
            getSelected: function () {
                return getSelected();
            }
        });
    };

    var entitySingleSelector = function (cfg) {
        var hiddenVal;

        if (cfg.id && cfg.id != '' && $('#' + cfg.id).length > 0) {
            hiddenVal = $('#' + cfg.id);
        } else if (cfg.inputName && cfg.inputName != '' && $('input[name="' + cfg.inputName + '"]').length > 0) {
            hiddenVal = $('input[name="' + cfg.inputName + '"]');
        } else {
            hiddenVal = $('<input type="hidden" />').attr('id', cfg.id);

            if (cfg.inputName) {
                hiddenVal.attr('name', cfg.inputName);
            }

            var parentEl = $('form:first');

            if (!!cfg.appendTo) {
                parentEl = $(cfg.appendTo);
            }

            hiddenVal.appendTo(parentEl);
        }

        function setVal(val) {
            hiddenVal.val(val);
        }

        function setText(text) {
            hiddenVal.data("selectedText", text);
        }

        function setView(view) {
            hiddenVal.data("selectedView", view);
        }

        function getVal() {
            return hiddenVal.val();
        }

        function getText() {
            return hiddenVal.data("selectedText");
        }

        function getView() {
            return hiddenVal.data("selectedView");
        }

        function getData() {
            var ds = hiddenVal.data("tComboBox").data;
            var value = getVal();
            if (value != "" && value != null) {
                for (var i = 0; i < ds.length; i++) {
                    if (ds[i].Value == value) {
                        return ds[i];
                    }
                }
            }
            return null;
        }

        $.extend(this, {
            _initialize: function () {
                this.onAddItem(function (evt, item) {
                    if (!!item) {
                        if (item.stopEvent) evt.stopPropagation();
                        if ($.isPlainObject(item)) {
                            if (item.val == getVal()) evt.stopPropagation();
                            setVal(item.val);
                            setText(item.text);
                            setView(item.view);
                        }
                        if ($.isArray(item) && item.length > 0) {
                            if (item[0].val == getVal()) evt.stopPropagation();
                            setVal(item[0].val);
                            setText(item[0].text);
                            setView(item[0].view);
                        }
                    } else if (typeof item === "undefined" || item == null) {
                        evt.stopPropagation();
                    }
                });
                this.onRemoveItem(function () {
                    setVal(null);
                    setText(null);
                    setView(null);
                });
            },

            //Получить элемент по значению
            getItem: function (val) {
                if (val == getVal())
                    return { val: getVal(), text: getText(), view: getView(), data: getData };
                return null;
            },

            //Получить выбранные элементы
            getSelected: function () {
                return [this.getItem(getVal())];
            }
        });
    };

    self.initConfig = $.extend({}, config);

    config = $.extend(self.defaultConfig, config);

    if (config.multiSelect) {
        var multiSelector = new entityMultiSelector(config);
        $.extend(self, multiSelector);

        self._initialize();

        if (config.selected && $.isArray(config.selected)) {
            $.each(config.selected, function () {
                self.addItem(this.val, this.text, this.view, true);
            });
        }
    }
    else {
        var singleSelector = new entitySingleSelector(config);
        $.extend(self, singleSelector);

        self._initialize();

        if ($.isArray(config.selected))
            config.selected = config.selected[0];

        config.selected = $.extend({
            val: null,
            text: null,
            view: null
        }, config.selected);

        self.addItem(config.selected.val, config.selected.text, config.selected.view, true);
    }

    this._triggerInit();
};

elma.EntitySelector.prototype = {

    //Default configs
    defaultConfig: {
        multiSelect: false,
        canAdd: true,
        canRemove: true
    },

    //Private triggers
    _initialize: $.noop,
    _triggerRemove: function (item) {
        $(this).trigger('removeitem', item);
    },
    _triggerAdd: function (item) {
        $(this).trigger('additem', item);
    },
    _triggerInit: function () {
        $(this).trigger('init');
    },
    _triggerAfterChange: function (items) {
        $(this).trigger('afterchange', items);
    },

    ignoreAfterChangeEvent: false,

    ignoreAfterAddEvent: false,

    //Добавить выбранный элемент
    addItem: function (val, text, viewtext, stopEvent) {
        var item = { val: val, text: text, view: viewtext || text, stopEvent: !!stopEvent };
        this._triggerAdd(item);
        return item;
    },

    //Убрать элемент по значению
    removeItem: function (val) {
        this._triggerRemove(this.getItem(val));
    },

    //Очистить все выбранные элементы
    clearSelected: function () {
        var oldIgnoreAfterChangeEvent = this.ignoreAfterChangeEvent;
        this.ignoreAfterChangeEvent = true;
        var self = this,
            selected = this.getSelected();
        $.each(selected, function () { self._triggerRemove(this); });
        this.ignoreAfterChangeEvent = oldIgnoreAfterChangeEvent;
        this.afterChange();
    },
    
    addItemWithWait: function (items, callback) {
        var item = items.pop();
        if (item) {
            this.addItem(item.val, item.text, item.viewtext, item.stopEvent);
            var that = this;
            setTimeout(function() {
                that.addItemWithWait(items, callback);
            }, 300);
        } else if (callback) {
            callback.call();
        }
    },
    
    // Добавить список элементов
    addItems: function (items) {
        var oldIgnoreAfterChangeEvent = this.ignoreAfterChangeEvent;
        this.ignoreAfterChangeEvent = true;
        var arrayToExecute = new Array();
        for (var i in items) {
            var item = items[i];
            arrayToExecute.push(item);
        }
        var that = this;
        this.addItemWithWait(arrayToExecute, function () {
            that.ignoreAfterChangeEvent = oldIgnoreAfterChangeEvent;
            that.afterChange(items);
        });
    },

    // Установить список элементов (удалить все текущие и добавить новые)
    setItems: function (items) {
        var oldIgnoreAfterChangeEvent = this.ignoreAfterChangeEvent;
        this.ignoreAfterChangeEvent = true;
        this.clearSelected();
        this.addItems(items);
        this.ignoreAfterChangeEvent = oldIgnoreAfterChangeEvent;
        this.afterChange(items);
    },

    //Вызвать событие после изменения значений
    afterChange: function (items) {
        if (!this.ignoreAfterChangeEvent) {
            this._triggerAfterChange(items);
        }
    },

    //Получить элемент по значению
    getItem: $.noop,

    //Получить выбранные элементы
    getSelected: $.noop,

    onAddItem: function (func) {
        $(this).bind('additem', func);
    },

    onRemoveItem: function (func) {
        $(this).bind('removeitem', func);
    },

    onInit: function (func) {
        $(this).bind('init', func);
    },

    onAfterChange: function (func) {
        $(this).bind('afterchange', func);
    }
};

elma.EntitySelector.Manager = function () {
    var selectors = [];
    return {
        create: function (cfg) {
            var selector = new elma.EntitySelector(cfg);
            return elma.EntitySelector.Manager.register(cfg.id, selector);
        },
        register: function (el, selector) {
            selectors[el] = selector;
            return elma.EntitySelector.Manager.get(el);
        },
        get: function (el) {
            return selectors[el] || null;
        }
    };
} ();

elma.SelectorControl = function () {
    return {
        getValue: function (id) {
            var valInput = $('#_' + id + '_value');
            return valInput.val();
        },
        setValue: function (id, value) {
            var valInput = $('#_' + id + '_value');
            valInput.val(value);
        }
    };
} ();


elma.qtip = function (selector, text, options) {
    var conf = {
        content: {
            text: text
        },
        position: {
            my: 'top left',  // Position my top left...
            at: 'bottom right',
            viewport: true
        }
    };
    if (!!options) jQuery.extend(conf, options);
    
    $(selector).qtip(conf);
};
elma.initQTip = function (selector, headerAttribute, textAttribute, optionsAttribute) {
    var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
    if (translationMode)
        return;
    if (selector == undefined || selector == null)
        selector = '*[tooltiptext]';
    if (headerAttribute == undefined || headerAttribute == null)
        headerAttribute = 'tooltipheader';
    if (textAttribute == undefined || textAttribute == null)
        textAttribute = 'tooltiptext';
    if (optionsAttribute == undefined || optionsAttribute == null)
        optionsAttribute = 'tooltipoptions';

    $(selector).each(function (i, a) {
        var text =
            $(a).attr(headerAttribute) && $(a).attr(headerAttribute) != ''
            ? '<b>' + $(a).attr(headerAttribute) + '</b><br/>' + $(a).attr(textAttribute)
            : $(a).attr(textAttribute);
        var options;
        try {
            options = $.parseJSON($(a).attr(optionsAttribute));
        } catch (ex) {
        }
        if (text.length > 0) {
            elma.qtip(a, text, options);
        }
    });

};

elma.initCleanupQTip = function (selector) {
    $("div[id*='ui-tooltip']").empty();
    elma.initQTip();
};

$(document).ready(function () {
    elma.initQTip();
});



elma.wizards = function () { 
}

elma.wizards.freezed = false;

elma.wizards.freeze = function (flag) {
    elma.wizards.freezed = flag;
}

elma.wizards.nextStep = function (id, selectedStep) {
    if (selectedStep != $("#" + id).formwizard("state").currentStep) {
        var activatedSteps = $("#" + id).formwizard("state").activatedSteps;
        if (activatedSteps.some(function (item) { return item == selectedStep; })) {
            elma.wizards.showSelectedStep(id, selectedStep);
        }
        else {
            elma.wizards.showNextStep(id);
        }
    }
}

elma.wizards.validateStep = function (step) {
    var form = $(step).find('form:first');
    if (elma.wizards.freezed) {
        return false;
    }
    if (!$(form).data('validator')) {
        return true;
    }
    if (!form.valid()) {
        form.validate().focusInvalid();
        return false;
    }
    return true;
}

elma.wizards.collectPostData = function (step, postData) {
    if (!postData) {
        postData = {};
    }
    var curIndex = $(step).attr('index');
    for (var i = curIndex; i--; i > 0) {
        var idcontainerstep = "#step_" + i;
        postData = elma.dynamics.getPostData(idcontainerstep, postData);
    }
    return postData
}

elma.wizards.initCurrentStep = function (id) {
    elma.wizards.freeze(true);
    var currentStep = $("#" + id).formwizard("state").currentStep;
    var previousStep = $("#" + id).formwizard("state").previousStep;
    elma.wizards.changeTheButton(id, currentStep, previousStep);
    elma.wizards.changeTheTitle(id, currentStep, previousStep);
    var idPanel = id + "_panel_" + currentStep;
    var panel = $("#" + idPanel);
    if (panel.length != 0 || panel.parent().attr('reload') == 'True') {
        panel.show();
        var postData = {};
        if (panel.attr("method").toUpperCase() == "POST") {
            postData = elma.wizards.collectPostData('#' + currentStep);
        }
        if (panel.parent().attr('reload') == 'True') {
            elma.dynamics.update(idPanel, postData, function () {
                elma.wizards.freeze(false);
            });
        } else {
            elma.dynamics.loadOnce(idPanel, postData, function () {
                elma.wizards.freeze(false);
            });
        }
    }
    else {
        elma.wizards.freeze(false);
    }
}

elma.wizards.renameForms = function (id) {
    $("#" + id).find('form').each(function (i, a) {
        $(a).attr('id', 'from' + i);
    });    
}

elma.wizards.showNextStep = function (id) {
    var currentStep = $("#" + id).formwizard("state").currentStep;
    if (!elma.wizards.validateStep('#' + currentStep))
        return;
    $("#" + id).formwizard("next");
    elma.wizards.initCurrentStep(id); 
}

elma.wizards.showSelectedStep = function (id, selectedStep) {
    var currentStep = $("#" + id).formwizard("state").currentStep;
    if (selectedStep > currentStep && !elma.wizards.validateStep('#' + currentStep))
        return;
    $("#" + id).formwizard("show", selectedStep);
    elma.wizards.initCurrentStep(id);    
}

elma.wizards.changeTheButton = function (wizard, selectedStep, previousStep) {
    $("#" + wizard + "_button_" + selectedStep).addClass("WizardCurrentStep");
    var currentStepName = $("#" + wizard + "_button_" + previousStep).removeClass("WizardCurrentStep");
}

elma.wizards.changeTheTitle = function (wizard, selectedStep, previousStep) {
    $("#" + wizard + "_StepName_" + selectedStep).show();
    var currentStepId = $("#" + wizard).formwizard("state").currentStep;
    var currentStepName = $("#" + wizard + "_StepName_" + previousStep).hide();
}

elma.wizards.changeStepTitle = function (wizard, step, name) {
    $("#" + wizard + "_StepName_" + step).text(name);
    $("#" + wizard + "_button_" + step).find('p').find('span').text(name);
}

elma.wizards.showBackStep = function (id) {
    var currentStep = $("#" + id).formwizard("state").currentStep;
    $("#" + id).formwizard("back");
    elma.wizards.initCurrentStep(id);   
}

elma.wizards.convertElement = function (element, targettag) {
    var attrs = $.getAttributes(element);
    var targetelement = $('<' + targettag + '>');
    var keys = $.map(attrs, function (item, key) {
        targetelement.attr(key, item);
        return key;
    });   
    return targetelement;
}

elma.wizards.convertWizard = function (id, steptargettag, wizardtargettag) {
    var steps = $("#" + id).formwizard("state").steps;
    $.each(steps, function (i, step) {
        var form = steptargettag == 'div' ? $(step).find('form:first') : $(step).find('div[fromform=1]:first');
        if ($(form).length > 0) {
            var divForm = elma.wizards.convertElement($(form), steptargettag);
            if (form.is('form')) {
                divForm.attr('fromform', 1);
            }
            divForm.appendTo($(step));
            $(form).find("input[name=__RequestVerificationToken]").remove();
            form.children().appendTo(divForm);
            form.remove();
        }
    });

    var wizardform = elma.wizards.convertElement($("#" + id), wizardtargettag);
    $(wizardform).attr('enctype', 'multipart/form-data');
    var parent = $("#" + id).parent();
    wizardform.appendTo(parent);
    $("#" + id).children().appendTo(wizardform);
    $("#" + id).remove();
}

elma.wizards.post = function (id, onsubmit, disablevalidate, ajaxPost, ajaxCallback) {
    var currentStep = $("#" + id).formwizard("state").currentStep;
    if (!disablevalidate && !elma.wizards.validateStep('#' + currentStep))
        return;
    elma.openPleaseWait(true);
    elma.wizards.convertWizard(id, 'div', 'form');
    //document.getElementById(id).submit();
    if (onsubmit) {
        $("#" + id).attr('onsubmit', onsubmit);
    }

    if (ajaxPost) {
        if (ajaxCallback) {
            $("#" + id).attr('callbackFunc', ajaxCallback);
        }
        $("#" + id).ajaxForm(elma.getAjaxFormOptions("#" + id));
    }
    $("#" + id).AddAntiForgeryToken();
    $("#" + id).submit();
}


function saveGlobalSettingsCallBack(moduleUid, data) {
    if (!data.success) {
        jAlert(data.reason);
    }
    else {
        window.location.reload(true);
    }
}

function editGlobalSettingsPopup(moduleUid, title) {
    createAndLoadWindow('popupSettings_' + moduleUid, { title: title.toString(), width: 800 }, window.BaseUrl + 'SDK.Action/GlobalSettings/Edit?moduleUid=' + moduleUid);
}


/**
* http://github.com/valums/file-uploader
* 
* Multiple file upload component with progress-bar, drag-and-drop. 
* © 2010 Andrew Valums ( andrew(at)valums.com ) appendChild
* 
* Licensed under GNU GPL 2 or later, see license.txt.
*/

//
// Helper functions
//

var qq = qq || {};

/**
* Adds all missing properties from second obj to first obj
*/
qq.extend = function (first, second) {
    for (var prop in second) {
        first[prop] = second[prop];
    }
};

/**
* Searches for a given element in the array, returns -1 if it is not present.
* @param {Number} [from] The index at which to begin the search
*/
qq.indexOf = function (arr, elt, from) {
    if (arr.indexOf) return arr.indexOf(elt, from);

    from = from || 0;
    var len = arr.length;

    if (from < 0) from += len;

    for (; from < len; from++) {
        if (from in arr && arr[from] === elt) {
            return from;
        }
    }
    return -1;
};

qq.getUniqueId = (function () {
    var id = 0;
    return function () { return id++; };
})();

//
// Events


qq.attach = function (element, type, fn, scope) {
    if (scope) {
        $(element).bind(type, scope, fn);
    } else {
        if (element.addEventListener) {
            element.addEventListener(type, fn, false);
        } else if (element.attachEvent) {
            element.attachEvent('on' + type, fn);
        }
    }
};


qq.detach = function (element, type, fn, scope) {
    if (scope) {
        $(element).unbind(type, scope, fn);
    } else {
        if (element.removeEventListener) {
            element.removeEventListener(type, fn, false);
        } else if (element.detachEvent) {
            element.detachEvent('on' + type, fn);
        }
    }
};

qq.preventDefault = function (e) {
    if (e.preventDefault) {
        e.preventDefault();
    } else {
        e.returnValue = false;
    }
};

//
// Node manipulations

/**
* Insert node a before node b.
*/
qq.insertBefore = function (a, b) {
    b.parentNode.insertBefore(a, b);
};
qq.remove = function (element) {
    element.parentNode.removeChild(element);
};

qq.contains = function (parent, descendant) {
    // compareposition returns false in this case
    if (parent == descendant) return true;

    if (parent.contains) {
        return parent.contains(descendant);
    } else {
        return !!(descendant.compareDocumentPosition(parent) & 8);
    }
};

/**
* Creates and returns element from html string
* Uses innerHTML to create an element
*/
qq.toElement = (function () {
    var div = document.createElement('div');
    return function (html) {
        div.innerHTML = html;
        var element = div.firstChild;
        div.removeChild(element);
        return element;
    };
})();

//
// Node properties and attributes

/**
* Sets styles for an element.
* Fixes opacity in IE6-8.
*/
qq.css = function (element, styles) {
    if (styles.opacity != null) {
        if (element.style) {
            if (typeof (element.style.opacity) != 'string') {
                if (typeof (element.filters) != 'undefined') {
                    styles.filter = 'alpha(opacity=' + Math.round(100 * styles.opacity) + ')';
                }
            }
        }
    }
    qq.extend(element.style, styles);
};
qq.hasClass = function (element, name) {
    var re = new RegExp('(^| )' + name + '( |$)');
    return re.test(element.className);
};
qq.addClass = function (element, name) {
    if (!qq.hasClass(element, name)) {
        element.className += ' ' + name;
    }
};
qq.removeClass = function (element, name) {
    var re = new RegExp('(^| )' + name + '( |$)');
    element.className = element.className.replace(re, ' ').replace(/^\s+|\s+$/g, "");
};
qq.setText = function (element, text) {
    element.innerText = text;
    element.textContent = text;
};

//
// Selecting elements

qq.children = function (element) {
    var children = [],
    child = element.firstChild;

    while (child) {
        if (child.nodeType == 1) {
            children.push(child);
        }
        child = child.nextSibling;
    }

    return children;
};

qq.getByClass = function (element, className) {
    if (element.querySelectorAll) {
        return element.querySelectorAll('.' + className);
    }

    var result = [];
    var candidates = element.getElementsByTagName("*");
    var len = candidates.length;

    for (var i = 0; i < len; i++) {
        if (qq.hasClass(candidates[i], className)) {
            result.push(candidates[i]);
        }
    }
    return result;
};

/**
* obj2url() takes a json-object as argument and generates
* a querystring. pretty much like jQuery.param()
* 
* how to use:
*
*    `qq.obj2url({a:'b',c:'d'},'http://any.url/upload?otherParam=value');`
*
* will result in:
*
*    `http://any.url/upload?otherParam=value&a=b&c=d`
*
* @param  Object JSON-Object
* @param  String current querystring-part
* @return String encoded querystring
*/
qq.obj2url = function (obj, temp, prefixDone) {
    var uristrings = [],
        prefix = '&',
        add = function (nextObj, i) {
            var nextTemp = temp
                ? (/\[\]$/.test(temp)) // prevent double-encoding
                   ? temp
                   : temp + '[' + i + ']'
                : i;
            if ((nextTemp != 'undefined') && (i != 'undefined')) {
                uristrings.push(
                    (typeof (nextObj) === 'object')
                        ? qq.obj2url(nextObj, nextTemp, true)
                        : (Object.prototype.toString.call(nextObj) === '[object Function]')
                            ? encodeURIComponent(nextTemp) + '=' + encodeURIComponent(nextObj())
                            : encodeURIComponent(nextTemp) + '=' + encodeURIComponent(nextObj)
                );
            }
        };

    if (!prefixDone && temp) {
        prefix = (/\?/.test(temp)) ? (/\?$/.test(temp)) ? '' : '&' : '?';
        uristrings.push(temp);
        uristrings.push(qq.obj2url(obj));
    } else if ((Object.prototype.toString.call(obj) === '[object Array]') && (typeof (obj) != 'undefined')) {
        // we wont use a for-in-loop on an array (performance)
        for (var i = 0, len = obj.length; i < len; ++i) {
            add(obj[i], i);
        }
    } else if ((typeof (obj) != 'undefined') && (obj !== null) && (typeof (obj) === "object")) {
        // for anything else but a scalar, we will use for-in-loop
        for (var i in obj) {
            add(obj[i], i);
        }
    } else {
        uristrings.push(encodeURIComponent(temp) + '=' + encodeURIComponent(obj));
    }

    return uristrings.join(prefix)
                     .replace(/^&/, '')
                     .replace(/%20/g, '+');
};

//
//
// Uploader Classes
//
//

var qq = qq || {};

/**
* Creates upload button, validates upload, but doesn't create file list or dd. 
*/
qq.FileUploaderBasic = function (o) {
    this._options = {
        // set to true to see the server response
        debug: false,
        action: '/server/upload',
        params: {},
        button: null,
        multiple: true,
        maxConnections: 3,
        // validation        
        allowedExtensions: [],
        sizeLimit: 0,
        sizeToUploadsInParts: 0, //Кастом: размер файла для его загрузки по частям [Мб]
        sizePart: 0, //Кастом: максимальный размер части файла [Мб]
        clipboardIcon: '',
        clearListIcon: '/Content/Images/x32/cancel.png',
        minSizeLimit: 0,
        readonly : false,
        // events
        // return false to cancel submit
        onSubmit: function (id, fileName) { },
        onProgress: function (id, fileName, loaded, total) { },
        onComplete: function (id, fileName, responseJSON) { },
        onRemove: function (id, fileName) { },
        onCancel: function (id, fileName) { },
        // messages                
        messages: {
            typeError:  SR.T("{file} имеет неверное расширение. Только файлы {extensions} разрешены."),
            sizeError:  SR.T("{file} слишком большой, максимальный размер файла {sizeLimit}."),
            minSizeError:  SR.T("{file} слишком маленький, минимальный размер файла {minSizeLimit}."),
            emptyError: SR.T("{file} пустой, выберите другой файл."),
            clipboardTooltip: SR.T("Вставить скриншот из буфера обмена"),
            clearListTooltip: SR.T("Очистить список прикреплённых файлов"),
            onLeave: SR.T("Загрузка файлов еще не завершена, если вы уйдете сейчас данные будут потеряны."),
            onRemove: SR.T("Действительно хотите удалить файл {file}?")
        },
        showMessage: function (message) {
            return alert(message);
        },
        showConfirm: function (message) {
            return confirm(message);
        }
    };
    qq.extend(this._options, o);

    // number of files being uploaded
    this._filesInProgress = 0;
    this._handler = this._createUploadHandler();

    if (this._options.button) {
        this._button = this._createUploadButton(this._options.button);
    }

    this._preventLeaveInProgress();
};

qq.FileUploaderBasic.prototype = {
    setParams: function (params) {
        this._options.params = params;
    },
    getInProgress: function () {
        return this._filesInProgress;
    },
    _createUploadButton: function (element) {
        var self = this;

        return new qq.UploadButton({
            element: element,
            multiple: this._options.multiple && qq.UploadHandlerXhr.isSupported(),
            readonly: this._options.readonly,
            onChange: function (input) {
                self._onInputChange(input);
            }
        });
    },
    _createUploadHandler: function () {
        var self = this,
            handlerClass;

        if (qq.UploadHandlerXhr.isSupported()) {
            handlerClass = 'UploadHandlerXhr';
        } else {
            handlerClass = 'UploadHandlerForm';
        }

        var handler = new qq[handlerClass]({
            debug: this._options.debug,
            action: this._options.action,
            sizeToUploadsInParts: this._options.sizeToUploadsInParts,
            sizePart: this._options.sizePart,
            maxConnections: this._options.maxConnections,
            onProgress: function (id, fileName, loaded, total) {
                self._onProgress(id, fileName, loaded, total);
                self._options.onProgress(id, fileName, loaded, total);
            },
            onComplete: function (id, fileName, result) {
                self._onComplete(id, fileName, result);
                self._options.onComplete.apply(self, arguments);
            },
            onCancel: function (id, fileName) {
                self._onCancel(id, fileName);
                self._options.onCancel(id, fileName);
            }
        });

        return handler;
    },
    _preventLeaveInProgress: function () {
        var self = this;

        qq.attach(window, 'beforeunload', function (e) {
            if (!self._filesInProgress) { return; }

            var e = e || window.event;
            // for ie, ff
            e.returnValue = self._options.messages.onLeave;
            // for webkit
            return self._options.messages.onLeave;
        });
    },
    _onSubmit: function (id, fileName) {
        this._filesInProgress++;
    },
    _onProgress: function (id, fileName, loaded, total) {
    },
    _onComplete: function (id, fileName, result) {
        this._filesInProgress--;
        if (result.error) {
            this._options.showMessage(result.error);
        }
    },
    _onCancel: function (id, fileName) {
        this._filesInProgress--;
    },
    _onInputChange: function (input) {
        if (this._handler instanceof qq.UploadHandlerXhr) {
            this._uploadFileList(input.files);
        } else {
            if (this._validateFile(input)) {
                this._uploadFile(input);
            }
        }
        this._button.reset();
    },
    _uploadFileList: function (files) {
        for (var i = 0; i < files.length; i++) {
            if (!this._validateFile(files[i])) {
                return;
            }
        }

        for (var i = 0; i < files.length; i++) {
            this._uploadFile(files[i]);
        }
    },
    _uploadFile: function (fileContainer) {
        if (!this._options.multiple) {
            // remove existing item
            this._listElement.innerHTML = '';
        }
        var id = this._handler.add(fileContainer);
        var fileName = this._handler.getName(id);

        if (this._options.onSubmit(id, fileName) !== false) {
            this._onSubmit(id, fileName);
            this._handler.upload(id, this._options.params);
        }
    },
    _validateFile: function (file) {
        var name, size;

        if (file.value) {
            // it is a file input            
            // get input value and remove path to normalize
            name = file.value.replace(/.*(\/|\\)/, "");
        } else {
            // fix missing properties in Safari
            name = file.fileName != null ? file.fileName : file.name;
            size = file.fileSize != null ? file.fileSize : file.size;
        }

        if (!this._isAllowedExtension(name)) {
            this._error('typeError', name);
            return false;

        } else if (size === 0) {
            this._error('emptyError', name);
            return false;

        } else if (size && this._options.sizeLimit && size > this._options.sizeLimit) {
            this._error('sizeError', name);
            return false;

        } else if (size && size < this._options.minSizeLimit) {
            this._error('minSizeError', name);
            return false;
        }

        return true;
    },
    _formatMessage: function (code, fileName) {
        var message = this._options.messages[code];
        function r(name, replacement) { message = message.replace(name, replacement); }

        r('{file}', this._formatFileName(fileName));
        r('{extensions}', this._options.allowedExtensions.join(', '));
        r('{sizeLimit}', this._options.sizeLimitText);
        r('{minSizeLimit}', this._formatSize(this._options.minSizeLimit));

        return message;
    },
    _error: function (code, fileName) {
        return this._options.showMessage(this._formatMessage(code, fileName));
    },
    _confirm: function (code, fileName) {
        return this._options.showConfirm(this._formatMessage(code, fileName));
    },
    _formatFileName: function (name) {
        //elma.CutDisplayFileName && 
        if (name.length > 33) {
            name = name.slice(0, 19) + '...' + name.slice(-13);
        }
        return name;
    },
    _isAllowedExtension: function (fileName) {
        var ext = (-1 !== fileName.indexOf('.')) ? fileName.replace(/.*[.]/, '').toLowerCase() : '';
        var allowed = this._options.allowedExtensions;

        if (!allowed.length) { return true; }

        for (var i = 0; i < allowed.length; i++) {
            if (allowed[i].toLowerCase() == ext) { return true; }
        }

        return false;
    },
    _formatSize: function (bytes) {
        var i = -1;
        do {
            bytes = bytes / 1024;
            i++;
        } while (bytes > 0x400);

        return Math.max(bytes, 0.1).toFixed(1) + ' ' + [SR.T('КБ'), SR.T('МБ'), SR.T('ГБ'), SR.T('ТБ'), SR.T('ПБ'), SR.T('EB')][i];
    }
};


/**
* Class that creates upload widget with drag-and-drop and file list
* @inherits qq.FileUploaderBasic
*/
qq.FileUploader = function (o) {
    
    // call parent constructor
    qq.FileUploaderBasic.apply(this, arguments);

    // additional options    
    qq.extend(this._options, {
        fileNameList: [],
        elemIdList: [],
        fileNameListModified: [],
        element: null,
        // if set, will be used instead of qq-upload-list in template
        listElement: null,

        template: '<div class="qq-uploader">' +
                   '<div class="qq-upload-button">' +
                    '<div class="qq-upload-header">' +
                       '<span class="qq-upload-title"></span>' +
                       '<span class="qq-upload-comment-right"></span>' +
                    '</div>' +
                    '<div class="qq-upload-inner-container"></div>' +
                    '<div class="qq-upload-comment-bottom"></div>' +
                   '</div>' +
                   '<div class="qq-clipboard-button" title="' + this._options.messages.clipboardTooltip + '" id = "clipboardContainer_' + $(this._options.element).attr('id') + '">' +
                    '<img src=' + this._options.clipboardIcon + ' style="position:relative; top:15%; left:15%;">' +
                   '</div>' +
                   '<ul class="qq-upload-list"></ul>' +
                  '</div>',
        //Контейнер для хранения скриншота, необходим только для Firefox
        screenshotContainer: 'Screenshot_' + $(this._options.element).attr('id'),
        // template for one item in file list
        fileTemplate: '<li>' +
                '<span class="qq-upload-file"></span>' +
                '<span class="qq-upload-spinner"></span>' +
                '<span class="qq-upload-size"></span>' +
                '<a class="qq-upload-cancel" href="#">' + SR.T('Отменить') + '</a>' +
                '<a class="qq-upload-remove" href="#"> </a>' +
                '<span class="qq-upload-failed-text">' + SR.T('Ошибка') + '</span>' +
              '</li>',

        classes: {
            // used to get elements from templates
            button: 'qq-upload-button',
            clipboardButton: 'qq-clipboard-button',
            rightComment: 'qq-upload-comment-right',
            bottomComment: 'qq-upload-comment-bottom',
            drop: 'qq-upload-drop-area',
            dropActive: 'qq-upload-drop-area-active',
            list: 'qq-upload-list',
            header: 'qq-upload-header',
            title: 'qq-upload-title',
            innerContainer: 'qq-upload-inner-container',

            file: 'qq-upload-file',
            spinner: 'qq-upload-spinner',
            size: 'qq-upload-size',
            cancel: 'qq-upload-cancel',
            href: 'qq-upload-href',
            remove: 'qq-upload-remove',

            // added to list item when upload completes
            // used in css to hide progress spinner
            success: 'qq-upload-success',
            fail: 'qq-upload-fail'
        },
        onComplete: function () {
            this._onChange();
        }
    });
    // overwrite options with user supplied    
    qq.extend(this._options, o);

    this._element = this._options.element;
    this._dragDropEnabled = !this._options.readonly && elma.IsHtml5FileUploadCapable();
    if (!this._dragDropEnabled) {
        qq.addClass(this._element, "no-drop");
    }
    if (this._options.customBottomText) {
        qq.addClass(this._element, "show-description");
    }
    this._element.innerHTML = this._options.template;
    this._listElement = this._options.listElement || this._find(this._element, 'list');
    this._innerContainer = this._find(this._element, 'innerContainer');
    qq.attach(this._listElement, 'click', function (e) { if (e.stopPropagation) e.stopPropagation(); });
    
    this._find(this._element, 'title').innerHTML = this._options.multiple ? SR.T('Загрузить файлы') : SR.T('Загрузить файл');
    
    this._find(this._element, 'bottomComment').innerHTML = this._options.customBottomText ? this._options.customBottomText : SR.T('Вы можете загрузить файл, перетащив его мышкой в данную область');
    if (!this._options.multiple) {
        $(this._listElement).detach();
        $(this._innerContainer).append($(this._listElement));
    }
    this._header = this._find(this._element, 'header');

    this._classes = this._options.classes;

    if (this._canAdd()) {
        var buttonElement = this._find(this._element, 'button');
        buttonElement.setAttribute('title', SR.T('Не более {0}', this._options.sizeLimitText));
        this._button = this._createUploadButton(buttonElement);
        var comm = this._find(this._element, 'rightComment');
        if (comm) {
            var text = this._options.showLimitText == 'true' ? '(' + SR.T('не более {0}', this._options.sizeLimitText) + ')' : '';
            qq.setText(comm, text);
        }
    }
    this._bindCancelEvent();
    if (this._dragDropEnabled) {
        this._addDragDrop();
    }
    this._registerInGlobal();
    var self = this;
    this._bindFiles();
    if (elma.isIE() || this._options.readonly) {
        var container = $('.qq-clipboard-button[id = "clipboardContainer_' + $(this._options.element).attr('id') + '"]');
        if (container.length > 0) {
            container.hide();
        }
    } else {
        //Настройка отображения контрола
        qq.attach($('.' + this._options.classes.clipboardButton + '[id="clipboardContainer_' + $(this._options.element).attr('id') + '"]')[0], 'mouseover', function () {
            qq.addClass($('.' + self._options.classes.clipboardButton + '[id="clipboardContainer_' + $(self._options.element).attr('id') + '"]')[0], 'qq-clipboard-button-hover');
        });
        qq.attach($('.' + this._options.classes.clipboardButton + '[id="clipboardContainer_' + $(this._options.element).attr('id') + '"]')[0], 'mouseout', function () {
            qq.removeClass($('.' + self._options.classes.clipboardButton + '[id="clipboardContainer_' + $(self._options.element).attr('id') + '"]')[0], 'qq-clipboard-button-hover');
        });
        var element = this._find(this._element, 'clipboardButton');
        $(element).bind('click', onClipboardButtonClick);
        //Адаптивная разметка контрола (начинаем ее изменять только в том случае, если это не IE, так как в противном случае ширины текущей разметки вполне хватает)
        var buttonElement = $(this._find(this._element, 'button'));
        $(window).ready(function () {
            $(element).css('height', $(buttonElement).css('height'));
        });
        $(window).resize(function () {
            $(element).css('height', $(buttonElement).css('height'));
        });
    };
    function onClipboardButtonClick(e) {
        $.event.props.push('clipboardData');
        refreshPopup('ScreenshotInputPopup', null, null, null, elma.ScreenshotPasteControl.Init(), function () {
            if (window.screenshotIsPaste == 1) {
                var base64Image = window.screenShotImage.split(',')[1];
                var name = 'screenshot_' + Math.floor(Math.random() * 100000).toString() + '.png';
                var binary = window.atob(base64Image);
                var array = [];

                for (var i = 0; i < binary.length; i++) {
                    array.push(binary.charCodeAt(i));
                };

                var blob = new Blob([new Uint8Array(array)], { type: 'image/png' });
                var imageFile = new File([blob], name);

                if (!self._options.multiple) {
                    self._listElement.innerHTML = '';
                }

                var id = self._handler.add(imageFile);
                var fileName = self._handler.getName(id);

                if (self._options.onSubmit(id, fileName) !== false) {
                    self._onSubmit(id, fileName);
                    self._handler.upload(id, self._options.params);
                }
                window.screenshotIsPaste = 0;
                window.screenShotImage = null;
            }
        });
    }
};

// inherit from Basic Uploader
qq.extend(qq.FileUploader.prototype, qq.FileUploaderBasic.prototype);

qq.extend(qq.FileUploader.prototype, {
    /**
    * Gets one of the elements listed in this._options.classes
    **/
    _find: function (parent, type) {
        var element = qq.getByClass(parent, this._options.classes[type])[0];
        if (!element) {
            throw new Error('element not found ' + type);
        }

        return element;
    },
    _hideDropArea: function () {
        if (this._dropZone) this._dropZone._hide();
        if (this._getItemsCount() == 0 || this._options.multiple)
            if (this._button) this._button._show();
    },
    _showDropArea: function () {
        if (this._button) this._button._hide();
        if (this._dropZone) this._dropZone._show();
    },
    _addDragDrop: function () {
        if (this._canAdd()) {
            this._dropZone = this._setupDragDrop();
        }
    },
    _removeDragDrop: function () {
        if (this._dropZone) {
            this._dropZone._detachEvents();

            this._hideDropArea();

            delete (this._dropZone);
        }
    },
    _setupDragDrop: function () {
        var self = this,
            dropArea = this._find(this._element, 'button');

        var dz = new qq.UploadDropZone({
            element: dropArea,
            uploader: this,
            classes: this._classes,
            onEnter: function (e) {
                qq.addClass(dropArea, self._classes.dropActive);
                e.stopPropagation();
            },
            onLeave: function (e) {
                e.stopPropagation();
            },
            onLeaveNotDescendants: function (e) {
                qq.removeClass(dropArea, self._classes.dropActive);
            },
            onDrop: function (e) {
                qq.removeClass(dropArea, self._classes.dropActive);
                self._uploadFileList(e.dataTransfer.files);
            }
        });

        return dz;
    },
    _onSubmit: function (id, fileName) {
        qq.FileUploaderBasic.prototype._onSubmit.apply(this, arguments);
        this._addToList(id, fileName);
    },
    _onProgress: function (id, fileName, loaded, total) {
        qq.FileUploaderBasic.prototype._onProgress.apply(this, arguments);

        var item = this._getItemByFileId(id);
        var size = this._find(item, 'size');
        size.style.display = 'inline';

        var text;
        if (loaded != total) {
            text = SR.T('{0}% от {1}', Math.round(loaded / total * 100), this._formatSize(total));
        } else {
            text = this._formatSize(total);
        }

        qq.setText(size, text);
    },
    _onComplete: function (id, fileName, result) {
        qq.FileUploaderBasic.prototype._onComplete.apply(this, arguments);

        // mark completed
        var item = this._getItemByFileId(id);
        qq.remove(this._find(item, 'cancel'));
        qq.remove(this._find(item, 'spinner'));

        if (result.success) {
            qq.addClass(item, this._classes.success);
            item.tmpFilePath = result.fileTmpPath;
            item.fileDbId = result.fileDbId;
            item.isNew = true;

            var fileNewHide;

            if (result.uid) {
                fileNewHide = qq.toElement('<input id="input_' + this._options.params.format + '_' + id + '" format="' + this._options.params.format + '" name="' + this._options.params.uid + '" type="hidden" value="' + result.uid + '" />');
            } else if (item.fileDbId) {
                fileDbHide = qq.toElement('<input id="input_' + this._options.params.format + '_' + id + '" format="' + this._options.params.format + '" name="' + this._options.params.id + '" type="hidden" value="' + result.fileDbId + '" />');
                item.isNew = false;
            }

            if (this._canDelete()) {
                if (this._options.multiple) {
                    // Добавить запись в список имён файлов.
                    // Сохранять id элементов <li> необходимо для установления соответствия 
                    // между списком имён файлов и <li> в случае множественной загрузки файлов.
                    this._options.elemIdList.push(id);
                    this._options.fileNameList.push(fileName);
                    this._options.fileNameListModified.push(fileName);
                }

                this._bindRemoveItemEvent(item, id, fileName);
            } else {
                qq.remove(this._find(item, 'remove'));
            }

            var href;
            var fileDbHide;
            if (this._canLoad() && result.fileHref) {
                href = qq.toElement('<a href="#"></a>');
                qq.setText(href, this._formatFileName(fileName));
                href.href = result.fileHref || "#";
                href.target = '_blank';
            }
            else {
                href = qq.toElement('<span></span>');
                qq.setText(href, this._formatFileName(fileName));
            }

            var fileElement = this._find(item, 'file');
            qq.setText(fileElement, '');

            if (result.fileSizeText) {
                var sizeElement = this._find(item, 'size');
                sizeElement.style.display = 'inline';
                qq.setText(sizeElement, result.fileSizeText);
            } else if (result.fileSize != null) {
                var sizeElement = this._find(item, 'size');
                sizeElement.style.display = 'inline';
                qq.setText(sizeElement, this._formatSize(result.fileSize));
            }

            fileElement.appendChild(href);
            if (item.fileDbId) {
                fileElement.appendChild(fileDbHide);
            }

            if (result.uid) {
                fileElement.appendChild(fileNewHide);
            }

            if (result.attachmentId) {
                fileElement.appendChild(qq.toElement('<input id="input_' + this._options.params.attachmentFormat + '_' + id + '" format="' + this._options.params.attachmentFormat + '" name="' + this._options.params.attachmentId + '" type="hidden" value="' + result.attachmentId + '" />'));
            }
        } else {
            if (("validMaxSize" in result && "validSizeZero" in result)) {
                item.isNew = true;
                if (result.validSizeZero == false) {
                    this._error('emptyError', fileName);
                } else if (result.validMaxSize == false) {
                    this._error('sizeError', fileName);
                };
            }

            this._removeFromList(id, fileName);
        }
        this._replaceNumberField();
    },
    _removeFromList: function (id, fileName) {
        var item = this._getItemByFileId(id);
        item.setAttribute('style', 'display:none;');
        var inp = document.getElementById("input_" + this._options.params.format + '_' + item.qqFileId);
        if (inp && inp.value) {
            inp.value = '';
        }
        
        if (!this._options.multiple) {
            this._showHeader();
        } else {
            var attIdInput = document.getElementById("input_" + this._options.params.attachmentFormat + '_' + item.qqFileId);
            if (attIdInput) {
                attIdInput.remove();
            }
        }
        if (this._handler) this._handler._count--;
        this._onChange();
        this._replaceNumberField();
        this._options.onRemove.apply(this, [id, fileName]);

        var fileNameId = this._options.fileNameListModified.indexOf(fileName);
        if (fileNameId >= 0) {
            this._options.fileNameListModified.splice(fileNameId, 1);
            if (this._options.fileNameListModified.length == 0) {
                this._options.elemIdList.length = 0;
                this._options.fileNameList.length = 0;
            }
        }
    },
    _clearFileList: function () {
        var length = this._options.fileNameList.length;
        if (length == 0) {
            return;
        }
        var startElemId = this._listElement.childNodes.length - length;
        var elem = this._listElement.childNodes[startElemId];

        var id, fileId, fileName;
        while (elem) {
            id = elem.qqFileId;
            fileId = this._options.elemIdList.indexOf(id);
            fileName = this._options.fileNameList[fileId];
            this._removeFromList(id, fileName);
            elem = elem.nextSibling;
        }
        this._options.fileNameList.length = 0;
        this._options.fileNameListModified.length = 0;
    },
    _addToList: function (id, fileName) {
        var item = qq.toElement(this._options.fileTemplate);
        item.qqFileId = id;

        var fileElement = this._find(item, 'file');
        qq.setText(fileElement, this._formatFileName(fileName));
        this._find(item, 'size').style.display = 'none';

        this._listElement.appendChild(item);

        if (!this._options.multiple) {
            this._hideHeader();
            //this._removeDragDrop();
        }
    },
    _getItemsCount: function () {
        var item = this._listElement.firstChild;
        var res = 0;

        // there can't be txt nodes in dynamically created list
        // and we can  use nextSibling
        while (item) {
            res++;
            item = item.nextSibling;
        }
        return res;
    },
    _getItemByFileId: function (id) {
        var item = this._listElement.firstChild;

        // there can't be txt nodes in dynamically created list
        // and we can  use nextSibling
        while (item) {
            if (item.qqFileId == id) return item;
            item = item.nextSibling;
        }
        return null;
    },
    _replaceNumberField: function () {
        var item = this._listElement.firstChild;
        var ind = 0;
        var param1 = this._options.params.format;
        var param2 = this._options.params.attachmentFormat;
        if (param1 != "one") {
            while (item) {
                var input = document.getElementById("input_" + param1 + '_' + item.qqFileId);
                if (input && input.name) {
                    var regExp = /\[.*\]/;
                    var zam = '[' + ind + ']';
                    input.name = input.name.replace(regExp, zam);
                }
                input = document.getElementById("input_" + param2 + '_' + item.qqFileId);
                if (input && input.name) {
                    var regExp = /\[.*\]/;
                    var zam = '[' + ind + ']';
                    input.name = input.name.replace(regExp, zam);
                }
                item = item.nextSibling;
                ind++;

            }
        }
    },
    /**
    * delegate click event for cancel link 
    **/
    _bindCancelEvent: function () {
        var self = this,
            list = this._listElement;

        qq.attach(list, 'click', function (e) {
            e = e || window.event;
            var target = e.target || e.srcElement;

            if (qq.hasClass(target, self._classes.cancel)) {
                qq.preventDefault(e);

                var item = target.parentNode;
                self._handler.cancel(item.qqFileId);
                qq.remove(item);
            }
        });
    },
    _bindRemoveItemEvent: function (item, id, fileName) {
        var self = this;
        var rm = this._find(item, 'remove');
        if (this._options.onCustomRemove) {
            qq.attach(rm, 'click', function (e) {
                e = e || window.event;

                qq.preventDefault(e);
                jConfirm(self._formatMessage('onRemove', fileName), SR.T("Удаление файла"), function (r) {
                    if (r) {
                        self._options.onCustomRemove.apply(null);
                    }
                });
            });
        } else {
            qq.attach(rm, 'click', function (e) {
                e = e || window.event;

                qq.preventDefault(e);
                if (self._options.multiple && $('#ClearListPopup').length) {
                    if (!$.event.props['clientResponse']) {
                        $.event.props.push('clientResponse');
                    } else {
                        $.event.props['clientResponse'] = -1;
                    }
                    refreshPopup('ClearListPopup', null, null, SR.T("Удаление файла"), elma.ClearListControl.Init(fileName), function () {
                        if ($.event.props['clientResponse'] == 0) {
                            self._removeFromList(id, fileName);
                        } else if ($.event.props['clientResponse'] == 1) {
                            self._clearFileList();
                        }
                    });
                } else {
                    jConfirm(self._formatMessage('onRemove', fileName), SR.T("Удаление файла"), function (r) {
                        if (r) {
                            self._removeFromList(id, fileName);
                        }
                    });
                }
            });
        }
    },
    _bindFiles: function () {
        var self = this;
        $.each(this._options.dbFiles, function (i, item) {
            var result = {
                success: true,
                fileHref: self._options.dbFileUrl.replace("*dbID*", item.dbID),
                fileDbId: item.dbID,
                fileSizeText: item.FileSizeString,
                fileSize: item.FileSize,
                attachmentId: item.AttachmentId
            };

            var fileId = 'qq-dbstored-file' + qq.getUniqueId();
            self._onSubmit(fileId, item.FileName);
            self._handler._count++;
            self._onComplete(fileId, item.FileName, result);
        });


        $.each(this._options.newFiles, function (i, item) {
            var result = {
                success: true,
                uid: item.uid,
                fileHref: self._options.newFileUrl.replace("*newUid*", item.uid),

                //fileTmpPath: item.TMPFilePath,
                fileSizeText: item.FileSizeString
            };

            var fileId = 'qq-temp-file' + qq.getUniqueId();
            self._onSubmit(fileId, item.FileName);
            self._handler._count++;
            self._onComplete(fileId, item.FileName, result);
        });
    },
    _onChange: function () {
        var ocfResult = true;
        if (this._options.params.ocf && this._options.params.ocf != '') {
            try {
                ocfResult = eval(this._options.params.ocf + '()');
            } catch (e) { if (this._options.debug && window.console) console.log(e); }
        }
        if (ocfResult != false && this._options.params.pbf && this._options.params.pbf != '') {
            try {
                eval(this._options.params.pbf + '()');
            } catch (e) { if (this._options.debug && window.console) console.log(e); }
        }
        validHiddenInput($('#' + this._options.idhidden));
    },
    _registerInGlobal: function () {
        elma.fileUploaders = elma.fileUploaders || {};
        elma.fileUploaders[this._options.element.id] = this;
    },
    _canAdd: function () {
        return this._options.params.ca == 'true';
    },
    _canDelete: function () {
        return this._options.params.cd == 'true';
    },
    _canLoad: function () {
        return this._options.params.cl == 'true';
    },
    _hideHeader: function () {
        qq.addClass(this._button._element, 'fileSelected');
    },
    _showHeader: function () {
        qq.removeClass(this._button._element, 'fileSelected');
    }
});

qq.UploadDropZone = function (o) {
    this._options = {
        element: null,
        uploader: null,
        onEnter: function (e) { },
        onLeave: function (e) { },
        // is not fired when leaving element by hovering descendants   
        onLeaveNotDescendants: function (e) { },
        onDrop: function (e) { }
    };
    qq.extend(this._options, o);

    this._element = this._options.element;
    this._uploader = this._options.uploader;
    this._classes = this._options.classes;

    this._attachEvents();
};

qq._isValidFileDrag = function (e) {
    var dt = e.dataTransfer,
    // do not check dt.types.contains in webkit, because it crashes safari 4            
            isWebkit = navigator.userAgent.indexOf("AppleWebKit") > -1,
            isIE = elma.isIE();
    
    // dt.effectAllowed is none in Safari 5
    // dt.types.contains check is for firefox
    if (isIE)
        return dt && (dt.files || dt.types.contains && dt.types.contains('Files'));

    return dt && dt.effectAllowed && dt.effectAllowed != 'none' &&
            (dt.files || (!isWebkit && dt.types.contains && dt.types.contains('Files')));
},

qq._unwrapDropEvent = function (evt, checkValid) {
    var e = evt.browserEvent || evt;
    if (!!e && e.originalEvent) {
        e = e.originalEvent;
    }
    if (!e || !e.dataTransfer || !evt.data) {
        return null;
    }
    if (checkValid && !qq._isValidFileDrag(e)) {
        return null;
    }
    return e;
};

qq.UploadDropZone.DisableDropOutside = function () {
    // Disable drop outside
    if (!qq.UploadDropZone.dropOutsideDisabled) {
        qq.attach(document, 'dragover', function (evt) {
            var e = qq._unwrapDropEvent(evt);
            if (!e) {
                return;
            }
            e.dataTransfer.dropEffect = 'none';
            e.preventDefault();
        }, this);

        qq.attach(document, 'dragenter', function (evt) {
            var e = qq._unwrapDropEvent(evt);
            if (!e) {
                return;
            }
            e.dataTransfer.dropEffect = 'none';
            e.preventDefault();
        }, this);

        qq.attach(document, 'drop', function (evt) {
            var e = qq._unwrapDropEvent(evt);
            if (!e) {
                return;
            }
            e.preventDefault();
        }, this);
        
        qq.UploadDropZone.dropOutsideDisabled = true;
    }
};

$(document).ready(qq.UploadDropZone.DisableDropOutside);

qq.UploadDropZone.prototype = {
    _onElementDragOver: function (evt) { //
        var e = qq._unwrapDropEvent(evt, true);
        if (!e) {
            return;
        }
        if (typeof e.dataTransfer.effectAllowed == "string") {
            var effect = e.dataTransfer.effectAllowed;
            if (effect == 'move' || effect == 'linkMove') {
                e.dataTransfer.dropEffect = 'move'; // for FF (only move allowed)    
            } else {
                e.dataTransfer.dropEffect = 'copy'; // for Chrome
            }
        }
        e.stopPropagation();
        e.preventDefault();
    },
    _onElementDragEnter: function (evt) {
        var e = qq._unwrapDropEvent(evt, true);
        if (!e) {
            return;
        }

        evt.data._options.onEnter.apply(evt.data, [e]);
    },
    _onElementDragLeave: function (evt) {
        var e = qq._unwrapDropEvent(evt, true);
        if (!e) {
            return;
        }

        evt.data._options.onLeave.apply(evt.data, [e]);

        var relatedTarget = document.elementFromPoint(e.clientX, e.clientY);
        // do not fire when moving a mouse over a descendant
        if (relatedTarget && qq.contains(evt.data._element, relatedTarget)) return;

        evt.data._options.onLeaveNotDescendants.apply(evt.data, [e]);
    },
    _onElementDrop: function (evt) {
        var e = qq._unwrapDropEvent(evt, true);
        if (!e) {
            return;
        }

        e.preventDefault();
        evt.data._options.onDrop.apply(this, [e]);
    },
    _attachEvents: function () {
        qq.attach(this._element, 'dragover', this._onElementDragOver, this);

        qq.attach(this._element, 'dragenter', this._onElementDragEnter, this);

        qq.attach(this._element, 'dragleave', this._onElementDragLeave, this);

        qq.attach(this._element, 'drop', this._onElementDrop, this);
    },
    _detachEvents: function () {
        qq.detach(this._element, 'dragover', this._onElementDragOver, this);

        qq.detach(this._element, 'dragenter', this._onElementDragEnter, this);

        qq.detach(this._element, 'dragleave', this._onElementDragLeave, this);

        qq.detach(this._element, 'drop', this._onElementDrop, this);
    },
    _hide: function () {
        qq.css(this._element, {
            display: 'none'
        });
        qq.removeClass(this._element, this._classes.dropActive);
    },
    _show: function () {
        qq.css(this._element, {
            display: 'block'
        });
    }
};

qq.UploadButton = function (o) {
    this._options = {
        element: null,
        // if set to true adds multiple attribute to file input      
        multiple: false,
        // name attribute of file input
        name: 'file',
        onChange: function (input) { },
        hoverClass: 'qq-upload-button-hover',
        focusClass: 'qq-upload-button-focus'
    };

    qq.extend(this._options, o);

    this._element = this._options.element;

    // make button suitable container for input
    qq.css(this._element, {
        position: 'relative',
        overflow: 'hidden',
        // Make sure browse button is in the right side
        // in Internet Explorer
        direction: 'ltr'
    });

    if ($.browser.msie) {
        qq.css(this._element, {
            height: 24
        });
    }

    this._input = this._createInput();
};

qq.UploadButton.prototype = {
    /* returns file input element */
    getInput: function () {
        return this._input;
    },
    /* cleans/recreates the file input */
    reset: function () {
        if (this._input.parentNode) {
            qq.remove(this._input);
        }

        qq.removeClass(this._element, this._options.focusClass);
        this._input = this._createInput();
    },
    _createInput: function () {
        var input = document.createElement("input");

        if (this._options.multiple) {
            input.setAttribute("multiple", "multiple");
        }

        input.setAttribute("type", "file");
        input.setAttribute("name", this._options.name);
        input.setAttribute("originalid", "file_upload_new");
        qq.css(input, { opacity: 0 });

        this._element.appendChild(input);

        this._dragDropEnabled = !this._options.readonly && elma.IsHtml5FileUploadCapable();

        var self = this;
        qq.attach(input, 'change', function () {
            self._options.onChange(input);
        });
        qq.attach(input, 'focus', function () {
            qq.addClass(self._element, self._options.focusClass);
        });
        qq.attach(input, 'blur', function () {
            qq.removeClass(self._element, self._options.focusClass);
        });

        if (!this._eventsAttached) {
            if (this._dragDropEnabled) {
                this._element.setAttribute('tabIndex', "0");
                qq.attach(this._element, 'click', function () {
                    $(self._input).css("display", "block");
                    self._input.click();
                });
                qq.attach(this._element, 'keydown', function (e) {
                    if (e.keyCode == 32 || e.keyCode == 13) {
                        $(self._input).css("display", "block");
                        self._input.click();
                        e.preventDefault();
                        return false;
                    }
                });
            }
            qq.attach(this._element, 'mouseover', function () {
                qq.addClass(self._element, self._options.hoverClass);
            });
            qq.attach(this._element, 'mouseout', function () {
                qq.removeClass(self._element, self._options.hoverClass);
            });
            this._eventsAttached = true;
        }

        // IE and Opera, unfortunately have 2 tab stops on file input
        // which is unacceptable in our case, disable keyboard access
        if (window.attachEvent) {
            // it is IE or Opera
            input.setAttribute('tabIndex', "-1");
        }

        return input;
    },
    _hide: function () {
        qq.css(this._element, {
            display: 'none'
        });
    },
    _show: function () {
        qq.css(this._element, {
            display: 'inline-block'
        });
    }
};

/**
* Class for uploading files, uploading itself is handled by child classes
*/
qq.UploadHandlerAbstract = function (o) {
    this._options = {
        debug: false,
        action: '/upload.php',
        // maximum number of concurrent uploads        
        maxConnections: 999,
        onProgress: function (id, fileName, loaded, total) { },
        onComplete: function (id, fileName, response) { },
        onCancel: function (id, fileName) { }
    };
    qq.extend(this._options, o);

    this._queue = [];
    // params for files in queue
    this._params = [];
};
qq.UploadHandlerAbstract.prototype = {
    log: function (str) {
        if (this._options.debug && window.console) console.log('[uploader] ' + str);
    },
    /**
    * Adds file or file input to the queue
    * @returns id
    **/
    add: function (file) { },
    getCount: function () { },
    /**
    * Sends the file identified by id and additional query params to the server
    */
    upload: function (id, params) {
        var len = this._queue.push(id);

        var copy = {};
        qq.extend(copy, params);
        this._params[id] = copy;

        // if too many active uploads, wait...
        if (len <= this._options.maxConnections) {
            this._upload(id, this._params[id]);
        }
    },
    /**
    * Cancels file upload by id
    */
    cancel: function (id) {
        this._cancel(id);
        this._dequeue(id);
    },
    /**
    * Cancells all uploads
    */
    cancelAll: function () {
        for (var i = 0; i < this._queue.length; i++) {
            this._cancel(this._queue[i]);
        }
        this._queue = [];
    },
    /**
    * Returns name of the file identified by id
    */
    getName: function (id) { },
    /**
    * Returns size of the file identified by id
    */
    getSize: function (id) { },
    /**
    * Returns id of files being uploaded or
    * waiting for their turn
    */
    getQueue: function () {
        return this._queue;
    },
    /**
    * Actual upload method
    */
    _upload: function (id) { },
    /**
    * Actual cancel method
    */
    _cancel: function (id) { },
    /**
    * Removes element from queue, starts upload of next
    */
    _dequeue: function (id) {
        var i = qq.indexOf(this._queue, id);
        this._queue.splice(i, 1);

        var max = this._options.maxConnections;

        if (this._queue.length >= max) {
            var nextId = this._queue[max - 1];
            this._upload(nextId, this._params[nextId]);
        }
    }
};

/**
* Class for uploading files using form and iframe
* @inherits qq.UploadHandlerAbstract
*/
qq.UploadHandlerForm = function (o) {
    qq.UploadHandlerAbstract.apply(this, arguments);

    this._inputs = {};
    this._count = 0;
};
// @inherits qq.UploadHandlerAbstract
qq.extend(qq.UploadHandlerForm.prototype, qq.UploadHandlerAbstract.prototype);

qq.extend(qq.UploadHandlerForm.prototype, {
    add: function (fileInput) {
        fileInput.setAttribute('name', 'qqfile');
        var id = 'qq-upload-handler-iframe' + qq.getUniqueId();

        this._inputs[id] = fileInput;
        this._count++;

        // remove file input from DOM
        if (fileInput.parentNode) {
            qq.remove(fileInput);
        }

        return id;
    },
    getCount: function () {
        return this._count;
    },
    getName: function (id) {
        // get input value and remove path to normalize
        return this._inputs[id].value.replace(/.*(\/|\\)/, "");
    },
    _cancel: function (id) {
        this._options.onCancel(id, this.getName(id));

        delete this._inputs[id];
        this._count--;

        var iframe = document.getElementById(id);
        if (iframe) {
            // to cancel request set src to something else
            // we use src="javascript:false;" because it doesn't
            // trigger ie6 prompt on https
            iframe.setAttribute('src', 'javascript:false;');

            qq.remove(iframe);
        }
    },
    _upload: function (id, params) {
        var input = this._inputs[id];

        if (!input) {
            throw new Error('file with passed id was not added, or already uploaded or cancelled');
        }

        var fileName = this.getName(id);

        var iframe = this._createIframe(id);
        var form = this._createForm(iframe, params);
        form.appendChild(input);

        var self = this;
        this._attachLoadEvent(iframe, function () {
            self.log('iframe loaded');

            var response = self._getIframeContentJSON(iframe);

            self._options.onComplete.apply(self, [id, fileName, response]);
            self._dequeue(id);

            delete self._inputs[id];

            // timeout added to fix busy state in FF3.6
            setTimeout(function () {
                qq.remove(iframe);
            }, 1);
        });
        $(form).AddAntiForgeryToken().submit();
        qq.remove(form);

        return id;
    },
    _attachLoadEvent: function (iframe, callback) {
        qq.attach(iframe, 'load', function () {
            // when we remove iframe from dom
            // the request stops, but in IE load
            // event fires
            if (!iframe.parentNode) {
                return;
            }

            // fixing Opera 10.53
            if (iframe.contentDocument &&
                iframe.contentDocument.body &&
                iframe.contentDocument.body.innerHTML == "false") {
                // In Opera event is fired second time
                // when body.innerHTML changed from false
                // to server response approx. after 1 sec
                // when we upload file with iframe
                return;
            }

            callback();
        });
    },
    /**
    * Returns json object received by iframe from server.
    */
    _getIframeContentJSON: function (iframe) {
        // iframe.contentWindow.document - for IE<7
        var doc = iframe.contentDocument ? iframe.contentDocument : iframe.contentWindow.document,
            response;

        this.log("converting iframe's innerHTML to JSON");
        this.log("innerHTML = " + doc.body.innerHTML);

        try {
            response = eval("(" + doc.body.innerHTML + ")");
        } catch (err) {
            response = {};
        }

        return response;
    },
    /**
    * Creates iframe with unique name
    */
    _createIframe: function (id) {
        // We can't use following code as the name attribute
        // won't be properly registered in IE6, and new window
        // on form submit will open
        // var iframe = document.createElement('iframe');
        // iframe.setAttribute('name', id);

        var iframe = qq.toElement('<iframe src="javascript:false;" name="' + id + '" />');
        // src="javascript:false;" removes ie6 prompt on https

        iframe.setAttribute('id', id);

        iframe.style.display = 'none';
        document.body.appendChild(iframe);

        return iframe;
    },
    /**
    * Creates form, that will be submitted to iframe
    */
    _createForm: function (iframe, params) {
        // We can't use the following code in IE6
        // var form = document.createElement('form');
        // form.setAttribute('method', 'post');
        // form.setAttribute('enctype', 'multipart/form-data');
        // Because in this case file won't be attached to request
        var form = qq.toElement('<form method="post" enctype="multipart/form-data"></form>');

        var queryString = qq.obj2url(params, this._options.action);

        form.setAttribute('action', queryString);
        form.setAttribute('target', iframe.name);
        form.style.display = 'none';
        document.body.appendChild(form);

        return form;
    }
});

/**
* Class for uploading files using xhr
* @inherits qq.UploadHandlerAbstract
*/
qq.UploadHandlerXhr = function (o) {
    qq.UploadHandlerAbstract.apply(this, arguments);

    this._files = [];
    this._xhrs = [];

    // current loaded size in bytes for each file
    this._loaded = [];
    this._count = 0;
};

// static method
qq.UploadHandlerXhr.isSupported = function () {
    var input = document.createElement('input');
    input.type = 'file';

    return (
        'multiple' in input &&
        typeof (File) != "undefined" &&
        typeof (new XMLHttpRequest()).upload != "undefined");
};

// @inherits qq.UploadHandlerAbstract
qq.extend(qq.UploadHandlerXhr.prototype, qq.UploadHandlerAbstract.prototype);

qq.extend(qq.UploadHandlerXhr.prototype, {
    /**
    * Adds file to the queue
    * Returns id to use with upload, cancel
    **/
    add: function (file) {
        if (!(file instanceof File)) {
            throw new Error('Passed obj in not a File (in qq.UploadHandlerXhr)');
        }

        this._count++;

        return this._files.push(file) - 1;
    },
    getCount: function () {
        return this._count;
    },
    getName: function (id) {
        var file = this._files[id];
        // fix missing name in Safari 4
        return file.fileName != null ? file.fileName : file.name;
    },
    getSize: function (id) {
        var file = this._files[id];
        return file.fileSize != null ? file.fileSize : file.size;
    },
    /**
    * Returns uploaded bytes for file identified by id 
    */
    getLoaded: function (id) {
        return this._loaded[id] || 0;
    },
    /**
    * Sends the file identified by id and additional query params to the server
    * @param {Object} params name-value string pairs
    */
    _upload: function (id, params) {
        var file = this._files[id],
            name = this.getName(id),
            size = this.getSize(id);

        this._loaded[id] = 0;
        fileUploader = new html5upl.FileUploader({
            action: this._options.action,
            sizeToUploadsInParts: this._options.sizeToUploadsInParts,
            sizePart: this._options.sizePart,
            params: params,
            xhrObject: this._xhrs,
            onProgress: this._options.onProgress,
            onComplete: this._onComplete.bind(this)
        }); 
        fileUploader.uploadFile(file, id);
    },
    _onComplete: function (id, xhr) {
        // the request was aborted/cancelled
        if (!this._files[id]) return;

        var name = this.getName(id);
        var size = this.getSize(id);

        this._options.onProgress(id, name, size, size);

        if (xhr.status == 200) {
            this.log("xhr - server response received");
            this.log("responseText = " + xhr.responseText);

            var response;

            try {
                response = eval("(" + xhr.responseText + ")");
            } catch (err) {
                response = {};
            }

            this._options.onComplete.apply(this, [id, name, response]);

        } else {
            this._options.onComplete.apply(this, [id, name, {}]);
        }

        this._files[id] = null;
        this._xhrs[id] = null;
        this._dequeue(id);
    },
    _cancel: function (id) {
        this._options.onCancel(id, this.getName(id));

        this._files[id] = null;
        this._count--;

        if (this._xhrs[id]) {
            this._xhrs[id].abort();
            this._xhrs[id] = null;
        }
    }
});





elma.QuickSearch = {};

var dataFilter_initial = [];

elma.QuickSearch.Init = function (form, fieldsprefix) {
    var isFilterForm = $("#" + form).attr('action') != undefined;
    var prefix = fieldsprefix + (isFilterForm ? '.Filter' : '');
    var fields = $("#" + form).serializeArray();
    for (var i = 0, l = fields.length; i < l; i++) {
        var field = fields[i];
        if ((field.name.substr(0, prefix.length) !== prefix && field.name !== fieldsprefix + '.FilterTypeSelector') || field.name === prefix + '.__TypeName') continue;
        dataFilter_initial[form + field.name] = field.value;
    }
};

elma.QuickSearch.MoveToQuickInitial = function (form, fieldsprefix) {
    var formHtml = $("#" + form);
    formHtml.attr('MoveToQuick', true);
    var isFilterForm = $("#" + form).attr('action') != undefined;
    var prefix = fieldsprefix + (isFilterForm ? '.Filter' : '');
    var fields = formHtml.serializeArray();
    var dataFilter = [];
    var side = false;
    var forcemoveside = false;
    var quickFieldsDiv = $('#' + form + ' > div.filter-search-form-content > div.quicksearch-fields:first');
    if (quickFieldsDiv.length == 0) {
        return;
    }
    for (var i = 0, l = fields.length; i < l; i++) {
        var field = fields[i];
        if ((field.name.substr(0, prefix.length) !== prefix && field.name !== fieldsprefix + '.FilterTypeSelector') || field.name === prefix + ".__TypeName") continue;
        dataFilter_initial[form + field.name] = field.value;
        dataFilter[field.name] = field.value;

        var container = formHtml.find("[name='" + field.name + "']").closest('tr.editorContainer');
        if (container == undefined || container == null) {
            container = $(document.getElementsByName(field.name)[0]).closest('tr.editorContainer');
        }

        if (dataFilter_initial[form + field.name] !== '' && dataFilter_initial[form + field.name] !== undefined || container.hasClass('forcemove')) {
            if (container.length > 0 && !container.hasClass('moved') && !container.hasClass('default')) {
                container.find('script').remove();
                var newTr = $("<tr class='editorContainer moved'></tr>");
                if (container.hasClass('forcemove')) {
                    if (!forcemoveside) {
                        quickFieldsDiv.find('table.forcequickFieldsLeftContainer:first').append(newTr);
                    } else {
                        quickFieldsDiv.find('table.forcequickFieldsRightContainer:first').append(newTr);
                    }
                    forcemoveside = !forcemoveside;
                } else {
                    if (!side) {
                        quickFieldsDiv.find('table.quickFieldsLeftContainer:first').append(newTr);
                    } else {
                        quickFieldsDiv.find('table.quickFieldsRightContainer:first').append(newTr);
                    }
                    side = !side;
                }
                var tds = container.children('td');
                newTr.attr('originalTr', container.attr('id'));
                for (var i2 = 0, l2 = tds.length; i2 < l2; i2++) {
                    $(tds[i2]).detach().appendTo(newTr);
                }
            }
        }
    }

    var anymoved = quickFieldsDiv.find('tr.editorContainer');
    if (anymoved.length === 0) {
        quickFieldsDiv.hide();
    }
};

elma.QuickSearch.RefreshMove = function (fieldsprefix) {
    $('form[MoveToQuick]').each(function (i, a) {
        elma.QuickSearch.MoveToExtended($(a).attr('id'), true);
        elma.QuickSearch.MoveToQuick($(a).attr('id'), fieldsprefix);
    });
}

elma.QuickSearch.RefreshMoveForm = function (form, fieldsprefix) {
    var forms = $('form[MoveToQuick]').filter("#" + form);
    if (forms.length > 0) {
        forms.each(function(i, a) {
            elma.QuickSearch.MoveToExtended(form, true);
            elma.QuickSearch.MoveToQuick(form, fieldsprefix);
        });
    }
}

elma.QuickSearch.MoveToQuick = function (form, fieldsprefix) {
    var formHtml = $("#" + form);
    formHtml.attr('MoveToQuick', true);
    var isFilterForm = formHtml.attr('action') != undefined;
    var prefix = fieldsprefix + (isFilterForm ? '.Filter' : '');
    var side = false;
    var forcemoveside = false;
    var dataFilter = [];
    var fields = formHtml.serializeArray();
    var quickFieldsDiv = $('#' + form + ' > div.filter-search-form-content > div.quicksearch-fields:first');
    if (quickFieldsDiv.length == 0) {
        return;
    }
    for (var i = 0, l = fields.length; i < l; i++) {
        var field = fields[i];
        if ((field.name.substr(0, prefix.length) !== prefix && field.name !== fieldsprefix + '.FilterTypeSelector') || field.name === prefix + '.__TypeName') continue;
        dataFilter[field.name] = field.value;

        var container = formHtml.find("[name='" + field.name + "']").closest('tr.editorContainer');
        if (container == undefined || container == null) {
            container = $(document.getElementsByName(field.name)[0]).closest('tr.editorContainer');
        }

        if ((dataFilter_initial[form + field.name] !== dataFilter[field.name] || (dataFilter_initial[form + field.name] !== '' && !container.hasClass('default'))) && dataFilter[field.name] !== '' || container.hasClass('forcemove')) {
            if (container.length > 0 && !container.hasClass('moved')) {
                container.find('script').remove();
                var newTr = $("<tr class='editorContainer moved'></tr>");
                if (container.hasClass('forcemove')) {
                    if (!forcemoveside) {
                        quickFieldsDiv.find('table.forcequickFieldsLeftContainer:first').append(newTr);
                    } else {
                        quickFieldsDiv.find('table.forcequickFieldsRightContainer:first').append(newTr);
                    }
                    forcemoveside = !forcemoveside;
                }
                else {
                    if (!side) {
                        quickFieldsDiv.find('table.quickFieldsLeftContainer:first').append(newTr);
                    } else {
                        quickFieldsDiv.find('table.quickFieldsRightContainer:first').append(newTr);
                    }
                    side = !side;
                }
                var tds = container.children('td');
                newTr.attr('originalTr', container.attr('id'));
                for (var i2 = 0, l2 = tds.length; i2 < l2; i2++) {
                    $(tds[i2]).detach().appendTo(newTr);
                }
            }
        }
    }

    var anymoved = quickFieldsDiv.find('tr.editorContainer');
    if (anymoved.length > 0) {
        quickFieldsDiv.slideDown();
    }
};

elma.QuickSearch.MoveToExtended = function (form, noslideup) {
    var quickFieldsDiv = $('#' + form + ' > div.filter-search-form-content > div.quicksearch-fields:first');
    if (quickFieldsDiv.length == 0) {
        return;
    }
    var formHtml = $("#" + form);
    var trs = quickFieldsDiv.children('table :first').find('tr.moved');
    for (var i = 0, l = trs.length; i < l; i++) {
        var tr = $(trs[i]);
        var originalTr = formHtml.find('#' + tr.attr('originalTr'));
        $(originalTr).empty();
        var childTds = tr.children('td');
        for (var i2 = 0, l2 = childTds.length; i2 < l2; i2++) {
            $(childTds[i2]).detach().appendTo(originalTr);
        }
        tr.remove();
    }
    if (!noslideup)
        quickFieldsDiv.slideUp();
    $("#" + form).removeAttr('MoveToQuick');
};


elma.MultiButtons = function () {
    var panels = [];


    var autoSizeInitFlg = false;
    var autoSizeInit = function() {
        if (autoSizeInitFlg)
            return;
        autoSizeInitFlg = true;

        $(document).ready(function () {
            elma.MultiButtons.SetSizeAll();

            $(window).resize(function () {
                elma.MultiButtons.SetSizeAll();
            });

            window.setInterval(function () {
                elma.MultiButtons.SetSizeAll();
            }, 2000);
        });
    }

    var setSize = function (id, showAll) {
        var panel = panels[id];
        
        if (panel.objectFlg)
            return;

        var buttons = panel.containerObject.find(".mb-Item");
        if (buttons.length == 0)
            return;

        panel.objectFlg = true;
        var isLine = function() {
            var flg = true;
            for (var i = 0; i < buttons.length; i++) {
                flg = $(buttons[i]).position().top == $(buttons[0]).position().top;
                if (!flg)
                    break;
            }
            return flg;
        }

        var showAllButtonSet = function (value) {
            var table = panel.containerObject.parents("table:first");
            if (value) {
                table.addClass("mb-EnableShowAll");
            } else {
                table.removeClass("mb-EnableShowAll");
            }
        };
        var showLineButtonSet = function (value) {
            if (value) {
                panel.containerObject.addClass("mb-InLine");
            } else {
                panel.containerObject.removeClass("mb-InLine");
            }
        };

        if (showAll != null || panel.showAllFlg) {
            if (showAll == true && !isLine()) {
                showLineButtonSet(false);
                showAllButtonSet(false);
                panel.showAllFlg = true;
                showAll = null;
            }
            if (showAll == false) {
                showLineButtonSet(true);
                showAllButtonSet(true);
                panel.showAllFlg = false;
                showAll = null;
            }
        }
        if (showAll == null && !panel.showAllFlg) {
            if (isLine()) {
                if (!panel.objectHide) {
                    panel.objectHide = true;
                    showAllButtonSet(false);
                }
            } else {
                if (panel.objectHide) {
                    panel.objectHide = false;
                    showAllButtonSet(true);
                }
            }
        }
        if (showAll == null && panel.showAllFlg) {
            if (isLine()) {
                showLineButtonSet(true);
            } else {
                showLineButtonSet(false);
            }
        }
        panel.objectFlg = false;
    };

    return {

        SetSizeAll: function () {
            var keys = Object.keys(panels);
            for (var i = 0; i < keys.length; i++) {
                setSize(keys[i]);
            }
        },

        ShowAll: function (id, showAll) {
            setSize(id, showAll);
        },

        GetCurrentButtonUid: function (id, el) {
            return $(el).parents("#" + id + ":first").find("div.t-switchview.current-watch").attr("uid");
        },

        Select: function (id, el) {
            if (jQuery.type(el) === "string")
                el = $(GetByUid(el)).find(".mb-ButtonLink")[0];

            if ($(el).hasClass('current-watch'))
                return;

            var uid = $(el).attr("uid");
            var oldUid = elma.MultiButtons.GetCurrentButtonUid(id, el);
            $(el).parents("#" + id + ":first").find("div.t-switchview.current-watch").removeClass('current-watch').addClass('backlight');
            $(el).removeClass('backlight').addClass('current-watch');
            window[elma.MultiButtons.Info(id).OnclickScript](uid, oldUid);
        },

        DeleteClick: function (id, el) {
            var info = elma.MultiButtons.Info(id);
            if (!info.Deletable)
                return;

            var uid = $(el).parents(".mb-Item:first").find(".mb-ButtonLink").attr("uid");
            var e = { Cancel: false };
            window[elma.MultiButtons.Info(id).OnDeleteClickScript](uid, e);

            if (!e.Cancel)
                elma.MultiButtons.Remove(id, uid);
        },

        Add: function (id, name, uid) {
            var panel = panels[id];
            var info = elma.MultiButtons.Info(id);
            var app = "<div class='mb-Item'>"
                    + " <div style='display: inline-block;" + (name.length > info.MaxSymbols ? "width: " + info.MaxWidth + "px" : "") + "'>"
                    + "  <div class='mb-Button'>"
                    + "   <div uid='" + uid + "' class='mb-ButtonLink t-switchview backlight' tooltiptext='" + name + "' onclick='elma.MultiButtons.Select(\"" + id + "\", this)'>" + name + "</div>"
                    + "  </div>"
                    + " </div>"
                    + (info.Deletable ? "<div class='delete_middle' style='position: relative; float: right; top: 6px; right: 0; width: 16px; height: 16px;' aria-describedby='ui-tooltip-90' onclick='elma.MultiButtons.DeleteClick(\"" + id + "\", this)'></div>" : "")
                    + "</div>";
            var lastButton = $(".mb-Item:last");
            if (lastButton.length != 0) {
                $(".mb-Item:last").after(app);
            } else {
                panel.containerObject.prepend(app);
            }
            setSize(id);
        },

        Remove: function (id, uid) {
            $(elma.MultiButtons.GetByUid(id, uid)).remove();
            setSize(id);
        },

        GetByUid: function (id, uid) {
            var panel = panels[id];
            return panel.containerObject.find(".mb-Item .mb-ButtonLink[uid='" + uid + "']").parents(".mb-Item:first")[0];
        },

        Info: function (id) {
            var panel = panels[id];
            return {
                MaxWidth: panel.maxWidth,
                MaxSymbols: panel.maxSymbols,
                OnclickScript: panel.onclickScript,
                OnDeleteClickScript: panel.onDeleteClickScript,
                Deletable: panel.deletable
            };
        },

        RegisterPanel: function (id, maxWidth, maxSymbols, onclickScript, deletable, onDeleteClickScript) {
            panels[id] = {
                id: id,
                containerObject: $("#" + id),
                objectHide: true,
                objectFlg: false,
                showAllFlg: false,
                maxWidth: maxWidth,
                maxSymbols: maxSymbols,
                onclickScript: onclickScript,
                deletable: deletable,
                onDeleteClickScript: onDeleteClickScript
            };
            autoSizeInit();
        }
    };
}();



elma.MultiEdit = function () {
    var objectTypeName;
    var objectId;
    var objectIds;
    var userId;
    var sessionUid;
    var extUid;
    var pingUrl;
    var pingManyUrl;
    var warningIconUrl;
    var savedIconUrl;
    var publishedIconUrl;
    var editedIconUrl;
    var wasSaved;
    var savedObjectId;
    var warningPanelId;
    var warningPanelContentId;
    var warningIconId;
    var isInited = false;
    var isDisabled = false;
    var isCustomHtmlMarkup = false;

    var savedObjectIds = [];
    var errMsgs = [];

    return {
        Disable: function() {
            isDisabled = true;
        },

        ShowWarningPanel: function () {
            $('#' + warningIconId).addClass('active');
            if ($("#" + warningPanelId).is(":visible")) return;
            var pos = $("#" + warningIconId).position();
            var style = elma.MultiEdit.getWarningPanelStyle(pos);
            $("#" + warningPanelId).css(style);
            $("#" + warningPanelId).fadeIn('slow');
        },

        HideWarningPanel: function () {
            $('#' + warningIconId).removeClass('active');
            if (!$("#" + warningPanelId).is(":visible")) return;
            setTimeout(function () {
                if (!$('#' + warningIconId).hasClass('active')) $("#" + warningPanelId).fadeOut('slow');
            }, 1500);
        },

        CloseWarningPanel: function () {
            $("#" + warningPanelId).hide();
        },

        GetWarningTableContent: function(info, us) {
            var isSaved = us.saveTime != null;
            var isPublished = us.publishTime != null;

            var tr = '<tr>'
                + '<td>' + (isPublished ? "<img src='" + info.PublishedIconUrl + "' />" : (isSaved ? "<img src='" + info.SavedIconUrl + "' />" : "<img src='" + info.EditedIconUrl + "' />")) + '</td>'
                + '<td>' + '<a href="javascript:elma.MultiEdit.CloseWarningPanel();showUserInfo(' + us.userId + ');">' + us.userName + '</a>' + '</td>'
                + '<td>' + us.objectName + '</td>'
                + '<td>' + (isSaved ? us.saveTimeStr : us.lastActivityTimeStr) + '</td>'
                + '</tr>';

            return tr;
        },

        GetWarningContent: function (usersStr) {
            var text = SR.T("{0}Внимание!{1} В данный момент {2} редактируется также следующими пользователями:{3}", "<span class=\"header-text\"><span class=\"red_text\">", "</span>", objectTypeName, "</span>") + '<div style="padding-top: 10px;"><table class="multiedit-userslist">' + usersStr + '</table></div>';
            return text;
        },

        getWarningPanelStyle: function (pos) {
            if (isCustomHtmlMarkup) {
                return {
                    top: 10 + 'px',
                    left: (pos.left - 330) + 'px'
                };
            } else {
                return {
                    left: -330 + 'px'
                };
            }
        },

        getErrorMsg: function(info, us) {
            return SR.T('{0} сохранил {1} {2} проекта {3} {4}', us.userName, objectTypeName, us.objectName, us.parentObjectName, us.saveTimeStr);
        },

        PingFromServer: function () {
            if (isDisabled) {
                return;
            }

            $.ajax({
                url: pingUrl,
                data: { objectId: objectId, userId: userId, editSessionUid: sessionUid, extUid: extUid },
                type: "GET",
                cache: false,
                success: function (data) {
                    if (data.success) {
                        if (data.users != null && data.users.length > 0) {
                            var usersStr = "";
                            wasSaved = false;
                            for (var i = 0; i < data.users.length; i++) {
                                var us = data.users[i];
                                if (us.savedAfter != null && us.savedAfter) {
                                    wasSaved = true;
                                    savedObjectId = us.objectId;
                                }
                                var info = elma.MultiEdit.GetInfo();
                                usersStr += elma.MultiEdit.GetWarningTableContent(info, us);
                            }
                            $("#" + warningIconId).show();
                            var text = elma.MultiEdit.GetWarningContent(usersStr);
                            $("#" + warningPanelContentId).html(text);
                        } else {
                            $("#" + warningIconId).hide();
                        }
                    }
                }
            });

        },

        PingFromServerMany: function () {
            if (isDisabled) {
                return;
            }

            if (objectIds == null || objectIds == "") {
                $("#" + warningIconId).hide();
                return;
            }

            $.ajax({
                url: pingManyUrl,
                data: { objectIds: objectIds, userId: userId, editSessionUid: sessionUid, extUid: extUid },
                type: "GET",
                cache: false,
                success: function (data) {
                    if (data.success) {
                        var usersStr = "";
                        wasSaved = false;
                        savedObjectIds = [];
                        errMsgs = [];

                        if (data.users != null && data.users.length > 0) {
                            var info = elma.MultiEdit.GetInfo();
                            for (var i = 0; i < data.users.length; i++) {
                                var us = data.users[i];
                                if (us.savedAfter != null && us.savedAfter) {
                                    wasSaved = true;
                                    savedObjectIds.push(us.objectId);
                                    errMsgs[us.objectId] = elma.MultiEdit.getErrorMsg(info, us);
                                }
                                usersStr += elma.MultiEdit.GetWarningTableContent(info, us);
                            }
                            $("#" + warningIconId).show();
                            var text = elma.MultiEdit.GetWarningContent(usersStr);
                            $("#" + warningPanelContentId).html(text);
                        } else {
                            $("#" + warningIconId).hide();
                        }
                    }
                }
            });
        },

        SetNewObjectIds: function (newObjectIds) {
            objectIds = newObjectIds;
        },

        GetInfo: function () {
            return {
                ObjectId: objectId,
                ObjectIds: objectIds,
                UserId: userId,
                SessionUid: sessionUid,
                ExtUid: extUid,
                PingUrl: pingUrl,
                PingManyUrl: pingManyUrl,
                WarningIconUrl: warningIconUrl,
                SavedIconUrl: savedIconUrl,
                PublishedIconUrl: publishedIconUrl,
                EditedIconUrl: editedIconUrl,
                WasSaved: wasSaved,
                SavedObjectId: savedObjectId,
                WarningPanelId: warningPanelId,
                WarningPanelContentId: warningPanelContentId,
                WarningIconId: warningIconId,
                IsInited: isInited,
                ErrMsgs: errMsgs,
                SavedObjectIds: savedObjectIds
            };
        },

        Init: function (param) {
            objectTypeName = param.ObjectTypeName,
            objectId = param.ObjectId;
            objectIds = param.ObjectIds;
            userId = param.UserId;
            sessionUid = param.SessionUid;
            extUid = param.ExtUid;
            pingUrl = param.PingUrl;
            pingManyUrl = param.PingManyUrl;
            warningIconUrl = param.WarningIconUrl;
            savedIconUrl = param.SavedIconUrl;
            publishedIconUrl = param.PublishedIconUrl;
            editedIconUrl = param.EditedIconUrl;
            wasSaved = param.WasSaved;
            savedObjectId = param.SavedObjectId;
            warningPanelId = param.WarningPanelId;
            warningPanelContentId = param.WarningPanelContentId;
            warningIconId = param.WarningIconId;
            isInited = true;
            isCustomHtmlMarkup = param.IsCustomHtmlMarkup;
        }
    };
}();


(function ($) {
    // Плагин для медиа-элементов audio/video
    $.fn.elmaMedia = function (mediaId) {
        // iterate and reformat each matched element
        return this.each(function () {
            var $elmaMedia = $(this);

            //Создание структуры html
            //Обертка
            var elmaMediaId = 'elmaMedia_' + mediaId;
            var $video_wrap = $('<div id="' + elmaMediaId + '"></div>').addClass('elma-media-player');
            //Элементы управления
            var $video_controls = $('<div class="elma-media-controls"><a class="elma-media-play"></a><div class="elma-volume-box"><div class="elma-volume-slider"></div><a class="elma-volume-button"></a></div><div class="elma-media-timer elma-media-timer-current">00:00</div><div class="elma-media-seek"></div><div class="elma-media-timer elma-media-timer-remaining">00:00</div></div>');
            $elmaMedia.wrap($video_wrap);
            $elmaMedia.after($video_controls);

            var $fullscreencontrol = $('<a class="elma-media-fullscreen"></a>');

            //Получение каждого элемента управления
            var $video_container = $elmaMedia.parent('.elma-media-player');
            var $video_controls = $('.elma-media-controls', $video_container);
            var $elma_play_btn = $('.elma-media-play', $video_container);
            var $elma_video_seek = $('.elma-media-seek', $video_container);
            var $elma_video_timer = $('.elma-media-timer-current', $video_container);
            var $elma_video_timer_remaining = $('.elma-media-timer-remaining', $video_container);
            var $elma_volume = $('.elma-volume-slider', $video_container);
            var $elma_volume_btn = $('.elma-volume-button', $video_container);

            $video_controls.hide(); // По умолчанию контролы скрываем
            $elmaMedia.hide(); //По умолчанию скрываем элемент для расчета размера

            var play = function () {
                if ($elmaMedia.context.paused === false) {
                    $elmaMedia[0].pause();
                } else {
                    $elmaMedia[0].play();
                }
            };

            // Полный экран для видео в каждом браузере
            if ($elmaMedia[0].tagName === 'VIDEO') {
                if ($elmaMedia[0].requestFullscreen) {
                    var fullScreen = function () {
                        var state = document.fullscreenElement;
                        if (!state)
                            document.getElementById(elmaMediaId).requestFullscreen();
                        else {
                            document.exitFullscreen();
                        }
                    };
                    $elma_video_timer_remaining.after($fullscreencontrol);
                    $fullscreencontrol.click(fullScreen);
                } else if ($elmaMedia[0].msRequestFullscreen) {
                    var fullScreenIE = function () {
                        var state = document.msFullscreenElement;
                        if (!state) {
                            document.getElementById(elmaMediaId).msRequestFullscreen();
                        } else {
                            document.msExitFullscreen();
                        }
                    };
                    $elma_video_timer_remaining.after($fullscreencontrol);
                    $fullscreencontrol.click(fullScreenIE);
                } else if ($elmaMedia[0].mozRequestFullScreen) {
                    var fullScreenFF = function () {
                        var state = document.mozFullScreen;
                        if (!state)
                            document.getElementById(elmaMediaId).mozRequestFullScreen();
                        else {
                            document.mozCancelFullScreen();
                        } 
                    };
                    $elma_video_timer_remaining.after($fullscreencontrol);
                    $fullscreencontrol.click(fullScreenFF);
                } else if ($elmaMedia[0].webkitRequestFullscreen) {
                    var fullScreen = function() {
                        var state = document.webkitIsFullScreen;
                        if (!state)
                            document.getElementById(elmaMediaId).webkitRequestFullscreen();
                        else {
                            document.webkitExitFullscreen();
                        }
                    };
                    $elma_video_timer_remaining.after($fullscreencontrol);
                    $fullscreencontrol.click(fullScreen);
                } else {
                    console.log("Fullscreen API is not supported");
                }
            }

            //Работа в полноэкранном режиме
            $(document).bind('webkitfullscreenchange mozfullscreenchange fullscreenChange MSFullscreenChange', function (e) {
                var state = document.fullscreenElement ||
                            document.mozFullScreen ||
                            document.webkitIsFullScreen ||
                            document.msFullscreenElement;
                if (state) {
                    //FullscreenOn
                    $elmaMedia.addClass("fullscreen");
                } else {
                    //FullscreenOff
                    $elmaMedia.removeClass("fullscreen");
                }
            });

            $elma_play_btn.click(play);
            $elmaMedia.click(play);

            $elmaMedia.bind('play', function () {
                $elma_play_btn.addClass('elma-paused-button');
            });

            $elmaMedia.bind('pause', function () {
                $elma_play_btn.removeClass('elma-paused-button');
            });

            $elmaMedia.bind('ended', function () {
                $elma_play_btn.removeClass('elma-paused-button');
            });

            var gTimeFormat = function (seconds) {
                var m = Math.floor(seconds / 60) < 10 ? "0" + Math.floor(seconds / 60) : Math.floor(seconds / 60);
                var s = Math.floor(seconds - (m * 60)) < 10 ? "0" + Math.floor(seconds - (m * 60)) : Math.floor(seconds - (m * 60));
                return m + ":" + s;
            };

            var seeksliding;
            var video_duration;
            var createSeek = function () {
                if ($elmaMedia.context.readyState > 0) {
                    video_duration = $elmaMedia.context.duration;
                    $elma_video_seek.slider({
                        value: 0,
                        step: 0.01,
                        orientation: "horizontal",
                        range: "min",
                        max: video_duration,
                        animate: true,
                        slide: function () {
                            seeksliding = true;
                        },
                        stop: function (e, ui) {
                            seeksliding = false;
                            $elmaMedia.context.currentTime = ui.value;
                        }
                    });
                    $elma_video_timer_remaining.text(gTimeFormat(video_duration));
                    $video_controls.show();
                    $elmaMedia.show();
                } else {
                    setTimeout(createSeek, 150);
                }
            };

            createSeek();

            var seekUpdate = function () {
                var currenttime = $elmaMedia.context.currentTime;
                if (!seeksliding) {
                    $elma_video_seek.slider('value', currenttime);
                }
                $elma_video_timer.text(gTimeFormat(currenttime));
                var remainingtime = video_duration - currenttime;
                $elma_video_timer_remaining.text(gTimeFormat(remainingtime));
            };

            $elmaMedia.bind('timeupdate', seekUpdate);

            var media_volume = 1;
            $elma_volume.slider({
                value: 1,
                orientation: "horizontal",
                range: "min",
                max: 1,
                step: 0.05,
                animate: true,
                slide: function (e, ui) {
                    media_volume = ui.value;
                    $elmaMedia.context.volume = ui.value;
                    $elmaMedia.context.muted = false;
                    $elma_volume_btn.removeClass('elma-volume-mute');
                }
            });

            var muteVolume = function () {
                if ($elmaMedia.context.muted == true) {
                    $elma_volume.slider('value', media_volume);
                    $elmaMedia.context.volume = media_volume;
                    $elmaMedia.context.muted = false;
                    $elma_volume_btn.removeClass('elma-volume-mute');
                } else {
                    $elma_volume.slider('value', '0');
                    $elmaMedia.context.volume = 0;
                    $elmaMedia.context.muted = true;
                    $elma_volume_btn.addClass('elma-volume-mute');
                };
            };

            $elma_volume_btn.click(muteVolume);

            $elmaMedia.removeAttr('controls');
        });
    };

})(jQuery);


/*
 * Загрузка файлов через HTML5 File API. Предназначен для совместной работы с qq.FileUploader
*/

var html5upl = html5upl || {};

html5upl.extend = function (first, second) {
    for (var prop in second) {
        first[prop] = second[prop];
    }
};

html5upl.FileUploader = function (options) {
    this._options = {
        action: '/server/upload',
        sizeToUploadsInParts: '64',
        sizePart: '64',
        params: {},
        xhrObject: null,
        //Обработчик событий для отрисовки прогресс бара
        onProgress: function (id, fileName, loaded, total) { },
        //Обработчки события завершения отправки
        onComplete: function (id, xhr) { }
    };
    html5upl.extend(this._options, options);
    this.checkBrowser = function () {
        return window.File && window.FileReader && window.FileList && window.Blob;
    };
    this.getFileName = function (file) {
        return file.fileName != null ? file.fileName : file.name;
    };
    this.getFileSize = function (file) {
        return file.fileSize != null ? file.fileSize : file.size;
    };
    this.uploadFile = function (file, id) {
        if (!this.checkBrowser) return 1; //Ошибочка

        var fileName = this.getFileName(file);
        var fileSize = this.getFileSize(file);

        if (!elma.isIE() && fileSize > parseInt(this._options.sizeToUploadsInParts) * 1024 * 1024) {
            //Загрузка по частям
            var self = this;

            this.loaded = 0;
            this.fileUID = '';
            this._xhr = this._options.xhrObject[id] = new XMLHttpRequest();

            this.uploadPart(file, id, 0, 1);
        } else {
            //Загрузка без деления на части
            var xhr = this._options.xhrObject[id] = new XMLHttpRequest();
            var self = this;

            xhr.upload.onprogress = function (e) {
                self._options.onProgress(id, fileName, e.loaded, fileSize);
            };
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4)
                    self._options.onComplete(id, xhr);
            };
            this._options.params = this._options.params || {};
            this._options.params['qqfile'] = encodeURIComponent(fileName);
            var queryString = qq.obj2url(this._options.params, this._options.action);
            xhr.open("POST", queryString, true);
            xhr.setRequestHeader("__RequestVerificationToken", AntiForgeryToken.Generate());
            xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            xhr.setRequestHeader("X-File-Name", encodeURIComponent(fileName));
            xhr.setRequestHeader("Content-Type", "application/octet-stream");
            xhr.send(file);
        };
    };
    this.universalFileSlice = function (file, startPosition, stopPosition) {
        var blob = new Blob();
        if (file.slice) {
            blob = file.slice(startPosition, stopPosition);
        };
        if (file.webkitSlice) {
            blob = file.webkitSlice(startPosition, stopPosition);
        };
        if (file.mozSlice) {
            blob = file.mozSlice(startPosition, stopPosition);
        };

        return blob;
    };
    this.getPartOfFile = function (file, startPosition, stopPosition) {
        var blobPart = this.universalFileSlice(file, startPosition, stopPosition);

        if (elma.isIE()) {
            return window.navigator.msSaveBlob(blobPart, this.getFileName(file))
        }

        var filePart = new File([blobPart], this.getFileName(file));

        return filePart;
    };
    this.uploadPart = function (file, id, startPosition, partNumber) {
        var sizePart = parseInt(this._options.sizePart) * 1024 * 1024;
        var fileSize = this.getFileSize(file);
        var fileName = this.getFileName(file);
        if (startPosition < fileSize) {
            var stopPosition = startPosition + sizePart;
            if (stopPosition > fileSize) stopPosition = fileSize;
            var filePart = this.getPartOfFile(file, startPosition, stopPosition);
            var self = this;
    
            this._xhr.onreadystatechange = function () {
                if (self._xhr.readyState == 4)
                    if (startPosition >= fileSize)
                        self._options.onComplete(id, xhr);
                    else {
                        var responseData = $.parseJSON(self._xhr.response);
                        if (responseData.success == true) {
                            self.loaded += stopPosition - startPosition;
                            startPosition += sizePart;
                            partNumber += 1;
                            self.fileUID = responseData.uid;
                            self.uploadPart(file, id, startPosition, partNumber);
                        }
                    }
            };
            this._xhr.upload.onprogress = function (e) {
                self._options.onProgress(id, fileName, self.loaded + e.loaded, fileSize);
            };
            this._options.params = this._options.params || {};
            this._options.params['qqfile'] = encodeURIComponent(fileName);
            var queryString = qq.obj2url(this._options.params, this._options.action);
            this._xhr.open("POST", queryString, true);
            this._xhr.setRequestHeader("__RequestVerificationToken", AntiForgeryToken.Generate());
            this._xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            this._xhr.setRequestHeader("X-File-Name", encodeURIComponent(fileName));
            this._xhr.setRequestHeader("Content-Type", "application/octet-stream");
            this._xhr.setRequestHeader("FileGuid", encodeURIComponent(this.fileUID));
            this._xhr.setRequestHeader("Content-Range", "bytes " + encodeURIComponent(startPosition.toString()) + "-" + encodeURIComponent(stopPosition.toString()) + "/" + encodeURIComponent(fileSize.toString()));
            this._xhr.send(filePart);
        } else {
            this._options.onComplete(id, this._xhr);
        }
    };
    this.loaded = 0;
    this._xhr = null;
    this.fileUID = '';
};



isMobile = {
    Android: function () {
        return navigator.userAgent.match(/Android/i);
    },
    BlackBerry: function () {
        return navigator.userAgent.match(/BlackBerry/i);
    },
    iOS: function () {
        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
    },
    Opera: function () {
        return navigator.userAgent.match(/Opera Mini/i);
    },
    Windows: function () {
        return navigator.userAgent.match(/IEMobile/i);
    },
    EnotherTouchDevice: function() {
        return (('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
    },
    any: function () {
        return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
    }
};

$(document).ready(function () {
    if (!isMobile.any()) {
        if ($("#div_WorkPlaceCustomizer").height() == null && $(".floatMainMenu").height() != null) {

            function getFloatMenuTop() {
                var mainMenuOffset = $(".floatMainMenu").offset();
                return mainMenuOffset ? mainMenuOffset.top : 0;
            }

            var winHeight = $(window).height();
            var mainMenuTop = getFloatMenuTop();
            var mainMenuHeight = $(".floatMainMenu").outerHeight();
            var mainMenuTopPx = mainMenuTop;
            var scrollUpOrDown = 0;
            var witchScroll = null;
            var rootToolBarHeight = $('#rootToolBar').outerHeight();
            var widthFloatMainMenu = $(".floatMainMenu").width();
            var heightFloatMainMenu = $(".floatMainMenu").height();
            var rootToolBarTopPx = 0;
            var arrowTopPx = $('#arrow').offset().top;

            $(window).resize(function () {
                winHeight = $(window).height();
                var scroll = $(window).scrollTop();
                winResize();
                $("#arrow")
                    .css({
                        'margin-top': arrowTopPx - rootToolBarHeight + scroll
                    })
            });

            function winResize() {
                if ($(window).scrollTop() > mainMenuTop) {
                    $(".floatMainMenu")
                        .css({
                            'position': 'fixed',
                            'top': '0px'
                        })
                    mainMenuTopPx = getFloatMenuTop();
                }
                else {
                    $(".floatMainMenu")
                            .css({
                                'position': 'relative',
                                'top': 'auto'
                            })
                }
            };

            $(window).scroll(function () {
                widthFloatMainMenu = $(".floatMainMenu").width();
                heightFloatMainMenu = $(".floatMainMenu").height();

                var scrollPx = $(window).scrollTop();
                var scrollPxLeft = $(window).scrollLeft();

                $("#arrow")
                    .css({
                        'margin-top': arrowTopPx - rootToolBarHeight + scrollPx
                    })

                if (scrollPx > scrollUpOrDown) {
                    scrollUpOrDown = scrollPx;
                    witchScroll = "Down";
                }
                else {
                    scrollUpOrDown = scrollPx;
                    witchScroll = "Up";
                }

                if (scrollPx >= 0) {
                    if (winHeight >= mainMenuHeight || widthFloatMainMenu < 100 || heightFloatMainMenu < 100) {
                        if (witchScroll == "Down" && scrollPx >= rootToolBarHeight) {
                            if (scrollPx < mainMenuTopPx) {
                                $(".floatMainMenu")
                                    .css({
                                        'position': 'relative',
                                        'top': (mainMenuTopPx - rootToolBarHeight),
                                        'left': 'auto'
                                    })
                            }
                            else {
                                $(".floatMainMenu")
                                    .css({
                                        'position': 'fixed',
                                        'top': '0px',
                                        'left': -scrollPxLeft
                                    })
                                mainMenuTopPx = getFloatMenuTop();
                            }
                        }
                        else {
                            if (scrollPx == 0) {
                                $(".floatMainMenu")
                                    .css({
                                        'position': 'relative',
                                        'top': 'auto',
                                        'left': 'auto'
                                    })
                            }
                            else {
                                if (scrollPx > mainMenuTopPx - rootToolBarHeight) {
                                    $(".floatMainMenu")
                                        .css({
                                            'position': 'relative',
                                            'top': (mainMenuTopPx - rootToolBarHeight),
                                            'left': 'auto'
                                        })
                                }
                                else {
                                    $(".floatMainMenu")
                                        .css({
                                            'position': 'fixed',
                                            'top': rootToolBarHeight,
                                            'left': -scrollPxLeft
                                        })
                                    mainMenuTopPx = getFloatMenuTop();
                                }
                            }
                        }
                    }
                    else if (winHeight < mainMenuHeight || widthFloatMainMenu > 100 || heightFloatMainMenu > 100) {
                        if (witchScroll == "Down") {
                            if ((scrollPx + winHeight) >= (mainMenuTop + mainMenuHeight)) {
                                if ((scrollPx + winHeight) >= (mainMenuTopPx + mainMenuHeight)) {
                                    $(".floatMainMenu")
                                        .css({
                                            'top': 'auto',
                                            'position': 'fixed',
                                            'bottom': '0px',
                                            'left': -scrollPxLeft
                                        })
                                    mainMenuTopPx = getFloatMenuTop();
                                }
                                else {
                                    $(".floatMainMenu")
                                        .css({
                                            'position': 'relative',
                                            'top': mainMenuTopPx - mainMenuTop,
                                            'left': 'auto'
                                        })
                                }
                            }
                            else {
                                $(".floatMainMenu")
                                    .css({
                                        'position': 'relative',
                                        'top': 'auto',
                                        'bottom': 'auto',
                                        'left': 'auto'
                                    })
                            }
                        }
                        else {
                            if (scrollPx != 0) {
                                if (scrollPx > mainMenuTopPx - rootToolBarHeight) {
                                    $(".floatMainMenu")
                                        .css({
                                            'position': 'relative',
                                            'top': mainMenuTopPx - mainMenuTop,
                                            'bottom': 'auto',
                                            'left': 'auto'
                                        })
                                }
                                else {
                                    $(".floatMainMenu")
                                        .css({
                                            'position': 'fixed',
                                            'top': rootToolBarHeight,
                                            'left': -scrollPxLeft
                                        })
                                    mainMenuTopPx = getFloatMenuTop();
                                }
                            }
                            else {
                                $(".floatMainMenu")
                                    .css({
                                        'position': 'relative',
                                        'top': 'auto',
                                        'left': 'auto'
                                    })
                                mainMenuTopPx = mainMenuTop;
                            }
                        }
                    }
                }
                else {
                    $(".floatMainMenu")
                        .css({
                            'position': 'relative',
                            'top': 'auto',
                            'left': 'auto'
                        })
                }
            });
        }
    }
});


if (!isMobile.any()) {
    var rootToolBarTopPx = 0;
    var scrollUpOrDown = 0;
    var witchScroll = null;
    var rootTableWidth;
    var lastScrollPx = 0;

    $(window).resize(function () {
        if (!isMobile.any()) {
            if ($("#div_WorkPlaceCustomizer").height() == null && $(".floatMainMenu").height() != null) {
                rootTableWidth = $("#rootTable").width()

                $("#rootToolBar").css({
                    'width': rootTableWidth
                })
            }
        }
    });

    $(window).scroll(function () {
            if ($("#div_WorkPlaceCustomizer").height() == null && $(".floatMainMenu").height() != null) {

                var scrollPx = $(window).scrollTop();
                var scrollPxLeft = $(window).scrollLeft();

                if (scrollPx > scrollUpOrDown) {
                    scrollUpOrDown = scrollPx;
                    witchScroll = "Down";
                }
                else {
                    scrollUpOrDown = scrollPx;
                    witchScroll = "Up";
                }
                if (scrollPx >= 0 && lastScrollPx > 0) {
                    if (witchScroll == 'Down') {
                        if (scrollPx >= (rootToolBarTopPx + 75)) {
                            $('#rootToolBar')
                            .css({
                                'position': 'fixed',
                                'top': '-75px',
                                'z-index': '1000',
                                'left': -scrollPxLeft
                            })
                            rootToolBarTopPx = scrollPx - 75;
                        }
                        else {
                            $('#rootToolBar')
                            .css({
                                'position': 'absolute',
                                'top': rootToolBarTopPx,
                                'z-index': '1000',
                                'left': 'auto'
                            })
                        }
                    }
                    else {
                        if (scrollPx >= rootToolBarTopPx) {
                            $('#rootToolBar')
                            .css({
                                'position': 'absolute',
                                'top': rootToolBarTopPx,
                                'z-index': '1000',
                                'left': 'auto'
                            })
                        }
                        else {
                            if (scrollPx == 0) {
                                $('#rootToolBar')
                                    .css({
                                        'position': 'relative',
                                        'top': 'auto',
                                        'z-index': '1000',
                                        'left': 'auto'
                                    })
                                rootToolBarTopPx = scrollPx;
                            }
                            else {
                                $('#rootToolBar')
                                    .css({
                                        'position': 'fixed',
                                        'top': '0px',
                                        'z-index': '1000',
                                        'left': -scrollPxLeft
                                    })
                                rootToolBarTopPx = scrollPx;
                            }
                        }
                    }
                }
                else {
                    $("#rootToolBar")
                        .css({
                            'position': 'relative',
                            'top': 'auto',
                            'left': 'auto'
                        })
                }
            }

            lastScrollPx = scrollPx;
    });
}


(function ($) {
    // fix background flickering under IE6
    try {
        if (document.execCommand)
            document.execCommand('BackgroundImageCache', false, true);
    } catch (e) { }

    var dateCheck = /\d/;
    var whiteSpaceRegExp = /\s+/;
    var version = parseInt($.browser.version.substring(0, 5).replace('.', ''));
    var geckoFlicker = $.browser.mozilla && version >= 180 && version <= 191;
    var dateFormatTokenRegExp = /d{1,4}|M{1,4}|yy(?:yy)?|([Hhmstf])\1*|"[^"]*"|'[^']*'/g;

    var $t = $.telerik = {

        create: function (query, settings) {
            var name = settings.name;
            var options = $.extend({}, $.fn[name].defaults, settings.options);

            return query.each(function () {
                var $$ = $(this);
                options = $.meta ? $.extend({}, options, $$.data()) : options;

                if (!$$.data(name)) {
                    var component = settings.init(this, options);

                    $$.data(name, component);

                    $t.trigger(this, 'load');

                    if (settings.success) settings.success(component);
                }
            });
        },

        toJson: function (o) {
            function serializeArray(array) {
                return '[' + $.map(array, serialize).join(',') + ']';
            }

            function serialize(obj) {
                var result = [];
                for (var key in obj) {
                    var value = obj[key];
                    if ($.isArray(value)) {
                        result.push('"' + key + '":' + serializeArray(value));
                    } else if (typeof value != 'object') {
                        result.push('"' + key + '":"' + (value == null ? "" : value) + '"');
                    } else {
                        result.push('"' + key + '":' + serialize(value));
                    }
                }
                return '{' + result.join(',') + '}';
            }

            if ($.isArray(o)) {
                return serializeArray(o);
            } else {
                return serialize(o);
            }
        },

        delegate: function (context, handler) {
            return function (e) {
                handler.apply(context, [e, this]);
            };
        },

        stop: function (handler, context) {
            return function (e) {
                e.stopPropagation();
                handler.apply(context || this, arguments);
            };
        },

        stopAll: function (handler, context) {
            return function (e) {
                e.preventDefault();
                e.stopPropagation();
                handler.apply(context || this, arguments);
            };
        },

        bind: function (context, events) {
            var $element = $(context.element ? context.element : context);
            $.each(events, function (eventName) {
                if ($.isFunction(this)) $element.bind(eventName, this);
            });
        },

        preventDefault: function (e) {
            e.preventDefault();
        },

        hover: function () {
            $(this).addClass('t-state-hover');
        },

        leave: function () {
            $(this).removeClass('t-state-hover');
        },

        buttonHover: function () {
            $(this).addClass('t-button-hover');
        },

        buttonLeave: function () {
            $(this).removeClass('t-button-hover');
        },

        stringBuilder: function () {
            this.buffer = [];
        },

        ajaxError: function (element, eventName, xhr, status) {
            var prevented = this.trigger(element, eventName,
                {
                    XMLHttpRequest: xhr,
                    textStatus: status
                });

            if (!prevented) {
                if (status == 'error' && xhr.status != '0')
                    alert('Error! The requested URL returned ' + xhr.status + ' - ' + xhr.statusText);
                if (status == 'Forbidden')
                    alert('Error! Forbidden ' + xhr.status);
                if (status == 'timeout')
                    alert('Error! Server timeout.');
            }

            return prevented;
        },

        trigger: function (element, eventName, e) {
            e = $.extend(e || {}, new $.Event(eventName));
            e.stopPropagation();
            $(element).trigger(e);
            return e.isDefaultPrevented();
        },

        // Returns the type as a string. Not full. Used in string formatting
        getType: function (obj) {
            if (obj instanceof Date)
                return 'date';
            if (!isNaN(obj))
                return 'number';
            return 'object';
        },

        formatString: function () {
            var s = arguments[0];

            for (var i = 0, l = arguments.length - 1; i < l; i++) {
                var reg = new RegExp('\\{' + i + '(:([^\\}]+))?\\}', 'gm');

                var argument = arguments[i + 1];

                var formatter = this.formatters[this.getType(argument)];
                if (formatter) {
                    var match = reg.exec(s);
                    if (match)
                        argument = formatter(argument, match[2]);
                }

                s = s.replace(reg, function () {
                    return argument;
                });
            }
            return s;
        },

        getElementZIndex: function (element) {
            var zIndex = 'auto';
            $(element).parents().andSelf().each(function () {
                zIndex = $(this).css('zIndex');
                if (Number(zIndex)) {
                    zIndex = Number(zIndex) + 1;
                    return false;
                }
            });

            return zIndex;
        },

        getElementPosition: function (element) {
            var position = { position: 'absolute', offset: null };
            $($(element).parents().andSelf().toArray().reverse()).each(function () {
                if ($(this).css('position') != 'relative' && $(this).css('position') != 'static') {
                    position.position = $(this).css('position');
                    position.offset = $(this).offset();
                    return false;
                }
            });

            return position;
        },

        lastIndexOf: function (value, character) {
            var characterLength = character.length;
            for (var i = value.length - 1; i > -1; i--)
                if (value.substr(i, characterLength) == character) return i;
            return -1;
        },

        caretPos: function (element) {
            var pos = -1;

            if (document.selection)
                pos = Math.abs(document.selection.createRange().moveStart('character', -element.value.length));
            else if (element.selectionStart !== undefined)
                pos = element.selectionStart;

            return pos;
        },

        encode: function (value) {
            return value.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\u00a0/g, '&nbsp;');
        },

        decode : function(value){
            return !value ? value : String(value).replace(/&amp;/g, "&").replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"');
        },

        formatters: {},

        fx: {},

        cultureInfo: {
            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            abbrDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            abbrMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            longTime: 'h:mm:ss tt',
            longDate: 'dddd, MMMM dd, yyyy',
            shortDate: 'M/d/yyyy',
            shortTime: 'h:mm tt',
            fullDateTime: 'dddd, MMMM dd, yyyy h:mm:ss tt',
            generalDateShortTime: 'M/d/yyyy h:mm tt',
            generalDateTime: 'M/d/yyyy h:mm:ss tt',
            sortableDateTime: "yyyy'-'MM'-'ddTHH':'mm':'ss",
            universalSortableDateTime: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
            monthYear: 'MMMM, yyyy',
            monthDay: 'MMMM dd',
            today: 'today',
            tomorrow: 'tomorrow',
            yesterday: 'yesterday',
            next: 'next',
            last: 'last',
            year: 'year',
            month: 'month',
            week: 'week',
            day: 'day',
            am: 'AM',
            pm: 'PM',
            dateSeparator: '/',
            timeSeparator: ':',
            firstDayOfWeek: 0
        }
    };

    var filter, map;

    if (Array.prototype.filter !== undefined) {
        filter = function (array, predicate) {
            return array.filter(predicate);
        };
    } else {
        filter = function (array, predicate) {
            var result = [], length = array.length;

            for (var i = 0; i < length; i++) {
                var value = array[i];

                if (predicate(value, i, array)) {
                    result[result.length] = value;
                }
            }

            return result;
        };
    }

    if (Array.prototype.map !== undefined) {
        map = function (array, callback) {
            return array.map(callback);
        };
    } else {
        map = function (array, callback) {
            var length = array.length, result = new Array(length);

            for (var i = 0; i < length; i++) {
                result[i] = callback(array[i], i, array);
            }

            return result;
        };
    }

    var query = function (data) {
        return new query.fn.init(data);
    };
    $t.query = query;

    query.fn = query.prototype = {
        init: function (data) {
            this.data = data;

            return this;
        },
        toArray: function () {
            return this.data;
        },
        where: function (predicate) {
            return query(filter(this.data, predicate));
        },
        select: function (selector) {
            return query(map(this.data, selector));
        },
        skip: function (count) {
            return query(this.data.slice(count));
        },
        take: function (count) {
            return query(this.data.slice(0, count));
        },
        orderBy: function (selector) {
            var result = this.data.slice(0);

            return query(result.sort(function (a, b) {
                a = selector(a);
                b = selector(b);

                return a > b ? 1 : (a < b ? -1 : 0);
            }));
        },
        orderByDescending: function (selector) {
            var result = this.data.slice(0);

            return query(result.sort(function (a, b) {
                a = selector(a);
                b = selector(b);

                return a < b ? 1 : (a > b ? -1 : 0);
            }));
        },
        concat: function (value) {
            return query(this.data.concat(value.data));
        },
        count: function () {
            return this.data.length;
        },
        any: function (predicate) {
            if ($.isFunction(predicate)) {
                for (var index = 0, length = this.data.length; index < length; index++) {
                    if (predicate(this.data[index], index)) {
                        return true;
                    }
                }

                return false;
            }
            return !!this.data.length;
        }
    };
    query.fn.init.prototype = query.fn;



    $t.dropDown = function (options) {
        $.extend(this, options);

        this.$element = $(new $t.stringBuilder().cat('<div ')
                                 .catIf(options.attr, options.attr)
                                 .cat('><ul class="t-reset"></ul></div>')
                                 .string())
                                 .addClass("t-popup t-group")
                                 .hide();
    };
    $t.dropDown.prototype = {
        _html: function (data) {
            var html = new $t.stringBuilder();
            if (data) {
                for (var i = 0, length = data.length; i < length; i++) {

                    var text = "&nbsp;",
                        dataItem = data[i],
                        htmltext = "&nbsp;";
                    if (dataItem) {
                        if (dataItem.DropDownText !== undefined && dataItem.DropDownText !== null) {
                            text = dataItem.DropDownText;
                        } else if (dataItem.Text !== undefined) {
                            text = dataItem.Text;
                        } else {
                            text = dataItem;
                        }
                        if (!text || !text.replace(whiteSpaceRegExp, '')) {
                            text = '&nbsp;';
                        }
                        htmltext = dataItem.Html ? dataItem.Html : text;
                        if (!htmltext || !htmltext.replace(whiteSpaceRegExp, '')) {
                            htmltext = '&nbsp;';
                        }
                    }

                    var e = {
                        html: text,
                        dataItem: dataItem
                    };

                    if (this.onItemCreate) this.onItemCreate(e);
                    var separator = "";
                    if (dataItem.IsEndItem) {
                        separator = '<div style=\"margin:0 -5px -3px -3px; padding-left:10px;\" class="Gray_Input_Separator">' + (dataItem.EndItemText ? dataItem.EndItemText : SR.T('Остальное')) + '</div>';
                    }
                    if (dataItem.ListItemClass) {
                        htmltext = '<div class="' + dataItem.ListItemClass + '">' + htmltext + '</div>';
                    }
                    html.cat('<li class="' + (!dataItem.VirtualItem ? "t-item" : "t-virtual-item") + '">').cat(htmltext).cat(separator).cat('</li>');
                }
            }
            return html.string();
        },

        playBottom: true,

        open: function (position) {
            if (this.onOpen) this.onOpen();

            if (this.isOpened() || !this.$items) return;

            var $element = this.$element,
                selector = '.t-reset > .t-item';

            $element.appendTo(document.body);

            var width;

            if ($element[0].style.width == '')
                width = position.outerWidth ? position.outerWidth : 0;
            else
                width = parseInt(this.attr ? $('<div' + this.attr + '></div>')[0].style.width : $element[0].style.width);

            $element.css('overflowY', 'auto')
                    .css('min-width', width - 2);

            $element.delegate(selector, 'mouseenter', $t.hover)
                    .delegate(selector, 'mouseleave', $t.leave)
                    .delegate(selector, 'click',
                        $.proxy(function (e) {
                            if (this.onClick)
                                this.onClick($.extend(e, { item: $(e.target).closest('.t-item')[0] }));
                        }, this));
            $element.delegate('.t-reset > .t-virtual-item', 'click', $.proxy(function (e) {
                this.close();
            }, this));

            var elementPosition = position.offset;
            var height = $element.height();
            if (elementPosition.top >= $element.height() && elementPosition.top + position.outerHeight - 1 + height > $(window).height() + $(window).scrollTop()) {
                elementPosition.top -= $element.height();
                this.playBottom = false;
            } else {
                elementPosition.top += position.outerHeight - 1;
                this.playBottom = true;
            }
            if (!position.position) {
                position.position = { position: 'absolute' };
            }
            else if (position.position.offset && position.position.position == 'fixed') {
                elementPosition.top -= $(window).scrollTop();
                elementPosition.left -= $(window).scrollLeft();
            }

            $t.fx._wrap($element).css($.extend({
                position: position.position.position,
                zIndex: position.zIndex
            }, elementPosition));

            if (geckoFlicker)
                $element.css('overflow', 'hidden');

            $t.fx.play(this.effects, $element, { direction: this.playBottom ? 'bottom' : 'top' }, $.proxy(function () {
                if (geckoFlicker)
                    $element.css('overflow', 'auto');

                var $selectedItems = this.$items.filter('.t-state-selected');
                if ($selectedItems.length) this.scrollTo($selectedItems[0]);
            }, this));
        },

        close: function () {
            if (!this.isOpened()) return;

            var $element = this.$element;

            if (geckoFlicker)
                $element.css('overflow', 'hidden');

            $t.fx.rewind(this.effects, $element, { direction: this.playBottom ? 'bottom' : 'top' }, function () {
                if (geckoFlicker)
                    $element.css('overflow', 'auto');
                $element.parent().remove();
            });
        },

        dataBind: function (data) {
            data = data || [];

            var $element = this.$element;
            var elementHeight = $element[0].style.height;
            var height = elementHeight && elementHeight != 'auto' ? $element[0].style.height : '189px';

            var $items = this.$items = $(this._html(data));
            $element.find('> ul').html($items);
            $element.css('height', $items.length > 11 ? height : 'auto');
        },

        highlight: function (li) {
            return $(li).addClass('t-state-selected')
                        .siblings()
                        .removeClass('t-state-selected')
                        .end()
                        .index();
        },

        isOpened: function () {
            return this.$element.is(':visible');
        },

        scrollTo: function (item) {

            if (!item) return;

            var itemOffsetTop = item.offsetTop;
            var itemOffsetHeight = item.offsetHeight;

            var dropDown = this.$element[0];
            var dropDownScrollTop = dropDown.scrollTop;
            var dropDownOffsetHeight = dropDown.clientHeight;
            var bottomDistance = itemOffsetTop + itemOffsetHeight;

            dropDown.scrollTop = dropDownScrollTop > itemOffsetTop
                                    ? itemOffsetTop
                                    : bottomDistance > (dropDownScrollTop + dropDownOffsetHeight)
                                    ? bottomDistance - dropDownOffsetHeight
                                    : dropDownScrollTop;
        }
    };
    $t.datetime = function () {
        if (arguments.length == 0)
            this.value = new Date();
        else if (arguments.length == 1)
            this.value = new Date(arguments[0]);
        else if (arguments.length == 3)
            this.value = new Date(arguments[0], arguments[1], arguments[2]);
        else if (arguments.length == 6)
            this.value = new Date(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        else
            this.value = new Date(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);

        return this;
    };
    $.extend($t.datetime, {
        msPerMinute: 60000,
        msPerDay: 86400000,
        add: function (date, valueToAdd) {
            var tzOffsetBefore = date.timeOffset();
            var resultDate = new $t.datetime(date.time() + valueToAdd);
            var tzOffsetDiff = resultDate.timeOffset() - tzOffsetBefore;
            return new $t.datetime(resultDate.time() + tzOffsetDiff * $t.datetime.msPerMinute);
        },

        subtract: function (date, dateToSubtract) {
            dateToSubtract = new $t.datetime(dateToSubtract).toDate();
            var diff = date.time() - dateToSubtract;
            var tzOffsetDiff = date.timeOffset() - dateToSubtract.timeOffset();
            return diff - (tzOffsetDiff * $t.datetime.msPerMinute);
        },

        firstDayOfMonth: function (date) {
            return new $t.datetime(0)
                        .hours(date.hours())
                        .minutes(date.minutes())
                        .seconds(date.seconds())
                        .milliseconds(date.milliseconds())
                        .year(date.year(), date.month(), 1);
        },

        firstVisibleDay: function (date) {
            var firstDayOfWeek = $t.cultureInfo.firstDayOfWeek;
            var firstVisibleDay = new $t.datetime(date.year(), date.month(), 0, date.hours(), date.minutes(), date.seconds(), date.milliseconds());
            while (firstVisibleDay.day() != firstDayOfWeek) {
                $t.datetime.modify(firstVisibleDay, -1 * $t.datetime.msPerDay);
            }
            return firstVisibleDay;
        },

        modify: function (date, value) {
            var tzOffsetBefore = date.timeOffset();
            var resultDate = new $t.datetime(date.time() + value);
            var tzOffsetDiff = resultDate.timeOffset() - tzOffsetBefore;
            date.time(resultDate.time() + tzOffsetDiff * $t.datetime.msPerMinute);
        },

        pad: function (value) {
            if (value < 10)
                return '0' + value;
            return value;
        },

        standardFormat: function (format) {
            var l = $t.cultureInfo;

            var standardFormats = {
                d: l.shortDate,
                D: l.longDate,
                F: l.fullDateTime,
                g: l.generalDateShortTime,
                G: l.generalDateTime,
                m: l.monthDay,
                M: l.monthDay,
                s: l.sortableDateTime,
                t: l.shortTime,
                T: l.longTime,
                u: l.universalSortableDateTime,
                y: l.monthYear,
                Y: l.monthYear
            };

            return standardFormats[format];
        },

        format: function (date, format) {
            var l = $t.cultureInfo;

            var d = date.getDate();
            var day = date.getDay();
            var M = date.getMonth();
            var y = date.getFullYear();
            var h = date.getHours();
            var m = date.getMinutes();
            var s = date.getSeconds();
            var f = date.getMilliseconds();
            var pad = $t.datetime.pad;

            var dateFormatters = {
                d: d,
                dd: pad(d),
                ddd: l.abbrDays[day],
                dddd: l.days[day],

                M: M + 1,
                MM: pad(M + 1),
                MMM: l.abbrMonths[M],
                MMMM: l.months[M],

                yy: pad(y % 100),
                yyyy: y,

                h: h % 12 || 12,
                hh: pad(h % 12 || 12),
                H: h,
                HH: pad(h),

                m: m,
                mm: pad(m),

                s: s,
                ss: pad(s),

                f: Math.floor(f / 100),
                ff: Math.floor(f / 10),
                fff: f,

                tt: h < 12 ? l.am : l.pm
            };

            format = format || 'G';
            format = $t.datetime.standardFormat(format) ? $t.datetime.standardFormat(format) : format;

            return format.replace(dateFormatTokenRegExp, function (match) {
                return match in dateFormatters ? dateFormatters[match] : match.slice(1, match.length - 1);
            });
        },

        parse: function (options) {
            var value = options.value;
            var format = options.format;

            if (value && value.value) return value;

            format = $t.datetime.standardFormat(format) ? $t.datetime.standardFormat(format) : format;
            if (dateCheck.test(value))
                return $t.datetime.parseMachineDate({
                    value: value,
                    format: format,
                    shortYearCutOff: options.shortYearCutOff,
                    baseDate: options.baseDate,
                    AM: $t.cultureInfo.am,
                    PM: $t.cultureInfo.pm
                });

            return $t.datetime.parseByToken ? $t.datetime.parseByToken(value, options.today) : null;
        },

        parseMachineDate: function (options) {

            var AM = options.AM,
                PM = options.PM,
                value = options.value,
                format = options.format,
                baseDate = options.baseDate,
                shortYearCutOff = options.shortYearCutOff || 30,
                year = -1,
                month = -1,
                day = -1,
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                isAM,
                isPM,
                literal = false,
                matches = function (match) {
                    return (formatPosition + 1 < format.length && format.charAt(formatPosition + 1) == match);
                },
            // Returns count of the format character in the date format string
                lookAhead = function (match) {
                    var index = 0;
                    while (matches(match)) {
                        index++;
                        formatPosition++;
                    }
                    return index;
                },
            // Extract a number from the string value
                getNumber = function (size) {
                    var digits = new RegExp('^\\d{1,' + size + '}');
                    var num = value.substr(currentTokenIndex).match(digits);
                    if (num) {
                        currentTokenIndex += num[0].length;
                        return parseInt(num[0], 10);
                    } else {
                        return -1;
                    }
                },
            // Extract a name from the string value and convert to an index
                getName = function (names) {
                    for (var i = 0; i < names.length; i++) {
                        if (value.substr(currentTokenIndex, names[i].length) == names[i]) {
                            currentTokenIndex += names[i].length;
                            return i + 1;
                        }
                    }
                    return -1;
                },
                checkLiteral = function () {
                    if (value.charAt(currentTokenIndex) == format.charAt(formatPosition)) {
                        currentTokenIndex++;
                    }
                },
                normalizeTime = function (val) {
                    return val === -1 ? 0 : val;
                },
                count = 0,
                currentTokenIndex = 0,
                valueLength = value.length;

            for (var formatPosition = 0, flength = format.length; formatPosition < flength; formatPosition++) {
                if (currentTokenIndex == valueLength) break;
                if (literal) {
                    checkLiteral();
                    if (format.charAt(formatPosition) == "'")
                        literal = false;
                } else {
                    switch (format.charAt(formatPosition)) {
                        case 'd':
                            count = lookAhead('d');
                            day = count <= 1 ? getNumber(2) : getName($t.cultureInfo[count == 3 ? 'days' : 'abbrDays']);
                            break;
                        case 'M':
                            count = lookAhead('M');
                            month = count <= 1 ? getNumber(2) : getName($t.cultureInfo[count == 3 ? 'months' : 'abbrMonths']);
                            break;
                        case 'y':
                            count = lookAhead('y');
                            year = getNumber(count <= 1 ? 2 : 4);
                            break;
                        case 'H': // 0-24 hours
                            count = lookAhead('H');
                            hours = normalizeTime(getNumber(2));
                            break;
                        case 'h': // 0-12 hours
                            lookAhead('h');
                            hours = normalizeTime(getNumber(2));
                            break;
                        case 'm':
                            lookAhead('m');
                            minutes = normalizeTime(getNumber(2));
                            break;
                        case 's':
                            lookAhead('s');
                            seconds = normalizeTime(getNumber(2));
                            break;
                        case 'f':
                            count = lookAhead('f');
                            milliseconds = normalizeTime(getNumber(count <= 0 ? 1 : count + 1));
                            break;
                        case 't': // AM/PM or A/P
                            count = lookAhead('t');
                            AM = count > 0 ? AM : 'a';
                            PM = count > 0 ? PM : 'p';

                            var subValue = value.substr(currentTokenIndex).toLowerCase();
                            isAM = subValue.indexOf(AM.toLowerCase()) != -1;
                            isPM = subValue.indexOf(PM.toLowerCase()) != -1;

                            currentTokenIndex += isPM ? PM.length : isAM ? AM.length : 0;
                            break;
                        case "'":
                            checkLiteral();
                            literal = true;
                            break;
                        default:
                            checkLiteral();
                    }
                }
            }

            var date = new $t.datetime();

            if (year != -1 && year < 100)
                year += date.year() - date.year() % 100 +
                                (year <= shortYearCutOff ? 0 : -100);

            hours = (isPM && hours < 12)
                  ? hours + 12
                  : hours == 12 && isAM
                  ? 0
                  : hours;

            if (baseDate == undefined) {
                if (year == -1) year = date.year();
                if (month == -1) month = date.month();
                if (day == -1) day = date.day();

                date = new $t.datetime(year, month - 1, day, hours, minutes, seconds, milliseconds);

                if (date.year() != year || date.month() != (month - 1) || date.date() != day)
                    return null;

            } else {
                date = baseDate.year(year != -1 ? year : baseDate.year())
                               .month(month != -1 ? month - 1 : baseDate.month())
                               .date(day != -1 ? day : baseDate.date())
                               .hours(hours)
                               .minutes(minutes)
                               .seconds(seconds)
                               .milliseconds(milliseconds);



                if ((year != -1 && date.year() != year)
                 || (month != -1 && date.month() != (month - 1))
                 || (day != -1 && date.date() != day)
                 || (hours != -1 && date.hours() != hours)
                 || (minutes != -1 && date.minutes() != minutes)
                 || (seconds != -1 && date.seconds() != seconds)
                 || (milliseconds != -1 && date.milliseconds() != milliseconds))
                    return null;
            }
            return date;
        }
    });

    $t.datetime.prototype = {

        year: function () {
            if (arguments.length == 0)
                return this.value.getFullYear();
            else if (arguments.length == 1)
                this.value.setFullYear(arguments[0]);
            else
                this.value.setFullYear(arguments[0], arguments[1], arguments[2]);

            return this;
        },

        timeOffset: function () {
            return this.value.getTimezoneOffset();
        },

        day: function () {
            return this.value.getDay();
        },

        toDate: function () {
            return this.value;
        },

        addMonth: function (value) {
            this.month(this.month() + value);
        },

        addYear: function (value) {
            this.year(this.year() + value);
        }
    };

    $.each(["Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds", "Time"], function (index, timeComponent) {
        $t.datetime.prototype[timeComponent.toLowerCase()] =
            function () {
                if (arguments.length == 1)
                    this.value["set" + timeComponent](arguments[0]);
                else
                    return this.value["get" + timeComponent]();

                return this;
            };
    });

    $t.stringBuilder.prototype = {

        cat: function (what) {
            this.buffer.push(what);
            return this;
        },

        rep: function (what, howManyTimes) {
            for (var i = 0; i < howManyTimes; i++)
                this.cat(what);
            return this;
        },

        catIf: function () {
            var args = arguments;
            if (args[args.length - 1])
                for (var i = 0, length = args.length - 1; i < length; i++)
                    this.cat(args[i]);

            return this;
        },

        string: function () {
            return this.buffer.join('');
        }
    };
    var isTouch = (/iphone|ipad|android/gi).test(navigator.appVersion);

    if (isTouch) {
        var moveEvent = "touchmove",
            startEvent = "touchstart",
            endEvent = "touchend";
    } else {
        var moveEvent = "mousemove",
            startEvent = "mousedown",
            endEvent = "mouseup";
    }

    $.extend($.fn, {
        tScrollable: function (options) {
            $(this).each(function () {
                if (isTouch || (options && options.force)) {
                    new Scroller(this);
                }
            });
        }
    });

    function Scroller(element) {
        this.element = element;
        this.wrapper = $(element);

        this._horizontalScrollbar = $('<div class="t-touch-scrollbar" />');
        this._verticalScrollbar = this._horizontalScrollbar.clone();
        this._scrollbars = this._horizontalScrollbar.add(this._verticalScrollbar);

        this._startProxy = $.proxy(this._start, this);
        this._stopProxy = $.proxy(this._stop, this);
        this._dragProxy = $.proxy(this._drag, this);

        this._create();
    }

    function touchLocation(e) {
        var changedTouches = e.originalEvent.changedTouches;

        if (changedTouches && changedTouches.length < 2) {
            return {
                x: changedTouches[0].pageX,
                y: changedTouches[0].pageY
            };
        }

        return {
            x: e.pageX,
            y: e.pageY
        };
    }

    Scroller.prototype = {
        _create: function () {
            this.wrapper
                .css("overflow", "hidden")
                .bind(startEvent, $.proxy(this._wait, this));

        },
        _wait: function (e) {
            var startLocation = touchLocation(e);

            this.start = {
                x: startLocation.x + this.wrapper.scrollLeft(),
                y: startLocation.y + this.wrapper.scrollTop()
            };

            $(document)
                .bind(moveEvent, this._startProxy)
                .bind(endEvent, this._stopProxy);
        },
        _start: function (e) {
            var currentLocation = touchLocation(e);

            if (this.start.x - currentLocation.x > 10 || this.start.y - currentLocation.y > 10) {

                $(document).unbind(moveEvent, this._startProxy)
                           .bind(moveEvent, this._dragProxy);

                var width = this.wrapper.innerWidth(),
                    height = this.wrapper.innerHeight();
                offset = this.wrapper.offset(),
                    scrollWidth = this.wrapper.attr("scrollWidth"),
                    scrollHeight = this.wrapper.attr("scrollHeight");

                if (scrollWidth > width) {
                    this._horizontalScrollbar
                        .appendTo(document.body)
                        .css({
                            width: Math.floor((width / scrollWidth) * width),
                            left: this.wrapper.scrollLeft() + offset.left + parseInt(this.wrapper.css("borderLeftWidth")),
                            top: offset.top + this.wrapper.innerHeight() + parseInt(this.wrapper.css("borderTopWidth")) - this._horizontalScrollbar.outerHeight()
                        });
                }

                if (scrollHeight > height) {
                    this._verticalScrollbar
                        .appendTo(document.body)
                        .css({
                            height: Math.floor((height / scrollHeight) * height),
                            top: this.wrapper.scrollTop() + offset.top + parseInt(this.wrapper.css("borderTopWidth")),
                            left: offset.left + this.wrapper.innerWidth() + parseInt(this.wrapper.css("borderLeftWidth")) - this._verticalScrollbar.outerWidth()
                        });
                }

                this._scrollbars
                    .stop()
                    .fadeTo(200, 0.5);
            }
        },

        _drag: function (e) {
            var currentLocation = touchLocation(e),
                offset = this.wrapper.offset(),
                startLeft = offset.left + parseInt(this.wrapper.css("borderLeftWidth")),
                startTop = offset.top + parseInt(this.wrapper.css("borderTopWidth")),
                horizontalDifference = this.start.x - currentLocation.x,
                verticalDifference = this.start.y - currentLocation.y,
                left = Math.max(startLeft, startLeft + horizontalDifference),
                top = Math.max(startTop, startTop + verticalDifference);

            left = Math.min(startLeft + this.wrapper.innerWidth() - this._horizontalScrollbar.outerWidth() - this._horizontalScrollbar.outerHeight(), left);
            top = Math.min(startTop + this.wrapper.innerHeight() - this._verticalScrollbar.outerHeight() - this._verticalScrollbar.outerWidth(), top);

            this._horizontalScrollbar.css("left", left);
            this._verticalScrollbar.css("top", top);

            this.wrapper
                .scrollLeft(horizontalDifference)
                .scrollTop(verticalDifference);
        },
        _stop: function (e) {
            $(document).unbind(moveEvent, this._startProxy)
                       .unbind(moveEvent, this._dragProxy)
                       .unbind(endEvent, this._stopProxy);

            this._scrollbars
                .stop()
                .fadeTo(400, 0);
        }
    }; // Effects ($t.fx)

    var prepareAnimations = function (effects, target, end, effectExecuted) {
        if (target.length == 0 && end) {
            end();
            return null;
        }

        var animationsToPlay = effects.list.length;

        return function () {
            if (effectExecuted) {
                effectExecuted();
            }
            if (--animationsToPlay == 0 && end)
                end();
        };
    };

    $.extend($t.fx, {
        _wrap: function (element) {
            if (!element.parent().hasClass('t-animation-container')) {
                element.wrap(
                             $('<div/>')
                             .addClass('t-animation-container')
                             .css({
                                 "min-width": element.outerWidth(),
                                 height: element.outerHeight() + 2,
                                 top: element.parent().height()
                             }));
            }

            return element.parent();
        },

        play: function (effects, target, options, end, effectExecuted) {
            var afterAnimation = prepareAnimations(effects, target, end, effectExecuted);

            if (afterAnimation === null) return;

            target.stop(false, true);

            for (var i = 0, len = effects.list.length; i < len; i++) {

                var effect = new $t.fx[effects.list[i].name](target);

                if (!target.data('effect-' + i)) {
                    effect.play(
                    $.extend(
                        effects.list[i], {
                            openDuration: effects.openDuration,
                            closeDuration: effects.closeDuration
                        },
                        options), afterAnimation);

                    target.data('effect-' + i, effect);
                }
            }
        },

        rewind: function (effects, target, options, end, effectExecuted) {
            var afterAnimation = prepareAnimations(effects, target, end, effectExecuted);

            if (afterAnimation === null) return;

            for (var i = effects.list.length - 1; i >= 0; i--) {

                var effect = target.data('effect-' + i) || new $t.fx[effects.list[i].name](target);

                effect.rewind(
                    $.extend(
                        effects.list[i], {
                            openDuration: effects.openDuration,
                            closeDuration: effects.closeDuration
                        },
                        options), afterAnimation);

                target.data('effect-' + i, null);
            }
        }
    });

    // simple show/hide toggle

    $t.fx.toggle = function (element) {
        this.element = element.stop(false, true);
    };

    $t.fx.toggle.prototype = {
        play: function (options, end) {
            this.element.show();
            if (end) end();
        },
        rewind: function (options, end) {
            this.element.hide();
            if (end) end();
        }
    };
    $t.fx.toggle.defaults = function () {
        return { list: [{ name: 'toggle'}] };
    };

    // slide animation

    $t.fx.slide = function (element) {
        this.element = element;

        this.animationContainer = $t.fx._wrap(element);
    };

    $t.fx.slide.prototype = {
        play: function (options, end) {

            var animationContainer = this.animationContainer;

            this.element.css('display', 'block').stop();

            animationContainer
                .css({
                    display: 'block',
                    overflow: 'hidden'
                });

            var width = this.element.outerWidth();
            var height = this.element.outerHeight();
            var animatedProperty = options.direction == 'bottom' ? 'marginTop' : options.direction == 'top' ? 'marginTop' : 'marginLeft';
            var animatedStartValue = options.direction == 'bottom' ? -height : options.direction == 'top' ? height : -width;

            animationContainer
                .css({
                    width: width,
                    height: height
                });

            var animationEnd = {};
            animationEnd[animatedProperty] = 0;

            this.element
                .css('width', this.element.width())
                .each(function () { this.style.cssText = this.style.cssText; })
                .css(animatedProperty, animatedStartValue)
                .animate(animationEnd, {
                    queue: false,
                    duration: options.openDuration,
                    easing: 'linear',
                    complete: function () {
                        animationContainer.css('overflow', '');

                        if (end) end();
                    }
                });
        },

        rewind: function (options, end) {
            var animationContainer = this.animationContainer;

            this.element.stop();

            animationContainer.css({
                overflow: 'hidden'
            });

            var animatedProperty;

            switch (options.direction) {
                case 'bottom': animatedProperty = { marginTop: -this.element.outerHeight() };
                    break;
                case 'top': animatedProperty = { marginTop: this.element.outerHeight() };
                    break;
                case 'right': animatedProperty = { marginLeft: -this.element.outerWidth() }; break;
            }

            this.element
                .animate(animatedProperty, {
                    queue: false,
                    duration: options.closeDuration,
                    easing: 'linear',
                    complete: function () {
                        animationContainer
                            .css({
                                display: 'none',
                                overflow: ''
                            });

                        if (end) end();
                    }
                });
        }
    };
    $t.fx.slide.defaults = function () {
        return { list: [{ name: 'slide'}], openDuration: 'fast', closeDuration: 'fast' };
    };

    // property animation

    $t.fx.property = function (element) {
        this.element = element;
    };

    $t.fx.property.prototype = {
        _animate: function (properties, duration, reverse, end) {
            var startValues = { overflow: 'hidden' },
                endValues = {},
                $element = this.element;

            $.each(properties, function (i, prop) {
                var value;

                switch (prop) {
                    case 'height':
                    case 'width': value = $element[prop](); break;

                    case 'opacity': value = 1; break;

                    default: value = $element.css(prop); break;
                }

                startValues[prop] = reverse ? value : 0;
                endValues[prop] = reverse ? 0 : value;
            });

            $element.css(startValues)
                    .show()
                    .animate(endValues, {
                        queue: false,
                        duration: duration,
                        easing: 'linear',
                        complete: function () {
                            if (reverse)
                                $element.hide();

                            $.each(endValues, function (property) {
                                endValues[property] = '';
                            });

                            $element.css($.extend({ overflow: '' }, endValues));

                            if (end) end();
                        }
                    });
        },

        play: function (options, complete) {
            this._animate(options.properties, options.openDuration, false, complete);
        },

        rewind: function (options, complete) {
            this._animate(options.properties, options.closeDuration, true, complete);
        }
    };
    $t.fx.property.defaults = function () {
        return { list: [{ name: 'property', properties: arguments}], openDuration: 'fast', closeDuration: 'fast' };
    };

    // fix the MVC validation code for IE (document.getElementsByName matches `id` and `name` instead of just `name`). http://www.w3.org/TR/REC-DOM-Level-1/level-one-html.html#ID-71555259
    $(document).ready(function () {
        if ($.browser.msie && typeof (Sys) != 'undefined' && typeof (Sys.Mvc) != 'undefined' && typeof (Sys.Mvc.FormContext) != 'undefined') {
            var patch = function (formElement, name) {
                return $.grep(formElement.getElementsByTagName('*'), function (element) {
                    return element.name == name;
                });
            };

            if (Sys.Mvc.FormContext)
                Sys.Mvc.FormContext.$F = Sys.Mvc.FormContext._getFormElementsWithName = patch;
        }

    });
})(jQuery);



(function ($) {

    var $t = $.telerik;

    function isLocalUrl(url) {
        var loweredUrl = url ? url.toLowerCase() : '';
        return loweredUrl && loweredUrl.indexOf('http') !== 0 && loweredUrl.indexOf('https') !== 0;
    }

    function fixIE6Sizing($element) {
        if ($.browser.msie && $.browser.version < 7) {
            $element
                .find('.t-resize-e,.t-resize-w').css('height', $element.height()).end()
                .find('.t-resize-n,.t-resize-s').css('width', $element.width()).end();
            //.find('.t-overlay').css({ width: $element.width(), height: $element.height() });
        }
    }

    // zoom animation

    $t.fx.zoom = function (element) {
        this.element = element;
    };

    $t.fx.zoom.prototype = {
        play: function (options, end) {
            var $element = this.element.show(),
                $window = $(window);

            $element.find('> .t-window-content')
                .css({
                    height: $element.data("tWindow").height || 'auto'
                });

            var center = options.center | false;

            var endValues = {
                left: center ? $window.scrollLeft() + Math.max(0, ($window.width() - $element.width()) / 2) : parseInt($element.css('left')),
                top: center ? $window.scrollTop() + Math.max(0, ($window.height() - $element.height()) / 2) : parseInt($element.css('top'))
            };

            $element
                .css({
                    left: endValues.left + 20,
                    top: endValues.top + 20
                })
                .animate({
                    left: endValues.left,
                    top: endValues.top
                }, options.openDuration);
        },

        rewind: function (options, end) {
            var $element = this.element;

            var resizeElement = $element.find('> .t-window-content');
            var endValues = {
                width: resizeElement.width(),
                height: resizeElement.height(),
                left: parseInt($element.css('left')),
                top: parseInt($element.css('top'))
            };

            resizeElement.animate({
                width: endValues.width - 40,
                height: endValues.height - 40
            }, options.closeDuration);

            $element.animate({
                left: endValues.left + 20,
                top: endValues.top + 20
            }, options.closeDuration, function () {
                $element.css({
                    left: endValues.left,
                    top: endValues.top
                }).hide();

                resizeElement.css({
                    width: endValues.width
                    , height: endValues.height
                });

                if (end) end();
            });
        }
    };
    $t.fx.zoom.defaults = function () {
        return { list: [{ name: 'zoom'}], openDuration: 'fast', closeDuration: 'fast' };
    };

    $t.window = function (element, options) {
        this.element = element;
        this.loaded = false;
        this.postData = null;
        var $element = $(element);

        $.extend(this, options);

        if (!$element.is('.t-window')) {
            $element.addClass('t-widget t-window');
            $t.window.create(element, options);
        }

        if (!$element.parent().is('body')) {
            var offset;

            if ($element.is(':visible')) {
                offset = $element.offset();
                $element.css({ top: offset.top, left: offset.left });
            } else {
                $element.css({ visibility: 'hidden', display: '' });
                offset = $element.offset();
                $element.css({ top: offset.top, left: offset.left })
                        .css({ visibility: 'visible', display: 'none' });
            }

            $('body').children('#' + $element[0].id).remove();

            $element
                .toggleClass('t-rtl', $element.closest('.t-rtl').length > 0)
                .appendTo(document.body);
        }

        //if (this.modal)
        //this.overlay($element.is(':visible')).css({ opacity: 0.5 });

        var windowActions = '.t-window-titlebar .t-window-action';

        $element
            .delegate(windowActions, 'mouseenter', $t.hover)
            .delegate(windowActions, 'mouseleave', $t.leave)
            .delegate(windowActions, 'click', $.proxy(this.windowActionHandler, this));

        if (this.resizable) {
            $element
                .delegate('.t-window-titlebar', 'dblclick', $.proxy(this.toggleMaximization, this))
                .append($t.window.getResizeHandlesHtml());

            fixIE6Sizing($element);

            (function (wnd) {

                function start(e) {
                    var $element = $(wnd.element);

                    wnd.initialCursorPosition = $element.offset();

                    wnd.resizeDirection = e.$draggable.attr('className').replace('t-resize-handle t-resize-', '').split('');

                    wnd.resizeElement = $element.find('> .t-window-content');

                    wnd.initialSize = {
                        width: wnd.resizeElement.width(),
                        height: wnd.resizeElement.height()
                    };

                    wnd.outlineSize = {
                        left: wnd.resizeElement.outerWidth() - wnd.resizeElement.width()
                            + $element.outerWidth() - $element.width(),
                        top: wnd.resizeElement.outerHeight() - wnd.resizeElement.height()
                            + $element.outerHeight() - $element.height()
                            + $element.find('> .t-window-titlebar').outerHeight()
                    }; //$('<div class="t-overlay" />').appendTo(wnd.element);

                    $element.find('.t-resize-handle').not(e.$draggable).hide();

                    $(document.body).css('cursor', e.$draggable.css('cursor'));
                }

                function drag(e) {
                    var $element = $(wnd.element);

                    var resizeHandlers = {
                        'e': function () {
                            var width = e.pageX - wnd.initialCursorPosition.left - wnd.outlineSize.left;
                            wnd.resizeElement.width((width < wnd.minWidth
                                                        ? wnd.minWidth
                                                        : (wnd.maxWidth && width > wnd.maxWidth)
                                                        ? wnd.maxWidth
                                                        : width));
                        },
                        's': function () {
                            var height = e.pageY - wnd.initialCursorPosition.top - wnd.outlineSize.top;
                            wnd.resizeElement
                                    .height((height < wnd.minHeight ? wnd.minHeight
                                            : (wnd.maxHeight && height > wnd.maxHeight) ? wnd.maxHeight
                                            : height));
                        },
                        'w': function () {
                            var windowRight = wnd.initialCursorPosition.left + wnd.initialSize.width;

                            $element.css('left', e.pageX > (windowRight - wnd.minWidth) ? windowRight - wnd.minWidth
                                                : e.pageX < (windowRight - wnd.maxWidth) ? windowRight - wnd.maxWidth
                                                : e.pageX);

                            var width = windowRight - e.pageX;
                            wnd.resizeElement.width((width < wnd.minWidth ? wnd.minWidth
                                                    : (wnd.maxWidth && width > wnd.maxWidth) ? wnd.maxWidth
                                                    : width));

                        },
                        'n': function () {
                            var windowBottom = wnd.initialCursorPosition.top + wnd.initialSize.height;

                            $element.css('top', e.pageY > (windowBottom - wnd.minHeight) ? windowBottom - wnd.minHeight
                                                : e.pageY < (windowBottom - wnd.maxHeight) ? windowBottom - wnd.maxHeight
                                                : e.pageY);

                            var height = windowBottom - e.pageY;
                            wnd.resizeElement
                                    .height((height < wnd.minHeight ? wnd.minHeight
                                            : (wnd.maxHeight && height > wnd.maxHeight) ? wnd.maxHeight
                                            : height));
                        }
                    };

                    $.each(wnd.resizeDirection, function () {
                        resizeHandlers[this]();
                    });

                    fixIE6Sizing($element);

                    $t.trigger(wnd.element, 'resize');
                }

                function stop(e) {
                    var $element = $(wnd.element);
                    $element
                    //.find('.t-overlay').remove().end()
                        .find('.t-resize-handle').not(e.$draggable).show();

                    $(document.body).css('cursor', '');

                    if (e.keyCode == 27) {
                        fixIE6Sizing($element);
                        $element.css(wnd.initialCursorPosition);
                        wnd.resizeElement.css(wnd.initialSize);
                    }

                    return false;
                }

                new $t.draggable({
                    owner: wnd.element,
                    selector: '.t-resize-handle',
                    scope: wnd.element.id + '-resizing',
                    distance: 0,
                    start: start,
                    drag: drag,
                    stop: stop
                });
            })(this);
        }

        if (this.draggable) {
            (function (wnd) {
                function start(e) {
                    wnd.initialWindowPosition = $(wnd.element).position();

                    wnd.startPosition = {
                        left: e.pageX - wnd.initialWindowPosition.left,
                        top: e.pageY - wnd.initialWindowPosition.top
                    };

                    $('.t-resize-handle', wnd.element).hide();

                    //$('<div class="t-overlay" />').appendTo(wnd.element);

                    $(document.body).css('cursor', e.$draggable.css('cursor'));
                }

                function drag(e) {
                    var coordinates = {
                        left: e.pageX - wnd.startPosition.left,
                        top: Math.max(e.pageY - wnd.startPosition.top, 0)
                    };

                    $(wnd.element).css(coordinates);
                }

                function stop(e) {
                    $(wnd.element).find('.t-resize-handle')
                                  .show()
                                  .end();
                    //.find('.t-overlay').remove();

                    $(document.body).css('cursor', '');

                    if (e.keyCode == 27)
                        e.$draggable.closest('.t-window').css(wnd.initialWindowPosition);

                    return false;
                }
                new $t.draggable({
                    owner: wnd.element,
                    selector: '.t-window-titlebar',
                    scope: wnd.element.id + '-moving',
                    start: start,
                    drag: drag,
                    stop: stop
                });
            })(this);
        }

        $t.bind(this, {
            open: this.onOpen,
            activated: this.onActivate,
            close: this.onClose,
            refresh: this.onRefresh,
            resize: this.onResize,
            error: this.onError,
            load: this.onLoad,
            move: this.onMove
        });

        /* commented after merge to new telerik
        if (!$element.parent().is('body')) {
        if ($element.is(':visible'))
        $element.css($element.offset());

        $element
        .toggleClass('t-rtl', $element.closest('.t-rtl').length > 0)
        .appendTo(document.body);
        }

        //if (this.modal)
        //this.overlay(true); //($element.is(':visible'));

        */
        $(window).resize($.proxy(this.onDocumentResize, this));

        /*if (isLocalUrl(this.contentUrl))
        this.ajaxRequest();*/
    };

    $t.window.prototype = {
        overlay: function (visible) {
            var overlay = visible ? elma.showBlockerDiv() : elma.hideBlockerDiv();
            /*
            var overlay = $('body > .t-overlay'),
            $doc = $(document);

            if (overlay.length == 0)
            overlay = $('<div class="t-overlay" />')
            .toggle(visible)
            .appendTo(this.element.ownerDocument.body);
            else
            overlay.toggle(visible);

            if ($.browser.msie && $.browser.version < 7)
            overlay.css({
            width: $doc.width() - 21,
            height: $doc.height(),
            position: 'absolute'
            });
            */
            return overlay;
        },

        windowActionHandler: function (e) {
            var $target = $(e.target).closest('.t-window-action').find('.t-icon'),
                contextWindow = this;

            $.each({
                't-close': this.close,
                't-maximize': this.maximize,
                't-restore': this.restore,
                't-refresh': this.refresh
            }, function (commandName, handler) {
                if ($target.hasClass(commandName)) {
                    e.preventDefault();
                    handler.call(contextWindow);
                    return false;
                }
            });
        },

        center: function () {
            var $element = $(this.element),
                $window = $(window);

            $element.css({
                left: $window.scrollLeft() + Math.max(0, ($window.width() - $element.width()) / 2),
                top: $window.scrollTop() + Math.max(0, ($window.height() - $element.height()) / 2)
            });

            return this;
        },

        title: function (text) {
            var $title = $('.t-window-titlebar > .t-window-title', this.element);

            if (!text)
                return $title.text();

            $title.text(text);
            return this;
        },

        content: function (html) {
            var $content = $('> .t-window-content', this.element);

            if (!html)
                return $content.html();

            $content.html(html);
            return this;
        },

        open: function (e) {
            var $element = $(this.element);
            if (this.modal) {

                var overlay = this.overlay(true);
                /*
                if (this.effects.list.length > 0 && this.effects.list[0].name != 'toggle')
                overlay.css('opacity', 0).show().animate({ opacity: 0.5 }, this.effects.openDuration);
                else
                overlay.css('opacity', 0.5).show();
                */
            }
            $(".t-window:visible").each(function () {
                if ($(this).css("z-index") != undefined && $(this).css("z-index") != "" && parseInt($(this).css("z-index")) >= parseInt($($element).css("z-index"))) {
                    $($element).css("z-index", parseInt($(this).css("z-index")) + 2);
                }
            });
            if (this.contentUrl != undefined && !this.loaded)
                this.ajaxRequest();
            else {
                if (!$t.trigger(this.element, 'open')) {
                    if (!$element.is(':visible'))
                        $t.fx.play(this.effects, $element, {}, function () {
                            $t.trigger($element[0], 'activated');
                        }, 
                        function () {
                            elma.dynamics.globalEvents.popupOpenExecute();
                        }
                    );
                    elma.setDefaultInput(this.element);
                }
                if (this.isMaximized)
                    $('html, body').css('overflow', 'hidden');
            }

            if (this.isMaximized)
                $('html, body').css('overflow', 'hidden');

            return this;
        },

        close: function () {
            var $element = $(this.element);

            if ($element.is(':visible')) {
                if (!$t.trigger(this.element, 'close')) {
                    //var overlay = this.modal ? this.overlay(false) : $(undefined);

                    //overlay.animate({ opacity: 0 }, this.effects.closeDuration);

                    $t.fx.rewind(this.effects, $element, null, function () {
                        //overlay.add($element[0]).hide();
                        elma.hideBlockerDiv();
                    });
                }
            }

            if (this.isMaximized)
                $('html, body').css('overflow', '');

            return this;
        },

        toggleMaximization: function (e) {
            if (e && $(e.target).closest('.t-window-action').length > 0) return;
            this[this.isMaximized ? 'restore' : 'maximize']();
        },

        restore: function () {
            if (!this.isMaximized)
                return;

            $(this.element)
                .css({
                    position: 'absolute',
                    left: this.restorationSettings.left,
                    top: this.restorationSettings.top
                })
                .find('> .t-window-content')
                    .css({
                        width: this.restorationSettings.width,
                        height: this.restorationSettings.height
                    }).end()
                .find('.t-resize-handle').show().end()
                .find('.t-window-titlebar .t-restore').addClass('t-maximize').removeClass('t-restore');

            $('html, body').css('overflow', '');

            this.isMaximized = false;

            $t.trigger(this.element, 'resize');

            return this;
        },

        maximize: function (e) {
            if (this.isMaximized)
                return;

            var $element = $(this.element),
                resizeElement = $element.find('> .t-window-content');

            this.restorationSettings = {
                left: $element.position().left,
                top: $element.position().top,
                width: resizeElement.width(),
                height: resizeElement.height()
            };

            $element
                .css({ left: 0, top: 0, position: 'fixed' })
                .find('.t-resize-handle').hide().end()
                .find('.t-window-titlebar .t-maximize').addClass('t-restore').removeClass('t-maximize');

            $('html, body').css('overflow', 'hidden');

            this.isMaximized = true;

            this.onDocumentResize();

            return this;
        },

        onDocumentResize: function () {
            if (!this.isMaximized)
                return;

            var $element = $(this.element),
                resizeElement = $element.find('> .t-window-content');

            resizeElement
                .css({
                    width: $(window).width()
                        - (resizeElement.outerWidth() - resizeElement.width()
                        + $element.outerWidth() - $element.width()),
                    height: $(window).height()
                        - (resizeElement.outerHeight() - resizeElement.height()
                        + $element.outerHeight() - $element.height()
                        + $element.find('> .t-window-titlebar').outerHeight())
                });

            fixIE6Sizing($element);

            $t.trigger($element, 'resize');
        },

        refresh: function () {
            if (isLocalUrl(this.contentUrl)) this.ajaxRequest();

            return this;
        },

        ajaxRequest: function (url) {
            var loadingIconTimeout = setTimeout(function () {
                $('.t-refresh', this.element).addClass('t-loading');
            }, 100);

            var data = {};
            var dataElement = this;
            elma.openPleaseWait(false);
            $.ajax({
                type: this.postData != null ? 'POST' : 'GET',
                url: url || this.contentUrl,
                dataType: 'html',
                data: this.postData || data,
                cache: false,
                error: $.proxy(function (xhr, status) {
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;
                }, this),

                complete: function () {
                    /*
                    clearTimeout(loadingIconTimeout);
                    $('.t-refresh', this.element).removeClass('t-loading');
                    */
                    clearTimeout(loadingIconTimeout);
                    $('.t-refresh', this.element).removeClass('t-loading');
                    elma.closePleaseWait(false);
                },
                headers: {
                    "Elma-PopupWindow": "1"
                },
                success: $.proxy(function (data, textStatus) {
                    /*
                    $('.t-window-content', this.element).html(data);
                    $t.trigger(this.element, 'refresh');
                    */
                    $('.t-window-content', this.element).html(data);
                    if (!$t.trigger(this.element, 'open')) {
                        var $element = $(this.element);
                        if (!$element.is(':visible'))
                            $t.fx.play(this.effects, $element, {}, function () {
                                $t.trigger($element[0], 'activated');
                            },
                            function () {
                                elma.dynamics.globalEvents.popupOpenExecute();
                            }
                            );
                        elma.setDefaultInput(this.element);
                    }
                    if (this.isMaximized)
                        $('html, body').css('overflow', 'hidden');
                    $t.trigger(this.element, 'refresh');
                    dataElement.loaded = true;
                    dataElement.postData = null;
                }, this)
            });
        },

        destroy: function () {
            $(this.element).remove();
            /*
            var openedModalWindows = $('.t-window').filter(function() {
            var window = $(this);
            return window.is(':visible') && window.data('tWindow').modal;
            });
                        
            var shouldHideOverlay = this.modal && openedModalWindows.length == 0;

            if (shouldHideOverlay)
            this.overlay(false).remove();
            */
            if (this.modal) this.overlay(false); //.remove();
        }
    };

    // client-side rendering
    $.extend($t.window, {
        create: function () {
            var element, options;

            if ($.isPlainObject(arguments[0]))
                options = arguments[0];
            else {
                element = arguments[0];
                options = $.extend({
                    html: element.innerHTML
                }, arguments[1]);
            }

            options = $.extend({
                title: '',
                html: '',
                actions: ['Close']
            }, options);

            var windowHtml = new $t.stringBuilder()
                .catIf('<div class="t-widget t-window">', !element)
                    .cat('<div class="t-window-titlebar t-header">')
                        .cat('&nbsp;<span class="t-window-title">').cat(options.title).cat('</span>')
                        .cat('<div class="t-window-actions t-header">');

            $.map(options.actions, function (command) {
                windowHtml.cat('<a href="#" class="t-window-action t-link">')
                        .cat('<span class="t-icon t-').cat(command.toLowerCase()).cat('">')
                            .cat(command)
                        .cat('</span></a>');
            });

            windowHtml.cat('</div></div>')
                .cat('<div class="t-window-content t-content" style="');

            if (options.width) windowHtml.cat('width:').cat(options.width).cat('px;');
            if (options.height) windowHtml.cat('height:').cat(options.height).cat('px;');

            windowHtml.cat('">').cat(options.html).cat('</div>')
                .catIf('</div>', !element);

            if (element)
                $(element).html(windowHtml.string());
            else
                return $(windowHtml.string()).appendTo(document.body).tWindow(options);
        },

        getResizeHandlesHtml: function () {
            var html = new $t.stringBuilder();

            $.each('n e s w se sw ne nw'.split(' '), function (i, item) {
                html.cat('<div class="t-resize-handle t-resize-').cat(item).cat('"></div>');
            });

            return html.string();
        }
    });

    // jQuery extender
    $.fn.tWindow = function (options) {
        return $t.create(this, {
            name: 'tWindow',
            init: function (element, options) {
                return new $t.window(element, options);
            },
            success: function (component) {
                var element = component.element,
                    $element = $(element);

                if ($element.is(':visible')) {
                    $t.trigger(element, 'open');
                    $t.trigger(element, 'activated');
                }
            },
            options: options
        });
    };

    // default options
    $.fn.tWindow.defaults = {
        effects: { list: [{ name: 'zoom' }, { name: 'property', properties: ['opacity']}], openDuration: 'fast', closeDuration: 'fast' },
        modal: false,
        resizable: true,
        draggable: true,
        minWidth: 50,
        minHeight: 50
    };
})(jQuery);


(function ($) {
    var $t = $.telerik,
        nop = function () { },
        draggables = {},
        cues = {},
        droppableDefaults = {
            scope: 'default',
            drop: nop,
            over: nop,
            out: nop,
            owner: document.body
        },
        draggableDefaults = {
            distance: 5, /* Dinstance in pixels the mouse should move before dragging should start. */
            cursorAt: { left: 10, top: 10 }, /* The offset of the cursor from the dragging cue. */
            scope: 'default', /* Used to group draggables and droppables. */
            start: nop, /* Called when dragging starts. Return `false` to prevent dragging. */
            drag: nop, /* Called when the mouse is moved during dragging. */
            stop: nop, /* Called when dragging stops. Return `false` to prevent the stop animation. */
            destroy: nop, /* Called when the draggable is destroyed. Used to remove any dragging/dropping cues from DOM. */
            owner: document.body, /* The DOM element to which events are attached. Used with 'selector' and 'delegate'. */
            cue: function() { /* Called to create the dragging cue. Return a jQuery object representing the cue. */
                return $('<span />');
            }
        };    
    
    $t.droppable = function (options) {
       $.extend(this, droppableDefaults, options);
       $(this.owner).delegate(this.selector, 'mouseenter', $.proxy(this._over, this))
                    .delegate(this.selector, 'mouseup', $.proxy(this._drop, this))
                    .delegate(this.selector, 'mouseleave', $.proxy(this._out, this));
    }
    
    $t.droppable.prototype = {
        _over: function(e) {
            this._raise(e, this.over);
        },
        _out: function(e) {
            this._raise(e, this.out);
        },
        _drop: function(e) {
            this._raise(e, $.proxy(function(e) {
                this.drop(e);
                e.destroy(e);
            }, this));
        },
        _raise: function(e, callback) {
            var draggable = draggables[this.scope];
            if (draggable)
                callback($.extend(e, draggable, { $droppable: $(e.currentTarget) }));
        }
    }

    $t.dragCue = function (html) {
        return $('<div class="t-header t-drag-clue" />')
            .html(html)
            .prepend('<span class="t-icon t-drag-status t-denied" />')
            .appendTo(document.body);
    }
    
    $t.dragCueStatus = function($cue, status) {
        $cue.find('.t-drag-status')
            .attr('class', 't-icon t-drag-status')
            .addClass(status);
    }

    $t.draggable = function (options) {
        $.extend(this, draggableDefaults, options);
        
        $(this.owner).delegate(this.selector, 'mousedown', $.proxy(this._wait, this))
                     .delegate(this.selector, 'dragstart', $t.preventDefault);
    
        this._startProxy = $.proxy(this._start, this);
        this._destroyProxy = $.proxy(this._destroy, this);
        this._stopProxy = $.proxy(this._stop, this);
        this._dragProxy = $.proxy(this._drag, this);
    }
    
    $t.draggable.get = function(scope) {
        return draggables[scope];
    }
    
    $t.draggable.prototype = {
        _raise: function(e, callback) {
            var draggable = draggables[this.scope];
            if (draggable)
                return callback($.extend(e, draggable));
        },

        _wait: function (e) {
            this.$target = $(e.currentTarget);
            this._startPosition = { x: e.pageX, y: e.pageY };

            $(document).bind( {
                mousemove: this._startProxy,
                mouseup: this._destroyProxy
            });

            $(document.documentElement).trigger('mousedown', e); // manually triggering 'mousedown' because the next statement will prevent that.

            // required to avoid selection in Gecko
            return false;
        },

        _start: function(e) {
            var x = this._startPosition.x - e.pageX, 
                y = this._startPosition.y - e.pageY;

            var distance = Math.sqrt((x * x) + (y * y));
            
            if (distance >= this.distance) {
                var $cue = cues[this.selector];
                
                if (!$cue) {
                    $cue = cues[this.selector] = this.cue({ $draggable: this.$target });
                    
                    $(document).unbind('mousemove', this._startProxy)
                               .unbind('mouseup', this._destroyProxy)
                               .bind({
                                'mouseup keydown': this._stopProxy,
                                mousemove: this._dragProxy,
                                selectstart: false
                                });
                } 
                    
                draggables[this.scope] = {
                    $cue: $cue.css({ position: 'absolute', left: e.pageX + this.cursorAt.left, top: e.pageY + this.cursorAt.top }),
                    $draggable: this.$target,
                    destroy: this._destroyProxy
                }

                if (this._raise(e, this.start) === false)
                    this._destroy(e);
            }
        },

        _drag: function(e) {
            this._raise(e, this.drag);
            draggables[this.scope].$cue.css({ left: e.pageX + this.cursorAt.left, top: e.pageY + this.cursorAt.top });
        },

        _stop: function(e) {
            if (e.type == 'mouseup' || e.keyCode == 27)
                if (this._raise(e, this.stop) === false) {
                    this._destroy(e);
                } else {
                    var draggable = draggables[this.scope];
                    draggable.$cue.animate(draggable.$draggable.offset(), 'fast', this._destroyProxy);
                }
        },

        _destroy: function(e) {
            $(document).unbind('mouseup keydown', this._stopProxy)
                       .unbind('mousemove', this._dragProxy)
                       .unbind('mousemove', this._startProxy)
                       .unbind('selectstart', false);
            
            this._raise(e, this.destroy);

            draggables[this.scope] = null;
            cues[this.selector] = null;
        }
    }
})(jQuery);


(function ($) {

    var $t = $.telerik;

    $t.tabstripGlobal = {
        onTabSelected: function (fn) {
            $(document).bind('tabstripGlobal_tabSelected', fn);
        },
        tabSelectedExecute: function () {
            $(document).trigger('tabstripGlobal_tabSelected');
        }
    }

    $t.tabstrip = function (element, options) {
        this.element = element;

        var $element = $(element);

        this.$contentElements = $element.find('> .t-content');

        $.extend(this, options);

        if (this.contentUrls)
            $element.find('.t-tabstrip-items > .t-item')
                .each($.proxy(function (index, item) {
                    $(item).find('.t-link').data('ContentUrl', this.contentUrls[index]);
                }, this));

        var enabledItems = '.t-tabstrip-items > .t-item:not(.t-state-disabled)';

        $element
            .delegate(enabledItems, 'mouseenter', $t.hover)
			.delegate(enabledItems, 'mouseleave', $t.leave)
			.delegate(enabledItems, options.activateEvent, $t.delegate(this, this._click))
            .delegate('.t-tabstrip-items > .t-state-disabled .t-link', 'click', $t.preventDefault);

        $t.bind(this, {
            select: $.proxy(function (e) {
                if (e.target == this.element && this.onSelect) this.onSelect(e);
            }, this),
            contentLoad: this.onContentLoad,
            error: this.onError,
            load: this.onLoad
        });

        var selectedItems = $element.find('li.t-state-active'),
            $content = $(this.getContentElement(selectedItems.parent().children().index(selectedItems)));

        if ($content.length > 0 && $content[0].childNodes.length == 0)
            this.activateTab(selectedItems.eq(0));
    };

    $.extend($t.tabstrip.prototype, {

        select: function (li) {
            $(li).each($.proxy(function (index, item) {
                var $item = $(item);
                if ($item.is('.t-state-disabled,.t-state-active'))
                    return;

                this.activateTab($item);
            }, this));
        },

        enable: function (li) {
            $(li).addClass('t-state-default')
                 .removeClass('t-state-disabled');
        },

        disable: function (li) {
            $(li).removeClass('t-state-default')
                 .removeClass('t-state-active')
				 .addClass('t-state-disabled');
        },

        reload: function (li) {
            var tabstrip = this;

            $(li).each(function () {
                var $item = $(this),
                    contentUrl = $item.find('.t-link').data('ContentUrl');

                if (contentUrl) {
                    tabstrip.ajaxRequest($item, $(tabstrip.getContentElement($item.index())), null, contentUrl);
                }
            });
        },

        _click: function (e, element) {
            var $item = $(element),
                $link = $item.find('.t-link'),
                href = $link.attr('href'),
                $content = $(this.getContentElement($item.index()));

            if ($item.is('.t-state-disabled,.t-state-active')) {
                e.preventDefault();
                return;
            }

            if ($t.trigger(this.element, 'select', { item: $item[0], contentElement: $content[0] })) {
                e.preventDefault();
            }

            var isAnchor = $link.data('ContentUrl') || (href && (href.charAt(href.length - 1) == '#' || href.indexOf('#' + this.element.id + '-') != -1));

            if (!href || isAnchor || ($content.length > 0 && $content[0].childNodes.length == 0))
                e.preventDefault();
            else return;

            if (this.activateTab($item))
                e.preventDefault();
        },

        activateTab: function ($item) {
            // deactivate previously active tab
            var itemIndex =
				$item.parent().children()
					.removeClass('t-state-active')
					.addClass('t-state-default')
					.index($item);

            // activate tab
            $item.removeClass('t-state-default').addClass('t-state-active');

            // handle content elements
            var $contentElements = this.$contentElements;

            if ($contentElements.length == 0)
                return false;

            var $visibleContentElements = $contentElements.filter('.t-state-active');

            // find associated content element
            var $content = $(this.getContentElement(itemIndex));

            var tabstrip = this;
            if ($content.length == 0) {
                $visibleContentElements.removeClass('t-state-active');

                $t.fx.rewind(tabstrip.effects, $visibleContentElements, {});

                return false;
            }

            var isAjaxContent = $content.is(':empty'),
                showContentElement = function () {
                    $content.addClass('t-state-active');

                    $t.fx.play(tabstrip.effects, $content, {}, function () { $t.tabstripGlobal.tabSelectedExecute(); });
                };

            $visibleContentElements.removeClass('t-state-active').stop(false, true);

            $t.fx.rewind(
                tabstrip.effects,
			    $visibleContentElements, {},
			    function () {
			        if ($item.hasClass('t-state-active')) {
			            if (!isAjaxContent)
			                showContentElement();
			            else
			                tabstrip.ajaxRequest($item, $content, function () {
			                    if ($item.hasClass('t-state-active'))
			                        showContentElement();
			                });
			        }
			    });

            return true;
        },

        getSelectedTabIndex: function () {
            return $(this.element).find('li.t-state-active').index();
        },

        getContentElement: function (itemIndex) {
            if (isNaN(itemIndex - 0)) return;

            var $contentElements = this.$contentElements,
                idTest = new RegExp('-' + (itemIndex + 1) + '$');

            for (var i = 0, len = $contentElements.length; i < len; i++) {
                if (idTest.test($contentElements[i].id)) {
                    return $contentElements[i];
                }
            }
        },

        ajaxRequest: function ($element, $content, complete, url) {
            if ($element.find('.t-loading').length)
                return;

            var $link = $element.find('.t-link'),
                data = {},
                statusIcon = null,
                loadingIconTimeout = setTimeout(function () {
                    statusIcon = $('<span class="t-icon t-loading"></span>').prependTo($link)
                }, 100);

            $.ajax({
                global: true,
                type: 'GET',
                cache: false,
                url: url || $link.data('ContentUrl') || $link.attr('href'),
                dataType: 'html',
                data: data,

                error: $.proxy(function (xhr, status) {
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;
                }, this),

                complete: function () {
                    clearTimeout(loadingIconTimeout);
                    if (statusIcon !== null)
                        statusIcon.remove();
                },

                success: $.proxy(function (data, textStatus) {
                    $content.html(data);

                    if (complete)
                        complete.call(this, $content);

                    $t.trigger(this.element, 'contentLoad', { item: $element[0], contentElement: $content[0] });
                }, this)
            });
        }
    });

    // Plugin declaration
    $.fn.tTabStrip = function (options) {
        return $t.create(this, {
            name: 'tTabStrip',
            init: function (element, options) {
                return new $t.tabstrip(element, options);
            },
            options: options
        });
    }

    // default options
    $.fn.tTabStrip.defaults = {
        activateEvent: 'click',
        effects: $t.fx.toggle.defaults()
    };
})(jQuery);


(function ($) {
    var $t = $.telerik;
    var rdate = /"\\\/Date\((.*?)\)\\\/"/g;

    function template(value) {
        return new Function('data', ("var p=[];" +
            "with(data){p.push('" + unescape(value).replace(/[\r\t\n]/g, " ")
                .replace(/'(?=[^#]*#>)/g, "\t")
                .split("'").join("\\'")
                .split("\t").join("'")
                .replace(/<#=(.+?)#>/g, "',$1,'")
                .split("<#").join("');")
                .split("#>").join("p.push('")
                + "');}return p.join('');"));
    }

    function encode(value) {
        return (value != null ? value + '' : '').replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
    }

    $t.grid = function (element, options) {
        this.element = element;
        this.groups = [];
        this.editing = {};
        this.filterBy = '';
        this.groupBy = '';
        this.additionalData = {};
        this.orderBy = '';
        this.dataFilter = [];
        this.data = [];
        this.formId = '';

        $.extend(this, options);

        this.sorted = $.grep(this.columns, function (column) { return column.order; });

        this.$tbody = $('> .t-grid-content > table > tbody', element);
        this.scrollable = this.$tbody.length > 0;

        if (!this.scrollable) {
            this.$tbody = $('> .t-grid-table-container > table > tbody', element);
            this.$header = $('> .t-grid-table-container > table > thead tr', element);
            this.$footer = $('> .t-grid-table-container > table > tfoot', element);
        } else {

            $('> .t-grid-content', element).tScrollable();

            this.$header = $('> .t-grid-header tr', element);
            this.$footer = $('> .t-grid-footer', element);
        }

        this.$headerWrap = $('> .t-grid-header > .t-grid-header-wrap', element);
        this.$footerWrap = $('> .t-grid-footer > .t-grid-footer-wrap', element);

        var scrollables = this.$headerWrap.add(this.$footerWrap);

        $('> .t-grid-content', element).bind('scroll', function () {
            scrollables.scrollLeft(this.scrollLeft);
        });


        this.$tbody.delegate('.t-hierarchy-cell .t-plus, .t-hierarchy-cell .t-minus', 'click', $t.stopAll(function (e) {
            var $icon = $(e.target);
            var expanding = $icon.hasClass('t-plus');

            $icon.toggleClass('t-minus', expanding)
                .toggleClass('t-plus', !expanding);
            var $tr = $icon.closest('tr.t-master-row');
            if (this.detail && !$tr.next().hasClass('t-detail-row'))
                $(new $t.stringBuilder()
                        .cat('<tr class="t-detail-row">')
                        .rep('<td class="t-group-cell"></td>', $tr.find('.t-group-cell').length)
                        .cat('<td class="t-hierarchy-cell"></td>')
                        .cat('<td class="t-detail-cell" colspan="')
                        .cat(this.$header.find('th:not(.t-group-cell,.t-hierarchy-cell):visible').length)
                        .cat('">')
                        .cat(this.displayDetails(this.dataItem($tr)))
                        .cat('</td></tr>').string()).insertAfter($tr);

            $t.trigger(this.element, expanding ? 'detailViewExpand' : 'detailViewCollapse', { masterRow: $tr[0], detailRow: $tr.next('.t-detail-row')[0] });
            $tr.next().toggle(expanding);
        }, this));

        var pagerElement = $('> .t-grid-pager, > .t-grid-top-container .t-grid-pager', element);
        this.$pager = $('.t-pager', pagerElement);

        var dropDown = new $t.dropDown({
            effects: $t.fx.slide.defaults(),
            onClick: $.proxy(function (e) {
                this.changePageSize($(e.item).text());
                dropDown.close();
            }, this)
        });

        dropDown.dataBind(options.pageSizesInDropDown || []);

        $(document.documentElement).bind('mousedown', function (e) {
            var element = dropDown.$element[0];

            if (!$.contains(element, e.target)) {
                dropDown.close();
            }
        });

        this.$pager.delegate('.t-state-disabled', 'click', $t.preventDefault)
                   .delegate('.t-link:not(.t-state-disabled)', 'mouseenter', $t.hover)
                   .delegate('.t-link:not(.t-state-disabled)', 'mouseleave', $t.leave)
                   .delegate('input[type=text]', 'keydown', $.proxy(this.pagerKeyDown, this))
                   .delegate('.t-page-size .t-dropdown-wrap', 'click', function () {
                       var a = $(this);
                       dropDown.open({
                           offset: a.offset(),
                           outerHeight: a.outerHeight(),
                           outerWidth: a.outerWidth(),
                           zIndex: $t.getElementZIndex(this)
                       });
                   });
        var pagerElement = $('> .t-grid-pager, > .t-grid-top-container .t-grid-pager', element);
        pagerElement.delegate('.t-button.t-refresh', 'click', $.proxy(this.refreshClick, this));
        $('> .t-page-size, > .t-page-size', pagerElement).delegate('select', 'change', $.proxy(this.changePageSizeClick, this));
        var grid = this;
        $(document).bind("telerikgridresizableupdate", function (e, id) { $('#' + id).data('tGrid').showExportExcelQtip(); });
        pagerElement.delegate('.t-button.t-export-excel', 'click', $.proxy(this.exportExcel, this));
        $('> .t-status > .t-settings, > .t-status > .t-settings', pagerElement).click(function () { openWindow("gridSettings_" + grid.element.id); });
        $(element).delegate('.t-button', 'hover', $t.preventDefault);

        if (this.sort)
            this.$header.delegate('.t-link', 'hover', function () {
                $(this).toggleClass('t-state-hover');
            });

        var nonSelectableRows = 'tr:not(.t-grouping-row,.t-detail-row,.t-no-data,:has(>.t-edit-container))';

        if (this.selectable) {
            var tbody = this.$tbody[0];
            this.$tbody.delegate(nonSelectableRows, 'click', function (e) {
                if (this.parentNode == tbody)
                    grid.rowClick(e);
            })
            .delegate(nonSelectableRows, 'hover', function () {
                if (this.parentNode == tbody)
                    $(this).toggleClass('t-state-hover');
            });
        }
        if (this.isAjax()) {
            this.$pager.delegate('.t-link:not(.t-state-disabled)', 'click', $t.stop(this.pagerClick, this));
            if (this.sort)
                this.$header.delegate('.t-link', 'click', $t.stop(this.headerClick, this));
        }

        for (var i = 0; i < this.plugins.length; i++) {
            var plg = $t[this.plugins[i]];
            if (plg) {
                $t[this.plugins[i]].initialize(this);
            }
        }

        $t.bind(this, {
            columnResize: this.onColumnResize,
            columnReorder: this.onColumnReorder,
            'delete': this.onDelete,
            detailViewExpand: this.onDetailViewExpand,
            detailViewCollapse: this.onDetailViewCollapse,
            dataBinding: this.onDataBinding,
            dataBound: this.onDataBound,
            edit: this.onEdit,
            error: this.onError,
            load: this.onLoad,
            rowSelect: this.onRowSelect,
            rowDataBound: this.onRowDataBound,
            save: this.onSave,
            submitChanges: this.onSubmitChanges
        });

        this.initializeColumns();
        BottomPagerVisible();
    };
    $t.grid.prototype = {
        rowClick: function (e) {
            var $target = $(e.target);
            if (!$target.is(':button,a,:input,a>.t-icon')) {
                e.stopPropagation();
                var $row = $target.closest('tr')
                                  .addClass('t-state-selected')
                                  .siblings()
                                  .removeClass('t-state-selected')
                                  .end();
                $t.trigger(this.element, 'rowSelect', { row: $row[0] });
            }
        },

        $rows: function () {
            return this.$tbody.find('> tr:not(.t-grouping-row,.t-detail-row)');
        },

        hideDetails: function (tr) {
            $(tr).find('> td .t-plus, > td .t-expand').hide();
            $(tr).find('> td .t-minus, > td .t-collapse').hide();
            if ($(tr).next().hasClass('t-detail-row')) {
                $(tr).next().hide();
            }
        },

        expandRow: function (tr) {
            $(tr).find('> td .t-plus, > td .t-expand').click();
        },

        collapseRow: function (tr) {
            $(tr).find('> td .t-minus, > td .t-collapse').click();
        },

        headerClick: function (e) {
            e.preventDefault();
            this.toggleOrder(this.$columns().index($(e.target).closest('th')));
            this.sort(this.sortExpr());
        },

        checkPageSize: function (size) {
            if (this.pageSize != size) {
                this.currentPage = 1;
            }
            return size;
        },

        changePageSizeClick: function (e) {
            this.pageSize = this.checkPageSize(parseInt(e.currentTarget.value));
            this.ajaxRequestWithValidation(true);
        },

        refreshClick: function (e, element) {
            if ($(element).is('.t-loading'))
                return;

            if (this.isAjax()) {
                e.preventDefault();
                this.ajaxRequestWithValidation(true);
            }
        },

        sort: function (orderBy) {
            this.orderBy = orderBy;
            this.ajaxRequestWithValidation();
        },

        columnFromTitle: function (title) {
            title = $.trim(title);

            var result = $.grep(this.$columns(), function (th) {
                return $.trim($(th).text()) == title;
            })[0];

            if (result)
                return this.columns[this.$columns().index(result)];

            return $.grep(this.columns, function (c) { return c.title == title; })[0];
        },

        columnFromMember: function (member) {
            var column = $.grep(this.columns, function (c) { return c.member == member; })[0];

            if (!column)
                column = $.grep(this.columns, function (c) {
                    var suffix = "." + c.member;
                    return member.substr(member.length - suffix.length) == suffix;
                })[0];

            return column;
        },

        toggleOrder: function (column) {
            column = typeof column == 'number' ? this.columns[column] : column;

            var order = 'asc';

            if (column.order == 'asc')
                order = 'desc';
            else if (column.order == 'desc')
                order = null;

            column.order = order;

            var sortedIndex = $.inArray(column, this.sorted);

            if (this.sortMode == 'single' && sortedIndex < 0) {
                $.each(this.sorted, function () {
                    this.order = null;
                });
                this.sorted = [];
            }
            if (sortedIndex < 0 && order)
                this.sorted.push(column);

            if (!order)
                this.sorted.splice(sortedIndex, 1);
        },

        sortExpr: function () {
            return $.map(this.sorted, function (s) { return s.member + '-' + s.order; }).join('~');
        },

        pagerKeyDown: function (e) {
            if (e.keyCode == 13) {
                var page = this.sanitizePage($(e.target).val());
                if (page != this.currentPage)
                    this.pageTo(page);
                else
                    $(e.target).val(page);
            }
        },

        isAjax: function () {
            return this.ajax || this.ws || this.onDataBinding;
        },

        url: function (which) {
            return (this.ajax || this.ws)[which];
        },

        pagerClick: function (e) {
            e.preventDefault();
            var $element = $(e.target).closest('.t-link');

            var page = this.currentPage;
            var pagerButton = $element.find('.t-icon');

            if (pagerButton.hasClass('t-arrow-next'))
                page++;
            else if (pagerButton.hasClass('t-arrow-last'))
                page = this.totalPages();
            else if (pagerButton.hasClass('t-arrow-prev'))
                page--;
            else if (pagerButton.hasClass('t-arrow-first'))
                page = 1;
            else if ($element.attr('page') != null) {
                //переделано определение страницы под логику ELMA 2.5, страница храниться в атрибуте page
                page = parseInt($element.attr('page'));
            } else {
                var linkText = $element.text();

                if (linkText == '...') {
                    var elementIndex = $element.parent().children().index($element);

                    if (elementIndex == 0)
                        page = parseInt($element.next().text()) - 1;
                    else
                        page = parseInt($element.prev().text()) + 1;
                } else {
                    page = parseInt(linkText);
                }
            }
            var pager = $element.parent().parent().parent();

            if (!$element.parent().parent().parent().hasClass('t-grid-top'))
            ScrollToTopPager(this);
            this.pageTo(isFinite(page) ? page : this.currentPage);
        },

        changePageSize: function (size) {
            var result = parseInt(size, 10);
            if (isNaN(result) || result < 1) {
                return this.pageSize;
            }

            result = Math.max(result, 1);
            this.pageSize = this.checkPageSize(result);

            if (this.isAjax()) {
                this.ajaxRequest();
            } else {
                this.serverRequest();
            }
        },

        pageTo: function (page) {
            this.currentPage = page;
            if (this.isAjax())
                this.ajaxRequestWithValidation();
            else
                this.serverRequest();
        },

        ajaxOptions: function (options) {
            var result = {
                type: 'POST',
                dataType: 'text', // using 'text' instead of 'json' because of DateTime serialization
                dataFilter: function (data, dataType) {
                    // convert "\/Date(...)\/" to "new Date(...)"
                    return data.replace(rdate, 'new Date($1)');
                },
                error: $.proxy(function (xhr, status) {
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;
                }, this),

                complete: $.proxy(this.hideBusy, this),

                success: $.proxy(function (data, status, xhr) {
                    // $(document).trigger('telerikgridresizableupdate', $(this.element).attr('id'));
                    try {
                        data = eval('(' + data + ')');
                    } catch (e) {
                        // in case the result is not JSON raise the 'error' event
                        if (!$t.ajaxError(this.element, 'error', xhr, 'parseeror'))
                            alert('Error! The requested URL did not return JSON.');
                        return;
                    }

                    data = data.d || data; // Support the `d` returned by MS Web Services 

                    if (options.hasErrors && options.hasErrors(data)) {
                        if (!$t.trigger(this.element, 'error', {
                            XMLHttpRequest: xhr,
                            textStatus: 'modelstateerror',
                            modelState: data.modelState
                        })) {
                            options.displayErrors(data);
                        }
                        return;
                    }

                    elma.dynamicForms.afterUpdateActions = [];

                    this.ajaxData = data;

                    this.total = data.total || data.Total || 0;
                    if (!!data.currentPage) {
                        this.currentPage = data.currentPage;
                    }
                    if ('emptyDataPage' in data) {
                        this.emptyDataPage = data.emptyDataPage;
                    }
                    this.aggregates = data.aggregates || {};
                    this.colspans = data.colspans || [];
                    this.rowclasses = data.rowclasses || [];
                    this.rowstyles = data.rowstyles || [];
                    this.rowHtmlAttributes = data.rowHtmlAttributes || [];
                    this.cellhtmlattributes = data.cellhtmlattributes || [];
                    this.jsonDataHiddenFieldId = data.jsonDataHiddenFieldId;
                    this.setJsonData(data.jsondata);
                    this.parentDataHiddenFieldId = data.parentDataHiddenFieldId;
                    this.parentDataObjectId = data.parentDataObjectId;
                    this.parentDataMetadataUid = data.parentDataMetadataUid;
                    this.showEditorsDescription = data.showEditorsDescription;
                    this.headerSummary = data.headerSummary;
                    if (!!data.lastTemporaryId) {
                        $t.grid.setLastTemporaryId(data.lastTemporaryId);
                    }
                    if (!!data.validationMetadata) {
                        this.validationMetadata = data.validationMetadata;
                    }
                    if (this.onDataBound)
                        this.element.dataBound = this.onDataBound;
                    this.dataBind(data.data || data.Data);
                    var dynamicFormResult = data.dynamicFormResult;
                    if (!!dynamicFormResult) {
                        var parentForm = $(this.element).closest('form');
                        var parentDynamicForm = $(this.element).closest('div[type=dynamicForm]');
                        var modelPrefix = $(parentDynamicForm).find('input[name=\'__DynamicFormSettings.HtmlPrefix\']').val();
                        elma.dynamicForms.processResults(parentForm, dynamicFormResult, modelPrefix);
                        elma.dynamicForms.renderNotifyMessages(parentForm, dynamicFormResult.NotifyMessages);
                    }
                    if (options.afterAjaxAction) {
                        options.afterAjaxAction(this);
                    }
                }, this)
            };
            $.extend(result, options);

            var state = this.ws ? result.data.state = {} : result.data;

            if (this.jsonDataHiddenFieldId) {
                var jsonDataField = $(this.element).parent().find('#' + this.jsonDataHiddenFieldId);
                state[this.queryString.jsondata] = jsonDataField.val();
                state[this.queryString.jsonDataHiddenFieldId] = this.jsonDataHiddenFieldId;
            }
            if (this.jsondata && !this.jsonDataHiddenFieldId) {
                state[this.queryString.jsondata] = this.jsondata;
            }
            if (this.parentDataHiddenFieldId) {
                state[this.queryString.parentDataHiddenFieldId] = this.parentDataHiddenFieldId;
                var jsonDataField = $(this.element).closest('form').find('#' + this.parentDataHiddenFieldId);
                state[this.queryString.parentRootJsonData] = jsonDataField.val();
            }
            if (this.parentDataObjectId) {
                state[this.queryString.parentDataObjectId] = this.parentDataObjectId;
            }
            if (this.parentDataMetadataUid) {
                state[this.queryString.parentDataMetadataUid] = this.parentDataMetadataUid;
            }
            if (this.showEditorsDescription) {
                state[this.queryString.showEditorsDescription] = this.showEditorsDescription;
            }
            if (this.prefix) {
                state[this.queryString.prefix] = this.prefix;
            }
            if (!!$t.grid.lastTemporaryId) {
                state[this.queryString.lastTemporaryId] = $t.grid.lastTemporaryId;
            }
            state[this.queryString.page] = this.currentPage;
            state[this.queryString.size] = this.pageSize;
            state[this.queryString.orderBy] = this.orderBy || '';
            state[this.queryString.groupBy] = this.groupBy;
            state[this.queryString.filter] = (this.filterBy || '').replace(/\"/g, '\\"');
            state[this.queryString.aggregates] = $.map(this.columns, function (c) {
                if (c.aggregates)
                    return c.member + '-' + c.aggregates.join('-');
            }).join('~');

            if (this.ws) {
                result.data = $t.toJson(result.data);
                result.contentType = 'application/json; charset=utf-8';
            }
            return result;
        },

        showBusy: function () {
            this.busyPleaseWaitOpened = false;
            this.busyTimeout = setTimeout($.proxy(function () {
                if (!this.noPleaseWaitOnBusy) {
                    elma.openPleaseWait(true);
                    this.busyPleaseWaitOpened = true;
                }
                var pagerElement = $('> .t-grid-pager, > .t-grid-top-container .t-grid-pager', this.element);
                $('.t-status .t-icon', pagerElement).addClass('t-loading');
            }, this), 100);
        },

        hideBusy: function () {
            clearTimeout(this.busyTimeout);
            var pagerElement = $('> .t-grid-pager, > .t-grid-top-container .t-grid-pager', this.element);
            $('.t-status .t-icon', pagerElement).removeClass('t-loading');
            if (this.busyPleaseWaitOpened) {
                elma.closePleaseWait(true);
                this.busyPleaseWaitOpened = false;
            }
        },

        serverRequest: function () {
            location.href = $t.formatString(unescape(this.urlFormat),
                    this.currentPage, this.orderBy || '~', this.groupBy || '~', encodeURIComponent(this.filterBy) || '~', this.pageSize || '~');
        },

        applyDataFilter: function (form, nonav, replaceExpKeyFrom, replaceExpKeyTo) {
            if (form == null)
                return;

            this.formId = form || "filteringGridForm";
            this.dataFilter = elma.dynamics.getPostData("#" + form, {}, replaceExpKeyFrom, replaceExpKeyTo);

            if (nonav !== true) this.pageTo(1);
        },

        checkValid: function () {
            var hiddenInputId = null;
            if ('jsonDataHiddenFieldId' in this.data) {
                hiddenInputId = this.data.jsonDataHiddenFieldId;
            } else if ('parentDataHiddenFieldId' in this.data) {
                hiddenInputId = this.data.parentDataHiddenFieldId;
            }
            if (hiddenInputId !== null) {
                var hiddenInput = $('#' + hiddenInputId);
                hiddenInput.valid();
            }
        },

        ajaxRequestWithValidation: function (additionalData) {
            additionalData = additionalData || {};
            var validationCallback = !!this.formId ? this.checkValid : null;
            this.ajaxRequest(additionalData, validationCallback);
        },

        ajaxRequest: function (additionalData, afterAjaxAction) {
            var e = {
                page: this.currentPage,
                sortedColumns: this.sorted,
                filteredColumns: $.grep(this.columns, function (column) {
                    return column.filters;
                })
            };

            if ($t.trigger(this.element, 'dataBinding', e))
                return;

            if (!this.ajax && !this.ws)
                return;

            this.showBusy();
            if (additionalData) {
                this.additionalData = $.extend({}, this.additionalData, additionalData);
            }
            
            var addData = $.extend({}, e.data, this.additionalData);
            
            $.ajax(this.ajaxOptions({
                data: $.extend({}, addData, this.dataFilter),
                url: this.url('selectUrl'),
                afterAjaxAction: afterAjaxAction
            }));
        },

        valueFor: function (column) {
            return new Function('data', 'return data' + (column.member ? '[\'' + column.member + '\']' : '') + ';');
        },

        displayFor: function (column) {
            var localization = this.localization;

            if (column.commands) {
                var html = $.map(column.commands, function (command) {
                    var builder = $t.grid.ButtonBuilder.create($.extend({ text: localization[command.name] }, command));
                    return builder.build();
                }).join('');

                return function () {
                    return html;
                };
            }

            if (!column.template) {
                var result = column.value || function () { return ""; };

                if (column.format || column.type == 'Date')
                    result = function (data) {
                        var value = column.value(data);
                        return value == null ? '' : $t.formatString(column.format || '{0:G}', value);
                    };

                return result;
                //return column.encoded === false ? result : function (data) { return encode(result(data)) };
            }

            return template(column.template);
        },

        insertFor: function (column) {
            return this.displayFor(column);
        },

        editFor: function (column) {
            return this.displayFor(column);
        },

        initializeColumns: function () {
            $.each(this.columns, $.proxy(function (_, column) {
                if (column.member !== undefined) {
                    column.value = this.valueFor(column);
                } else {
                    column.readonly = true;
                }

                column.insert = this.insertFor(column);
                column.edit = this.editFor(column);
                column.display = this.displayFor(column);

                if (column.footerTemplate)
                    column.footer = template(column.footerTemplate);

                if (column.groupFooterTemplate) {
                    this.showGroupFooter = true;
                    column.groupFooter = template(column.groupFooterTemplate);
                }

                column.groupHeader = template('<#= Title #>: <#= Key #>');

                if (column.groupHeaderTemplate)
                    column.groupHeader = template(column.groupHeaderTemplate);

            }, this));

            if (this.detail)
                this.displayDetails = template(this.detail.template);
        },

        bindData: function (data, html, groups) {
            Array.prototype.push.apply(this.data, data);

            var dataLength = Math.min(this.pageSize, data.length);

            dataLength = this.pageSize ? dataLength : data.length;

            /* fix for ie8 hidden columns in ajax binding becoming ghosts */
            if ($.browser.msie)
                $(this.element).find('.t-grid-content colgroup:first col').css('display', '');

            for (var rowIndex = 0; rowIndex < dataLength; rowIndex++) {
                var className = $.trim((this.detail ? 't-master-row' : '') + (rowIndex % 2 == 1 ? ' t-alt' : '') + (rowIndex == dataLength - 1 ? ' t-last-row' : ''));
                var rowClassName = (this.rowclasses && this.rowclasses[rowIndex] ? this.rowclasses[rowIndex] : '');
                var rowStyle = (this.rowstyles && this.rowstyles[rowIndex] ? this.rowstyles[rowIndex] : null);
                var rowHtmlAttrs = (this.rowHtmlAttributes && this.rowHtmlAttributes[rowIndex] ? this.rowHtmlAttributes[rowIndex] : null);

                //if (className)

                html.cat('<tr ');
                var hasClass = false;
                if (rowHtmlAttrs) {
                    $.each(rowHtmlAttrs, function (i, a) {
                        if (i.toUpperCase() == 'CLASS') {
                            hasClass = true;
                            a = (className || '') + ' ' + (rowClassName || '') + ' ' + a;
                        }
                        html.cat(' ' + i + '="' + a + '" ');
                    });
                }

                if (!hasClass) {
                    html.cat(' class="')
                        .cat(className || '')
                        .cat(rowClassName != '' ? ' ' : '')
                        .cat(rowClassName)
                        .cat('"');
                }

                if (rowStyle) {
                    html.cat(' style="')
                        .cat(rowStyle)
                        .cat('"');
                }
                html.cat('>');
                //else
                //    html.cat('<tr>');

                html.rep('<td class="t-group-cell"></td>', groups)
                    .catIf('<td class="t-hierarchy-cell"><a class="t-icon t-plus" href="#" /></td>', this.detail);

                for (var i = 0, len = this.columns.length; i < len; i++) {
                    var column = this.columns[i];

                    var colspan = 1;
                    if (this.colspans && this.colspans[rowIndex] && this.colspans[rowIndex][column.member] != undefined) {
                        colspan = this.colspans[rowIndex][column.member] + 0;
                    }

                    if (colspan == 0)
                        continue;

                    var htmlAttributes;

                    if (!!this.cellhtmlattributes
                        && !!this.cellhtmlattributes[rowIndex]
                        && !!this.cellhtmlattributes[rowIndex][column.member]) {
                        htmlAttributes = this.cellhtmlattributes[rowIndex][column.member];
                    } else {
                        htmlAttributes = null;
                    }

                    html.cat('<td')
                        .cat(column.attr);
                    if (!!htmlAttributes) {
                        $.each(htmlAttributes, function (i, a) {
                            html.cat(' ' + i + '="' + a + '" ');
                        });
                    }
                    html.catIf(' class="t-last"', i == len - 1)
                        .catIf(' colspan="' + colspan + '"', colspan > 1)
                        .cat('>')
                        .cat(column.display(data[rowIndex]));

                    html.cat('</td>');
                    //if (colspan > 1) {
                    //    i = i + colspan - 1;
                    //}
                }

                html.cat('</tr>');
            }
        },

        normalizeColumns: function () {
            // empty - overridden in telerik.grid.grouping.js
        },

        nonGroupDataItems: function () {
            var nonGroupItems = [];
            if (typeof this.data == 'undefined' || !$.isArray(this.data)) {
                return nonGroupItems;
            }
            var stack = [].concat(this.data);
            stack.reverse();
            while (stack.length > 0)
            {
                var item = stack.pop();
                if (typeof item.HasSubgroups != 'undefined') {
                    // Group
                    if (typeof item.Items != 'undefined' && $.isArray(item.Items)) {
                        var subItems = [].concat(item.Items);
                        subItems.reverse();
                        stack = stack.concat(subItems);
                    }
                }
                else {
                    // Item
                    nonGroupItems.push(item);
                }
            }
            return nonGroupItems;
        },

        dataItem: function (tr) {
            var nonGroupItems = this.nonGroupDataItems();
            return nonGroupItems[this.$tbody.find('> tr:not(.t-grouping-row,.t-detail-row,.t-grid-new-row)').index($(tr))];
        },

        bindTo: function (data) {
            var html = new $t.stringBuilder();
            var colspan = this.groups.length + this.columns.length + (this.detail ? 1 : 0);

            if (data && data.length) {

                this.normalizeColumns(colspan);
                if (typeof data[0].HasSubgroups != 'undefined')
                    for (var i = 0, l = data.length; i < l; i++)
                        this.bindGroup(data[i], colspan, html, 0);
                else
                    this.bindData(data, html);
            }
            else
                html.cat("<tr class='t-no-data'>")
                    .cat("<td colspan='")
                    .cat(colspan)
                    .cat("'>")
                    .cat(this.localization.noRecords)
                    .cat('</td></tr>');

            this.$tbody.html(html.string());

            if (this.onRowDataBound) {

                var rows = jQuery.grep(this.$tbody[0].rows, function (row) {
                    return !$(row).hasClass('t-grouping-row');
                });

                for (var i = 0, l = this.data.length; i < l; i++)
                    $t.trigger(this.element, 'rowDataBound', { row: rows[i], dataItem: this.data[i] });
            }
        },

        updatePager: function () {
            var totalPages = this.totalPages(this.total);
            var currentPage = this.currentPage;
            var pageSize = this.pageSize;
            var headerSummary = this.headerSummary;

            this.$pager.parent().each(function () {
                if (totalPages > 0 || headerSummary) {
                    this.style.display = '';
                } else {
                    var headerSummaryText = $(this).find('.t-headerSummary-text').html();
                    this.style.display = headerSummaryText == null || headerSummaryText == '' ? 'none' : '';
                }
            });

            // nextPrevious
            // work-around for weird issue in IE, when using comma-based selector
            this.$pager.find('.t-arrow-next').parent().add(this.$pager.find('.t-arrow-last').parent())
	            .toggleClass('t-state-disabled', currentPage >= totalPages)
	            .removeClass('t-state-hover');

            this.$pager.find('.t-arrow-prev').parent().add(this.$pager.find('.t-arrow-first').parent())
	            .toggleClass('t-state-disabled', currentPage == 1)
	            .removeClass('t-state-hover');

            var localization = this.localization;
            // pageInput
            this.$pager.find('.t-page-i-of-n').each(function () {
                this.innerHTML = new $t.stringBuilder()
                                       .cat(localization.page)
                                       .cat('<input type="text" value="')
                                       .cat(currentPage)
                                       .cat('" /> ')
                                       .cat($t.formatString(localization.pageOf, totalPages))
                                       .string();
            });

            this.$pager.find('.t-page-size').each(function () {
                var html = '<div style="width: 50px;" class="t-dropdown t-header">' +
                             '<div class="t-dropdown-wrap t-state-default"><span class="t-input">' + pageSize + '</span>' +
                                '<span class="t-select"><span class="t-icon t-arrow-down">select</span></span>' +
                             '</div>' +
                           '</div>';
                this.innerHTML = html;
            });

            // numeric
            this.$pager.find('.t-numeric').each($.proxy(function (index, element) {
                this.numericPager(element, currentPage, totalPages);
            }, this));

            // status
            this.$pager.parent()
                       .find('.t-status-text')
                       .html('<span class="t-pager-total t-pager-text">' + localization.displayingItems + '</span><span>' + this.total + '</span>');

            //headerSummary
            if (headerSummary != undefined) {
                $('.t-headerSummary-text', this.element)
                    .each(function() {
                        this.innerHTML = headerSummary;
                    });
            }

            BottomPagerVisible();
            ScrollToTopPager(this);
        },

        /*
        numericPager: function (pagerElement, currentPage, totalPages) {
        var numericLinkSize = 10;
        var numericStart = 1;

        if (currentPage > numericLinkSize) {
        var reminder = (currentPage % numericLinkSize);

        numericStart = (reminder == 0) ? (currentPage - numericLinkSize) + 1 : (currentPage - reminder) + 1;
        }

        var numericEnd = (numericStart + numericLinkSize) - 1;

        numericEnd = Math.min(numericEnd, totalPages);

        var pagerHtml = new $t.stringBuilder();
        if (numericStart > 1)
        pagerHtml.cat('<a class="t-link">...</a>');

        for (var page = numericStart; page <= numericEnd; page++) {
        if (page == currentPage) {
        pagerHtml.cat('<span class="t-state-active">')
        .cat(page)
        .cat('</span>');
        } else {
        pagerHtml.cat('<a class="t-link">')
        .cat(page)
        .cat('</a>');
        }
        }

        if (numericEnd < totalPages)
        pagerHtml.cat('<a class="t-link">...</a>');

        pagerElement.innerHTML = pagerHtml.string();
        },
        */
        numericPagerLink: function (page, text, isCurrent) {
            var link = new $t.stringBuilder();
            if (isCurrent) {
                link.cat('<span class="t-state-active">')
                        .cat(text)
                        .cat('</span>');
            } else {
                link.cat('<a class="t-link" page="')
                    .cat(page)
                    .cat('">')
	                .cat(text)
	                .cat('</a>');
            }
            return link.string();
        },
        //переделано поведение и отображение под  ELMA 2.5
        numericPager: function (pagerElement, currentPage, totalPages) {
            var pagerHtml = new $t.stringBuilder();

            //Всегда показываем первую страницу
            pagerHtml.cat(this.numericPagerLink(1, '1', currentPage == 1));
            if (totalPages > 1) {
                //если страниц 5 или меньше, рендерим все
                var i = 0;
                if (totalPages <= 5) {
                    for (i = 2; i < totalPages; i++) {
                        pagerHtml.cat(this.numericPagerLink(i, i, currentPage == i));
                    }
                } else {
                    //рисуем многоточие
                    if (currentPage > 4) {
                        pagerHtml.cat(this.numericPagerLink(currentPage - 5 > 0 ? currentPage - 5 : 1, '...', false));
                    }
                    //рисуем x x currentPage x x
                    var start = currentPage - 2 > 1 ? currentPage - 2 : 2;
                    var end = currentPage + 2 < totalPages ? currentPage + 2 : totalPages - 1;
                    for (i = start; i <= end; i++) {
                        pagerHtml.cat(this.numericPagerLink(i, i, currentPage == i));
                    }
                    //рисуем многоточие
                    if (currentPage < totalPages - 3) {
                        pagerHtml.cat(this.numericPagerLink(currentPage + 5 <= totalPages ? currentPage + 5 : totalPages, '...', false));
                    }
                }
                //Всегда показываем последнюю страницу
                pagerHtml.cat(this.numericPagerLink(totalPages, totalPages, currentPage == totalPages));
            }
            pagerElement.innerHTML = pagerHtml.string();
        },

        $columns: function () {
            return this.$header.find('th:not(.t-hierarchy-cell,.t-group-cell)');
        },

        updateSorting: function () {
            this.sorted = [];
            $.each(this.orderBy.split('~'), $.proxy(function (_, expr) {
                var memberAndOrder = expr.split('-');
                var column = this.columnFromMember(memberAndOrder[0]);
                if (column) {
                    column.order = memberAndOrder[1];
                    this.sorted.push(column);
                }
            }, this));

            this.$columns().each($.proxy(function (i, header) {
                var direction = this.columns[i].order;
                var $link = $(header).children('.t-link');
                var $icon = $link.children('.t-icon');

                if (!direction) {
                    $icon.hide();
                } else {
                    if ($icon.length == 0)
                        $icon = $('<span class="t-icon"/>').appendTo($link);

                    $icon.toggleClass('t-arrow-up', direction == 'asc')
                        .toggleClass('t-arrow-down', direction == 'desc')
                        .html('(' + (direction == 'asc' ? this.localization.sortedAsc : this.localization.sortedDesc) + ')')
                        .show();
                }
            }, this));
        },

        sanitizePage: function (value) {
            var result = parseInt(value, 10);
            if (isNaN(result) || result < 1)
                return this.currentPage;
            return Math.min(result, this.totalPages());
        },

        totalPages: function () {
            return Math.ceil(this.total / this.pageSize);
        },

        firstItemInPage: function () {
            return this.total > 0 ? (this.currentPage - 1) * this.pageSize + 1 : 0;
        },

        lastItemInPage: function () {
            return Math.min(this.currentPage * this.pageSize, this.total);
        },

        dataBind: function (data) {
            this.data = [];
            this.bindTo(data);

            this.bindFooter();

            this.updatePager();
            this.updateSorting();
            $t.trigger(this.element, 'dataBound');
            $t.trigger(this.element, 'repaint');
            BottomPagerVisible();
        },

        bindFooter: function () {
            var $footerCells = this.$footer.find('td:not(.t-group-cell,.t-hierarchy-cell)');
            var aggregates = this.aggregates;

            $.each(this.columns, function (index) {
                if (this.footer)
                    $footerCells.eq(index).html(this.footer(aggregates[this.member]));
            });
        },

        rebind: function (args) {
            this.sorted = [];
            this.orderBy = '';
            this.filterBy = '';
            this.currentPage = 1;

            $.each(this.columns, function () {
                this.order = null;
                this.filters = null;
            });

            $('.t-filter-options', this.element)
                .find('input[type="text"], select')
                .val('')
                .removeClass('t-state-error')
                .end()
                .find('div.t-formatted-value')
                .html('');

            $('.t-grid-filter', this.element)
                .removeClass('t-active-filter');

            this.ajaxRequest(args);
        },

        setJsonData: function (data) {
            this.jsondata = data;
            if (!!this.jsonDataHiddenFieldId) {
                var jsonDataField = $(this.element).parent().find('#' + this.jsonDataHiddenFieldId);
                if (jsonDataField.length) {
                    jsonDataField.val(data);
                }
            }
        },

        showExportExcelWaitQtip: function () {
            this.exportExcelWait = setTimeout($.proxy(function () {
                var pagerElement = $('> .t-grid-pager, > .t-grid-top-container .t-grid-pager', this.element);
                $('.t-export-excel', pagerElement).addClass('t-wait').attr('disabled');
                this.showExportExcelQtip();
            }, this), 100);
        },

        hideExportExcelWait: function () {
            clearTimeout(this.exportExcelWait);
            var pagerElement = $('> .t-grid-pager, > .t-grid-top-container .t-grid-pager', this.element);
            $('.t-export-excel', pagerElement).removeClass('t-wait').removeAttr('disabled');
        },

        exportExcel: function (e, element) {
            if ($(element).is('.t-loading'))
                return;

            if (!this.isAjax())
                return;

            var grid = this;
            e.preventDefault();

            if ($(e.currentTarget).hasClass('t-wait'))
                return;

            var exportExcel = this.$pager.parent().find('.t-export-excel');
            if ($(e.currentTarget).hasClass('t-download')) {
                var tDownloadExport = this;
                if (grid.url('exportExcelResetUrl')) {
                    grid.showExportExcelWaitQtip();
                    $.ajax({
                        type: 'POST',
                        url: grid.url('exportExcelResetUrl'),
                        success: $.proxy(function () {
                            var fileHref = $(e.currentTarget).attr("fileHref");
                            exportExcel.each(function () {
                                $(this).removeAttr("fileHref");
                                grid.hideExportExcelWait();
                                $(this).removeClass('t-download');
                            })
                            grid.showExportExcelQtip();
                            document.location = fileHref;
                        })
                    });
                } else {
                    var fileHref = $(e.currentTarget).attr("fileHref");
                    exportExcel.each(function () {
                        $(this).removeClass('t-download');
                        $(tDownloadExport).removeAttr("fileHref");
                        grid.showExportExcelQtip();
                    })
                    document.location = fileHref;
                }
                return;
            }


            if (grid.total <= grid.pageSize)
                grid.exportExcelStart(e.currentTarget, $(e.currentTarget).attr("fileName"));
            else {
                $.alerts._show(null, null, null, null, null, null, '<div id="popup_container" class="t-widget t-window">' +
                        '<div id="popup_title" class="t-window-titlebar t-header"></div>' +
                        '<div class="t-window-content t-content">' +
                            '<div class="elma-window-content">' +
                                '<div>' +
                                    '<a class="link-button" id="exportAll" href="">' + SR.T('Экспортировать все записи') + '</a> ' +
                                    '<a class="link-button" id="exportCurrentPage" href="">' + SR.T('Экспортировать текущую страницу') + '</a>' +
                                '</div>' +
                                '<div class="popup-buttons"><input type="button" class="t-button" value="' + SR.T('Отмена') + '" id="popup_cancel" /></div>' +
                            '</div>' +
                        '</div>' +
                    '</div>');
                $("#popup_title").html(SR.T('Экспорт в Excel') + '<div class="t-window-actions t-header"><a id="exportClose" href="" class="t-window-action t-link"><span class="t-icon t-close">Close</span></a></div>');

                $("#exportCurrentPage").click(function () {
                    $.alerts._hide();
                    grid.exportExcelStart(e.currentTarget, $(e.currentTarget).attr("fileName"), true);
                    return false;
                });
                $("#exportAll").click(function () {
                    $.alerts._hide();
                    grid.exportExcelStart(e.currentTarget, $(e.currentTarget).attr("fileName"));
                    return false;
                });
                $("#exportClose, #popup_cancel").click(function () {
                    $.alerts._hide();
                    return false;
                });
            }
        },
        exportExcelStart: function (currentTarget, fileName, currentPageOnly) {
            var e = {
                page: this.currentPage,
                sortedColumns: this.sorted,
                filteredColumns: $.grep(this.columns, function (column) {
                    return column.filters;
                })
            };

            if ($t.trigger(this.element, 'dataBinding', e))
                return;

            if (!this.ajax && !this.ws)
                return;

            var grid = this;
            grid.showExportExcelWaitQtip();

            var options = this.ajaxOptions({
                url: this.url('selectUrl'),
                error: $.proxy(function (xhr, status) {
                    grid.hideExportExcelWait();
                    grid.showExportExcelQtip();
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;
                }, this),

                complete: $.proxy(function () { }),

                success: $.proxy(function (data, status, xhr) {
                    try {
                        data = eval('(' + data + ')');
                    } catch (e) {
                        // in case the result is not JSON raise the 'error' event
                        if (!$t.ajaxError(this.element, 'error', xhr, 'parseeror'))
                            alert('Error! The requested URL did not return JSON.');
                        return;
                    }
                    if (data.ready) {
                        if (data.error) {
                            hide.hideExportExcelWait();
                            grid.showExportExcelQtip(data.error);
                        } else if (grid.url('exportExcelResetUrl')) {
                            $.ajax({
                                type: 'POST',
                                url: grid.url('exportExcelResetUrl'),
                                success: $.proxy(function () {
                                    grid.hideExportExcelWait();
                                    grid.showExportExcelQtip();
                                    document.location = data.fileHref;
                                })
                            });
                        } else {
                            grid.hideExportExcelWait();
                            grid.showExportExcelQtip();
                            document.location = data.fileHref;
                        }
                    }
                }),
                data: $.extend({ exportExcel: true, exportExcelFileName: fileName == undefined ? "" : fileName }, e.data, elma.dynamics.getPostData('#filteringGridForm', grid.dataFilter))
            });
            if (!currentPageOnly === true) {
                $.extend(options.data, { page: 1, size: 0 });
            }
            $.ajax(options);
        },

        showExportExcelQtip: function (error) {
            var exportExcel = this.$pager.parent().find('.t-export-excel');
            exportExcel.each(function() {
                $(this).qtip('destroy');
                var text = error || $(this).attr('error');
                $(this).removeAttr('error');
                if (!text && $(this).hasClass('t-wait'))
                    text = SR.T('Формирование файла экспорта');
                if (!text && $(this).hasClass('t-download'))
                    text = SR.T('Файл экспорта готов для скачивания.<br>Нажмите на иконку для скачивания файла.');
                var visibilyti = this.parentElement.parentElement.style.display;
                if (text && visibilyti != "none") {
                    $(this).qtip(conf = {
                        content: text,
                        position: {
                            my: 'bottom right',
                            at: 'top middle',
                            viewport: true
                        },
                        show: {
                            ready: true
                        },
                        hide: false
                    });
                }
                if (text && visibilyti == "none") {
                    $(this).qtip(conf = {
                        content: text,
                        position: {
                            my: 'bottom right',
                            at: 'top middle',
                            viewport: true
                        },
                    });
                }
            });
        }
    };

    $t.grid.exportExcelUpdateStatus = function (d) {
        try {
            var d = eval(d);
            for (var i = 0; i < d.length; i++) {
                var data = d[i];
                var grid = $('#' + data.GridId).data('tGrid');
                if (grid) {
                    var exportExcel = grid.$pager.parent().find('.t-export-excel');
                    if (data.ready && exportExcel.hasClass('t-wait')) {
                        grid.hideExportExcelWait();
                        grid.showExportExcelQtip();

                        if (data.error) {
                            grid.showExportExcelQtip(data.error);
                        } else {
                            exportExcel.addClass('t-download');
                            exportExcel.attr("fileHref", data.fileHref);

                            grid.showExportExcelQtip();
                        }
                    }
                }
            }
        } catch (e) {
            alert(e);
        }
    };

    $t.grid.ButtonBuilder = function (button) {
        this.classNames = ['t-button', 't-grid-' + button.name];

        this.content = function () {
            return '<span class="t-button-text">' + button.text + '</span>';
        };
        this.build = function () {
            return '<a href="#" class="' + this.classNames.join(' ') + (button.cssClasses ? ' ' + button.cssClasses : '') + '" ' + (button.attr ? button.attr : '') + '>' +
                        this.content() +
                   '</a>';
        };
    };
    $t.grid.ButtonBuilder.create = function (button) {
        return new (buttonBuilderTypes[button.buttonType])(button);
    };

    function sprite(name, imageAttr) {
        return '<span class="t-icon t-' + name + '"' + (imageAttr ? imageAttr : '') + '>' + '</span>';
    }

    $t.grid.ImageButtonBuilder = function (button) {
        $t.grid.ButtonBuilder.call(this, button);

        this.classNames.push('t-button-icon');

        this.content = function () {
            return sprite(button.name, button.imageAttr);
        };
    };
    $t.grid.ImageTextButtonBuilder = function (button) {
        $t.grid.ButtonBuilder.call(this, button);

        this.classNames.push('t-button-icontext');

        this.content = function () {
            return '<span class="t-icon t-' + button.name + '"' + (button.imageAttr ? button.imageAttr : '') + '>' +
                   '</span>' + '<span class="t-button-text">' + button.text + '</span>';
        };
    };
    $t.grid.BareImageButtonBuilder = function (button, localization) {
        $t.grid.ImageButtonBuilder.call(this, button, localization);
        this.classNames.push('t-button-icon', 't-button-bare');
    };
    var buttonBuilderTypes = {
        Text: $t.grid.ButtonBuilder,
        ImageAndText: $t.grid.ImageTextButtonBuilder,
        Image: $t.grid.ImageButtonBuilder,
        BareImage: $t.grid.BareImageButtonBuilder
    };

    $.fn.tGrid = function (options) {
        return $t.create(this, {
            name: 'tGrid',
            init: function (element, options) {
                return new $t.grid(element, options);
            },
            options: options,
            success: function (grid) {
                $(document).trigger('telerikgridresizableupdate', grid.element.id);
                /*
                if (grid.$tbody.find('tr.t-no-data').length) {
                var dyn = grid.$tbody.parents('.dynamic');
                if (dyn.length == 0 || dyn.attr('loaded') == undefined || dyn.attr('loaded') == "0") {
                grid.ajaxRequest();
                }
                }*/
            }
        });
    };

    // default options

    $.fn.tGrid.defaults = {
        columns: [],
        plugins: [],
        currentPage: 1,
        pageSize: 10,
        emptyDataPage: 0,
        localization: {
            addNew: 'Add new record',
            'delete': 'Delete',
            cancel: 'Cancel',
            insert: 'Insert',
            update: 'Update',
            select: 'Select',
            pageOf: 'of {0}',
            displayingItems: 'Displaying items {0} - {1} of {2}',
            edit: 'Edit',
            noRecords: 'No records to display.',
            page: 'Page ',
            filter: 'Filter',
            filterClear: 'Clear Filter',
            filterShowRows: 'Show rows with value that',
            filterAnd: 'And',
            filterStringEq: 'Is equal to',
            filterStringNe: 'Is not equal to',
            filterStringStartsWith: 'Starts with',
            filterStringSubstringOf: 'Contains',
            filterStringEndsWith: 'Ends with',
            filterNumberEq: 'Is equal to',
            filterNumberNe: 'Is not equal to',
            filterNumberLt: 'Is less than',
            filterNumberLe: 'Is less than or equal to',
            filterNumberGt: 'Is greater than',
            filterNumberGe: 'Is greater than or equal to',
            filterDateEq: 'Is equal to',
            filterDateNe: 'Is not equal to',
            filterDateLt: 'Is before',
            filterDateLe: 'Is before or equal to',
            filterDateGt: 'Is after',
            filterDateGe: 'Is after or equal to',
            filterEnumEq: 'Is equal to',
            filterEnumNe: 'Is not equal to',
            filterBoolIsTrue: 'is true',
            filterBoolIsFalse: 'is false',
            filterSelectValue: '-Select value-',
            filterOpenPopupHint: 'Open the calendar popup',
            groupHint: 'Drag a column header and drop it here to group by that column',
            deleteConfirmation: 'Are you sure you want to delete this record?',
            sortedAsc: 'sorted ascending',
            sortedDesc: 'sorted descending',
            ungroup: 'ungroup'
        },
        queryString: {
            page: 'page',
            size: 'size',
            orderBy: 'orderBy',
            groupBy: 'groupBy',
            filter: 'filter',
            aggregates: 'aggregates',
            jsondata: 'jsonData',
            parentRootJsonData: 'parentRootJsonData',
            dynamicFormResult: 'dynamicFormResult',
            jsonDataHiddenFieldId: 'jsonDataHiddenFieldId',
            parentDataHiddenFieldId: 'parentDataHiddenFieldId',
            parentDataObjectId: 'parentDataObjectId',
            parentDataMetadataUid: 'parentDataMetadataUid',
            lastTemporaryId: 'lastTemporaryId',
            showEditorsDescription: 'showEditorsDescription',
            prefix: 'prefix'
        }
    };
    $t.grid.lastTemporaryId = null;
    $t.grid.setLastTemporaryId = function (id) {
        if (!$.telerik.grid.lastTemporaryId || (!!id && (parseInt($.telerik.grid.lastTemporaryId) > id))) {
            $.telerik.grid.lastTemporaryId = id;
        }
    };

    $(document).ready(function () {

        $(window).scroll(function () {
            BottomPagerVisible();
        });

        $(window).resize(function () {
            BottomPagerVisible();
        });
    });

    function BottomPagerVisible() {
        var pagers = $('div.t-grid-pager.t-grid-top');
        pagers.each(function () {
            var box = this.getBoundingClientRect();
            var bottom = $(this).parent().find('.t-grid-bottom');
            var Bottom = $(this).parent().find('.t-grid-Bottom');
            if (box.top + this.offsetHeight >= 0 || this.style.display == "none") {
                if (bottom.length == 0) bottom = $(this).parent().parent().parent().find('.t-grid-bottom');
                if (Bottom.length == 0) Bottom = $(this).parent().parent().parent().find('.t-grid-Bottom');
                bottom.hide();
                Bottom.hide();
            }
            else {
                if (bottom.length == 0) bottom = $(this).parent().parent().parent().find('.t-grid-bottom');
                if (Bottom.length == 0) Bottom = $(this).parent().parent().parent().find('.t-grid-Bottom');
                bottom.show();
                Bottom.show();
            }
        });
    }

    function ScrollToTopPager(e)
    {
        var pager = e.$pager.parent().parent().find('.t-grid-pager.t-grid-bottom')
        if (pager) {
                if (pager.css('display') != "none") {
                    var pagerTop = e.$pager.parent().parent().find('.t-grid-pager.t-grid-top')
                    if (pagerTop.length>0) {
                        var topPosition = pagerTop.offset().top;
                    }
                    $('html, body').animate({ scrollTop: topPosition });
                }
            }
    }
})(jQuery);



(function ($) {

    var $t = $.telerik, dateRe = /^\/Date\((.*?)\)\/$/;

    var UnobtrusiveValidator = function (formId) {
        this.formId = formId;
        this._isBuild = false;
        var data_validation = "tUnobtrusiveValidation";
        var data_container = "tUnobtrusiveContainer";
        var unobtrusive = this.unobtrusive = {
            adapters: [],
            parseElement: function (element, skipAttach) {
                var $element = $(element),
						form = $element.parents("form")[0],
						valInfo, rules, messages;

                if (!form) {
                    return;
                }

                valInfo = unobtrusive.validationInfo(form);
                valInfo.options.rules[element.name] = rules = {};
                valInfo.options.messages[element.name] = messages = {};

                $.each(this.adapters, function () {
                    var prefix = "data-val-" + this.name,
							message = $element.attr(prefix),
							paramValues = {};

                    if (message !== undefined) {
                        prefix += "-";

                        $.each(this.params, function () {
                            paramValues[this] = $element.attr(prefix + this);
                        });

                        this.adapt({
                            element: element,
                            form: form,
                            message: message,
                            params: paramValues,
                            rules: rules,
                            messages: messages
                        });
                    }
                });

                if (!skipAttach) {
                    valInfo.attachValidation();
                }
            },

            parse: function (selector) {
                $(selector).find(":input[data-val=true]").each(function () {
                    unobtrusive.parseElement(this, true);
                });

                $("form").each(function () {
                    var info = unobtrusive.validationInfo(this);
                    if (info) {
                        info.attachValidation();
                    }
                });
            },

            onError: function (error, inputElement) {
                var container = $(this).find("[data-valmsg-for='" + inputElement[0].name + "']"),
						replace = $.parseJSON(container.attr("data-valmsg-replace")) !== false;

                container.removeClass("field-validation-valid").addClass("field-validation-error");
                error.data(data_container, container);

                if (replace) {
                    container.empty();
                    error.removeClass("input-validation-error").appendTo(container);
                }
                else {
                    error.hide();
                }
            },

            onErrors: function (form, validator) {
                var container = $(this).find("[data-valmsg-summary=true]"),
						list = container.find("ul");

                if (list && list.length && validator.errorList.length) {
                    list.empty();
                    container.addClass("validation-summary-errors").removeClass("validation-summary-valid");

                    $.each(validator.errorList, function () {
                        $("<li />").html(this.message).appendTo(list);
                    });
                }
            },

            onSuccess: function (error) {
                var container = error.data(data_container),
						replace = $.parseJSON(container.attr("data-valmsg-replace"));

                if (container) {
                    container.addClass("field-valiion-valid").removeClass("field-validation-error");
                    error.removeData(data_container);

                    if (replace) {
                        container.empty();
                    }
                }
            },

            validationInfo: function (form) {
                var $form = $(form),
						result = $form.data(data_validation);

                if (!result) {
                    result = {
                        options: {
                            errorClass: "input-validation-error",
                            errorElement: "span",
                            errorPlacement: $.proxy(unobtrusive.onError, form),
                            invalidHandler: $.proxy(unobtrusive.onErrors, form),
                            messages: {},
                            rules: {},
                            success: $.proxy(unobtrusive.onSuccess, form)
                        },
                        attachValidation: function () {
                            $form.validate(this.options);
                        },
                        validate: function () {
                            $form.validate();
                            return $form.valid();
                        }
                    };
                    $form.data(data_validation, result);
                }

                return result;
            }
        };
    };

    UnobtrusiveValidator.prototype = {
        build: function () {
            if (this._isBuild)
                return;

            this._isBuild = true;

            var adapters = [];
            function setValidationValues(options, ruleName, value) {
                options.rules[ruleName] = value;
                if (options.message) {
                    options.messages[ruleName] = options.message;
                }
            }

            function splitAndTrim(value) {
                return value.replace(/^\s+|\s+$/g, "").split(/\s*,\s*/g);
            }

            function getModelPrefix(fieldName) {
                return fieldName.substr(0, fieldName.lastIndexOf(".") + 1);
            }

            function appendModelPrefix(value, prefix) {
                if (value.indexOf("*.") === 0) {
                    value = value.replace("*.", prefix);
                }
                return value;
            }

            adapters = this.unobtrusive.adapters;
            adapters.add = function (adapterName, params, fn) {
                if (!fn) {
                    fn = params;
                    params = [];
                }
                this.push({ name: adapterName, params: params, adapt: fn });
                return this;
            };

            adapters.addBool = function (adapterName, ruleName) {
                return this.add(adapterName, function (options) {
                    setValidationValues(options, ruleName || adapterName, true);
                });
            };

            adapters.addMinMax = function (adapterName, minRuleName, maxRuleName, minMaxRuleName, minAttribute, maxAttribute) {
                return this.add(adapterName, [minAttribute || "min", maxAttribute || "max"], function (options) {
                    var min = options.params.min,
						max = options.params.max;

                    if (min && max) {
                        setValidationValues(options, minMaxRuleName, [min, max]);
                    }
                    else if (min) {
                        setValidationValues(options, minRuleName, min);
                    }
                    else if (max) {
                        setValidationValues(options, maxRuleName, max);
                    }
                });
            };

            adapters.addSingleVal = function (adapterName, attribute, ruleName) {
                return this.add(adapterName, [attribute || "val"], function (options) {
                    setValidationValues(options, ruleName || adapterName, options.params[attribute]);
                });
            };

            adapters.addSingleVal("accept", "exts").addSingleVal("regex", "pattern");
            adapters.addBool("creditcard").addBool("date").addBool("digits").addBool("email").addBool("number").addBool("url");
            adapters.addMinMax("length", "minlength", "maxlength", "rangelength").addMinMax("range", "min", "max", "range");
            adapters.add("equalto", ["other"], function (options) {
                var element = $(options.form).find(":input[name=" + options.params.other + "]")[0];
                setValidationValues(options, "equalTo", element);
            });
            adapters.add("required", function (options) {
                if (options.element.tagName.toUpperCase() !== "INPUT" || options.element.type.toUpperCase() !== "CHECKBOX") {
                    setValidationValues(options, "required", true);
                }
            });
            adapters.add("remote", ["url", "type", "additionalfields"], function (options) {
                var value = {
                    url: options.params.url,
                    type: options.params.type || "GET",
                    data: {}
                },
                    prefix = getModelPrefix(options.element.name);

                $.each(splitAndTrim(options.params.additionalfields || options.element.name), function (i, fieldName) {
                    var paramName = appendModelPrefix(fieldName, prefix);
                    value.data[paramName] = function () {
                        return $(options.form).find(":input[name='" + paramName + "']").val();
                    };
                });

                setValidationValues(options, "remote", value);
            });

            if ($.validator.unobtrusive && $.validator.unobtrusive.adapters)
                $.extend(adapters, $.validator.unobtrusive.adapters);

            $.validator.addMethod("regex", function (value, element, params) {
                if (this.optional(element))
                    return true;

                var match = new RegExp(params).exec(value);
                return match && match.index == 0 && match[0].length == value.length;
            });

            $.validator.addMethod('number', function (value, element) {
                var groupSize = $t.cultureInfo.numericgroupsize;
                var builder = new $t.stringBuilder();

                builder.cat('^-?(?:\\d+|\\d{1,')
					   .cat(groupSize)
					   .cat('}(?:')
					   .cat($t.cultureInfo.numericgroupseparator)
					   .cat('\\d{')
					   .cat(groupSize)
					   .cat('})+)(?:\\')
					   .cat($t.cultureInfo.numericdecimalseparator)
					   .cat('\\d+)?$');

                return this.optional(element) || new RegExp(builder.string()).test(value);
            });
        },
        parse: function () {
            this.build();
            this.unobtrusive.parse(this.formId);
        }
    };

    var Mvc2Validator = function (validationMetaData) {
        this.validationMetaData = validationMetaData;
    };

    Mvc2Validator.prototype = {
        build: function (validationContext) {

            $.validator.addMethod("regex", function (value, element, params) {
                if (this.optional(element))
                    return true;

                var match = new RegExp(params).exec(value);
                return match && match.index == 0 && match[0].length == value.length;
            });

            $.validator.addMethod('number', function (value, element) {
                var groupSize = $t.cultureInfo.numericgroupsize;
                var builder = new $t.stringBuilder();

                builder.cat('^-?(?:\\d+|\\d{1,')
					   .cat(groupSize)
					   .cat('}(?:')
					   .cat($t.cultureInfo.numericgroupseparator)
					   .cat('\\d{')
					   .cat(groupSize)
					   .cat('})+)(?:\\')
					   .cat($t.cultureInfo.numericdecimalseparator)
					   .cat('\\d+)?$');

                return this.optional(element) || new RegExp(builder.string()).test(value);
            });

            function applyRangeValidator(object, min, max) {
                object["range"] = [min, max];
            };

            function applyRegularExpressionValidator(object, pattern) {
                object["regex"] = pattern;
            };

            function applyRequiredValidator(object) {
                object["required"] = true;
            };

            function applyStringLengthValidator(object, maxLength) {
                object["maxlength"] = maxLength;
            };

            function applyUnknownValidator(object, validationType, validationParameters) {
                object[validationType] = validationParameters;
            };

            function createFieldToValidationMessageMapping(validationFields) {
                var mapping = {};

                for (var i = 0; i < validationFields.length; i++) {
                    var thisField = validationFields[i];
                    mapping[thisField.FieldName] = "#" + thisField.ValidationMessageId;
                }

                return mapping;
            };

            function createErrorMessagesObject(validationFields) {
                var messagesObj = {};

                for (var i = 0; i < validationFields.length; i++) {
                    var thisField = validationFields[i];
                    var thisFieldMessages = {};
                    messagesObj[thisField.FieldName] = thisFieldMessages;
                    var validationRules = thisField.ValidationRules;

                    for (var j = 0; j < validationRules.length; j++) {
                        var thisRule = validationRules[j];
                        if (thisRule.ErrorMessage) {
                            var jQueryValidationType = thisRule.ValidationType;
                            switch (thisRule.ValidationType) {
                                case "regularExpression":
                                    jQueryValidationType = "regex";
                                    break;

                                case "stringLength":
                                    jQueryValidationType = "maxlength";
                                    break;
                            }

                            thisFieldMessages[jQueryValidationType] = thisRule.ErrorMessage;
                        }
                    }
                }

                return messagesObj;
            }
            function createRulesForField(validationField) {
                var validationRules = validationField.ValidationRules;

                // hook each rule into jquery
                var rulesObj = {};
                for (var i = 0; i < validationRules.length; i++) {
                    var thisRule = validationRules[i];
                    switch (thisRule.ValidationType) {
                        case "range":
                            var min = (typeof (thisRule.ValidationParameters['minimum']) == "undefined") ? thisRule.ValidationParameters['min'] : thisRule.ValidationParameters['minimum'];
                            var max = (typeof (thisRule.ValidationParameters['maximum']) == "undefined") ? thisRule.ValidationParameters['max'] : thisRule.ValidationParameters['maximum'];
                            applyRangeValidator(rulesObj,
								    min, max);
                            break;

                        case "regularExpression":
                        case "regex":
                            applyRegularExpressionValidator(rulesObj,
								thisRule.ValidationParameters["pattern"]);
                            break;

                        case "required":
                            applyRequiredValidator(rulesObj);
                            break;

                        case "stringLength":
                            applyStringLengthValidator(rulesObj,
								thisRule.ValidationParameters["maximumLength"]);
                            break;
                        case "length":
                            applyStringLengthValidator(rulesObj,
								thisRule.ValidationParameters["max"]);
                            break;
                        default:
                            applyUnknownValidator(rulesObj,
								thisRule.ValidationType, thisRule.ValidationParameters);
                            break;
                    }
                }

                return rulesObj;
            }

            function createValidationOptions(validationFields) {
                var rulesObj = {};
                for (var i = 0; i < validationFields.length; i++) {
                    var validationField = validationFields[i];
                    var fieldName = validationField.FieldName;
                    rulesObj[fieldName] = createRulesForField(validationField);
                }

                return rulesObj;
            }

            var theForm = $("#" + validationContext.FormId);

            var fields = validationContext.Fields;
            var rulesObj = createValidationOptions(fields);
            var fieldToMessageMappings = createFieldToValidationMessageMapping(fields);
            var errorMessagesObj = createErrorMessagesObject(fields);

            var options = {
                errorClass: "input-validation-error",
                errorElement: "span",
                errorPlacement: function (error, element) {
                    var messageSpan = !isEmpty(fieldToMessageMappings[element.attr("name")]) ? fieldToMessageMappings[element.attr("name")] : '#' + (!isEmpty(element.attr('id')) ? element.attr('id') : element.attr('name')) + '_validationMessage';
                    //var messageSpan = fieldToMessageMappings[element.attr("name")];
                    if (messageSpan) {
                        $(messageSpan).empty()
										.removeClass("field-validation-valid")
										.addClass("field-validation-error")

                        error.removeClass("input-validation-error")
							 .attr("_for_validation_message", messageSpan)
							 .appendTo(messageSpan);
                    }
                },
                messages: errorMessagesObj,
                rules: rulesObj,
                success: function (label) {
                    $(label.attr("_for_validation_message"))
						.empty()
						.addClass("field-validation-valid")
						.removeClass("field-validation-error");
                }
            };
            elma.ValidationRulesManager.pushStartupValidation(validationContext);
            __MVC_EnableClientValidation(validationContext);
            //theForm.validate(options);
        },
        parse: function () {
            this.build(this.validationMetaData);
        }
    };

    $t.editing = {};

    function cancelAll(gridScope) {
        var parentWindow = document.body;
        if (gridScope && gridScope.$tbody) {
            parentWindow = $(gridScope.$tbody).parents('div.t-window');
            if (parentWindow.length < 1)
                parentWindow = $(document.body);
        }

        $(parentWindow).find('div.t-grid')
                        .each(function () {
                            var grid = $(this).data('tGrid');
                            if (grid && grid.cancel)
                                grid.cancel();
                        });
    }

    function insertOrUpdateAll(gridScope) {
        var parentWindow = document.body;
        if (gridScope && gridScope.$tbody) {
            parentWindow = $(gridScope.$tbody).parents('div.t-window');
            if (parentWindow.length < 1)
                parentWindow = $(document.body);
        }

        $(parentWindow).find('div.t-grid')
                        .each(function () {
                            var grid = $(this).data('tGrid');
                            if (grid && grid.insertOrUpdate)
                                grid.insertOrUpdate();
                        });
    }

    function flatten(result, value, prefix) {
        for (var key in value) {
            if ($.isPlainObject(value[key])) {
                flatten(result, value, prefix ? prefx + "." + key : key);
            } else {
                result[prefix ? prefix + "." + key : key] = value[key];
            }
        }
    }

    function unflatten(value) {
        for (var key in value) {
            var firstMemberIndex = key.indexOf(".");

            if (firstMemberIndex > -1) {
                var firstMember = key.substring(0, firstMemberIndex);
                var child = value[firstMember] || {};
                child[key.substring(firstMemberIndex + 1)] = value[key];
                value[firstMember] = unflatten(child);

                delete value[key];
            }
        }
        return value;
    }

    function sanitizeDates(dataItem) {
        var member, value, date;

        for (member in dataItem) {
            value = dataItem[member];
            if (typeof value === "string") {
                date = dateRe.exec(value);
                if (date) {
                    dataItem[member] = new Date(parseInt(date[1]));
                }
            } else if ($.isPlainObject(value)) {
                sanitizeDates(value);
            }
        }
    }

    $t.editing.initialize = function (grid) {
        $.extend(grid, this.implementation);
        var $element = $(grid.element);

        grid.modelBinder = new $t.grid.ModelBinder();

        grid.formViewBinder = new $t.grid.FormViewBinder({
            'date': function (name, value) {
                var column = grid.columnFromMember(name);
                var format = column ? column.format : '';
                return $t.formatString(format || '{0:G}', value);
            }
        });

        if (grid.isAjax()) {

            if (grid.editing.mode == 'InCell') {
                sanitizeDates(grid.editing.defaultDataItem || {});

                grid.changeLog = new $t.grid.ChangeLog(grid.pageSize || (grid.data && grid.data.length) || 0);

                $(grid.element).bind('dataBound', function () {
                    grid.changeLog.clear();
                });

                grid.cellEditor = new $t.grid.CellEditor(
                    {
                        columns: grid.columns,
                        cellIndex: function (td) { return td.index(); },
                        id: grid.formId(),
                        bind: $.proxy(grid.formViewBinder.bind, grid.formViewBinder),
                        validate: $.proxy(grid.validation, grid),
                        editing: grid.editing
                    }
                );

                $element.delegate('.t-grid-save-changes:not(.t-state-disabled)', 'click', $t.stopAll(function (e) {
                    grid.submitChanges();
                }));

                $element.delegate('.t-grid-cancel-changes', 'click', $t.stopAll(function (e) {
                    grid.cancelChanges();
                }));

                grid.hasChanges = function () {
                    return grid.changeLog.dirty();
                }

                grid.submitChanges = function () {
                    if (grid.changeLog.dirty()) {

                        var inserted = grid.changeLog.inserted;
                        var updated = $.grep(grid.changeLog.updated, function (value) { return value != undefined });
                        var deleted = $.grep(grid.changeLog.deleted, function (value) { return value != undefined });

                        if ($t.trigger(grid.element, 'submitChanges', {
                            inserted: inserted,
                            updated: updated,
                            deleted: deleted
                        })) {
                            return;
                        }

                        var serializedValues = grid.changeLog.serialize(inserted, updated, deleted);
                        var values = grid.ws ? {
                            inserted: $.map(inserted, function (value) { return grid._convert(value); }),
                            updated: $.map(updated, function (value) { return grid._convert(value); }),
                            deleted: $.map(deleted, function (value) { return grid._convert(value); })
                        } : serializedValues;

                        //grid.sendValues(values, 'updateUrl');

                        var jsonField = $("#" + grid.element.id + "___json");
                        if (jsonField.length > 0) {
                            var s = $.telerik.toJson(values);
                            jsonField[0].value = s;
                        }
                    }
                }

                grid.cancelChanges = function () {
                    grid.changeLog.clear();
                    grid.dataBind(grid.data.slice(0));
                    grid.valid = true;
                }

                grid.cellIndex = function (td) {
                    return $(td).parent().find('td:not(.t-group-cell,.t-hierarchy-cell)').index(td);
                }

                grid.rowIndex = function (tr) {
                    return $(tr).parent().find('tr:not(.t-detail-row,.t-grouping-row)').index(tr);
                }

                var dirtyIndicator;
                grid.valid = true;

                grid.editCell = function (td) {
                    var column = grid.columns[grid.cellIndex(td)];
                    if (grid.valid && (column && !column.readonly)) {
                        grid.td = td;

                        td = $(td);
                        var tr = td.parent();
                        var index = grid.rowIndex(tr);

                        var dataItem = grid.changeLog.get(index) || grid.dataItem(tr);

                        dirtyIndicator = td.find('.t-dirty');

                        grid.cellEditor.edit(td, dataItem);

                        $t.trigger(grid.element, 'edit', {
                            mode: tr.hasClass('t-grid-new-row') ? 'insert' : 'edit',
                            form: grid.form()[0],
                            dataItem: dataItem,
                            cell: td[0]
                        });
                    }
                }

                grid.saveCell = function (td) {
                    grid.valid = grid.validate();
                    if (grid.valid) {
                        td = $(td);
                        var tr = td.parent();
                        var dataItem = grid.dataItem(tr);

                        var values = unflatten(grid.modelBinder.bind(td));

                        var dirty = false;

                        if ($t.trigger(grid.element, 'save', { mode: tr.hasClass('t-grid-new-row') ? 'insert' : 'edit',
                            dataItem: dataItem,
                            values: values,
                            form: grid.form()[0],
                            cell: td[0]
                        })) {
                            return;
                        }

                        if (tr.hasClass('t-grid-new-row')) {
                            grid.changeLog.insert(grid.rowIndex(tr), values);
                        } else {

                            dirty = grid.changeLog.update(grid.rowIndex(tr), dataItem, values);
                        }

                        grid.cellEditor.display(td, values);
                        if (dirty || tr.hasClass('t-grid-new-row')) {
                            dirtyIndicator = $('<span class="t-dirty" />');
                        }

                        if (dirtyIndicator && dirtyIndicator.length) {
                            dirtyIndicator.prependTo(grid.td)
                        }

                        grid.td = null;
                        grid.submitChanges();
                    }
                }

                grid.td = null;
                grid.$tbody.delegate('td:not(.t-grid-edit-cell):not(.t-detail-cell)', grid.editing.beginEdit || 'dblclick', function (e) {
                    grid.editCell(this);
                });

                $(document).mousedown(function (e) {
                    if (grid.td && !$.contains(grid.td, e.target) && grid.td != e.target && !$(e.target).closest('.t-animation-container').length) {
                        grid.saveCell(grid.td);
                    }
                });
            } else {
                if (grid.editing.beginEdit) {
                    grid.$tbody.delegate('tr:not(.t-detail-row,.t-grouping-row,.t-grid-edit-row,.t-group-footer)', 'dblclick' || grid.editing.beginEdit, function (e) {
                        if (!$(e.target).is(':button,a,:input,a>.t-icon')) {
                            grid.editRow($(this), grid.editing.editRowMode == 'PopUp');
                        }
                    });
                }
                /*
                $(document).mousedown(function (e) {
                var editingRow = grid.$tbody.find('>.t-grid-edit-row');
                if (editingRow && editingRow.length && !$.contains(editingRow[0], e.target)) {
                insertOrUpdateRow(editingRow);
                }
                });
                */
            }
            $element.delegate('.t-grid-edit', 'click', $t.stopAll(function (e) {
                grid.editRow($(this).closest('tr'), grid.editing.editRowMode == 'PopUp' || grid.editing.editRowMode == 'PopUpAndTable');
            }))
            .delegate('.t-grid-delete', 'click', $t.stopAll(function (e) {
                grid.deleteRow($(this).closest('tr'), function (grid) {
                    $('#' + grid.jsonDataHiddenFieldId).valid();
                });
            }))
            .delegate('.t-grid-add', 'click', $t.stopAll(function (e) {
                grid.addRow(grid.editing.addRowMode == 'PopUp');
            }));
        } else {
            $element.delegate('.t-grid-delete', 'click', $t.stop(function (e) {
                if (grid.editing.confirmDelete !== false && !confirm(grid.localization.deleteConfirmation))
                    e.preventDefault();
            }));

            grid.validation();
        }

        grid.errorView = new $t.grid.ErrorView();

        var builder = new $t.grid.DataCellBuilder({ columns: grid.columns });

        var column = $.grep(grid.columns, function (c) {
            return c.commands && $.grep(c.commands, function (cmd) { return cmd.name == 'edit' })[0];
        })[0];

        var formContainerBuilder = new $t.grid.FormContainerBuilder({
            html: function () {
                return unescape(grid.editing.currentEditor);
            },
            insert: function () { return column.insert() },
            edit: function () { return column.edit() }
        });

        var editMode = grid.editing.mode;
        if (editMode == 'InLine') {
            grid.rowEditor = new $t.grid.Editor({
                id: grid.formId(),
                cancel: builder.display,
                edit: builder.edit,
                insert: builder.insert,
                groups: (grid.groups || []).length,
                details: grid.detail,
                editing: grid.editing
            });

            grid.popUpRowEditor = new $t.grid.PopUpEditor({
                id: grid.formId(),
                grid: grid,
                edit: formContainerBuilder.edit,
                editButtons: formContainerBuilder.editButtons,
                container: grid.element,
                settings: grid.editing.popup,
                insert: formContainerBuilder.insert,
                insertButtons: formContainerBuilder.insertButtons,
                editTitle: grid.localization.edit,
                insertTitle: grid.localization.insert
            });

        } else if (editMode == 'InForm') {
            grid.rowEditor = new $t.grid.Editor({
                id: grid.formId(),
                cancel: builder.display,
                groups: (grid.groups || []).length,
                details: grid.detail,
                edit: function () {
                    return '<td colspan="' + grid.columns.length + '">' +
                                formContainerBuilder.edit() +
                           '</td>';
                },
                insert: function () {
                    return '<td colspan="' + grid.columns.length + '">' +
                                formContainerBuilder.insert() +
                           '</td>';
                }
            });
        } else if (editMode == 'PopUp') {
            grid.rowEditor = new $t.grid.PopUpEditor({
                id: grid.formId(),
                grid: grid,
                edit: formContainerBuilder.edit,
                editButtons: formContainerBuilder.editButtons,
                container: grid.element,
                settings: grid.editing.popup,
                insert: formContainerBuilder.insert,
                insertButtons: formContainerBuilder.insertButtons,
                editTitle: grid.localization.edit,
                insertTitle: grid.localization.insert
            });
        } else {
            builder = new $t.grid.CellBuilder({ columns: grid.columns });

            grid.rowEditor = new $t.grid.Editor({
                id: grid.formId(),
                cancel: builder.display,
                edit: builder.edit,
                insert: builder.insert
            });
        }

        $element.delegate(':input:not(.t-button):not(textarea)', 'focus', function (e) {
            $(this).data("oldValue", $(this).val());
        });

        $element.delegate(':input:not(.t-button):not(textarea)', 'keydown', function (e) {
            if (e.keyCode == 27) {
                e.preventDefault();
                $(this).closest('tr.t-grid-edit-row').find('.t-grid-cancel').click();
            }
            if (e.keyCode == 13) {
                if ($(this).data("oldValue") == $(this).val()) {
                    e.preventDefault();
                    $(this).closest('tr.t-grid-edit-row').find('.t-grid-update, .t-grid-insert').click();
                } else {
                    $(this).data("onEnter", true);
                    $(this).blur().focus();
                }
            }
        });

        $element.delegate(':input:not(.t-button):not(textarea)', 'change', function (e) {
            if ($(this).data("onChange"))
                return;
            if ($(this).data("onEnter")) {
                $(this).data("onEnter", null);
                $(this).closest('tr.t-grid-edit-row').find('.t-grid-update, .t-grid-insert').click();
            }
        });
    }

    $t.editing.implementation = {
        editFor: function (column) {
            var localization = this.localization;
            if (column.commands) {
                var edit = $.grep(column.commands, function (column) { return column.name == 'edit' })[0];

                if (edit) {
                    var update = $t.grid.ButtonBuilder.create($.extend({ text: localization['saveChanges'] }, edit, { name: 'update', cssClasses: 'confirm' }));
                    var cancel = $t.grid.ButtonBuilder.create($.extend({ text: localization['cancel'] }, edit, { name: 'cancel' }));

                    var html = update.build() + cancel.build();

                    return function () {
                        return html;
                    };
                } else {
                    return function () { return '' };
                }
            } else if (column.editor) {
                return function () {
                    return unescape(column.editor);
                };
            }

            return this.displayFor(column);
        },

        insertFor: function (column) {
            var localization = this.localization;

            if (column.commands) {
                var edit = $.grep(column.commands, function (column) { return column.name == 'edit' })[0];

                if (edit) {
                    var insert = $t.grid.ButtonBuilder.create($.extend({ text: localization['saveChanges'] }, edit, { name: 'insert', cssClasses: 'confirm' }));
                    var cancel = $t.grid.ButtonBuilder.create($.extend({ text: localization['cancel'] }, edit, { name: 'cancel' }));

                    var html = insert.build() + cancel.build();

                    return function () {
                        return html;
                    };
                } else {
                    return function () { return '' };
                }
            } else {
                return this.editFor(column);
            }
        },

        insertOrUpdateRow: function ($tr, afterAjaxAction) {
            var updateContainer = $tr.data('updateRowContainer');
            if (updateContainer) {
                this.updateRow(updateContainer, afterAjaxAction);
            } else {
                var insertContainer = $tr.data('insertRowContainer');
                if (insertContainer) {
                    this.insertRow(insertContainer, afterAjaxAction);
                }
            }
        },

        insertRow: function ($tr, afterAjaxAction) {
            if (this.validate()) {
                //Удаляет поля помеченные class deleted 
                $("input.autocompliteValidateField").each(function () {
                    moveValidateRules(this.id);
                });
                $("input.validationMoveField").each(function () {
                    moveValidateRules(this.id);
                });
                //
                var values = this.extractValues($tr, this.form()[0]);

                if ($t.trigger(this.element, 'save', { mode: 'insert', values: values, form: this.form()[0] }))
                    return;

                this.sendValues(values, 'insertUrl', afterAjaxAction);
            }
        },

        updateRow: function ($tr, afterAjaxAction) {
            if (this.validate()) {
                //Удаляет поля помеченные class deleted 
                $("input.autocompliteValidateField").each(function () {
                    moveValidateRules(this.id);
                });
                $("input.validationMoveField").each(function () {
                    moveValidateRules(this.id);
                });

                var dataItem = this.dataItem($tr.data('tr') || $tr);
                var values = this.extractValues($tr, this.form()[0]);
                var childElement = $(this.form()[0]).children().first();
                if (childElement.is('div[type="dynamicForm"]')) {
                    childElement = childElement.children().first();
                }
                childElement.appendTo($(this.form()[0]).parent().first());
                $(this.form()[0]).remove();
                $(this.element).removeClass('validtionError');
                if ($t.trigger(this.element, 'save', { mode: 'edit', dataItem: dataItem, values: values, form: this.form()[0] }))
                    return;

                for (var dataKey in this.dataKeys) {
                    var value = this.valueFor({ member: dataKey })(dataItem);
                    if (value != undefined) {
                        values[this.dataKeys[dataKey]] = value;
                    }
                }
                this.sendValues(values, 'updateUrl', afterAjaxAction);
            }
        },

        getBindData: function (parentForm) {
            var arr = new Array();
            var jsonFieldName = $('#' + this.jsonDataHiddenFieldId).attr('name');
            if (jsonFieldName) {
                var lastIndex = jsonFieldName.lastIndexOf('.');
                if (lastIndex > 0) {
                    jsonFieldName = jsonFieldName.substring(0, lastIndex);
                    var targetJsonState = parentForm.find(':input[name=\'' + jsonFieldName + '.__jsonState\']');
                    var parentDynamicForm = targetJsonState.parent();
                    var modelPrefix = parentDynamicForm.find(':input[name=\'__DynamicFormSettings.HtmlPrefix\']').val();
                    arr.push(modelPrefix);
                    if (jsonFieldName == modelPrefix) {
                        jsonFieldName = null;
                    }
                } else {
                    jsonFieldName = null;
                }
            }
            arr.push(jsonFieldName);
            return arr;
        },

        deleteRow: function ($tr, afterAjaxAction) {
            var dataItem = this.dataItem($tr);

            if (this.editing.mode != 'InCell') {
                if ($t.trigger(this.element, 'delete', { dataItem: dataItem }))
                    return;

                if (this.editing.confirmDelete === false || confirm(this.localization.deleteConfirmation)) {
                    var model = {};
                    var parentForm = $(this.element).closest('form');
                    if (parentForm.length) {
                        var bindData = this.getBindData(parentForm);
                        var data = [];
                        elma.dynamicForms.bindFormData(data, $(parentForm), 'Parent.', bindData[1], bindData[0]);
                        for (var i in data) {
                            model[data[i].name] = data[i].value;
                        }
                        model["parentFormId"] = parentForm[0].id;
                    }
                    var dataKeyValues = {};
                    for (var dataKey in this.dataKeys) {
                        var value = this.valueFor({ member: dataKey })(dataItem);
                        dataKeyValues[this.dataKeys[dataKey]] = value;
                    }
                    var values = $.extend(dataKeyValues, model);
                    this.sendValues(values, 'deleteUrl', afterAjaxAction);
                }
            } else {
                if (this.editing.confirmDelete === false || confirm(this.localization.deleteConfirmation)) {
                    this.changeLog.erase(this.rowIndex($tr), dataItem);
                    this.cancelRow($tr);
                    $tr.hide();
                }
            }
        },

        addOrEditRow: function (dataItem, editInPopUp, afterAjaxFunc) {
            var values = {};
            if (!this.ws) {
                this._convert(values);
                for (var dataKey in this.dataKeys) {
                    var value = this.valueFor({ member: dataKey })(dataItem);
                    if (value != undefined) {
                        values["editingItem_" + (this.ws ? dataKey : this.dataKeys[dataKey])] = value;
                    }
                }
            }
            if (editInPopUp) {
                values["editInPopUp"] = true;
            }
            
            var parentForm = $(this.element).closest('form');
            if (parentForm.length) {
                var bindData = this.getBindData(parentForm);
                var data = [];
                elma.dynamicForms.bindFormData(data, $(parentForm), 'dataItem.Parent.', bindData[1], bindData[0]);
                for (var i in data) {
                    values[data[i].name] = data[i].value;
                }
                values["parentFormId"] = parentForm[0].id;
            }

            var grid = this;

            elma.openPleaseWait(true);
            $.ajax(this.ajaxOptions({
                data: this.ws ? { value: values} : values,
                url: this.url('selectUrl'),
                hasErrors: $.proxy(this.hasErrors, this),
                displayErrors: $.proxy(this.displayErrors, this),
                success: $.proxy(function (data, status, xhr) {
                    try {
                        data = eval('(' + data + ')');
                    } catch (e) {
                        // in case the result is not JSON raise the 'error' event
                        if (!$t.ajaxError(this.element, 'error', xhr, 'parseeror'))
                            alert('Error! The requested URL did not return JSON.');
                        elma.closePleaseWait(true);
                        return;
                    }

                    if (data && data.editingData) {
                        for (var i = 0; i < grid.columns.length; i++) {
                            var column = grid.columns[i];
                            var editingTemplate = data.editingData[column.member];
                            if (!!data.dynamicFormResult) {
                                for (var j = 0; j < data.dynamicFormResult.Properties.length; j++) {
                                    if (data.dynamicFormResult.Properties[j].Caption === column.member) {
                                        editingTemplate = data.dynamicFormResult.Properties[j].Value;
                                    }
                                }
                            }
                            if (editingTemplate) {
                                if (!column.newEditor) {
                                    column.newEditor = column.editor;
                                }
                                column.editor = editingTemplate;
                                if (data.editingDataHidden) {
                                    column.hidden = data.editingDataHidden[column.member];
                                }
                            }
                        }
                    }

                    insertOrUpdateAll(grid);

                    if (!!data.validationMetadata) {
                        grid.validationMetadata = data.validationMetadata;
                    }
                    if (!!data.editingFormContent) {
                        grid.editing.formContent = data.editingFormContent;
                    }

                    grid.data = [];
                    Array.prototype.push.apply(grid.data, data.data || data.Data);

                    if (editInPopUp && grid.popUpRowEditor) {
                        grid.editing.currentEditor = data.editingRowForm;
                    }

                    grid.currentRowEditor =
                            editInPopUp && grid.popUpRowEditor
                            ? grid.popUpRowEditor
                            : grid.rowEditor;

                    elma.closePleaseWait(true);

                    if (afterAjaxFunc) {
                        afterAjaxFunc(grid, data);
                    }
                })
            }));
        },

        editRow: function ($tr, editInPopUp) {
            var dataItem = this.dataItem($tr);

            if (!dataItem && dataItem == undefined) {
                return;
            }

            if (this.editing.mode != 'InCell') {

                var editingRow = this.$tbody.find('>.t-grid-edit-row');
                if (editingRow && editingRow.length) {
                    // Save editing row
                    var dataItem = this.dataItem($tr);
                    var dataKeyValues = {};
                    for (var dataKey in this.dataKeys) {
                        var value = this.valueFor({ member: dataKey })(dataItem);
                        dataKeyValues[this.dataKeys[dataKey]] = value;
                    }
                    this.insertOrUpdateRow(editingRow, function (grid) {
                        // Select the same row and edit it
                        var newTrs = grid.$tbody.find('tr:not(.t-detail-row,.t-grouping-row,.t-grid-edit-row,.t-group-footer)');
                        for (var i = 0; i < newTrs.length; i++) {
                            var newDataItem = grid.dataItem(newTrs[i]);
                            var successedTr = true;
                            for (var dataKey in grid.dataKeys) {
                                var value = grid.valueFor({ member: dataKey })(newDataItem);
                                if (value != dataKeyValues[grid.dataKeys[dataKey]]) {
                                    successedTr = false;
                                    break;
                                }
                            }
                            if (successedTr) {
                                grid.editRow($(newTrs[i]), editInPopUp);
                                return;
                            }
                        }
                    });
                    return;
                }

                this.addOrEditRow(dataItem, editInPopUp, function (grid, data) {
                    elma.onAjaxStart(); //required for validation recreate

                    dataItem['prefix'] = data.prefix;
                    var container = grid.currentRowEditor.edit($tr, dataItem);

                    $tr.data('updateRowContainer', container);

                    var form = grid.form();

                    if (data.dynamicFormResult != null) {
                        elma.dynamicForms.renderNotifyMessages(form, data.dynamicFormResult.NotifyMessages);
                    }

                    form.parent()
                            .undelegate('.t-grid-update', 'click')
                            .delegate('.t-grid-update', 'click', $t.stopAll($.proxy(function () {
                                grid.updateRow(container, function (grid) {
                                    $('#' + grid.jsonDataHiddenFieldId).valid();
                                });
                            }, grid)))
                            .undelegate('.t-grid-cancel', 'click')
                            .delegate('.t-grid-cancel', 'click', $t.stopAll($.proxy(function () {
                                grid.cancelRow($tr);
                                $('#' + grid.jsonDataHiddenFieldId).valid();
                            }, grid)));

                    //this.formViewBinder.bind(container, dataItem);

                    $t.trigger(grid.element, 'edit', {
                        mode: 'edit',
                        form: form[0],
                        dataItem: dataItem
                    });

                    grid.validation();

                    elma.onAjaxStop(); //required for validation recreate
                });

            } else {
                if (this.valid) {
                    this.rowEditor.edit($tr, dataItem);
                    this.td = row.find(':input:visible:first').focus().closest('td')[0];
                    this.validation();
                }
            }
        },

        form: function () {
            return $('#' + this.formId());
        },

        addRow: function (editInPopUp) {
            var dataItem = $.extend(true, {}, this.editing.defaultDataItem);

            if (this.editing.mode != 'InCell') {

                var editingRow = this.$tbody.find('>.t-grid-edit-row');
                if (editingRow && editingRow.length) {
                    // Save editing row
                    this.insertOrUpdateRow(editingRow, function (grid) {
                        grid.addRow(editInPopUp);
                    });
                    return;
                }

                this.addOrEditRow(dataItem, editInPopUp, function (grid, data) {
                    elma.onAjaxStart(); //required for validation recreate

                    dataItem['prefix'] = data.prefix;
                    var container = grid.currentRowEditor.insert(grid.$tbody, dataItem);

                    container.data('insertRowContainer', container);

                    var form = grid.form();

                    form.parent()
                        .undelegate('.t-grid-insert', 'click')
                        .delegate('.t-grid-insert', 'click', $t.stopAll($.proxy(function () {
                            grid.insertRow(container, function (grid) {
                                $('#' + grid.jsonDataHiddenFieldId).valid();
                            });
                        }, grid)))
                        .undelegate('.t-grid-cancel', 'click')
                        .delegate('.t-grid-cancel', 'click', $t.stopAll($.proxy(function () {
                            grid.cancelRow(container);
                            $('#' + grid.jsonDataHiddenFieldId).valid();
                        }, grid)));

                    $t.trigger(grid.element, 'edit', {
                        mode: 'insert',
                        form: form[0]
                    });

                    grid.validation();

                    elma.onAjaxStop(); //required for validation recreate
                });

                /*
                insertOrUpdateAll(this);

                for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                if (column.newEditor) {
                column.editor = column.newEditor;
                }
                }

                if (editInPopUp && this.popUpRowEditor) {
                this.editing.currentEditor = this.editing.editor;
                }

                this.currentRowEditor =
                editInPopUp && this.popUpRowEditor
                ? this.popUpRowEditor
                : this.rowEditor;

                var container = this.currentRowEditor.insert(this.$tbody, dataItem);

                container.data('insertRowContainer', container);

                var form = this.form();

                form.parent()
                .undelegate('.t-grid-insert', 'click')
                .delegate('.t-grid-insert', 'click', $t.stopAll($.proxy(function () {
                this.insertRow(container);
                }, this)))
                .undelegate('.t-grid-cancel', 'click')
                .delegate('.t-grid-cancel', 'click', $t.stopAll($.proxy(function () {
                this.cancelRow(container);
                }, this)));

                $t.trigger(this.element, 'edit', {
                mode: 'insert',
                form: form[0]
                });

                this.validation();
                */
            } else {
                if (this.valid) {

                    var row = this.rowEditor.insert(this.$tbody, dataItem);
                    this.changeLog.insert(dataItem);

                    this.td = row.find(':input:enabled:visible:first').focus().closest('td')[0];
                    for (var i = this.columns.length - 1; i >= 0; i--) {
                        if (!this.columns[i].readonly) {
                            var cell = row.children().eq(i);
                            if (cell[0] != this.td) {
                                cell.prepend('<span class="t-dirty" />');
                            }
                        }
                    }

                    this.validation();
                }
            }
        },

        extractValues: function ($tr, form) {
            return this.modelBinder.bind($tr, form);
        },

        cancelRow: function ($tr) {
            if (!$tr.length)
                return;

            var dataItem = this.dataItem($tr);
            (this.currentRowEditor ? this.currentRowEditor : this.rowEditor).cancel($tr, dataItem);
            var childElement = $(this.form()[0]).children().first();
            if (childElement.is('div[type="dynamicForm"]')) {
                childElement = childElement.children().first();
            }
            childElement.appendTo($(this.form()[0]).parent().first());
            $(this.form()[0]).remove();
            $(this.element).removeClass('validtionError');

            $t.trigger(this.element, 'rowDataBound', { row: $tr[0], dataItem: dataItem });
        },

        validate: function () {
            var form = this.form();
            if (form.length) {
                return form.validate().form();
            }
            return true;
        },

        cancel: function () {
            this.cancelRow(this.$tbody.find('>.t-grid-edit-row'));
        },

        insertOrUpdate: function () {
            this.insertOrUpdateRow(this.$tbody.find('>.t-grid-edit-row'));
        },

        _convert: function (values) {
            for (var key in values) {
                var value = values[key];
                if (value instanceof Date) {
                    var column = this.columnFromMember(key);
                    var format = '{0:G}';

                    if (column && column.format)
                        format = column.format;

                    values[key] = this.ws ? '\\/Date(' + value.getTime() + ')\\/' : $t.formatString(format, value);
                }
                if (value == undefined) {
                    delete values[key];
                }
            }
            return values;
        },

        sendValues: function (values, url, afterAjaxAction) {
            if (this.editing.mode != 'InCell' || !this.ws) {
                this._convert(values);

                for (var dataKey in this.dataKeys) {
                    var value = this.valueFor({ member: dataKey })(values);
                    if (value != undefined) {
                        values[this.ws ? dataKey : this.dataKeys[dataKey]] = value;
                    }
                }
            }

            var prefixedValues = {};
            for (name in values) {
                prefixedValues["dataItem." + name] = values[name];
            }
            var ajaxOptions = this.ajaxOptions({
                data: this.ws ? (this.editing.mode == 'InCell' ? prefixedValues : { value: prefixedValues }) : prefixedValues,
                afterAjaxAction: afterAjaxAction,
                url: this.url(url),
                hasErrors: $.proxy(this.hasErrors, this),
                displayErrors: $.proxy(this.displayErrors, this)
            });
            elma.openPleaseWait(true);
            var success = ajaxOptions.success;
            $.extend(ajaxOptions, {
                success: $.proxy(function (data, status, xhr) {
                    elma.closePleaseWait(true);
                    success(data, status, xhr);
                })
            });
            $.ajax(ajaxOptions);
        },

        displayErrors: function (data) {
            this.errorView.bind($('#' + this.formId()), data.modelState);
        },

        hasErrors: function (data) {
            var modelState = data.modelState;
            var result = false;

            if (modelState) {
                $.each(modelState, function (key, value) {
                    if ('errors' in value) {
                        result = true;
                        return false;
                    }
                });
            }

            return result;
        },

        formId: function () {
            return $(this.element).attr('id') + 'form';
        },

        validation: function () {
            this.validator().parse();
        },

        validator: function () {
            if (this.validationMetadata) {
                return new Mvc2Validator(this.validationMetadata);
            } else {
                return new UnobtrusiveValidator($("#" + this.formId()));
            }
        }
    }

    $t.grid.ModelBinder = function () {
        this.binders = {
            ':input:not(.t-input):not(:radio),:radio:checked': function () {
                return $(this).val();
            },
            ':checkbox': function () {
                return $(this).is(':checked');
            },
            '.t-datepicker :input': function () {
                return $(this).data('tDatePicker')
                              .value();
            },
            '.t-numerictextbox :input': function () {
                return $(this).val(); //.data('tTextBox').value();
            },
            '.t-editor textarea:hidden': function () {
                var editor = $(this).closest(".t-editor")
                                    .data("tEditor");
                if (editor.encoded) {
                    return editor.encodedValue();
                }
                return editor.value();
            }
        };

        this.bind = function ($ui, form) {
            /*
            $.each(this.binders, function (selector, callback) {
            $ui.find(selector).each(function () {
            if (!this.disabled) model[this.name] = callback.call(this);
            });
            });*/

            var data = elma.serializeFormToArray(form);
            elma.dynamicForms.bindParentFormData(data, $(form), '');

            var model = {};
            for (var i in data) {
                var name = data[i].name;
                if (!model[name] || model[name] != 'true') {
                    model[name] = data[i].value;
                }
            }

            return model;
        }
    }

    $t.grid.FormViewBinder = function (converters) {
        this.converters = converters || {};
        this.binders = {
            ':input:not(:radio)': function (value) {
                $(this).val(value);
            },
            ':checkbox': function (value) {
                $(this).attr('checked', value == true)
            },
            ':radio': function (value) {
                var input = $(this).val();
                if (typeof value == 'boolean') {
                    input = input.toLowerCase();
                }
                if (input == value.toString()) {
                    $(this).attr('checked', true);
                }
            }
        };

        function evaluator(type) {
            return function (value) {
                $(this).data(type)
                       .value(value);
            };
        }

        function editorEvaluator() {
            return function (value) {
                $(this).closest(".t-editor")
                       .data("tEditor")
                       .value(value);
            };
        }

        this.binders['.t-numerictextbox :input'] = evaluator('tTextBox');
        this.binders['.t-dropdown :input:hidden'] = evaluator('tDropDownList');
        this.binders['.t-combobox :input:hidden'] = evaluator('tComboBox');
        this.binders['.t-editor textarea:hidden'] = editorEvaluator();

        this.evaluate = function (model, expression) {
            if (expression != null) {
                var value = model, match = false, members = expression.split('.');

                while (members.length) {
                    var member = members.shift();
                    if (value != null && typeof (value[member]) != 'undefined') {
                        value = value[member];
                        match = true;
                    } else if (match) {
                        match = false;
                        break;
                    }
                }

                if (match && !$.isPlainObject(value)) {
                    var date = dateRe.exec(value);
                    if (date)
                        value = new Date(parseInt(date[1]));

                    var type = $t.getType(value);

                    if (type in this.converters)
                        value = this.converters[type](expression, value);

                    return value;
                }
            }
        }

        this.bind = function ($ui, model) {
            var undefined;

            $.each(this.binders, $.proxy(function (selector, callback) {
                $ui.find(selector).each($.proxy(function (index, element) {
                    var value = this.evaluate(model, element.name);
                    if (value != undefined)
                        callback.call(element, value);
                }, this));
            }, this));
        }
    }

    $t.grid.CellBuilder = function (options) {
        function impl(dataItem, method) {
            return $.map(options.columns, function (column, index) {
                return '<td ' + (column.attr ? column.attr : '') + (index == options.columns.length - 1 ? ' class="t-last">' : '>') +
                            column[index == 0 ? method : 'display'](dataItem) +
                       '</td>';
            }).join('');
        }

        this.edit = function (dataItem) {
            return impl(dataItem, 'edit');
        }

        this.insert = function (dataItem) {
            return impl(dataItem, 'insert');
        }

        this.display = function (dataItem) {
            return impl(dataItem, 'display');
        }
    }

    $t.grid.DataCellBuilder = function (options) {

        function impl(dataItem, method, writeId) {
            return $.map(options.columns, function (column, index) {
                var writeValueContainer = writeId && !!column.member;
                return '<td ' + (column.attr ? column.attr : '') +
                        (index == options.columns.length - 1 ? ' class="t-last">' : '>') +
                        (writeValueContainer ? '<div id="' + elma.createSanitizedId(dataItem['prefix'] + '_' + column.member, "_") + '_ValueContainer"' + (column.hidden ? ' style="display:none;"' : '') + '>' : '') +
                            column[method](dataItem) +
                        (writeValueContainer ? '</div>' : '') +
                       '</td>';
            }).join('');
        }

        this.edit = function (dataItem) {
            return impl(dataItem, 'edit', true);
        }

        this.insert = function (dataItem) {
            return impl(dataItem, 'insert', true);
        }

        this.display = function (dataItem) {
            return impl(dataItem, 'display');
        }
    }

    $t.grid.FormContainerBuilder = function (options) {
        function impl(method) {
            return '<div class="t-edit-form-container"><div type="dynamicForm">' +
                        options.html() +
                   '</div></div>';
        }

        function implButtons(method) {
            return '<div class="popup-buttons t-edit-form-buttons">' +
                        options[method]() +
                   '</div>';
        }

        this.edit = function () {
            return impl('edit');
        }

        this.editButtons = function () {
            return implButtons('edit');
        }

        this.insert = function () {
            return impl('insert');
        }

        this.insertButtons = function () {
            return implButtons('insert');
        }
    }

    function form(id, options, editMode) {
        var existingForm = $('#' + id);
        if (existingForm.length) {
            var childElement = existingForm.children(":first-child");
            if (childElement.is('div[type="dynamicForm"]')) {
                childElement.unwrap();
                childElement = childElement.children(":first-child");
            }
            childElement.unwrap();
            var formContentId = id + '_FormContent';
            var formContentDiv = $('#' + formContentId);
            if (formContentDiv.length) {
                formContentDiv.remove();
            }
        }
        var form = $('<form />', { className: 't-edit-form', id: id }).submit($t.preventDefault);
        form.data('EditMode', editMode);
        return form;
    }

    function addFormContent(parent, formId, options, dataItem) {
        if (!!options.editing && !!options.editing.formContent) {
            var id = formId + '_FormContent';
            var existingDiv = $('#' + id);
            if (existingDiv.length) {
                existingDiv.remove();
            }
            var identifierInput = '<input name="' + dataItem['prefix'] + '.Id" type="hidden" value="' + dataItem['Id'] + '" />\r\n';
            var div = $('<div id="' + id + '">' + identifierInput + options.editing.formContent + '</div>');
            parent.append(div);
        }
    }

    function renderDynamicForm() {
         return $('<div />', { type: 'dynamicForm' });
    }

    $t.grid.PopUpEditor = function (options) {

        var wnd;

        function destroy() {
            var w = wnd.data('tWindow');
            w && w.close();
            wnd.remove();
        }

        function impl(dataItem, method, tr) {
            var settings = {
                modal: true,
                resizable: false,
                draggable: true
            };
            settings = $.extend(settings, options.settings);

            var wndId = options.container.id + 'PopUp';
            if ($('#' + wndId).length > 0) {
                $('#' + wndId).remove();
            }

            wnd = $('<div />', { id: wndId })
                .tWindow(settings)
                .find('.t-window-content')
                .append(options[method](dataItem))
                .wrapInner(form(options.id, options, 'PopUp'));

            wnd.find("form").AddAntiForgeryToken();

            var element = $('#' + wndId);
            var top = $(window).scrollTop() + ($(window).height() - element.height()) / 2;
            var leftreal = ($(window).width() - 800) / 2;
            element.css({
                left: leftreal + "px",
                top: top < 0 ? 1 : top,
                marginLeft: 0, width: "850px"
            });

            if (!!options[method + 'Buttons']) {
                wnd = wnd
                    .append(options[method + 'Buttons'](dataItem));
            }

            wnd = wnd
                    .end();

            $(options.container).one('dataBound', destroy);

            wnd.find('.t-close')
               .bind('click', function () { options.grid.cancelRow(tr) })
               .end()
               .data('tWindow')
               .open()
               .title(options[method + 'Title']);

            return wnd;
        }

        this.edit = function (tr, dataItem) {
            tr.addClass('t-grid-edit-row');
            return impl(dataItem, 'edit', tr).data('tr', tr);
        }

        this.insert = function (tr, dataItem) {
            return impl(dataItem, 'insert', tr);
        }

        this.cancel = function (tr) {
            tr.removeClass('t-grid-edit-row');
            destroy();
        }
    }

    $t.grid.Editor = function (options) {
        var groupsCount = (options.groups || 0);

        function impl(tr, dataItem, method) {
            var td = tr.find('.t-group-cell,.t-hierarchy-cell');
            var table = tr.addClass('t-grid-edit-row')
              .empty()
              .append(td)
              .append(options[method](dataItem))
              .closest('table')
              .wrap(function () {
                  if (!$(this).parent().is('form')) {
                      return form(options.id, options, 'InLine');
                  }
              })
              .wrap(function () {
                  return renderDynamicForm();
                });

              addFormContent(table.parent(), options.id, options, dataItem);
        }

        this.cancel = function (tr, dataItem) {
            if (tr.is('.t-grid-new-row')) {
                tr.remove();
            } else {
                impl(tr, dataItem, 'cancel');
                tr.removeClass('t-grid-edit-row');
            }
        }

        this.insert = function (container, dataItem) {
            var html = '<tr class="t-grid-new-row">' +
                       new Array(groupsCount + 1).join('<td class="t-group-cell" />') +
                       ((options.details) ? '<td class="t-hierarchy-cell"/>' : "") +
                       '</tr>';
            var tr = $(html);

            container.prepend(tr);

            impl(tr, dataItem, 'insert');

            return tr;
        }

        this.edit = function (tr, dataItem) {
            impl(tr, dataItem, 'edit');
            return tr;
        }

    }

    $t.grid.CellEditor = function (options) {

        this.edit = function (td, dataItem) {
            var column = options.columns[options.cellIndex(td)];

            if (!column.readonly) {
                td.parent()
                  .addClass('t-grid-edit-row')
                  .end()
                  .empty()
                  .html(column.edit(dataItem))
                  .closest('table')
                  .wrap(function () {
                      if (!$(this).parent().is('form'))
                          return form(options.id, options, 'InCell');
                  });

                options.bind(td, dataItem);

                options.validate();

                td.find(':input:visible:first')
                  .trigger("focusin")
                  .focus();

                td.addClass('t-grid-edit-cell');
            }

            return !column.readonly;
        }

        this.display = function (td, dataItem) {
            var column = options.columns[options.cellIndex(td)];

            td.removeClass('t-grid-edit-cell')
              .empty()
              .html(column.display(dataItem))
              .parent()
              .removeClass('t-grid-edit-row');
        }
    }

    $t.grid.ChangeLog = function (size) {

        this.insert = function (index, values) {
            if (values == undefined) {
                values = index;
                this.inserted.splice(0, 0, values);
            } else {
                var original = this.inserted[index];

                if (original === undefined) {
                    this.inserted.splice(0, 0, values);
                } else {
                    $.extend(original, values);
                }
            }
        }

        this.get = function (index) {
            var inserted = this.inserted[index];

            if (this.inserted[index]) {
                return inserted;
            }

            return this.updated[index - this.inserted.length];
        }

        this.update = function (index, original, values) {
            index = index - this.inserted.length;

            var last = this.updated[index] || original || {};

            var dirty = false;

            for (var member in values) {
                var sourceValue = last[member],
                    destValue = values[member];

                if (sourceValue instanceof Date) {
                    if (destValue.getTime() !== sourceValue.getTime()) {
                        dirty = true;
                    }
                } else if (destValue !== sourceValue) {
                    dirty = true;
                }
            }

            if (dirty) {
                this.updated[index] = $.extend({}, last, values);
            }

            return dirty;
        }

        this.erase = function (index, values) {
            var inserted = this.inserted[index];

            if (inserted) {
                this.inserted.splice(index, 1);
            } else {
                index = index - this.inserted.length;

                var updated = this.updated[index];
                if (updated) {
                    delete this.updated[index];
                }

                this.deleted[index] = values;
            }
        }

        this.clear = function () {
            this.updated = new Array(size);
            this.deleted = new Array(size);
            this.inserted = [];
        }

        function serialize(data, prefix, predicate) {

            var result = {};

            for (var sourceIndex = 0, destinationIndex = 0; sourceIndex < data.length; sourceIndex++) {
                var dataItem = data[sourceIndex];

                if (predicate(dataItem)) {
                    for (var member in dataItem) {
                        var value = dataItem[member],
                            key = prefix + '[' + destinationIndex + '].' + member;



                        if ($.isPlainObject(value)) {
                            flatten(result, value, key);
                        } else {
                            result[key] = value;
                        }
                    }
                    destinationIndex++;
                }
            }

            return result;
        }

        this.serialize = function (inserted, updated, deleted) {
            return $.extend({},
                serialize(inserted, 'inserted', function () {
                    return true;
                }),
                serialize(updated, 'updated', function (dataItem) {
                    return dataItem !== undefined;
                }),
                serialize(deleted, 'deleted', function (dataItem) {
                    return dataItem !== undefined;
                })
            );
        }

        this.dirty = function () {

            if (this.inserted.length) {
                return true;
            }

            for (var i = 0; i < this.updated.length; i++) {
                if (this.updated[i]) {
                    return true;
                }
            }

            for (i = 0; i < this.deleted.length; i++) {
                if (this.deleted[i]) {
                    return true;
                }
            }

            return false;
        }

        this.clear();
    }

    $t.grid.ErrorView = function () {
        this.bind = function ($ui, modelState) {
            $ui.find('span[id$=_validationMessage]')
               .removeClass('field-validation-error')
               .addClass('field-validation-valid')
               .html('')
               .end()
               .find('.input-validation-error')
               .removeClass('input-validation-error')
               .addClass('valid');

            $.each(modelState, function (key, value) {
                if ('errors' in value && value.errors[0]) {
                    var originalKey = key;
                    key = key.replace('.', '_');
                    $ui.find('#' + key + '_validationMessage, [data-valmsg-for="' + originalKey + '"]')
                       .html(value.errors[0])
                       .removeClass('field-validation-valid')
                       .removeClass('field-valiion-valid')
                       .addClass('field-validation-error')
                       .end()
                       .find('#' + key)
                       .removeClass('valid')
                       .addClass('input-validation-error');
                }
            });
        }
    }
})(jQuery);



(function ($) {
    var $t = $.telerik;
    var escapeQuoteRegExp = /'/ig;
    var fx = $t.fx.slide.defaults();

    function getFormat(column) {
        if (!column.format)
            return $t.cultureInfo.shortDate;

        return /\{0(:([^\}]+))?\}/.exec(column.format)[2];
    }

    function value(column, value) {
        if (column.type == 'Date')
            return $t.formatString(column.format || '{0:G}', new Date(parseInt(value.replace(/\/Date\((.*?)\)\//, '$1'))));

        return value;
    }

    $t.filtering = {};

    $t.filtering.initialize = function (grid) {
        $.extend(grid, $t.filtering.implementation);

        grid.filterBy = grid.filterExpr();

        $('> .t-grid-content', grid.element).bind('scroll', function () {
            grid.hideFilter();
        });

        $(document).click(function (e) {
            if (e.which != 3) grid.hideFilter();
        });

        grid.$header.find('.t-grid-filter').click($.proxy(grid.showFilter, grid))
            .hover(function () {
                $(this).toggleClass('t-state-hover');
            });
    }

    /* Here `this` is the Grid instance*/

    $t.filtering.implementation = {
        createFilterCommands: function (html, column) {
            var filters = {};

            $.each(this.localization, function (key, value) {
                var prefix = 'filter' + column.type;
                var index = key.indexOf(prefix);
                if (index > -1)
                    filters[key.substring(index + prefix.length).toLowerCase()] = value;
            });

            html.cat('<select class="t-filter-operator">');
            $.each(filters, function (key, value) {
                html.cat('<option value="')
					.cat(key)
					.cat('">')
					.cat(value)
					.cat('</option>');
            });

            html.cat('</select>');
        },

        createTypeSpecificInput: function (html, column, fieldId, value) {
            if (column.type == 'Date') {
                html.cat('<div class="t-widget t-datepicker"><div class="t-picker-wrap">')
	                .cat('<input class="t-input" id="').cat(fieldId).cat('" type="text" value="" />')
	                .cat('<span class="t-select"><label class="t-icon t-icon-calendar" for="')
	                .cat(fieldId)
	                .cat('" title="').cat(this.localization.filterOpenPopupHint).cat('" /></span></div></div>');
            } else if (column.type == 'Boolean') {
                html.cat('<div><input type="radio" style="width:auto;display:inline" id="').cat(fieldId + value)
				    .cat('" name="').cat(fieldId)
				    .cat('" value="').cat(value).cat('" />')
				    .cat('<label style="display:inline" for="').cat(fieldId + value).cat('">')
                    .cat(this.localization[value ? 'filterBoolIsTrue' : 'filterBoolIsFalse'])
				    .cat('</label></div>');
            } else if (column.type == 'Enum') {
                html.cat('<div><select><option>')
                    .cat(this.localization.filterSelectValue)
                    .cat('</option>');
                $.each(column.values, function (key, value) {
                    html.cat('<option value="')
                        .cat(value)
                        .cat('">')
                        .cat(key)
                        .cat('</option>');
                });
                html.cat('</select></div>');
            } else if (column.type == 'Number') {
                html.cat('<div class="t-widget t-numerictextbox">')
	                .cat('<input class="t-input" name="')
	                .cat(fieldId)
	                .cat('" id="')
	                .cat(fieldId)
	                .cat('" type="text" value=""/>')
	                .cat('</div>');
            } else {
                html.cat('<input type="text" />');
            }
        },

        createFilterMenu: function (column) {
            var filterMenuHtml = new $t.stringBuilder();

            filterMenuHtml.cat('<div class="t-animation-container"><div class="t-filter-options t-group" style="display:none">')
					.cat('<button class="t-button t-button-icontext t-clear-button"><span class="t-icon t-clear-filter"></span>')
					.cat(this.localization.filterClear)
					.cat('</button><div class="t-filter-help-text">')
					.cat(this.localization.filterShowRows)
					.cat('</div>');

            var fieldIdPrefix = $(this.element).attr('id') + column.member;

            if (column.type == 'Boolean') {
                this.createTypeSpecificInput(filterMenuHtml, column, fieldIdPrefix, true);
                this.createTypeSpecificInput(filterMenuHtml, column, fieldIdPrefix, false);
            } else {
                this.createFilterCommands(filterMenuHtml, column);
                this.createTypeSpecificInput(filterMenuHtml, column, fieldIdPrefix + 'first');
                filterMenuHtml.cat('<div class="t-filter-help-text">')
                              .cat(this.localization.filterAnd)
                              .cat('</div>');
                this.createFilterCommands(filterMenuHtml, column);
                this.createTypeSpecificInput(filterMenuHtml, column, fieldIdPrefix + 'second');
            }

            filterMenuHtml.cat('<button class="t-button t-button-icontext t-filter-button"><span class="t-icon t-filter"></span>')
                          .cat(this.localization.filter)
				          .cat('</button></div></div>');

            var $filterMenu = $(filterMenuHtml.string());

            $.each(column.filters || [], function (i) {
                $filterMenu.find('.t-filter-operator:eq(' + i + ')')
                           .val(this.operator)
                           .end()
                           .find(':text:eq(' + i + '),select:not(.t-filter-operator):eq(' + i + ')')
                           .val(value(column, this.value));

                if (column.type == 'Boolean')
                    $filterMenu.find(':radio[id$=' + this.value + ']')
                               .attr('checked', true);
            });

            return $filterMenu
                        .find('.t-datepicker .t-input')
                        .each(function () {
                            $(this).tDatePicker({ format: getFormat(column) });
                        })
                        .end()
                        .find('.t-numerictextbox .t-input')
                        .each(function () {
                            $(this).tTextBox({ type: 'numeric', minValue: null, maxValue: null, numFormat: '', groupSeparator: '' });
                        })
                        .end()
                        .appendTo(this.element);
        },

        showFilter: function (e) {
            e.stopPropagation();

            var $element = $(e.target).closest('.t-grid-filter');

            this.hideFilter(function () {
                return this.parentNode != $element[0];
            });

            var $filterMenu = $element.data('filter');

            if (!$filterMenu) {
                // filtering menu should be created
                var column = this.columns[this.$columns().index($element.parent())];

                $filterMenu = this.createFilterMenu(column)
                        .data('column', column)
                        .click(function (e) {
                            e.stopPropagation();

                            if ($(e.target).parents('.t-datepicker').length == 0) {
                                $('.t-datepicker .t-input', this)
                                    .each(function () {
                                        $(this).data('tDatePicker').hidePopup();
                                    });
                            }
                        })
                        .find('.t-filter-button').click($.proxy(this.filterClick, this)).end()
                        .find('.t-clear-button').click($.proxy(this.clearClick, this)).end()
                        .find('input[type=text]').keyup($.proxy(function (e) {
                            if (e.keyCode == 13) this.filterClick(e);
                        }, this)).end();

                $element.data('filter', $filterMenu);
            }

            // position filtering menu
            var top = 0;

            $(this.element).find('> .t-grouping-header, > .t-grid-toolbar').add(this.$header).each(function () {
                top += this.offsetHeight;
            });

            var position = { top: top };

            var width = -this.$headerWrap.scrollLeft() - 1;

            $element.parent().add($element.parent().prevAll('th')).each(function () {
                if ($(this).css('display') != 'none')
                    width += this.offsetWidth;
            });

            var left = width - $element.outerWidth();

            // constrain filtering menu within grid
            var outerWidth = $filterMenu.outerWidth() || $filterMenu.find('.t-group').outerWidth();

            if (left + outerWidth > this.$header.outerWidth())
                left = width - outerWidth + 1;

            if ($(this.element).closest('.t-rtl').length)
                position['right'] = left + ($.browser.mozilla || $.browser.safari ? 18 : 0);
            else
                position['left'] = left;

            $filterMenu.css(position);

            $t.fx[$filterMenu.find('.t-filter-options').is(':visible') ? 'rewind' : 'play'](fx, $filterMenu.find('.t-filter-options'), { direction: 'bottom' });
        },

        hideFilter: function (filterCallback) {
            filterCallback = filterCallback || function () { return true; };

            $('.t-grid .t-animation-container')
                .find('.t-datepicker .t-input')
                .each(function () { $(this).data('tDatePicker').hidePopup(); })
                .end()
                .find('.t-filter-options')
                .filter(filterCallback)
                .each(function () {
                    $t.fx.rewind(fx, $(this), { direction: 'bottom' });
                });
        },

        clearClick: function (e) {
            e.preventDefault();
            var $element = $(e.target);
            var column = $element.closest('.t-animation-container').data('column');
            column.filters = null;

            $element.parent()
                .find('input')
                .removeAttr('checked')
                .removeClass('t-state-error')
                .not(':radio')
                .val('')
                .end()
                .end()
                .find('select')
                .removeClass('t-state-error')
                .find('option:first')
                .attr('selected', 'selected');

            this.filter(this.filterExpr());
        },

        filterClick: function (e) {
            e.preventDefault();
            var $element = $(e.target);
            var column = $element.closest('.t-animation-container').data('column');
            column.filters = [];
            var hasErrors = false;

            $element.closest(".t-filter-options").find('input[type=text]:visible,select:not(.t-filter-operator)').each($.proxy(function (index, input) {
                var $input = $(input);
                var value = $.trim($input.val());

                if (!value) {
                    $input.removeClass('t-state-error');
                    return true;
                }

                var valid = this.isValidFilterValue(column, value);

                $input.toggleClass('t-state-error', !valid);

                if (!valid) {
                    hasErrors = true;
                    return true;
                }

                var operator = $input.prev('select').val() || $input.parent().prev('select').val() || $input.parent().parent().prev('select').val();
                if (value != this.localization.filterSelectValue)
                    column.filters.push({ operator: operator, value: value });
            }, this));

            $element.parent().find('input:checked').each($.proxy(function (index, input) {
                var $input = $(input);
                var value = $(input).attr('value');
                column.filters.push({ operator: 'eq', value: value });
            }, this));

            if (!hasErrors) {
                if (column.filters.length > 0)
                    this.filter(this.filterExpr());

                this.hideFilter();
            }
        },

        isValidFilterValue: function (column, value) {
            if (column.type == 'Number')
                return !isNaN(value);

            return true;
        },

        encodeFilterValue: function (column, value) {
            switch (column.type) {
                case 'String':
                    return "'" + value.replace(escapeQuoteRegExp, "''") + "'";
                case 'Date':
                    var date;
                    if (value.indexOf('Date(') > -1)
                        date = new Date(parseInt(value.replace(/^\/Date\((.*?)\)\/$/, '$1')));
                    else
                        date = $t.datetime.parse({ value: value, format: getFormat(column) }).toDate();

                    return "datetime'" + $t.formatString('{0:yyyy-MM-ddTHH-mm-ss}', date) + "'";
            }

            return value;
        },

        filterExpr: function () {
            var result = [];

            for (var columnIndex = 0; columnIndex < this.columns.length; columnIndex++) {
                var column = this.columns[columnIndex];
                if (column.filters)
                    for (var filterIndex = 0; filterIndex < column.filters.length; filterIndex++) {
                        var filter = column.filters[filterIndex];
                        result.push(new $t.stringBuilder()
                            .cat(column.member)
                            .cat('~')
                            .cat(filter.operator)
                            .cat('~')
                            .cat(this.encodeFilterValue(column, filter.value)).string());
                    }
            }

            return result.join('~and~');
        },

        filter: function (filterBy) {
            this.currentPage = 1;
            this.filterBy = filterBy;

            if (this.isAjax()) {
                this.$columns().each($.proxy(function (index, element) {
                    $('.t-grid-filter', element).toggleClass('t-active-filter', !!this.columns[index].filters);
                }, this));

                this.ajaxRequest();
            } else {
                this.serverRequest();
            }
        }
    };
})(jQuery);



(function ($) {
    var $t = $.telerik;

    var dropCueOffsetTop = 3;
    var dropCueOffsetLeft = 0;

    $t.grouping = {};

    $t.grouping.initialize = function (grid) {
        $.extend(grid, $t.grouping.implementation);

        grid.$groupDropCue = $('<div id=groupDropCue_' + grid.element.id + ' class="t-grouping-dropclue"/>');
        grid.$groupHeader = $('> .t-grid-top-container > .t-grid-toolbar-container > .t-grid-top > .t-grouping-header', grid.element);
        
        function groups() {
            var all = $.map(grid.$groupHeader.find('.t-group-indicator'), function (group) {
                var $group = $(group);
                var left = $group.offset().left;
                var width = $group.outerWidth();
                return { left: left, right: left + width, width: width, $group: $group };
            });

            return {
                first: all[0],
                all: all,
                last: all[all.length - 1]
            };
        }

        function drag(e) {
            var title = e.$cue.text();
            
            if (!$.contains(grid.element, e.target) 
                || !$(e.target).closest('.t-grouping-header').length
                || (grid.groupFromTitle(title) && e.$draggable.closest('.t-header').length)) {
                grid.$groupDropCue.remove();
                return;
            }
            
            var top = $('> .t-grid-toolbar', grid.element).outerHeight() + dropCueOffsetTop;
                
            var state = groups();
                
            if (!state.all.length) {
                grid.$groupDropCue.css({ top: top, left: dropCueOffsetLeft }).appendTo(grid.$groupHeader);
                return;
            }

            var firstGroupIndicator = state.first;
            var lastGroupIndicator = state.last;
            var leftMargin = parseInt(firstGroupIndicator.$group.css('marginLeft'));
            var rightMargin = parseInt(firstGroupIndicator.$group.css('marginRight'));

            var currentGroupIndicator = $.grep(state.all, function (g) {
                return e.pageX >= g.left - leftMargin - rightMargin && e.pageX <= g.right;
            })[0];

            if (!currentGroupIndicator && firstGroupIndicator && e.pageX < firstGroupIndicator.left) {
                currentGroupIndicator = firstGroupIndicator;
            }

            if (currentGroupIndicator)
                grid.$groupDropCue.css({ top: top, left: currentGroupIndicator.$group.position().left - leftMargin + dropCueOffsetLeft })
                    .insertBefore(currentGroupIndicator.$group);
            else
                grid.$groupDropCue.css({ top: top, left: lastGroupIndicator.$group.position().left + lastGroupIndicator.$group.outerWidth() + rightMargin + dropCueOffsetLeft })
                                .appendTo(grid.$groupHeader);
        }

        function cue(e) {
            if (e.$draggable.hasClass('t-header')) {
                var column = grid.columnFromTitle(e.$draggable.text());
                return $t.dragCue(column.title);
            } else {
                // remove icons' hidden accessibility content first
                var groupButtonLink = $('.t-link', e.$draggable);
                var columnTitle = groupButtonLink.text().substr($('.t-icon', groupButtonLink).text().length);
                var column = grid.columnFromTitle(columnTitle);
                return $t.dragCue(column.title);
            }
        }
        
        function stop(e) {
            var title = e.$cue.text();
            
            grid.$groupDropCue.remove();

            if (e.$draggable.is('.t-group-indicator') && e.keyCode != 27) {
                grid.unGroup(title);
                return false;
            }
        }

        function destroy(e) {
            e.$cue.remove();
        }

        new $t.draggable({
            owner: grid.$header,
            selector: '.t-header:not(.t-group-cell,.t-hierarchy-cell)',
            scope: grid.element.id + '-grouping',
            cue: cue,
            start: function(e) {
                var column = grid.columnFromTitle(e.$draggable.text());
                return !!column.member && column.groupable !== false;
            },
            stop: stop,
            drag: drag,
            destroy: destroy
        });
        
        new $t.draggable({
            owner: grid.$groupingHeader,
            selector: '.t-group-indicator',
            scope: grid.element.id + '-grouping',
            cue: cue,
            stop: stop,
            drag: drag,
            destroy: destroy
        });        
        
        new $t.droppable({
            owner: grid.element,
            selector: '.t-grouping-header',
            scope: grid.element.id + '-grouping',
            over: function(e) {
                $t.dragCueStatus(e.$cue, 't-add');
            },
            out: function(e) {
                $t.dragCueStatus(e.$cue, 't-denied');
            },
            drop: function(e) {
                var title = e.$cue.text();
                var group = grid.groupFromTitle(title);

                var groupIndex = $.inArray(group, grid.groups);

                var position = grid.$groupHeader.find('div').index(grid.$groupDropCue);
                var delta = groupIndex - position;
                if (!group || (grid.$groupDropCue.is(':visible') && delta != 0 && delta != -1))
                    grid.group(title, position);
                 
                grid.$groupDropCue.remove();
            }
        });

        if (grid.isAjax()) {
            grid.$groupHeader
                .delegate('.t-button', 'click', function (e) {
                    e.preventDefault();
                    var groupButtonLink = $(this).parent().find('.t-link');
                    var columnTitle = groupButtonLink.text().substr($('.t-icon', groupButtonLink).text().length);
                    grid.unGroup(columnTitle);
                })
                .delegate('.t-link', 'click', function (e) {
                    e.preventDefault();
                    var groupButtonLink = $(this);
                    var columnTitle = groupButtonLink.text().substr($('.t-icon', groupButtonLink).text().length);
                    var group = grid.groupFromTitle(columnTitle);
                    group.order = group.order == 'asc' ? 'desc' : 'asc';
                    grid.group(group.title);
                });
        }

        grid.$groupHeader.delegate('.t-group-indicator', 'mouseenter', function () {
                grid.$currentGroupItem = $(this);
            })
            .delegate('.t-group-indicator', 'mouseleave', function () {
                grid.$currentGroupItem = null;
            });

        grid.$tbody.delegate('.t-grouping-row .t-collapse, .t-grouping-row .t-expand', 'click', $t.stop(function (e) {
            e.preventDefault();
            var $this = $(this), $tr = $this.closest('tr');
            if ($this.hasClass('t-collapse'))
                grid.collapseGroup($tr);
            else
                grid.expandGroup($tr);
        }));

        grid.groupFromTitle = function (title) {
            return $.grep(grid.groups, function (g) { return g.title == title; })[0];
        }

        grid.expandGroup = function (group) {
            var $group = $(group);
            var depth = $group.find('.t-group-cell').length;
            
            $group.nextAll('tr').each(function (i, tr) {
                var $tr = $(tr);
                var offset = $tr.find('.t-group-cell').length;
                if (offset <= depth)
                    return false;

                if (offset == depth + 1 && !$tr.hasClass('t-detail-row')) {
                    $tr.show();

                    if ($tr.hasClass('t-grouping-row') && $tr.find('.t-icon').hasClass('t-collapse'))
                        grid.expandGroup($tr);
                    if ($tr.hasClass('t-master-row') && $tr.find('.t-icon').hasClass('t-minus'))
                        $tr.next().show();
                }
            });

            $group.find('.t-icon').addClass('t-collapse').removeClass('t-expand');
        }

        grid.collapseGroup = function (group) {
            var $group = $(group);
            var depth = $group.find('.t-group-cell').length;
            $group.nextAll('tr').each(function () {
                var $tr = $(this);
                var offset = $tr.find('.t-group-cell').length;
                if (offset <= depth)
                    return false;

                $tr.hide();
            });
            $group.find('.t-icon').addClass('t-expand').removeClass('t-collapse');
        }

        grid.group = function (title, position) {
            if (this.groups.length == 0 && this.isAjax())
                grid.$groupHeader.empty();

            var group = $.grep(grid.groups, function (group) {
                return group.title == title;
            })[0];

            if (!group) {
                var column = grid.columnFromTitle(title);
                group = { order: 'asc', member: column.member, title: title };
                grid.groups.push(group);
            }

            if (position >= 0) {
                grid.groups.splice($.inArray(group, grid.groups), 1);
                grid.groups.splice(position, 0, group);
            }

            grid.groupBy = $.map(grid.groups, function (g) { return g.member + '-' + g.order; }).join('~')

            if (this.isAjax()) {
                var $groupItem = this.$groupHeader.find('div[member="' + group.member + '"]');
                if ($groupItem.length == 0) {
                    var html = new $.telerik.stringBuilder()
                        .cat('<div member="' + group.member + '" class="t-group-indicator">')
                        .cat('<a href="#" class="t-link"><span class="t-icon" />').cat(title).cat('</a>')
                        .cat('<a class="t-button"><span class="t-icon t-group-delete">').cat(grid.localization.ungroup).cat('</span></a>')
                        .cat('</div>')
                        .string();
                    $groupItem = $(html).appendTo(this.$groupHeader);
                }

                if (this.$groupDropCue.is(':visible'))
                    $groupItem.insertBefore(this.$groupDropCue);

                $groupItem.find('.t-link .t-icon')
                          .toggleClass('t-arrow-up-small', group.order == 'asc')
                          .toggleClass('t-arrow-down-small', group.order == 'desc')
                          .html('(' + (group.order == 'asc' ? grid.localization.sortedAsc : grid.localization.sortedDesc) + ')');

                this.ajaxRequestWithValidation();
            } else {
                this.serverRequest();
            }
        }

        grid.unGroup = function (title) {
            var group = grid.groupFromTitle(title);
            grid.groups.splice($.inArray(group, grid.groups), 1);

            if (grid.groups.length == 0)
                grid.$groupHeader.html(grid.localization.groupHint);

            grid.groupBy = $.map(grid.groups, function (g) { return g.member + '-' + g.order; }).join('~');
            if (grid.isAjax()) {
                grid.$groupHeader.find('div[member="' + group.member + '"]').remove();
                grid.ajaxRequestWithValidation();
            } else {
                grid.serverRequest();
            }
        },

        grid.normalizeColumns = function(colspan) {
            var groups = grid.groups.length;
            var diff = colspan - grid.$tbody.parent().find(' > colgroup > col').length;
            if (diff == 0) return;
            
            var $tables = grid.$tbody.parent().add(grid.$headerWrap.find('table')).add(grid.$footer.find("table"));
            if ($.browser.msie) {
                // ie8 goes into compatibility mode if the columns get removed
                if (diff > 0) {
                    $(new $t.stringBuilder().rep('<col class="t-group-col" style="width: 30px" />', diff).string())
                        .prependTo($tables.find('colgroup'))
                    $(new $t.stringBuilder().rep('<th class="t-group-cell t-header">&nbsp;</th>', diff).string())
                        .insertBefore($tables.find('th.t-header:first'));
                    $(new $t.stringBuilder().rep('<td class="t-group-cell">&nbsp;</td>', diff).string())
                        .insertBefore($tables.find('tr.t-footer-template > td:first'));

                } else {
                    $tables.find('th:lt(' + Math.abs(diff) + '), tr.t-footer-template > td:lt(' + Math.abs(diff) + ')')
                           .remove()
                           .end()
                           .find('col:lt(' + Math.abs(diff) + ')')
                           .remove();
                }
                
                // take the tables out for a walk. ie8 does not recalculate table layout properly.
                var containers = [];
                var i = 0;
                
                $('table, .t-grid-bottom', grid.element)
                    .each(function() { containers.push(this.parentNode); })
                    .appendTo($('<div />'))
                    .each(function() { containers[i++].appendChild(this); });
            } else {
                $tables.find('col.t-group-col').remove();

                $(new $t.stringBuilder().rep('<col class="t-group-col" style="width: 30px" />', groups).string())
                        .prependTo($tables.find('colgroup'));

                $tables.find('th.t-group-cell').remove();
                $tables.find('tr.t-footer-template > td.t-group-cell').remove();

                $(new $t.stringBuilder().rep('<th class="t-group-cell t-header">&nbsp;</th>', groups).string())
                        .insertBefore($tables.find('th.t-header:first'));
                
                $(new $t.stringBuilder().rep('<td class="t-group-cell">&nbsp;</td>', groups).string())
                        .insertBefore($tables.find('tr.t-footer-template > td:first'));
            }            
        },

        grid.bindGroup = function (dataItem, colspan, html, level) {
            var group = grid.groups[level];
            var key = dataItem.Key;
            var column = $.grep(grid.columns, function (column) { return group.member == column.member })[0];

            if (column && (column.format || column.type == 'Date'))
                key = $t.formatString(column.format || '{0:G}', key);

            html.cat('<tr class="t-grouping-row">')
                .rep('<td class="t-group-cell"></td>', level)
                .cat('<td colspan="')
                .cat(colspan - level)
                .cat('"><p class="t-reset"><a class="t-icon t-collapse" href="#"></a>');
            
            if (column)                            
                html.cat(column.groupHeader($.extend( { Title: group.title, Key: key }, dataItem.Aggregates[column.member] )));
            else
                html.cat(group.title + ': ' + key);
            
            html.cat('</p></td></tr>');

            if (dataItem.HasSubgroups) {
                for (var i = 0, l = dataItem.Items.length; i < l; i++)
                    grid.bindGroup(dataItem.Items[i], colspan, html, level + 1);
            } else {
                grid.bindData(dataItem.Items, html, level + 1);
            }
            
            if (grid.showGroupFooter) {
                html.cat('<tr class="t-group-footer">')
                    .rep('<td class="t-group-cell"></td>', grid.groups.length);
            
                $.each(grid.columns, function() {
                    html.cat('<td>');
                    if (this.groupFooter)
                        html.cat(this.groupFooter(dataItem.Aggregates[this.member]));
                    html.cat('</td>');
                });

                html.cat('</tr>');
            }
        }
    }
})(jQuery);


(function ($) {
    var $t = $.telerik;

    $t.reordering = {};

    $t.reordering.initialize = function (grid) {

        grid.$reorderDropCue = $('<div class="t-reorder-cue"><div class="t-icon t-arrow-down"></div><div class="t-icon t-arrow-up"></div></div>');

        var lastColumnIndex = grid.$header.children("th").length - 1;

        var reorderColumn = function (destIndex, column) {
            var sourceIndex = $.inArray(column, grid.columns);
            
            grid.columns.splice(sourceIndex, 1);
            
            grid.columns.splice(destIndex, 0, column);

            reorder(grid.$columns(), sourceIndex, destIndex);

            reorder(grid.$tbody.parent().find('> colgroup > col:not(.t-group-col,.t-hierarchy-col)'), sourceIndex, destIndex);
            
            reorder(grid.$headerWrap.find('table').find('> colgroup > col:not(.t-group-col,.t-hierarchy-col)'), sourceIndex, destIndex);

            var footerWrap = grid.$footer.find('table');
            reorder(footerWrap.find('> colgroup > col:not(.t-group-col,.t-hierarchy-col)'), sourceIndex, destIndex);            
            reorder(footerWrap.find('> tbody > tr.t-footer-template > td:not(.t-group-cell,.t-hierarchy-cell)')
                .add(grid.$footer.find('tr.t-footer-template > td:not(.t-group-cell,.t-hierarchy-cell)')), sourceIndex, destIndex);

            $.each(grid.$tbody.children(), function () {
                reorder($(this).find(' > td:not(.t-group-cell, .t-hierarchy-cell, .t-detail-cell)'), sourceIndex, destIndex);
            });
        }

        grid.reorderColumn = reorderColumn;

        function setLastColumnClass($source, sourceIndex, $dest, destIndex) {
            switchClasses($source, sourceIndex, $dest, destIndex, "th", "t-last-header");
            switchClasses($source, sourceIndex, $dest, destIndex, "td", "t-last");
        }

        function switchClasses($source, sourceIndex, $dest, destIndex, selector, className) {                

            if ($dest.is(selector) && destIndex == lastColumnIndex) {
                $source.addClass(className);
                $dest.removeClass(className);
            }

            if ($source.is(selector) && sourceIndex == lastColumnIndex) {                
                $source.removeClass(className)
                       .prev(selector)
                       .addClass(className);                
            }
        }

        function reorder(selector, sourceIndex, destIndex) {
            var $source = selector.eq(sourceIndex);
            var $dest = selector.eq(destIndex);

            setLastColumnClass($source, sourceIndex, $dest, destIndex);
            
            $source[sourceIndex > destIndex ? 'insertBefore' : 'insertAfter']($dest);
        }

        var onColumnReorder = function (grid) {
            var colOrders = {};
            for (var i = 0; i < grid.columns.length; i++) {
                var column = grid.columns[i];
                if (column.uniquename)
                    colOrders[column.uniquename] = i;
            }

            $.ajax({
                url: '/SDK.Action/GridSettings/SetColumnOrder',
                type: "POST",
                dataType: 'json',
                data: {
                        'gridId': $(grid.element).attr('id'),
                        'columnOrders': JSON.stringify(colOrders),
                        'provider': $(grid.element).attr('provider')
                },
                cache: false,
                success: function (data) {

                }
            });
        }

        new $t.draggable({
            owner: grid.$header,
            selector: '.t-header:not(.t-group-cell,.t-hierarchy-cell)',
            scope: grid.element.id + '-reodering',
            cue: function(e) {
                return $t.dragCue(e.$draggable.text());
            },
            destroy: function(e) {
                e.$cue.remove();
            }
        });

        new $t.droppable({
            owner: grid.$header,
            scope: grid.element.id + '-reodering',
            selector: '.t-header:not(.t-group-cell,.t-hierarchy-cell)',
            over: function(e) {
                var same = $.trim(e.$draggable.text()) == $.trim(e.$droppable.text());
                $t.dragCueStatus(e.$cue, same? 't-denied' : 't-add');
                
                var top = 0; 
                
                $('> .t-grid-top, > .t-grouping-header', grid.element).each(function() {
                    top += $(this).outerHeight();
                });
                
                if (!same)
                    grid.$reorderDropCue.css({
                         height: e.$droppable.outerHeight(),
                         top: top,
                         left: function() {
                                return e.$droppable.position().left + ((e.$droppable.index() > e.$draggable.index()) ? e.$droppable.outerWidth() : 0)
                            }
                         })
                         .appendTo(grid.element);
            },
            out: function(e) {
                grid.$reorderDropCue.remove();
                $t.dragCueStatus(e.$cue, 't-denied');
            },
            drop: function(e) {
                grid.$reorderDropCue.remove();
                if (e.$cue.find('.t-drag-status').is('.t-add')) {
                    var column = grid.columnFromTitle($.trim(e.$draggable.text()));
                    var position = grid.$columns().index(e.$droppable);                    
                    $t.trigger(grid.element, 'columnReorder', {
                        column: column,
                        oldIndex: $.inArray(column, grid.columns),
                        newIndex: position
                    });
                    reorderColumn(position, column);
                    onColumnReorder(grid);
                    //пересчитать положение grips
                    $t.resizing.initialize(grid);
                    $t.trigger(grid.element, 'repaint');
                }
            }
        });
    }
})(jQuery);



(function ($) {
    var $t = $.telerik;
    var firstInitialize = true;
    $t.resizing = {};
    $t.count = 0;
    $t.tables = []; 		//array of the already processed tables (table.id as key)
    $t.resizing.waitingInitResizing = [];
    $t.resizing.canInitResizing = true;
    $(document).ajaxStart(function () {
        $.telerik.resizing.canInitResizing = false;
    });
    $(document).ajaxStop(function () {
        $.telerik.resizing.canInitResizing = true;
        while ($.telerik.resizing.waitingInitResizing.length) {
            var f = $.telerik.resizing.waitingInitResizing.pop();
            f();
        }
    });
    $t.resizing.initialize = function (grid) {

        var showSaveAsDefaultComment = function (data) {
            if (data.success && data.cansave && $("#" + grid.element.id + " table:first").hasClass('width-default-settings') && $('#saveAsDefaultComment').length == 0 && !$.cookie("saveAsDefaultComment") && $("#" + grid.element.id + ' .t-grid-pager:first .t-settings:first').length > 0) {
                $("#" + grid.element.id).before("<div id=\"saveAsDefaultComment\" class=\"note\" style=\"margin-bottom: 5px;\"><div style=\"float: right; padding: 5px;\">" +
                        "<a onclick=\"$.cookie('saveAsDefaultComment', true, { expires: 100000 }); $('#saveAsDefaultComment').hide();\">" +
                        "<img src=\"/Content/Images/x16/Delete.png\" title=\"" + SR.T("Закрыть") + "\"></a></div><div style=\"padding: 10px; text-align: left; font-size: 12px;\">" +
                        SR.T("Установленную ширину и состав колонок можно сохранить как <b>настройки по умолчанию</b> в окне настройки отображения таблицы.") + "</div></div>");
                resizeTip();
            }
        };

        var d = $(document); 		//window object
        var h = $("head"); 		//head object
        var drag = null; 		//reference to the current grip that is being dragged
        //var count = 0; 			//internal count to create unique IDs when needed.	

        //common strings for minification	(in the minified version there are plenty more)
        var ID = "id";
        var PX = "px";
        var SIGNATURE = "JColResizer";

        //shortcuts
        var I = parseInt;
        var M = Math;
        var ie = $.browser.msie;
        var S;
        try { S = sessionStorage; } catch (e) { } //Firefox crashes when executed as local file system

        //append required CSS rules  
        //h.append("<style type='text/css'> .dotted{ width: 15px; background-image:url('/Content/Images/Grid/dotted.png'); background-repeat:repeat-y; } .JColResizer{table-layout:fixed;} .JColResizer th{overflow:hidden;text-indent: 5px;padding-left:0!important; padding-right:0!important;}  .JCLRgrips{ height:0px; position:relative;} .JCLRgrip{margin-left:-5px; position:absolute; z-index:5; } .JCLRgrip .JColResizer{position:absolute;background-color:red;filter:alpha(opacity=1);opacity:0;width:10px;height:100%;top:0px} .JCLRLastGrip{position:absolute; width:1px; } .JCLRgripDrag{ border-left:1px dotted black; } .JCLRgripInner { position: absolute; left: 4px; width: 2px; height:15px; margin-top: 5px; background-image: url('/Content/Images/Grid/handle.png');}</style>");

        var init = function (tb, options) {
            var t = $(tb); 									//the table object is wrapped
            if (options.disable) return destroy(t); 			//the user is asking to destroy a previously colResized table
            t.id = (t.attr(ID) || t.closest('.t-grid').attr(ID) || SIGNATURE + $t.count++); //its id is obtained, if null new one is generated		
            if (t.id !== t.attr(ID)) {
                t.id += '_table';
            }
            var id = t.id;
            t.p = options.postbackSafe; 						//shortcut to detect postback safe 		
            if (!t.is("table") || t.prev().hasClass('JCLRgrips') /*|| $t.tables[id]*/) return; 			//if the object is not a table or if it was already processed then it is ignored.
            t.addClass(SIGNATURE).attr(ID, id).before('<div class="JCLRgrips"/>'); //the grips container object is added. Signature class forces table rendering in fixed-layout mode to prevent column's min-width
            t.opt = options; t.g = []; t.c = []; t.w = t.width(); t.gc = t.prev(); //t.c and t.g are arrays of columns and grips respectively				
            if (options.marginLeft) t.gc.css("marginLeft", options.marginLeft);  	//if the table contains margins, it must be specified
            if (options.marginRight) t.gc.css("marginRight", options.marginRight);  	//since there is no (direct) way to obtain margin values in its original units (%, em, ...)
            t.cs = I(ie ? tb.cellSpacing || tb.currentStyle.borderSpacing : t.css('border-spacing')) || 2; //table cellspacing (not even jQuery is fully cross-browser)
            t.b = I(ie ? tb.border || tb.currentStyle.borderLeftWidth : t.css('border-left-width')) || 1; //outer border width (again cross-browser isues)
            // if(!(tb.style.width || tb.width)) t.width(t.width()); //I am not an IE fan at all, but it is a pitty that only IE has the currentStyle attribute working as expected. For this reason I can not check easily if the table has an explicit width or if it is rendered as "auto"

            t.pager = t.closest('.t-grid').find('.t-grid-pager:first');
            t.pagerBottom = t.closest('.t-grid').find('.t-grid-pager:last');
            t.pagerRightOffset = 0;
            t.updatebutton = t.pager.find('.t-status:first');

            // ширина таблицы не меньше ширины пейджера
            var visibleHeaderSummaryText = t.pager.find('> .t-headerSummary-text');
            t.css('min-width', visibleHeaderSummaryText.outerWidth() + t.pager.outerWidth());

            // в портлетах разрешен только resize-mode-web
            if (t.closest('.t-grid').parent().hasClass('portlet-content')) {
                if (t.hasClass('resize-mode-gui')) {
                    t.removeClass('resize-mode-gui');
                    t.addClass('resize-mode-web');
                }
                t.floatingpager = false;
            }
            else if (t.hasClass('locked-mode')) {
                t.floatingpager = false;
            }
            else {
                t.switchmodebutton = $("<div class='t-status'><a id='" + t.id + "_resizeModeButton' class='t-button' tooltiptext='" + (t.hasClass('resize-mode-gui') ? SR.T("Вписать колонки в размер окна") : SR.T("Колонки произвольной ширины")) + "'>" +
                    "<span class='t-icon' style=\"margin:0 -3px; width:22px; background:center center no-repeat url('/Content/Images/Grid/column_resize_mode_" + (t.hasClass('resize-mode-gui') ? 2 : 1) + ".gif');\" /></a></div>");
                if (t.updatebutton.length > 0) {
                    t.switchmodebutton.insertAfter(t.updatebutton);
                    t.switchmodebutton.click($.proxy(changeColumnResizeMode, t.switchmodebutton));

                }
                t.pagerbacking = $('<div class="t-grid-pager t-grid-Top" style="border-color: #5D8CC9; height: 29px"></div>');
                // floating pager
                if (t.pager.length > 0 && t.pager.css('display') !== 'none') {
                    t.pagerbacking.insertAfter(t.pager);
                    var headerSummary = t.pager.find('> .t-headerSummary-text');
                    headerSummary.show();
                    headerSummary.clone().appendTo(t.pagerbacking);
                    headerSummary.hide();
                    t.pagerstylecopy = t.pager.attr('style');
                    t.pager.css("position", "absolute").css('border-width', '0');
                    realignPager(t);
                    $(window).scroll(function () {
                        pagerPosition(t.pager);
                    });
                }
                t.pagerbackingBottom = $('<div class="t-grid-pager t-grid-Bottom" style="border-color: #5D8CC9; height: 29px"></div>');
                if (t.pager.length > 0 && t.pager.css('display') !== 'none') {
                    t.pagerbackingBottom.insertAfter(t.pagerBottom);
                    var headerSummaryBottom = t.pagerBottom.find('> .t-headerSummary-text');
                    headerSummaryBottom.show();
                    headerSummaryBottom.clone().appendTo(t.pagerbackingBottom);
                    headerSummaryBottom.hide();
                    t.pagerstylecopyBottom = t.pager.attr('style');
                    t.pagerBottom.css("position", "absolute").css('border-width', '0');
                    realignPager(t);
                    $(window).scroll(function () {
                        pagerPosition(t.pagerBottom);
                    });
                }
                t.floatingpager = true;
            }

            t.savedColWidth = [];
            t.resizeInProgress = false;
            t.table2 = t.closest('.t-grid').find('table:eq(1)');

            $t.tables[id] = t; 	//the table object is stored using its id as key	
            createGrips(t); 	//grips are created

            if (t.hasClass('resize-mode-gui')) {
                t.css("width", "0");
                t.table2.css("width", "0");
            } else {
                setColumnWidthToPercent(t);
                t.css("width", "100%");
                t.table2.css("width", "100%");
                t.prev().css("width", "100%");
            }
            BottomPagerVisible();
        };

        var destroy = function (t) {
            var id = t.attr(ID), t = $t.tables[id]; 	//its table object is found
            if (!t || !t.is("table")) return; 		//if none, then it wasnt processed	 
            t.removeClass(SIGNATURE).gc.remove(); //class and grips are removed
            if (t.switchmodebutton != undefined) t.switchmodebutton.remove();
            if (t.floatingpager) {
                t.pagerbacking.remove();
                t.pager.attr('style', t.pagerstylecopy);
                t.pager.find('> .t-headerSummary-text').show();
                t.pagerbackingBottom.remove();
                t.pagerBottom.attr('style', t.pagerstylecopyBottom);
                t.pagerBottom.find('> .t-headerSummary-text').show();
            }
            delete $t.tables[id]; 					//clean up data
        };

        var createGrips = function (t) {
            var th = t.find(">thead>tr>th,>thead>tr>td"); //if table headers are specified in its semantically correct tag, are obtained
            if (!th.length) th = t.find(">tbody>tr:first>th,>tr:first>th,>tbody>tr:first>td, >tr:first>td");  //but headers can also be included in different ways
            t.cg = t.find("col"); 						//a table can also contain a colgroup with col elements		
            t.cg2 = t.table2.find('col');
            t.ln = th.length; 						//table length is stored	
            if (t.p && S && S[t.id]) memento(t, th); 	//if 'postbackSafe' is enabled and there is data for the current table, its coloumn layout is restored
            var zIndex = 'auto';
            t.parents().andSelf().each(function () {
                zIndex = $(this).css('zIndex');
                if (Number(zIndex)) {
                    zIndex = Number(zIndex) + 1;
                    return false;
                }
            });
            th.each(function (i) {						//iterate through the table column headers			
                var c = $(this); 						//jquery wrap for the current column			
                var g = $(t.gc.append('<div class="JCLRgrip"></div>')[0].lastChild); //add the visual node to be used as grip
                g.css({ zIndex: zIndex });
                g.t = t; g.i = i; g.c = c; c.w = c.width(); 	//some values are stored in the grip's node data
                t.g.push(g); t.c.push(c); 					//the current grip and column are added to its table object
                c.width(c.w).removeAttr("width"); 			//the width of the column is converted into pixel-based measurements
                if (/*scrollPresent || */(i < t.ln - 1) || t.opt.guiResizeStyle) {
                    if (!c.hasClass('t-not-resizable') && !c.hasClass('t-hierarchy-cell')) {
                        g.mousedown(onGripMouseDown).append(t.opt.gripInnerHtml).append('<div class="' + SIGNATURE + '" style="cursor:' + t.opt.hoverCursor + '"></div>'); //bind the mousedown event to start dragging 
                    }
                }
                else g.addClass("JCLRLastGrip").removeClass("JCLRgrip"); //the last grip is used only to store data	                    

                g.data(SIGNATURE, { i: i, t: t.attr(ID) }); 					//grip index and its table name are stored in the HTML 												
            });
            t.cg.removeAttr("width"); //remove the width attribute from elements in the colgroup (in any)
            t.cg2.removeAttr("width"); //remove the width attribute from elements in the colgroup (in any)            
            syncGrips(t); 				//the grips are positioned according to the current table layout			
            //there is a small problem, some cells in the table could contain dimension values interfering with the 
            //width value set by this plugin. Those values are removed
            t.find('td, th').not(th).not('table th, table td').each(function () {
                $(this).removeAttr('width'); //the width attribute is removed from all table cells which are not nested in other tables and dont belong to the header
            });
        };

        var memento = function (t, th) {
            var w, m = 0, i = 0, aux = [];
            if (th) {										//in deserialization mode (after a postback)
                t.cg.removeAttr("width");
                t.cg2.removeAttr("width");
                if (t.opt.flush) { S[t.id] = ""; return; } 	//if flush is activated, stored data is removed
                w = S[t.id].split(";"); 				//column widths is obtained
                for (; i < t.ln; i++) {						//for each column
                    aux.push(100 * w[i] / w[t.ln] + "%"); 	//width is stored in an array since it will be required again a couple of lines ahead
                    th.eq(i).css("width", aux[i]); 	//each column width in % is resotred
                }
                for (i = 0; i < t.ln; i++) {
                    t.cg.eq(i).css("width", aux[i]); //this code is required in order to create an inline CSS rule with higher precedence than an existing CSS class in the "col" elements
                    t.cg2.eq(i).css("width", aux[i]); //this code is required in order to create an inline CSS rule with higher precedence than an existing CSS class in the "col" elements
                }
            } else {							//in serialization mode (after resizing a column)
                S[t.id] = ""; 			//clean up previous data
                for (i in t.c) {				//iterate through columns
                    w = t.c[i].width(); 	//width is obtained
                    S[t.id] += w + ";"; 	//width is appended to the sessionStorage object using ID as key
                    m += w; 				//carriage is updated to obtain the full size used by columns
                }
                S[t.id] += m; 				//the last item of the serialized string is the table's active area (width), 
                //to be able to obtain % width value of each columns while deserializing
            }
        };

        var syncGrips = function (t) {
            if (!t.closest('.t-grid').parent().hasClass('portlet-content')) {
                var totalWidth = 0;
                for (var i = 0; i < t.ln; i++) { //for each column
                    var c = t.c[i];
                    totalWidth += c.width();
                }
                totalWidth -= 2; // grid border
                t.gc.width(totalWidth); //the grip's container width is updated				
                t.table2.width(totalWidth);
            }
            for (var i = 0; i < t.ln; i++) {	//for each column
                var c = t.c[i];
                t.g[i].css({			//height and position of the grip is updated according to the table layout
                    left: c.offset().left - t.offset().left + c.outerWidth() + t.cs / 2 + PX,
                    height: t.opt.headerOnly ? t.c[0].outerHeight() : t.outerHeight()
                });
            }
        };

        var syncCols = function (t, i, isOver) {
            var inc = drag.x - drag.l, c = t.c[i], c2 = t.c[i + 1];

            if (t.opt.guiResizeStyle) {
                var w = c.w + inc;
                c.width(w + PX);
                t.cg.eq(i).width(w + PX);
                t.cg2.eq(i).width(w + PX);
                if (isOver) {
                    c.w = w;
                }
            }
            else {
                if (c2 != undefined) {
                    var w = c.w + inc;
                    var w2 = c2.w - inc; //their new width is obtained					
                    c.width(w + PX);
                    c2.width(w2 + PX); //and set	
                    t.cg.eq(i).width(w + PX);
                    t.cg.eq(i + 1).width(w2 + PX);
                    t.cg2.eq(i).width(w + PX);
                    t.cg2.eq(i + 1).width(w2 + PX);
                    if (isOver) {
                        c.w = w;
                        c2.w = w2;
                    }
                }
            }
        };

        var resizeTip = function () {
            if ($('#saveAsDefaultComment').length > 0) {
                $('#saveAsDefaultComment').css('width', $('#saveAsDefaultComment').parent().width() - 2 + 'px');
            }
        };

        var getScrollerWidth = function () {
            var scr = null;
            var inn = null;
            var wNoScroll = 0;
            var wScroll = 0;
            // Outer scrolling div
            scr = document.createElement('div');
            scr.style.position = 'absolute';
            scr.style.top = '-1000px';
            scr.style.left = '-1000px';
            scr.style.width = '100px';
            scr.style.height = '50px';
            scr.style.overflow = 'hidden';
            inn = document.createElement('div');
            inn.style.width = '100%';
            inn.style.height = '200px';
            scr.appendChild(inn);
            document.body.appendChild(scr);
            wNoScroll = inn.offsetWidth;
            scr.style.overflow = 'auto';
            wScroll = inn.offsetWidth;
            document.body.removeChild(document.body.lastChild);
            return (wNoScroll - wScroll);
        };

        var scrollerWidth = getScrollerWidth();

        var getScroll = function (a) {
            var d = document,
                b = d.body,
                e = d.documentElement,
                c = "client" + a;
            a = "scroll" + a;
            return /CSS/.test(d.compatMode) ? (e[c] < e[a]) : (b[c] < b[a]);
        };

        var realignPager = function (t) {
            if (t.floatingpager == false)
                return;

            if (t.pager.length > 0) {
                pagerPosition(t.pager);
            }
            if (t.pagerBottom.length > 0) {
                pagerPosition(t.pagerBottom);
            }
        };

        var pagerPosition = function (pager) {
            if (!isMobile.any()) {
                if (($(window).scrollLeft() + $(window).width()) <= (pager.parent().offset().left + pager.parent().width())) {
                    if (($(window).scrollLeft() + $(window).width()) >= (pager.parent().offset().left + pager.width())) {
                        pager.css('right', Math.abs((pager.parent().offset().left + pager.parent().width()) - ($(window).scrollLeft() + $(window).width())));
                    }
                    else {
                        pager.css('right', (pager.parent().width()) - (pager.width()));
                    }
                }
                else {
                    pager.css('right', 0);
                }
            }
            else {
                pager.css('right', 0);
            }
        }

        var setColumnWidthToPercent = function (t) {
            var totalWidth = 0;
            for (var i in t.c) { if (!t.c[i].hasClass('t-not-resizable') && !t.c[i].hasClass('t-hierarchy-cell')) totalWidth += t.c[i].outerWidth(); };
            if (totalWidth > 0) {
                for (var i in t.c) {
                    if (!t.c[i].hasClass('t-not-resizable') && !t.c[i].hasClass('t-hierarchy-cell')) {
                        var width = (t.c[i].outerWidth() / totalWidth * 100).toFixed(3) + "%";
                        t.cg.eq(i).width(width);
                        t.cg2.eq(i).width(width);
                    }
                };
            } else {
                for (var i in t.c) {
                    if (!t.c[i].hasClass('t-not-resizable') && !t.c[i].hasClass('t-hierarchy-cell')) {
                        var width = (100 / t.c.length).toFixed(3) + "%";
                        t.cg.eq(i).width(width);
                        t.cg2.eq(i).width(width);
                    }
                };
            }
        };

        var onGripDrag = function (e) {
            if (!drag) return; var t = drag.t; 	//table object reference 
            var x = e.pageX - drag.ox + drag.l; 	//next position according to horizontal mouse position increment
            var mw = t.opt.minWidth, i = drag.i; //cell's min width
            var l = t.cs * 1.5 + mw + t.b;
            var max = t.hasClass('resize-mode-web') ? i == t.ln - 1 ? t.w - l : t.g[i + 1].position().left - t.cs - mw : 10000; //max position according to the contiguous cells
            var min = i ? t.g[i - 1].position().left + t.cs + mw : l; 			//min position according to the contiguous cells
            x = M.max(min, M.min(max, x)); 					//apply boundings		
            drag.x = x; drag.css("left", x + PX); 			//apply position increment		
            if (t.opt.liveDrag) { 								//if liveDrag is enabled
                syncCols(t, i); syncGrips(t); 				//columns and grips are synchronized
                var cb = t.opt.onDrag; 						//check if there is an onDrag callback
                if (cb) { e.currentTarget = t[0]; cb(e); } 	//if any, it is fired			
            }

            realignPager(t);
            return false; 	//prevent text selection				
        };

        var onGripDragOver = function (e) {
            d.unbind('mousemove.' + SIGNATURE).unbind('mouseup.' + SIGNATURE);
            $("head :last-child").remove(); 				//remove the dragging cursor style	
            if (!drag) return;
            drag.removeClass(drag.t.opt.draggingClass); 	//remove the grip's dragging css-class
            var t = drag.t, cb = t.opt.onResize; 			//get some values	
            var ow = t.c[drag.i].w;
            if (drag.x) { 									//only if the column width has been changed
                syncCols(t, drag.i, true); syncGrips(t); //the columns and grips are updated
                if (cb) { e.currentTarget = t[0]; cb(e); } //if there is a callback function, it is fired
            }
            if (t.p && S) memento(t); 						//if postbackSafe is enabled and there is sessionStorage support, the new layout is serialized and stored

            if (t.hasClass('resize-mode-web')) {
                // для колонок задаем ширину в процентах
                setColumnWidthToPercent(t);
            }

            $t.trigger(grid.element, "columnResize", {
                column: t.c[drag.i],
                oldWidth: ow,
                newWidth: t.c[drag.i].width()
            });

            drag = null; 								//since the grip's dragging is over									
        };

        var onGripMouseDown = function (e) {
            var o = $(this).data(SIGNATURE); 		//retrieve grip's data
            var t = $t.tables[o.t], g = t.g[o.i]; 		//shortcuts for the table and grip objects
            g.ox = e.pageX; g.l = g.position().left; //the initial position is kept				
            d.bind('mousemove.' + SIGNATURE, onGripDrag).bind('mouseup.' + SIGNATURE, onGripDragOver); //mousemove and mouseup events are bound
            h.append("<style type='text/css'>*{cursor:" + t.opt.dragCursor + "!important}</style>"); 	//change the mouse cursor
            g.addClass(t.opt.draggingClass); 	//add the dragging class (to allow some visual feedback)				
            drag = g; 						//the current grip is stored as the current dragging object
            if (t.c[o.i].l) for (var i = 0, c; i < t.ln; i++) { c = t.c[i]; c.l = false; c.w = c.width(); } 	//if the colum is locked (after browser resize), then c.w must be updated		
            return false; 	//prevent text selection
        };

        var onResizeTable = function (t) {
            var mw = 0;
            // перед тем как сделать width: auto, ужно все грипы сдвинуть влево, чтобы не мешали
            for (var i = 0; i < t.ln; i++) { //for each column
                t.g[i].css({ left: 0, height: 0 });
            }
            t.gc.css("width", "auto");

            t.removeClass(SIGNATURE); 					//firefox doesnt like layout-fixed in some cases
            if (t.w != t.width()) {							//if the the table's width has changed
                t.w = t.width(); 						//its new value is kept
                for (i = 0; i < t.ln; i++) mw += t.c[i].w; 	//the active cells area is obtained
                for (i = 0; i < t.ln; i++) t.c[i].css("width", M.round(1000 * t.c[i].w / mw) / 10 + "%").l = true;
            }
            syncGrips(t.addClass(SIGNATURE));
            realignPager(t);
        };

        var onResize = function () {
            for (t in $t.tables) {
                var t = $t.tables[t];
                onResizeTable(t);
            }
            resizeTip();
        };

        var tt = function (e, id) {
            if (!$t.resizing.canInitResizing)
                return false;
            for (t in $t.tables) {
                var t = $t.tables[t];
                if (t.closest('.t-grid').attr('id') == id) {
                    var colWidthCopy = t.savedColWidth;
                    t.colResizable({ disable: true });
                    t.colResizable();
                    $t.tables[t.id].savedColWidth = colWidthCopy;
                }
            }
            return false;
        };
        if (firstInitialize) {
            $(window).bind('resize.' + SIGNATURE, onResize);
            $(document).bind("resizeLayout." + SIGNATURE, onResize);

            // triggs even first initialization! added for Dynamic Blocks
            $(document).bind("telerikgridresizableupdate", tt);
            firstInitialize = false;
        }

        $.fn.extend({
            colResizable: function (options) {
                var defaults = {
                    //attributes:
                    draggingClass: 'dragging',
                    gripInnerHtml: '<div class="JCLRgripInner"></div>',
                    guiResizeStyle: $(this).hasClass('resize-mode-gui') && !$(this).closest('.t-grid').parent().hasClass('portlet-content'),
                    liveDrag: true,
                    minWidth: 15,
                    headerOnly: true,
                    hoverCursor: "e-resize",
                    dragCursor: "e-resize",
                    postbackSafe: false,
                    flush: false,
                    marginLeft: null,
                    marginRight: null,
                    disable: false,

                    //events:
                    onDrag: null,
                    onResize: onColumnResize
                };
                var options = $.extend(defaults, options);
                return this.each(function () {
                    init(this, options);
                });
            }
        });

        var onColumnResize = function (e) {
            var t = $t.tables[$(e.currentTarget).attr('id')];

            var tgrid = t.closest('.t-grid').data('tGrid');
            var colWidths = {};

            var hcells = 0;
            while (t.c.length > 0 && t.c[hcells].hasClass('t-hierarchy-cell')) {
                hcells++;
            }

            for (var i = 0; i < tgrid.columns.length; i++) {
                if (tgrid.columns[i].uniquename != '')
                    colWidths[tgrid.columns[i].uniquename] = t.c[i + hcells].width();
            }

            $.ajax({
                url: '/SDK.Action/GridSettings/SetColumnWidth',
                type: "POST",
                dataType: 'json',
                data: {
                    'gridId': t.closest('.t-grid').attr('id'),
                    'columnWidths': JSON.stringify(colWidths),
                    'provider': t.closest('.t-grid').attr('provider')
                },
                cache: false,
                success: function (data) { showSaveAsDefaultComment(data); }
            });
        };

        var setResizeMode = function (t, mode) {
            // выключаем ресайз
            var colWidthCopy = t.savedColWidth;
            t.colResizable({ disable: true });
            if (mode == 1) {
                // устанавливаем ширину таблицы со 100% в 0
                t.css("width", "0");
                t.table2.css("width", "0");
            }
            t.removeClass(mode == 0 ? 'resize-mode-gui' : 'resize-mode-web');
            t.addClass(mode == 0 ? 'resize-mode-web' : 'resize-mode-gui');
            // включаем ресайз
            t.colResizable();
            $t.tables[t.id].savedColWidth = colWidthCopy;
            /*$('#' + grid.element.id + '_changeColumnResizeModeButton').attr('src', mode == 0 ? '/Content/Images/Grid/column_resize_mode_1.gif' : '/Content/Images/Grid/column_resize_mode_2.gif')
            .attr('title', mode == 0 ? 'Колонки произвольной ширины' : 'Вписать колонки в размер окна');*/
            t.find('.resize-mode-web').each(function (i) {
                if ($(this).attr(ID) !== undefined) {
                    onResizeTable($t.tables[$(this).attr(ID)]);
                    //syncGrips($t.tables[$(this).attr(ID)]);
                }
            });
            onColumnResize({ currentTarget: t });
        };

        var showHandles = function (a) {
            $('.JCLRgripInner').each(function (i) {
                $(this).css('display', a ? '' : 'none');
            });
        };

        var changeColumnResizeMode = function (e, forceMode) {
            var tableId = this.parent().parent().find('table:first').attr('id');
            for (var i in $t.tables) {
                if ($t.tables[i].id == tableId) {
                    var t = $t.tables[i];
                    break;
                }
            }
            if (t == undefined || t.resizeInProgress)
                return;

            var guidGenerator = function () {
                var S4 = function () {
                    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
                };
                return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
            };
            var targetMode = 0;
            var stepCount = 30;
            var startedTimers = [];
            var startWidth;
            var tableTargetWidth;
            var tableDx;

            var animFunc = function (el, dx2, targetWidth, timerGuid, startWidth) {
                var idx = -1;
                for (var i = 0; i < startedTimers.length; i++) {
                    if (startedTimers[i] == timerGuid) { idx = i; break; }
                }
                if (idx >= 0)
                    startedTimers.splice(idx, 1);
                if (dx2 == 0) return;
                var w = startWidth !== undefined ? startWidth : el.width(),
                            newW = Math.round(w + dx2);
                el.width(newW + 'px');
                if (Math.abs(newW - targetWidth) >= Math.abs(dx2)) {
                    var guid = guidGenerator();
                    startedTimers.push(guid);
                    setTimeout(function () { animFunc(el, dx2, targetWidth, guid); }, 10);
                }
                realignPager(t);
            };

            if (forceMode == undefined && t.hasClass('resize-mode-web') || forceMode == 1) {
                t.resizeInProgress = true;
                for (var i in t.c) {
                    t.cg.eq(i).width(t.c[i].outerWidth() + "px");
                    t.cg2.eq(i).width(t.c[i].outerWidth() + "px");
                };
                t.css("width", "0");
                t.table2.css("width", "0");
                if (forceMode !== undefined) {
                    if (t.savedColWidth !== undefined && t.savedColWidth.length > 0) {
                        for (var i in t.cg) {
                            t.cg.eq(i).width(t.savedColWidth[i]);
                            t.cg2.eq(i).width(t.savedColWidth[i]);
                        };
                    }
                    else {
                        // для колонок задаем актуальную ширину в пикселях
                        for (var i in t.c) {
                            t.cg.eq(i).width(t.c[i].outerWidth() + "px");
                            t.cg2.eq(i).width(t.c[i].outerWidth() + "px");
                        };
                    }
                }
                else {
                    // плавное переключение из режима 0 (web) в режим 1 (gui)
                    if (t.savedColWidth !== undefined && t.savedColWidth.length > 0) {
                        showHandles(false);
                        tableTargetWidth = 0;
                        for (var i = 0; i < t.savedColWidth.length; i++) {
                            tableTargetWidth += t.savedColWidth[i];
                        }
                        tableDx = (tableTargetWidth - t.width()) / stepCount;
                        if (Math.abs(tableDx) < 0.5)
                            tableDx = tableDx < 0 ? -1 : tableDx > 0 ? 1 : 0;
                        startWidth = t.width();
                        setColumnWidthToPercent(t);
                        animFunc(t, tableDx, tableTargetWidth, null, startWidth);
                        animFunc(t.table2, tableDx, tableTargetWidth, null, startWidth);
                    }
                }
                targetMode = 1;
            } else if (forceMode == undefined && t.hasClass('resize-mode-gui') || forceMode == 0) {
                t.resizeInProgress = true;
                // надо запомнить ширину таблицы
                t.css("width", "0");
                t.table2.css("width", "0");
                for (var i in t.c) { t.savedColWidth[i] = t.c[i].outerWidth(); };
                if (forceMode !== undefined) {
                    setColumnWidthToPercent(t);
                    t.css("width", "100%");
                    t.table2.css("width", "100%");
                    t.prev().css("width", "100%");
                } else {
                    // плавное переключение из режима 1 (gui) в режим 0 (web)
                    showHandles(false);
                    tableTargetWidth = Math.min($(window).width() - t.offset().left - 10, t.closest('.t-grid').width());
                    tableDx = (tableTargetWidth - t.width()) / stepCount;
                    if (Math.abs(tableDx) < 0.5)
                        tableDx = tableDx < 0 ? -1 : tableDx > 0 ? 1 : 0;
                    startWidth = t.width();
                    setColumnWidthToPercent(t);
                    animFunc(t, tableDx, tableTargetWidth, null, startWidth);
                    animFunc(t.table2, tableDx, tableTargetWidth, null, startWidth);
                }
                targetMode = 0;
            }

            var waitResizeFunc = function (t) {
                if (startedTimers.length > 0) {
                    setTimeout(function () { waitResizeFunc(t); }, 100);
                } else {
                    if (targetMode == 1) {
                        if (t.savedColWidth !== undefined && t.savedColWidth.length > 0) {
                            for (var i in t.cg) {
                                t.cg.eq(i).width(t.savedColWidth[i]);
                                t.cg2.eq(i).width(t.savedColWidth[i]);
                            };
                        }
                    }
                    else if (targetMode == 0) {
                        setColumnWidthToPercent(t);
                        t.css("width", "100%");
                        t.table2.css("width", "100%");
                        t.prev().css("width", "100%");
                    }
                    setResizeMode(t, targetMode);
                    realignPager(t);
                    showHandles(true);
                    t.resizeInProgress = false;
                    if (forceMode == undefined) {
                        $.ajax({
                            url: '/SDK.Action/GridSettings/SetColumnResizeMode?gridId=' + t.closest('.t-grid').attr('id') + '&mode=' + (t.hasClass('resize-mode-web') ? 0 : 1),
                            type: "POST",
                            dataType: 'json',
                            cache: false,
                            success: function (data) { showSaveAsDefaultComment(data); }
                        });
                    }
                }
            };

            waitResizeFunc(t);
        };

        $('#' + grid.element.id + ' table:first').colResizable();
        $(grid.element).bind('dataBound', function () {
            onResizeTable($t.tables[$('table:first', this).attr('id')]);
        });
        if (!$t.resizing.canInitResizing) {
            $t.resizing.waitingInitResizing.push(function () {
                if (!!$('#' + grid.element.id).length) {
                    $(document).trigger('telerikgridresizableupdate', grid.element.id);
                }
            });
        }
    };

    function BottomPagerVisible() {
        var pagers = $('div.t-grid-pager.t-grid-top');
        pagers.each(function () {
            var box = this.getBoundingClientRect();
            var bottom = $(this).parent().find('.t-grid-bottom');
            var Bottom = $(this).parent().find('.t-grid-Bottom');
            if (box.top + this.offsetHeight > 0 || this.style.display == "none") {
                bottom.hide();
                Bottom.hide();
            }
            else {
                bottom.show();
                Bottom.show();
            }
        });
    }

})(jQuery);



(function ($) {
    var $t = $.telerik;

    $t.menu = function (element, options) {
        this.element = element;
        this.nextItemZIndex = 100;

        $.extend(this, options);

        $('.t-item:not(.t-state-disabled)', element)
            .live('mouseenter', $t.delegate(this, this.mouseenter), true)
            .live('mouseleave', $t.delegate(this, this.mouseleave), true)
            .live('click', $t.delegate(this, this.click));

        $('.t-item').live('click', $t.delegate(this, this.click));

        $('.t-item:not(.t-state-disabled) > .t-link', element)
            .live('mouseenter', $t.hover)
            .live('mouseleave', $t.leave);

        $(document).click($t.delegate(this, this.documentClick));
        $(".t-menu").click($t.delegate(this, this.otherMenuClick));

        $t.bind(this, {
            select: this.onSelect,
            open: this.onOpen,
            close: this.onClose,
            load: this.onLoad
        });
    }

    function getEffectOptions(item) {
        var parent = item.parent();
        return {
            direction: parent.hasClass('t-menu') ? parent.hasClass('t-menu-vertical') ? 'right' : 'bottom' : 'right'
        };
    };

    function contains(parent, child) {
        try {
            return $.contains(parent, child);
        } catch (e) {
            return false;
        }
    }

    $t.menu.prototype = {

        toggle: function (li, enable) {
            $(li).each(function () {
                $(this)
                    .toggleClass('t-state-default', enable)
                    .toggleClass('t-state-disabled', !enable);
            });
        },

        enable: function (li) {
            this.toggle(li, true);
        },

        disable: function (li) {
            this.toggle(li, false);
        },

        open: function ($li) {
            var menu = this;

            var lazyLoadAttr = $($li).attr('lazyLoad');
            if (lazyLoadAttr && !$($li).attr('lazyLoaded')) {
                $($li).attr('lazyLoaded', 1);
                var imgSpan = $($li).find('.t-icon.t-arrow-next:first');
                imgSpan.removeClass("t-arrow-next");
                imgSpan.addClass("t-loading");
                $.ajax({
                    type: "POST",
                    dataType: "html",
                    url: lazyLoadAttr,
                    traditional: true,
                    success: $.proxy(this.onLazySuccess, { menu: this, li: $li, imgSpan: imgSpan }),
                    error: $.proxy(this.onLazyError, { menu: this, li: $li, imgSpan: imgSpan })
                });
            } else {
                this.openNonLazy($li);
            }
        },

        onLazySuccess: function (data, textStatus, xhr) {
            var ul = $(this.li).find('.t-group:first');
            ul.html(data);
            this.imgSpan.removeClass("t-loading");
            if (ul.children().length) {
                this.imgSpan.addClass("t-arrow-next");
                this.menu.openNonLazy(this.li);
            }
        },

        onLazyError: function (xhr, textStatus, textStatus) {
        },

        openNonLazy: function ($li) {
            var menu = this;

            $($li).each(function () {
                var $item = $(this);

                clearTimeout($item.data('timer'));

                $item.data('timer', setTimeout(function () {
                    var $ul = $item.find('.t-group:first');
                    if ($ul.length) {
                        $t.fx.play(menu.effects, $ul, getEffectOptions($item));
                        $item.css('z-index', menu.nextItemZIndex++);
                    }
                }, 100));
            });
        },

        close: function ($li) {
            var menu = this;

            $($li).each(function (index, item) {
                var $item = $(item);

                clearTimeout($item.data('timer'));

                $item.data('timer', setTimeout(function () {
                    var $ul = $item.find('.t-group:first');
                    if ($ul.length) {
                        $t.fx.rewind(menu.effects, $ul, getEffectOptions($item), function () {
                            $item.css('zIndex', '');
                            if ($(menu.element).find('.t-group:visible').length == 0)
                                menu.nextItemZIndex = 100;
                        });
                        $ul.find('.t-group').stop(false, true);
                    }
                }, 100));
            });
        },

        mouseenter: function (e, element) {
            var $li = $(element);
            if (!this.openOnClick || this.clicked) {
                if (!contains(element, e.relatedTarget)) {
                    this.triggerEvent('open', $li);
                    this.open($li);

                    var parentItem = $li.parent().closest('.t-item')[0];

                    if (parentItem && !contains(parentItem, e.relatedTarget))
                        this.mouseenter(e, parentItem);
                }
            }

            if (this.openOnClick && this.clicked) {
                this.triggerEvent('close', $li);

                $li.siblings().each($.proxy(function (_, sibling) {
                    this.close($(sibling));
                }, this));
            }
        },

        mouseleave: function (e, element) {
            if (!this.openOnClick && !contains(element, e.relatedTarget)) {
                var $li = $(element);
                this.triggerEvent('close', $li);

                this.close($li);

                var parentItem = $li.parent().closest('.t-item')[0];

                if (parentItem && !contains(parentItem, e.relatedTarget))
                    this.mouseleave(e, parentItem);
            }
        },

        click: function (e, element) {
            e.stopPropagation();

            var $li = $(element);

            if ($li.hasClass('t-state-disabled')) {
                e.preventDefault();
                return;
            }

            $t.trigger(this.element, 'select', { item: $li[0] });

            if (!$li.parent().hasClass('t-menu')
                || !this.openOnClick
                || $li.hasClass('not-click')
                || (e != null && e.target != null && ($(e.target).hasClass('out-arrow') || $(e.target).parent().hasClass('out-arrow')))
                || $li.find("ul.t-group").length == 0
                )
                return;

            e.preventDefault();

            this.clicked = true;

            this.triggerEvent('open', $li);

            this.open($li);
        },

        otherMenuClick: function (e, element) {
            if ($.contains(this.element, e.target))
                return;

            if (this.clicked) {
                this.clicked = false;
                $(this.element).children('.t-item').each($.proxy(function (i, item) {
                    this.close($(item));
                }, this));
            }
        },

        documentClick: function (e, element) {
            if ($.contains(this.element, e.target))
                return;

            if (this.clicked) {
                this.clicked = false;
                $(this.element).children('.t-item').each($.proxy(function (i, item) {
                    this.close($(item));
                }, this));
            }
        },

        hasChildren: function ($li) {
            return $li.find('.t-group:first').length;
        },

        triggerEvent: function (eventName, $li) {
            if (this.hasChildren($li))
                $t.trigger(this.element, eventName, { item: $li[0] });
        }
    }

    $.fn.tMenu = function (options) {
        return $t.create(this, {
            name: 'tMenu',
            init: function (element, options) {
                return new $t.menu(element, options);
            },
            options: options
        });
    };

    // default options
    $.fn.tMenu.defaults = {
        orientation: 'horizontal',
        effects: $t.fx.slide.defaults(),
        openOnClick: false
    };
})(jQuery);


(function ($) {

    var $t = $.telerik;

    function markAjaxLoadableNodes($element) {
        $element.find('.t-plus')
                .each(function () {
                    var item = $(this.parentNode);
                    item.parent().data('loaded', item.next('.t-group').length > 0);
                });
    }

    $t.treeview = function (element, options) {
        this.element = element;
        var $element = $(element);

        $.extend(this, options);

        var clickableItems = '.t-in:not(.t-state-selected,.t-state-disabled)';

        $('.t-in.t-state-selected', element)
            .live('mouseenter', $t.preventDefault);

        $element
            .delegate(clickableItems, 'mouseenter', $t.hover)
            .delegate(clickableItems, 'mouseleave', $t.leave)
            .delegate(clickableItems, 'click', $t.delegate(this, this.nodeSelect))
            .delegate('div:not(.t-state-disabled) .t-in', 'dblclick', $t.delegate(this, this.nodeClick))
            .delegate(':checkbox', 'click', $t.delegate(this, this.checkboxClick))
            .delegate('.t-plus, .t-minus', 'click', $t.delegate(this, this.nodeClick));

        if (this.isAjax())
            markAjaxLoadableNodes($element);

        if (this.dragAndDrop) {
            $t.bind(this, {
                nodeDragStart: this.onNodeDragStart,
                nodeDragging: this.onNodeDragging,
                nodeDragCancelled: this.onNodeDragCancelled,
                nodeDrop: this.onNodeDrop,
                nodeDropped: this.onNodeDropped
            });

            (function (treeview) {
                var $dropCue = $('<div class="t-drop-clue" />');
                var $dropTarget;

                function start(e) {
                    if ($t.trigger(treeview.element, 'nodeDragStart', { item: e.$draggable.closest('.t-item')[0] }))
                        return false;

                    $dropCue.appendTo(treeview.element);
                }

                function drag(e) {
                    var status;

                    $dropTarget = $(e.target);

                    var dropPosition = 'over', itemHeight, itemTop, itemContent, delta, insertOnTop, insertOnBottom, addChild;
                    var hoveredItem = $dropTarget.closest('.t-top,.t-mid,.t-bot');
                    var destinationItem = hoveredItem;

                    if (hoveredItem.length > 0) {
                        itemHeight = hoveredItem.outerHeight();
                        itemTop = hoveredItem.offset().top;
                        itemContent = $dropTarget.closest('.t-in');
                        delta = itemHeight / (itemContent.length > 0 ? 4 : 2);

                        insertOnTop = e.pageY < (itemTop + delta);
                        insertOnBottom = (itemTop + itemHeight - delta) < e.pageY;
                        addChild = itemContent.length > 0 && !insertOnTop && !insertOnBottom;

                        if (!addChild) {
                            if (insertOnTop) dropPosition = 'before';
                            if (insertOnBottom) dropPosition = 'after';
                        }
                    }

                    $t.trigger(treeview.element, 'nodeDragging', {
                        pageY: e.pageY,
                        pageX: e.pageX,
                        dropTarget: e.target,
                        destinationItem: destinationItem.parent()[0],
                        dropPosition: dropPosition,
                        setStatusClass: function (value) { status = value },
                        item: e.$draggable.closest('.t-item')[0]
                    });

                    if (status) {
                        $dropCue.css('visibility', 'hidden');
                        $t.dragCueStatus(e.$cue, status);
                        return;
                    }

                    status = 't-insert-middle';

                    if (treeview.dragAndDrop.dropTargets && $(e.target).closest(treeview.dragAndDrop.dropTargets).length > 0) {
                        $t.dragCueStatus(e.$cue, 't-add');
                        return;
                    }

                    if (!$.contains(treeview.element, e.target)) {
                        $dropCue.css('visibility', 'hidden');
                        $t.dragCueStatus(e.$cue, 't-denied');
                        return;
                    } else if ($.contains(e.$draggable.closest('.t-item')[0], e.target)) {
                        // dragging item within itself
                        $dropCue.css('visibility', 'hidden');
                        $t.dragCueStatus(e.$cue, 't-denied');
                        return;
                    }

                    $dropCue.css('visibility', 'visible');

                    if (hoveredItem.length > 0) {
                        itemContent.toggleClass('t-state-hover', addChild);
                        $dropCue.css('visibility', addChild ? 'hidden' : 'visible');

                        if (addChild) {
                            status = 't-add';
                        } else {
                            var hoveredItemPos = hoveredItem.position();
                            hoveredItemPos.top += insertOnTop ? 0 : itemHeight;

                            $dropCue.css(hoveredItemPos)[insertOnTop ? 'prependTo' : 'appendTo']
                                    ($dropTarget.closest('.t-item').find('> div:first'));

                            status = 't-insert-middle';

                            if (insertOnTop && hoveredItem.hasClass('t-top')) status = 't-insert-top';
                            if (insertOnBottom && hoveredItem.hasClass('t-bot')) status = 't-insert-bottom';
                        }
                    }

                    $t.dragCueStatus(e.$cue, status);
                }

                function stop(e) {
                    if (e.keyCode == 27) {
                        $t.trigger(treeview.element, 'nodeDragCancelled', { item: e.$draggable.closest('.t-item')[0] });
                    } else {
                        var dropPosition = 'over', destinationItem;
                        if ($dropCue.css('visibility') == 'visible') {
                            dropPosition = $dropCue.prevAll('.t-in').length > 0 ? 'after' : 'before';
                            destinationItem = $dropCue.closest('.t-item').find('> div');
                        } else if ($dropTarget) {
                            destinationItem = $dropTarget.closest('.t-top,.t-mid,.t-bot');
                        }

                        var isValid = !e.$cue.find('.t-drag-status').hasClass('t-denied'),
                            isDropPrevented = $t.trigger(treeview.element, 'nodeDrop', {
                                isValid: isValid,
                                dropTarget: e.target,
                                destinationItem: destinationItem.parent()[0],
                                dropPosition: dropPosition,
                                item: e.$draggable.closest('.t-item')[0]
                            });

                        if (!isValid) {
                            return false;
                        }

                        if (isDropPrevented || !$.contains(treeview.element, e.target)) {
                            return !isDropPrevented;
                        }

                        var sourceItem = e.$draggable.closest('.t-top,.t-mid,.t-bot');
                        var movedItem = sourceItem.parent(); // .t-item
                        var sourceGroup = sourceItem.closest('.t-group');
                        // dragging item within itself
                        if ($.contains(movedItem[0], e.target)) {
                            return false;
                        }
                        // normalize source group
                        if (movedItem.hasClass('t-last'))
                            movedItem.removeClass('t-last')
                                        .prev()
                                        .addClass('t-last')
                                        .find('> div')
                                        .removeClass('t-top t-mid')
                                        .addClass('t-bot');

                        // perform reorder / move
                        if ($dropCue.css('visibility') == 'visible') {
                            destinationItem.parent()[dropPosition](movedItem);
                        } else {
                            var targetGroup = destinationItem.next('.t-group');

                            if (targetGroup.length === 0) {
                                targetGroup = $('<ul class="t-group" />').appendTo(destinationItem.parent());

                                if (!treeview.isAjax()) {
                                    destinationItem.prepend('<span class="t-icon t-minus" />');
                                } else {
                                    targetGroup.hide();
                                    treeview.nodeToggle(null, destinationItem.parent(), true);
                                    targetGroup.show();
                                }
                            }

                            targetGroup.append(movedItem);

                            if (destinationItem.find('> .t-icon').hasClass('t-plus'))
                                treeview.nodeToggle(null, destinationItem.parent(), true);
                        }

                        var level = movedItem.parents('.t-group').length;

                        function normalizeClasses(item) {
                            var isFirstItem = item.prev().length === 0;
                            var isLastItem = item.next().length === 0;

                            item.toggleClass('t-first', isFirstItem && level === 1)
                                    .toggleClass('t-last', isLastItem)
                                    .find('> div')
                                        .toggleClass('t-top', isFirstItem && !isLastItem)
                                        .toggleClass('t-mid', !isFirstItem && !isLastItem)
                                        .toggleClass('t-bot', isLastItem);
                        };

                        normalizeClasses(movedItem);
                        normalizeClasses(movedItem.prev());
                        normalizeClasses(movedItem.next());

                        // remove source group if it is empty
                        if (sourceGroup.children().length === 0) {
                            sourceGroup.prev('div').find('.t-plus,.t-minus').remove();
                            sourceGroup.remove();
                        }

                        $t.trigger(treeview.element, 'nodeDropped', {
                            destinationItem: destinationItem.closest('.t-item')[0],
                            dropPosition: dropPosition,
                            item: sourceItem.parent('.t-item')[0]
                        });

                        return false;

                    }
                }

                new $t.draggable({
                    owner: treeview.element,
                    selector: 'div:not(.t-state-disabled) .t-in',
                    scope: treeview.element.id,
                    cue: function (e) {
                        return $t.dragCue(e.$draggable.text());
                    },
                    start: start,
                    drag: drag,
                    stop: stop,
                    destroy: function (e) {
                        $dropCue.remove();
                        e.$cue.remove();
                    }
                });

            })(this);
        }

        var $content = $element.find('.t-item > .t-content');
        if ($content.length > 0 && $($content[0]).children().length == 0)
            $element.find('.t-icon').hide();

        $t.bind(this, {
            expand: this.onExpand,
            collapse: this.onCollapse,
            select: $.proxy(function (e) {
                if (e.target == this.element && this.onSelect) this.onSelect(e);
            }, this),
            checked: this.onChecked,
            error: this.onError,
            load: this.onLoad,
            dataBinding: this.onDataBinding,
            dataBound: this.onDataBound
        });
    };

    $t.treeview.prototype = {

        expand: function (li) {
            $(li, this.element).each($.proxy(function (index, item) {
                var $item = $(item);
                var contents = $item.find('> .t-group, > .t-content, > .t-animation-container');
                if ((contents.length > 0 && !contents.is(':visible')) || this.isAjax()) {
                    this.nodeToggle(null, $item);
                }
            }, this));
        },

        collapse: function (li) {
            $(li, this.element).each($.proxy(function (index, item) {
                var $item = $(item),
                    contents = $item.find('> .t-group, > .t-content, > .t-animation-container');
                if (contents.length > 0 && contents.is(':visible')) {
                    this.nodeToggle(null, $item);
                }
            }, this));
        },

        enable: function (li) {
            this.toggle(li, true);
        },

        disable: function (li) {
            this.toggle(li, false);
        },

        toggle: function (li, enable) {
            $(li, this.element).each($.proxy(function (index, item) {
                var $item = $(item),
                    isCollapsed = !$item.find('> .t-group, > .t-content').is(':visible');

                if (!enable) {
                    this.collapse($item);
                    isCollapsed = true;
                }

                $item.find('> div > .t-in')
                        .toggleClass('t-state-default', enable)
                        .toggleClass('t-state-disabled', !enable)
                     .end()
                     .find('> div > .t-checkbox > :checkbox')
                        .attr('disabled', enable ? '' : 'disabled')
                     .end()
                     .find('> div > .t-icon')
                        .toggleClass('t-plus', isCollapsed && enable)
                        .toggleClass('t-plus-disabled', isCollapsed && !enable)
                        .toggleClass('t-minus', !isCollapsed && enable)
                        .toggleClass('t-minus-disabled', !isCollapsed && !enable);

            }, this));
        },

        reload: function (li) {
            var treeView = this;
            $(li).each(function () {
                var $item = $(this);
                $item.find('.t-group').remove();
                treeView.ajaxRequest($item);
            });
        },

        clear: function () {
            $(this.element).find('.t-group').remove();
        },

        shouldNavigate: function (element) {
            var contents = $(element).closest('.t-item').find('> .t-content, > .t-group');
            var href = $(element).attr('href');

            return !((href && (href.charAt(href.length - 1) == '#' || href.indexOf('#' + this.element.id + '-') != -1)) ||
                    (contents.length > 0 && contents.children().length == 0));
        },

        nodeSelect: function (e, element) {

            if (!this.shouldNavigate(element))
                e.preventDefault();

            var $element = $(element);

            if (!$element.hasClass('.t-state-selected') &&
                !$t.trigger(this.element, 'select', { item: $element.closest('.t-item')[0] })) {
                $('.t-in', this.element).removeClass('t-state-hover t-state-selected');

                $element.addClass('t-state-selected');
            }
        },

        nodeToggle: function (e, $item, suppressAnimation) {
            if ($item.find('.t-minus').length == 0 && $item.find('.t-plus').length == 0) {
                return;
            }

            if (e != null)
                e.preventDefault();

            if ($item.data('animating')
             || $item.find('> div > .t-in').hasClass('t-state-disabled'))
                return;

            if (suppressAnimation == null) {
                suppressAnimation = !$item.data().animating;
            }

            $item.data('animating', !suppressAnimation);

            var contents = $item.find('>.t-group, >.t-content, >.t-animation-container>.t-group, >.t-animation-container>.t-content'),
                isExpanding = !contents.is(':visible');

            if (contents.children().length > 0
             && $item.data('loaded') !== false
             && !$t.trigger(this.element, isExpanding ? 'expand' : 'collapse', { item: $item[0] })) {
                $item.find('> div > .t-icon')
                        .toggleClass('t-minus', isExpanding)
                        .toggleClass('t-plus', !isExpanding);

                if (!suppressAnimation)
                    $t.fx[isExpanding ? 'play' : 'rewind'](this.effects, contents, { direction: 'bottom' }, function () {
                        $item.data('animating', false);
                    });
                else
                    contents[isExpanding ? 'show' : 'hide']();
            } else if (isExpanding && this.isAjax() && (contents.length == 0 || $item.data('loaded') === false)) {
                if (!$t.trigger(this.element, isExpanding ? 'expand' : 'collapse', { item: $item[0] }))
                    this.ajaxRequest($item);
            }
        },

        nodeClick: function (e, element) {
            var $element = $(element),
                $item = $element.closest('.t-item');

            if ($element.hasClass('t-plus-disabled') || $element.hasClass('t-minus-disabled'))
                return;

            this.nodeToggle(e, $item);
        },

        isAjax: function () {
            return this.ajax || this.ws || this.onDataBinding;
        },

        url: function (which) {
            return (this.ajax || this.ws)[which];
        },

        ajaxOptions: function ($item, options) {
            var result = {
                type: 'POST',
                dataType: 'text',
                error: $.proxy(function (xhr, status) {
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;

                    if (status == 'parsererror')
                        alert('Error! The requested URL did not return JSON.');
                }, this),

                success: $.proxy(function (data) {
                    data = eval("(" + data + ")");
                    data = data.d || data; // Support the `d` returned by MS Web Services
                    this.dataBind($item, data);
                }, this)
            };

            result = $.extend(result, options);

            var node = this.ws ? result.data.node = {} : result.data;

            if ($item.hasClass('t-item')) {
                node[this.queryString.value] = this.getItemValue($item);
                node[this.queryString.text] = this.getItemText($item);

                var itemCheckbox = $item.find('.t-checkbox:first :checkbox');
                if (itemCheckbox.length)
                    node[this.queryString.checked] = itemCheckbox.is(':checked');
            }

            if (this.ws) {
                result.data = $t.toJson(result.data);
                result.contentType = 'application/json; charset=utf-8';
            }

            return result;
        },

        ajaxRequest: function ($item) {
            showOverlay = false;
            $item = $item || $(this.element);

            var e = { item: $item[0] };

            if ($t.trigger(this.element, 'dataBinding', e) || (!this.ajax && !this.ws))
                return;

            $item.data('loadingIconTimeout', setTimeout(function () {
                $item.find('> div > .t-icon').addClass('t-loading');
            }, 100));

            $.ajax(this.ajaxOptions($item, {
                data: $.extend({}, e.data),
                url: this.url('selectUrl')
            }));
            showOverlay = true;
        },

        bindTo: function (data) {
            this.dataBind(this.element, data);
        },

        dataBind: function ($item, data) {
            $item = $($item); // can be called from user code with dom objects

            if (data.length == 0) {
                $('.t-icon', $item).hide();
                $('ul.t-group', $item).html("");
                return;
            }

            var groupHtml = new $t.stringBuilder(),
                group = $item.find('> .t-group'),
                isGroup = group.length == 0;
            if (isGroup) {
                group = $item.find('> .t-animation-container> .t-group');
                isGroup = group.length == 0;
            }

            $t.treeview.getGroupHtml({
                data: data,
                html: groupHtml,
                isAjax: this.isAjax(),
                isFirstLevel: $item.hasClass('t-treeview'),
                showCheckBoxes: this.showCheckBox,
                groupLevel: $item.find('> div > .t-checkbox :input[name="' + this.element.id + '_checkedNodes.Index"]').val(),
                isExpanded: (isGroup ? $item.eq(0).is('.t-treeview') ? true : data[0].Expanded : false),
                renderGroup: isGroup,
                elementId: this.element.id
            });

            $item.data('animating', true);

            if (group.length > 0 && $item.data('loaded') === false)
                $(groupHtml.string()).prependTo(group);
            else if (group.length > 0 && $item.data('loaded') !== false)
                group.html(groupHtml.string());
            else if (group.length == 0)
                group = $(groupHtml.string()).appendTo($item);

            $t.fx.play(this.effects, group, { direction: 'bottom' }, function () {
                $item.data('animating', false);
            });

            clearTimeout($item.data('loadingIconTimeout'));

            if ($item.hasClass('t-item'))
                $item.data('loaded', true)
                    .find('.t-icon:first')
                        .removeClass('t-loading')
                        .removeClass('t-plus')
                        .addClass('t-minus');

            if (this.isAjax())
                markAjaxLoadableNodes($item);

            $t.trigger(this.element, 'dataBound');
        },

        checkboxClick: function (e, element) {
            var isChecked = $(element).is(':checked');

            var isEventPrevented =
                $t.trigger(this.element, 'checked', {
                    item: $(element).closest('.t-item')[0],
                    checked: isChecked
                });

            if (!isEventPrevented)
                this.nodeCheck(element, isChecked);
            else
                e.preventDefault();

            return isEventPrevented;
        },

        nodeCheck: function (li, isChecked) {
            $(li, this.element).each($.proxy(function (index, item) {
                var $item = $(item).closest('.t-item');
                var $checkboxHolder = $("> div > .t-in > .t-checkbox", $item);
                if ($checkboxHolder.length == 0) {
                    $checkboxHolder = $("div > .t-in > .t-checkbox", $item);
                }
                var arrayName = this.element.id + '_checkedNodes';
                index = $checkboxHolder.find(':input[name="' + arrayName + '.Index"]').val();
                $checkboxHolder.find(':input[name="' + arrayName + '[' + index + '].Text"]').remove();
                $checkboxHolder.find(':input[name="' + arrayName + '[' + index + '].Value"]').remove();

                $checkboxHolder.find(':checkbox').each(function (i, h) {
                    if (isChecked) {
                        $(h).attr({
                            checked: 'checked',
                            value: true
                        });
                    }
                    else {
                        $(h).removeAttr('checked');
                        $(h).attr({ value: false });
                    }
                });

                if (isChecked)
                    $($t.treeview.getNodeInputsHtml(this.getItemValue($item), this.getItemText($item), arrayName, index))
                        .appendTo($checkboxHolder);

            }, this));
        },

        getItemText: function (item) {
            return $(item).find('> div > .t-in').text();
        },

        getItemValue: function (item) {
            return $(item).find('>div>:input[name="itemValue"]').val() || this.getItemText(item);
        }
    };

    // client-side rendering
    $.extend($t.treeview, {
        getNodeInputsHtml: function (itemValue, itemText, arrayName, value) {
            return new $t.stringBuilder()
                .cat('<input type="hidden" value="')
                .cat(itemValue)
                .cat('" name="' + arrayName + '[').cat(value).cat('].Value" class="t-input">')
                .cat('<input type="hidden" value="')
                .cat(itemText)
                .cat('" name="' + arrayName + '[').cat(value).cat('].Text" class="t-input">')
                .string();
        },

        getItemHtml: function (options) {
            var item = options.item,
                html = options.html,
                isFirstLevel = options.isFirstLevel,
                groupLevel = options.groupLevel,
                itemIndex = options.itemIndex,
                itemsCount = options.itemsCount,
                absoluteIndex = new $t.stringBuilder()
                                    .cat(groupLevel).catIf(':', groupLevel).cat(itemIndex)
                                .string();

            html.cat('<li class="t-item')
                    .catIf(' t-first', isFirstLevel && itemIndex == 0)
                    .catIf(' t-last', itemIndex == itemsCount - 1);
            if (item.HtmlClass != null && item.HtmlClass.length > 0) {
                for (var i = 0; i < item.HtmlClass.length; i++) {
                    html.cat(' ').cat(item.HtmlClass[i]);
                }
            }
            html.cat('"');
            if (item.ExtHtmlAttributes != null && item.ExtHtmlAttributes.length > 0) {
                for (var i = 0; i < item.ExtHtmlAttributes.length; i++) {
                    html.cat(' ')
                        .cat(item.ExtHtmlAttributes[i].Key)
                        .cat('="')
                        .cat(item.ExtHtmlAttributes[i].Value)
                        .cat('"');
                }
            }
            html.cat('>')
                .cat('<div class="')
                    .catIf('t-top ', isFirstLevel && itemIndex == 0)
                    .catIf('t-top', itemIndex != itemsCount - 1 && itemIndex == 0)
                    .catIf('t-mid', itemIndex != itemsCount - 1 && itemIndex != 0)
                    .catIf('t-bot', itemIndex == itemsCount - 1)
                .cat('">');

            if ((options.isAjax && item.LoadOnDemand) || (item.Items && item.Items.length > 0))
                html.cat('<span class="t-icon')
                        .catIf(' t-plus', item.Expanded !== true)
                        .catIf(' t-minus', item.Expanded === true)
                        .catIf('-disabled', item.Enabled === false) // t-(plus|minus)-disabled
                    .cat('"></span>');

            if (options.showCheckBoxes && item.Checkable !== false) {
                var arrayName = options.elementId + '_checkedNodes';

                html.cat('<span class="t-checkbox">')
                        .cat('<input type="hidden" value="').cat(absoluteIndex)
                        .cat('" name="').cat(arrayName).cat('.Index')
                        .cat('" class="t-input"/>')

                        .cat('<input type="checkbox" value="').cat(item.Checked === true ? 'True' : 'False')
                        .cat('" class="t-input')
                        .cat('" name="').cat(arrayName).cat('[').cat(absoluteIndex).cat('].Checked"')
                        .catIf(' disabled="disabled"', item.Enabled === false)
                        .catIf(' checked="checked"', item.Checked)
                    .cat('/>');

                if (item.Checked)
                    html.cat($t.treeview.getNodeInputsHtml(item.Value, item.Text, arrayName, absoluteIndex));

                html.cat('</span>');
            }

            var navigateUrl = item.NavigateUrl || item.Url;

            html.cat(navigateUrl ? '<a href="' + navigateUrl + '" class="t-link ' : '<span class="')
                    .cat('t-in')
                    .catIf(' t-state-disabled', item.Enabled === false)
                    .catIf(' t-state-selected', item.Selected === true)
                .cat('">');

            if (item.ImageUrl != null) {
                html.cat('<img class="t-image" alt="" src="').cat(item.ImageUrl).cat('"');
                if (item.ExtImageHtmlAttributes != null && item.ExtImageHtmlAttributes.length > 0) {
                    for (var i = 0; i < item.ExtImageHtmlAttributes.length; i++) {
                        html.cat(' ')
                        .cat(item.ExtImageHtmlAttributes[i].Key)
                        .cat('="')
                        .cat(item.ExtImageHtmlAttributes[i].Value)
                        .cat('"');
                    }
                }
                html.cat(' />');
            }

            if (item.SpriteCssClasses != null)
                html.cat('<span class="t-sprite ').cat(item.SpriteCssClasses).cat('"></span>');

            html.catIf(item.Text, item.Encoded === false)
                .catIf(item.Text.replace(/</g, '&lt;').replace(/>/g, '&gt;'), item.Encoded !== false)
                .cat(navigateUrl ? '</a>' : '</span>');

            if (item.Value)
                html.cat('<input type="hidden" class="t-input" name="itemValue" value="')
                    .cat(item.Value)
                    .cat('" />');

            html.cat('</div>');

            if (item.Items && item.Items.length > 0)
                $t.treeview.getGroupHtml({
                    data: item.Items,
                    html: html,
                    isAjax: options.isAjax,
                    isFirstLevel: false,
                    showCheckBoxes: options.showCheckBoxes,
                    groupLevel: absoluteIndex,
                    isExpanded: item.Expanded,
                    elementId: options.elementId
                });

            html.cat('</li>');
        },

        getGroupHtml: function (options) {
            var data = options.data;
            var html = options.html;
            var isFirstLevel = options.isFirstLevel;
            var renderGroup = options.renderGroup;

            if (renderGroup !== false)
                html.cat('<ul class="t-group')
                    .catIf(' t-treeview-lines', isFirstLevel)
                    .cat('"')
                    .catIf(' style="display:none"', options.isExpanded !== true)
                    .cat('>');

            if (data && data.length > 0) {
                var getItemHtml = $t.treeview.getItemHtml;

                for (var i = 0, len = data.length; i < len; i++)
                    getItemHtml({
                        item: data[i],
                        html: html,
                        isAjax: options.isAjax,
                        isFirstLevel: isFirstLevel,
                        showCheckBoxes: options.showCheckBoxes,
                        groupLevel: options.groupLevel,
                        itemIndex: i,
                        itemsCount: len,
                        elementId: options.elementId
                    });
            }

            if (renderGroup !== false)
                html.cat('</ul>');
        }
    });

    $.fn.tTreeView = function (options) {
        return $t.create(this, {
            name: 'tTreeView',
            init: function (element, options) {
                return new $t.treeview(element, options);
            },
            options: options,
            success: function (treeView) {
                if (treeView.isAjax() && $(treeView.element).find('.t-item').length == 0)
                    treeView.ajaxRequest();
            }
        });
    };

    $.fn.tTreeView.defaults = {
        effects: $t.fx.property.defaults('height'),
        queryString: {
            text: 'Text',
            value: 'Value',
            checked: 'Checked'
        }
    };
})(jQuery);



(function ($) {

    var $t = $.telerik;
    var whiteSpaceRegExp = /\s+/;

    $t.list = {
        htmlBuilder: function (element, className, isSelect) {
            var val,
                text,
                id = element.id,
                name = element.name,
                builder = new $t.stringBuilder(),
                $element = $(element);

            if (isSelect) {
                text = $element.find('option:selected').text();
                val = $element.val();
            } else {
                text = element.value;
            }

            function wrapper() {
                return $(['<div class="t-widget', className, 't-header"></div>'].join(" "));
            }

            this.render = function () {
                $element.wrap(wrapper()).hide();
                var $innerWrapper = $('<div class="t-dropdown-wrap t-state-default"></div>').insertBefore($element);

                this.text({
                    builder: builder,
                    text: text,
                    id: id,
                    name: name
                })
                .appendTo($innerWrapper);

                //button
                $('<span class="t-select"><span class="t-icon t-arrow-down">select</span></span>')
                .appendTo($innerWrapper);

                if (isSelect) {
                    builder.buffer = [];
                    $(builder
                        .cat('<input style="display:none;" type="text" ')
                        .catIf('value="', val, '" ', val)
                        .catIf('name="', name, '" ', name)
                        .cat('/>')
                        .string())
                    .insertAfter($innerWrapper);
                }
            };
            this.text = function (options) {
                return $(['<span class="t-input">', options.text || '&nbsp;', '</span>'].join(""));
            };
        },

        initialize: function () {
            this.previousValue = this.value();
            this.previousText = this.text();

            $t.bind(this, {
                dataBinding: this.onDataBinding,
                dataBound: this.onDataBound,
                error: this.onError,
                open: this.onOpen,
                close: this.onClose,
                valueChange: this.onChange,
                load: this.onLoad
            });
        },

        common: function () {
            this.open = function () {
                if (this.data.length == 0) return;

                var $wrapper = this.$wrapper || this.$element,
                    dropDown = this.dropDown;

                var position = {
                    offset: $wrapper.offset(),
                    outerHeight: $wrapper.outerHeight(),
                    outerWidth: $wrapper.outerWidth(),
                    zIndex: $t.getElementZIndex($wrapper[0]),
                    position: $t.getElementPosition($wrapper[0])
                };
                if (dropDown.$items) {
                    dropDown.open(position);
                } else {
                    this.fill(function () { dropDown.open(position); });
                }
                elma.InitTranslationContainer();
            };
            this.close = function () {
                this.dropDown.close();
                elma.InitTranslationContainer();
            };
            this.dataBind = function (data, preserveStatus) {
                this.data = data = (data || []);

                var index = -1,
                    isAjax = !!this.loader.isAjax();

                for (var i = 0, length = data.length; i < length; i++) {
                    var item = data[i];
                    if (item) {
                        if (item.Selected) {
                            index = i;
                        }
                        if (this.encoded && isAjax && !this.onDataBinding) {
                            data[i].Text = $t.encode(item.Text);
                        }
                    }
                }

                this.dropDown.dataBind(data);

                if (index != -1) {
                    this.index = index;
                    this.select(index);
                }

                if (!preserveStatus) {
                    this.text('');
                    this.$element.val('');
                }
            };
            this.highlight = function (argument) {

                var rebind = function (component) {
                    var previousValue = component.previousValue;
                    var dropDown = component.dropDown;
                    component.close();
                    dropDown.dataBind(component.data);
                    component.previousValue = previousValue;
                    dropDown.$items
                            .removeClass('t-state-selected')
                            .eq(index)
                            .addClass('t-state-selected');
                };
                var index = -1;

                if (!this.data) return index;

                if (!isNaN(argument - 0)) { // index
                    if (argument > -1 && argument < this.data.length) {

                        index = argument;

                        rebind(this);
                    }

                } else if ($.isFunction(argument)) { // predicate

                    for (var i = 0, len = this.data.length; i < len; i++) {
                        if (argument(this.data[i])) {
                            index = i;
                            break;
                        }
                    }

                    if (index != -1)
                        rebind(this);

                } else { // dom node
                    index = this.dropDown.highlight(argument);
                }

                return index;
            };
        },

        filtering: function () {
            this.filter = function (component) {

                component.isFiltered = true;

                var performAjax = true;
                var data = component.data;
                var input = component.$text[0];
                var text = input.value;
                var trigger = component.trigger;
                var dropDown = component.dropDown;

                if (!component.autoFill && $.browser.msie && input.id.indexOf('-input') != -1) {
                    $('#' + input.id.split('-input')[0]).val(text);
                }

                text = this.multiple(text);

                if (text.length < component.minChars) return;

                var filterIndex = component.filter;
                if (component.loader.isAjax()) {

                    if (component.cache && data && data.length > 0) {

                        component.filters[filterIndex](component, data, text);

                        var filteredDataIndexes = component.filteredDataIndexes;

                        if ((filteredDataIndexes && filteredDataIndexes.length > 0)
                        || (filterIndex == 0 && component.selectedIndex != -1))
                            performAjax = false;
                    }

                    if (performAjax) {

                        var postData = component.extendData || {};
                        postData[component.queryString.text] = text;

                        component.loader.ajaxRequest(function (data) {
                            var trigger = component.trigger;
                            var dropDown = component.dropDown;

                            if (data && data.length == 0) {
                                dropDown.close();
                                dropDown.dataBind();
                                return;
                            }
                            if (component.encoded && !component.onDataBinding) {
                                for (var i = 0, length = data.length; i < length; i++) {
                                    var item = data[i];
                                    if (item.Text) {
                                        data[i].Text = $t.encode(item.Text);
                                    } else {
                                        data[i] = $t.encode(item);
                                    }
                                }
                            }

                            component.data = data;

                            $t.trigger(component.element, 'dataBound');

                            component.filters[filterIndex](component, data, text);

                            var $items = dropDown.$items;
                            if ($items.length > 0) {
                                if (!dropDown.isOpened()) trigger.open();
                                component.filtering.autoFill(component, data[this.selectedIndex >= 0 ? this.selectedIndex : 0].Text);
                            }
                            else trigger.close();

                        }, { data: postData });
                    }
                } else {
                    performAjax = false;
                    component.filters[filterIndex](component, component.data, text);
                }

                if (!performAjax) {
                    var $items = dropDown.$items;
                    if (!$items) {
                        return;
                    }

                    var itemsLength = $items.length,
                        selectedIndex = component.selectedIndex;

                    var itemText = filterIndex == 0
                    ? selectedIndex != -1
                    ? data[selectedIndex].Text
                    : ''
                    : $items.length > 0
                    ? $items.first().text()
                    : '';

                    this.autoFill(component, itemText);

                    if (itemsLength == 0) {
                        trigger.close();
                    } else {
                        if (!dropDown.isOpened()) {
                            trigger.open();
                        }
                    }
                }
            };
            this.multiple = function (text) { return text; }; // overriden by autocomplete
        },

        filters: function () { //mixin
            this.filters = [
                function firstMatch(component, data, inputText) {
                    if (!data || data.length == 0) return;
                    var dropDown = component.dropDown;
                    var $items = dropDown.$items;

                    if (!$items || $items.length == 0 || component.loader.isAjax()) {
                        dropDown.dataBind(data);
                        $items = dropDown.$items;
                    }

                    for (var i = 0, length = data.length; i < length; i++) {
                        if (data[i].Text.slice(0, inputText.length).toLowerCase() == inputText.toLowerCase()) {
                            var item = $items[i];

                            component.selectedIndex = i;
                            dropDown.highlight(item);
                            dropDown.scrollTo(item);
                            return;
                        }
                    }

                    $items.removeClass('t-state-selected');
                    component.selectedIndex = -1;

                    $t.list.highlightFirstOnFilter(component, $items);
                },

                createItemsFilter(false, function (inputText, itemText) {
                    return itemText.slice(0, inputText.length).toLowerCase() == inputText.toLowerCase();
                }),

                createItemsFilter(true, function (inputText, itemText) {
                    return itemText && itemText.toLowerCase().indexOf(inputText.toLowerCase()) != -1;
                })
            ];
        },

        loader: function (component) {
            this.ajaxError = false;
            this.component = component;

            this.isAjax = function () {
                return component.ajax || component.ws || component.onDataBinding;
            };

            function ajaxOptions(complete, options) {
                if (!component.lastAjaxRequestIndex) {
                    component.lastAjaxRequestIndex = 0;
                }
                var currentIndex = ++component.lastAjaxRequestIndex;
                var result = {
                    url: (component.ajax || component.ws)['selectUrl'],
                    type: 'POST',
                    data: {},
                    dataType: 'text', // using 'text' instead of 'json' because of DateTime serialization
                    error: function (xhr, status) {
                        component.loader.ajaxError = true;
                        if ($t.ajaxError(component.element, 'error', xhr, status))
                            return;
                    },
                    complete: $.proxy(function () { this.hideBusy(); }, component.loader),

                    success: function (data, status, xhr) {
                        if (component.lastAjaxRequestIndex > currentIndex) {
                            // we sent a newer request
                            return;
                        }

                        try {
                            data = eval('(' + data + ')');
                            if (data && data.error) {
                                jAlert(data.error);
                                return;
                            }
                        } catch (e) {
                            // in case the result is not JSON raise the 'error' event
                            if (!$t.ajaxError(component.element, 'error', xhr, 'parseeror'))
                                jAlert('Error! The requested URL did not return JSON.');
                            component.loader.ajaxError = true;
                            return;
                        }
                        data = data.d || data; // Support the `d` returned by MS Web Services 

                        if (complete)
                            complete.call(component, data);

                    }
                };
                $.extend(result, options);

                if (component.ws) {
                    result.data = $t.toJson(result.data);
                    result.contentType = 'application/json; charset=utf-8';
                }

                return result;
            }

            this.ajaxRequest = function (complete, options) {
                var e = {};

                if ($t.trigger(component.element, 'dataBinding', e))
                    return;

                if (component.ajax || component.ws) {
                    this.showBusy();
                    $.ajax(ajaxOptions(complete, { data: $.extend({}, options ? options.data : {}, e.data) }));
                }
                else
                    if (complete) complete.call(component, component.data);
            },

            this.showBusy = function () {
                this.busyTimeout = setTimeout($.proxy(function () {
                    this.component.$wrapper.find('> .t-dropdown-wrap .t-icon').addClass('t-loading');
                }, this), 100);
            },

            this.hideBusy = function () {
                clearTimeout(this.busyTimeout);
                this.component.$wrapper.find('> .t-dropdown-wrap .t-icon').removeClass('t-loading');
            };
        },

        trigger: function (component) {
            this.component = component;
            this.change = function (customValue) {
                var previousValue = component.previousValue;

                var value;
                if (!!customValue) {
                    value = customValue;
                }
                else
                    value = component.value();
                if (previousValue == undefined || value != previousValue) {
                    $t.trigger(component.element, 'valueChange', { value: value });
                } else if (component.autoFill) {
                    component.text(component.previousText || '');
                }

                component.previousValue = value;
                component.previousText = component.text();

                if (component.multiSelect) component.value(null);
            };
            this.open = function () {
                var dropDown = component.dropDown;
                if ((dropDown.$items && dropDown.$items.length > 0) && !dropDown.isOpened() && !$t.trigger(component.element, 'open'))
                    component.open();
            };
            this.close = function () {
                if (!component.dropDown.$element.is(':animated') && component.dropDown.isOpened() && !$t.trigger(component.element, 'close'))
                    component.close();
            };
        },

        retrieveData: function (select) {
            var items = [];
            var $options = $(select).find('option');

            for (var i = 0, length = $options.length; i < length; i++) {
                var $option = $options.eq(i);
                items[i] = {
                    Text: $option.text(),
                    Value: $option.val(),
                    Selected: $option.is(':selected')
                };
            }
            return items;
        },

        highlightFirstOnFilter: function (component, $items) {
            if (component.highlightFirst) {
                $items.filter(':not(.t-virtual-item)').first().addClass('t-state-selected');
                component.dropDown.scrollTo($items[0]);
            }
        },

        moveToEnd: function (element) {
            if (element.createTextRange) {
                var range = element.createTextRange();
                range.moveStart('textedit', 1);
                range.select();
            }
        },

        selection: function (input, start, end) {
            if (input.createTextRange) {
                var selRange = input.createTextRange();
                selRange.collapse(true);
                selRange.moveStart('character', start);
                selRange.moveEnd('character', end - start);
                selRange.select();
            } else if (input.selectionStart) {
                input.selectionStart = start;
                input.selectionEnd = end;
            }
        },

        updateTextAndValue: function (component, text, value) {
            if (component.encoded) {
                text = $.telerik.decode(text);
            }
            text = elma.htmlDecode(text);
            component.text(text);

            var val = value === null ? text : value;
            component.$element.val(val);
        },

        getZIndex: function (element) {
            var zIndex = 'auto';
            $(element).parents().andSelf().each(function () { //get element 
                zIndex = $(this).css('zIndex');
                if (Number(zIndex)) {
                    zIndex = Number(zIndex) + 1;
                    return false;
                }
            });
            return zIndex;
        },

        keycodes: [8, // backspace
                   9, // tab
                  13, // enter
                  27, // escape
                  37, // left arrow
                  38, // up arrow
                  39, // right arrow
                  40, // down arrow
                  35, // end
                  36, // home
                  46] // delete
    };

    function createItemsFilter(global, condition) {
        return function (component, data, inputText) {

            if (!data || data.length == 0) return;

            var filteredDataIndexes = $.map(data, function (item, index) {
                if (/*component.loader.isAjax() || */condition(inputText, (!item) ? "": item.Text|| (typeof (item) == 'string' ? item : ""))) return index;
            });

            var formatRegExp = new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + inputText.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1") + ")(?![^<>]*>)(?![^&;]+;)", global ? 'ig' : 'i');

            component.filteredDataIndexes = filteredDataIndexes;
            component.selectedIndex = -1;

            component.dropDown.onItemCreate = function (e) {
                if (inputText) e.html = e.html.replace(formatRegExp, "<strong>$1</strong>");
            };
            component.dropDown.dataBind($.map(filteredDataIndexes, function (item, index) {
                return data[item];
            }));

            var $items = component.dropDown.$items;
            $items.removeClass('t-state-selected');
            $t.list.highlightFirstOnFilter(component, $items);
        };
    }

    function firstMatch(data, $items, text) {
        if (!data || !$items) return null;

        var valueLength = text.length;
        text = text.toLowerCase();

        for (var i = 0, length = data.length; i < length; i++) {
            if (data[i].Text.slice(0, valueLength).toLowerCase() == text)
                return $items[i];
        }
    }

    $t.dropDownList = function (element, options) {
        $.extend(this, options);

        var isSelect = element.nodeName.toLowerCase() == 'select';
        if (isSelect && !this.data) {
            this.data = $t.list.retrieveData(element);
            new $t.list.htmlBuilder(element, 't-dropdown', isSelect).render();
            element = element.previousSibling; //set element to input
        }

        var cachedInput = '';
        this.element = element;
        var $element = this.$element = $(element);

        this.loader = new $t.list.loader(this);
        this.trigger = new $t.list.trigger(this);
        this.$wrapper = $element.closest('.t-dropdown');
        this.$text = this.$wrapper.find('> .t-dropdown-wrap > .t-input');

        //allow element to be focused
        if (!this.$wrapper.attr('tabIndex')) this.$wrapper.attr('tabIndex', 0);

        this.dropDown = new $t.dropDown({
            attr: this.dropDownAttr,
            effects: this.effects,
            onClick: $.proxy(function (e) {
                this.select(e.item);
                this.trigger.change();
                this.trigger.close();
                this.$wrapper.focus();
            }, this)
        });

        this.dropDown.$element.css('direction', this.$wrapper.closest('.t-rtl').length ? 'rtl' : '');

        // Focus & hover
        applyInputBorders(this.$wrapper, this.$wrapper.find('> .t-dropdown-wrap'));

        this.fill = function (callback) {
            function updateSelectedItem(component) {
                var selector,
                    value = component.selectedValue || component.value();

                if (value) {
                    selector = function (dataItem) { return value == (dataItem.Value || dataItem.Text); };
                } else {
                    var $items = component.dropDown.$items,
                        selectedIndex = component.index,
                        selectedItemsLength = $items.filter('.t-state-selected').length;

                    selector = selectedIndex != -1 && selectedIndex < $items.length
                            ? selectedIndex
                            : selectedItemsLength > 0
                            ? selectedItemsLength - 1
                            : 0;
                }

                component.select(selector);
            }

            var dropDown = this.dropDown,
                loader = this.loader;

            if (!dropDown.$items && !loader.ajaxError) {
                if (loader.isAjax()) {
                    loader.ajaxRequest(function (data) {
                        this.dataBind(data);
                        updateSelectedItem(this);

                        $t.trigger(this.element, 'dataBound');
                        this.trigger.change();

                        if (callback) callback();
                    });
                }
                else {
                    this.dataBind(this.data);
                    updateSelectedItem(this);

                    if (callback) callback();
                }
            }
        };
        this.enable = function () {
            this.$wrapper
                .removeClass('t-state-disabled')
                .bind({
                    keydown: $.proxy(keydown, this),
                    keypress: $.proxy(keypress, this),
                    click: $.proxy(function (e) {
                        var trigger = this.trigger;
                        var dropDown = this.dropDown;

                        this.$wrapper.focus();

                        if (dropDown.isOpened())
                            trigger.close();
                        else if (!dropDown.$items)
                            this.fill(trigger.open);
                        else
                            trigger.open();
                    }, this)
                });
        };
        this.disable = function () {
            this.$wrapper
                .addClass('t-state-disabled')
                .unbind();
        };
        this.reload = function () {
            this.dropDown.$items = null;
            this.fill();
        };
        this.select = function (item) {
            var index = this.highlight(item);

            if (index == -1) return index;

            this.selectedIndex = index;

            $t.list.updateTextAndValue(this, this.data[index].Text, this.data[index].Value);
        };
        this.text = function (text) {
            if (text !== undefined) {
                //this.previousText = text;
                this.$text.html(text && text.replace(whiteSpaceRegExp, '') ? text : '&nbsp&nbsp');
            } else {
                return this.$text.html();
            }
        };
        this.value = function (value) {
            if (value !== undefined) {
                var index = this.select(function (dataItem) {
                    return value == dataItem.Value;
                });

                if (index == -1) {
                    index = this.select(function (dataItem) {
                        return value == dataItem.Text;
                    });
                }

                if (index != -1)
                    this.previousValue = value; //prevent change event


            } else {
                return this.$element.val();
            }
        };
        $t.list.common.call(this);
        $t.list.initialize.call(this);

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var $dropDown = this.dropDown.$element;
            var isDropDown = $dropDown && $dropDown.parent().length > 0;

            if ($.contains(this.$wrapper[0], e.target)
                || (isDropDown && $.contains($dropDown.parent()[0], e.target)))
                return;

            this.trigger.change();
            this.trigger.close();
        }, this));

        this[this.enabled ? 'enable' : 'disable']();

        // PRIVATE methods
        function resetTimer() {
            clearTimeout(this.timeout);
            this.timeout = setTimeout($.proxy(function () { cachedInput = ''; }, this), 1000);
        }

        function keydown(e) {
            var trigger = this.trigger;
            var dropDown = this.dropDown;
            var key = e.keyCode || e.which;

            // close dropdown
            if (e.altKey && key == 38) {
                trigger.close();
                return;
            }

            // open dropdown
            if (e.altKey && key == 40) {
                trigger.open();
                return;
            }

            if (key > 34 && key < 41) {

                e.preventDefault();

                if (!dropDown.$items) {
                    var component = this;
                    this.fill(function () { $.proxy(keydown, component)(e); }, true); //creates items
                    return;
                }

                var $items = dropDown.$items,
                    $selectedItem = $($items[this.selectedIndex]);

                var $item = (key == 35) ? $items.filter(':not(.t-virtual-item)').last() // end
                         : (key == 36) ? $items.filter(':not(.t-virtual-item)').first() // home
                         : (key == 37 || key == 38) ? $selectedItem.prevAll(':not(.t-virtual-item)').first() // up
                         : (key == 39 || key == 40) ? $selectedItem.nextAll(':not(.t-virtual-item)').first() // down
                         : [];

                if ($item.length) {
                    var item = $item[0];

                    this.select(item);
                    dropDown.scrollTo(item);

                    if (!dropDown.isOpened())
                        trigger.change();
                }
            }

            if (key == 8) {
                resetTimer();
                e.preventDefault();
                cachedInput = cachedInput.slice(0, -1);
            }

            if (key == 9 || key == 13) {
                trigger.change();
                trigger.close();
            }

            if (key == 27) {
                if (this.multiSelect) {
                    this.text('');
                    this.$element.val('');
                } else {
                    this.text(this.previousText);
                    this.$element.val(this.previousValue);
                }
                trigger.change();
                trigger.close();
            }
        }

        function keypress(e) {
            var dropDown = this.dropDown;
            var key = e.keyCode || e.charCode;

            if (key == 0 || $.inArray(key, $t.list.keycodes) != -1 || e.ctrlKey || e.altKey || e.shiftKey) return;

            if (!dropDown.$items) {
                this.fill();
                return;
            }

            var tempInputValue = cachedInput;

            tempInputValue += String.fromCharCode(key);

            if (tempInputValue) {

                var item = firstMatch(this.data, dropDown.$items, tempInputValue);

                if (item) {
                    this.select(item);
                    dropDown.scrollTo(item);
                }

                cachedInput = tempInputValue;
            }

            resetTimer();
        }
    };
    $.fn.tDropDownList = function (options) {
        return $t.create(this, {
            name: 'tDropDownList',
            init: function (element, options) {
                return new $t.dropDownList(element, options);
            },
            options: options
        });
    };

    // default options
    $.fn.tDropDownList.defaults = {
        effects: $t.fx.slide.defaults(),
        accessible: false,
        index: 0,
        enabled: true,
        encoded: true
    };

})(jQuery);


(function ($) {

    var $t = $.telerik;

    $t.combobox = function (element, options) {
        $.extend(this, options);

        var isTextBox = element.nodeName.toLowerCase() == 'input' && element.type.toLowerCase() == 'text';
        var isSelect = element.nodeName.toLowerCase() == 'select';

        if ((isTextBox || isSelect) && !$(element).parent().hasClass("t-combobox")) {
            if (isSelect && !this.data) {
                this.data = $t.list.retrieveData(element);
            }

            var htmlBuilder = new $t.list.htmlBuilder(element, 't-combobox', isSelect);

            htmlBuilder.text = function (options) {
                var builder = options.builder;
                builder.buffer = [];
                return $(builder
                        .cat('<input class="t-input" autocomplete="off" type="text" ')
                        .catIf('value="', options.text, '" ', options.text)
                        .catIf('name="', options.name, '-input" ', options.name)
                        .cat('/>')
                        .string());
            };
            htmlBuilder.render();

            if (isSelect) {
                element = element.previousSibling; //set element to input
            }
        }

        this.element = element;
        var $element = this.$element = $(element)
        .bind({
            focus: function (e) {
                var input = e.target;
                setTimeout(function () {
                    if ($.browser.msie) {
                        input.select();
                    } else {
                        input.selectionStart = 0;
                        input.selectionEnd = input.value.length;
                    }
                }, 0);
            }

        });

        this.loader = new $t.list.loader(this);
        this.trigger = new $t.list.trigger(this);
        var $wrapper = this.$wrapper = $element.closest('.t-combobox');
        var $selectIcon = this.$wrapper.find('.t-select');

        var pasteMethod = $.browser.msie ? 'paste' : 'input';
        var $text = this.$text = this.$wrapper.find('> .t-dropdown-wrap > .t-input')
                                     .attr('autocomplete', 'off')
                                     .bind(pasteMethod, $.proxy(function (e) {
                                         var value = e.target.value;
                                         if ($.browser.msie && element && element.document && element.document.selection) {
                                             var selectedText = element.document.selection.createRange().text;
                                             var text = window.clipboardData.getData("Text");

                                             if (selectedText && selectedText.length > 0) {
                                                 value = value.replace(selectedText, text);
                                             } else {
                                                 value += text;
                                             }
                                         }

                                         if (!this.autoFill) this.$element.val(value);
                                         resetTimer(this);
                                     }, this));

        $wrapper.find(".t-input").bind("click", function () {
            $text.focus();
        });
        // Focus & hover
        applyInputBorders(this.$text, this.$wrapper.find('> .t-dropdown-wrap'));

        var updateCssOnPropertyChange = function (e) {
            var attr = 'class',
                classValue = $element.attr(attr);
            if (classValue != $text.attr(attr)) {
                if (typeof classValue != "undefined")
                    $text.attr(attr, classValue);
                $text.addClass('t-input');
            }
        };
        if ($.browser.msie) {
            element.attachEvent("onpropertychange", updateCssOnPropertyChange);

        } else {
            $element.bind("DOMAttrModified", updateCssOnPropertyChange);
        }

        $element.bind("valueChange", function (e) {
            if (e.isImmediatePropagationStopped()) return;
            if (e.value == '') $element.data("tComboBox").text('');
        });

        if (!$element.attr('disabled')) {
            $selectIcon.bind('click', $.proxy(togglePopup, this));
        }

        this.filtering = new $t.list.filtering(this);
        this.filtering.autoFill = function (component, itemText) {
            if (component.autoFill && (component.lastKeyCode != 8 && component.lastKeyCode != 46)) {
                
                var input = component.$text[0];

                var endIndex = $t.caretPos(input);

                var filterString = input.value.substring(0, endIndex);

                var matchIndex = itemText.toLowerCase().indexOf(filterString.toLowerCase());

                if (matchIndex != -1) {

                    var stringToAppend = itemText.substring(matchIndex + filterString.length);

                    input.value =  $.telerik.decode(filterString + stringToAppend);

                    $t.list.selection(input, endIndex, endIndex + stringToAppend.length);
                }
            }
        };
        this.dropDown = new $t.dropDown({
            attr: this.dropDownAttr,
            effects: this.effects,
            onOpen: $.proxy(function () {
                var data = this.data;
                var dropDown = this.dropDown;
                if (data.length == 0) return;

                var text = this.$text.val();
                var selectedIndex = this.selectedIndex;

                if (selectedIndex !== undefined && selectedIndex !== null && selectedIndex != -1 && this.isFiltered) {
                    if (text == data[selectedIndex].Text) {
                        this.filteredDataIndexes = [];
                        dropDown.onItemCreate = null;
                        dropDown.dataBind(this.data);
                        this.select(dropDown.$items[selectedIndex]);
                    } else
                        this.filters[this.filter](this, this.data, text);

                    this.isFiltered = false;
                }
            }, this),
            onItemCreate: options.onItemCreate,
            onClick: $.proxy(function (e) {
                this.select(e.item);
                if (!this.multiSelect) {
                    this.xElement.show();
                }
                this.trigger.change();
                this.trigger.close();
                $text.focus();
            }, this)
        });

        this.dropDown.$element.css('direction', $wrapper.closest('.t-rtl').length ? 'rtl' : '');

        this.enable = function () {
            $wrapper.removeClass('t-state-disabled');
            $text.removeAttr("disabled");
            $selectIcon.unbind('click');
            $selectIcon.bind('click', $.proxy(togglePopup, this));
        };
        this.disable = function () {
            $wrapper.addClass('t-state-disabled');
            $text.attr('disabled', 'disabled');
            $selectIcon.unbind('click');
        };
        this.extendData = {};
        this.fill = function (callback, forceLoad, postOptions) {
            function updateSelection(component) {
                var value = component.selectedValue || component.value();

                if (value) {
                    component.value(value);
                    return;
                }

                var $items = dropDown.$items;
                var selectedIndex = component.index;
                var $selectedItems = $items.filter('.t-state-selected');
                var selectedItemsLength = $selectedItems.length;

                var item = selectedIndex != -1 && selectedIndex < $items.length
                    ? $items[selectedIndex]
                    : selectedItemsLength > 0
                    ? $selectedItems[selectedItemsLength - 1]
                    : null;

                if (item)
                    component.select(item);
                else {
                    component.selectedIndex = -1;
                    if (component.highlightFirst)
                        component.highlight($items[0]);
                }
            }

            var loader = this.loader;
            var dropDown = this.dropDown;
            var minChars = this.minChars;
            var textValue = this.text();
            var textValueLength = textValue.length;

            if (!!forceLoad || (!dropDown.$items && !loader.ajaxError)) {
                if (loader.isAjax() && (!!forceLoad || textValueLength >= minChars)) {

                    var postData = $.extend({}, this.extendData);

                    $.extend(postData, postOptions);

                    postData[this.queryString.text] = !!forceLoad ? "" : textValue;
                    postData["showOnlyGroups"] = $wrapper.attr('showOnlyGroups') == 'true';

                    loader.ajaxRequest(function (data) {
                        this.dataBind(data, true);
                        updateSelection(this);

                        $t.trigger(this.element, 'dataBound');
                        this.trigger.change();

                        if (callback) callback();
                    },
                    { data: postData });
                }
                else {
                    this.dataBind(this.data, true);
                    updateSelection(this);
                    if (callback) callback();
                }
            }
        };
        this.reload = function (callback) {
            this.dropDown.$items = null;
            this.fill(callback, true);
        };
        this.isNativeComponent = true;
        this.xElement = this.$wrapper.find('div:first-child').find('span.combobox-x-icon-wrapper');
        this.$text
            .bind('input', $.proxy(function() {
                this.xElement.hide();
            }, this))
            .focusout($.proxy(function() {
                if (this.value() && !this.multiSelect) {
                    this.xElement.show();
                }
            }, this));
        this.select = function (item) {
            var index = this.highlight(item);

            if (index == -1) return index;

            var filteredDataIndexes = this.filteredDataIndexes;

            //set selected Index
            this.selectedIndex = (filteredDataIndexes && filteredDataIndexes.length > 0 && filteredDataIndexes.length > index) ? filteredDataIndexes[index] : index;
            var selectedItem = this.data[this.selectedIndex];
            this.selectedValue = selectedItem.Value;
            $t.list.updateTextAndValue(this, selectedItem.DropDownText != null ? selectedItem.Text : $(this.dropDown.$items[index]).text(), selectedItem.Value);
            this._textChanged = false;
        };
        this.reloadSelect = function (val) {
            var mas = String(val).split('_');
            var previousValue = this.previousValue;
            var self = this;
            this.fill(function () {
                self.select(function (data) {
                    if (!mas || mas == NaN || mas == null)
                        return false;
                    var resultB = false;
                    for (var key in mas) {
                        if (mas[key] == data.Value)
                            resultB = true;
                    }
                    return resultB;
                });
                self.previousValue = previousValue;
                for (var key in mas) {
                    self.trigger.change(mas[key]);
                }
            }, true, { 'id': val });

        };
        this.text = function (text) {
            if (text !== undefined) {
                //this.previousText = text;
            }
            return this.$text.val.apply(this.$text, arguments);
        };
        this.value = function () {
            if (arguments.length) {
                var value = arguments[0];
                var index = this.select(function (dataItem) {
                    return value == (dataItem.Value || dataItem.Text);
                });

                if (index == -1) {
                    this.selectedIndex = index;
                    this.$element.val(value);
                    this.text(value);
                }
                this.previousValue = this.$element.val(); //prevent change event

            } else {
                return this.$element.val();
            }
        };
        $t.list.common.call(this);
        $t.list.filters.call(this);
        $t.list.initialize.call(this);

        this.clearSelect = function () {
            this.$element.val('');
            this.selectedValue = '';
            this.xElement.hide();
            this.text('');
        }

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var $dropDown = this.dropDown.$element;
            var isDropDown = $dropDown && $dropDown.parent().length > 0;

            if ($.contains(this.$wrapper[0], e.target)
                || (isDropDown && $.contains($dropDown.parent()[0], e.target)))
                return;

            if (this._textChanged) {
                this._textChanged = false;
                var dataItem = findItemByText(this.data, this.$text.val());
                if (dataItem) {
                    this.text(dataItem.Text);
                    this.$element.val(dataItem.Value || dataItem.Text);
                }
            }

            this.trigger.change();
            this.trigger.close();

            if (!this.isNativeComponent) {
                this.text('');
                this.$text.blur();
            }

        }, this));

        this.$text
            .bind({
                change: $.proxy(function (e) { e.stopPropagation(); }, this),
                keydown: $.proxy(keydown, this),
                keypress: $.proxy(keypress, this),
                paste: $.proxy(paste, this),
                focus: $.proxy(function (e) {
                    if (this.openOnFocus) {
                        var trigger = this.trigger;
                        var dropDown = this.dropDown;
                        if (!dropDown.$items) {
                            this.fill(trigger.open);
                        } else {
                            trigger.open();
                        }
                    }
                    var $text = this.$text;
                    $t.list.selection($text[0], 0, $text.val().length);

                }, this)
            });

        function togglePopup(e) {
            var dropDown = this.dropDown,
                trigger = this.trigger;

            this.loader.ajaxError = false;
            if (!dropDown.isOpened()) {
                this.dropDown.$items = null;
                dropDown.$items = null;
                if (!dropDown.$items) {
                    this.fill(trigger.open, true);
                } else {
                    trigger.open();
                }
                $text[0].focus();
            } else {
                this.previousText = this.$text.val();
                trigger.close();
            }
        }

        //PRIVATE
        function resetTimer(component) {
            clearTimeout(component.timeout);
            component.timeout = setTimeout(function () { component.filtering.filter(component); }, component.delay);
        }

        function keydown(e) {
            var trigger = this.trigger;
            var dropDown = this.dropDown;
            var key = e.keyCode || e.which;
            this.lastKeyCode = key;

            //close dropdown
            if (e.altKey && key == 38) {
                trigger.close();
                return;
            }

            //open dropdown
            if (e.altKey && key == 40 || !e.shiftKey && (key == 38 || key == 40) && this.multiSelect && !dropDown.isOpened()) {
                if (!dropDown.$items) {
                    this.fill(trigger.open, true);
                } else {
                    trigger.open();
                }
                return;
            }

            if (!e.shiftKey && (key == 38 || key == 40)) {
                
                e.preventDefault();
                
                if (!dropDown.$items) {
                    var component = this;
                    this.fill(function () { $.proxy(keydown, component)(e); }, true); //creates items
                    return;
                }
                var $items = dropDown.$items;

                var $selectedItem = $items.filter('.t-state-selected:first');

                var $item = $selectedItem.length == 0 || $items.length == 1 ? $items.first()
                             : (key == 38) ? $selectedItem.prev() // up
                             : (key == 40) ? $selectedItem.next() // down
                             : [];

                if ($item.length) {
                    var item = $item[0];
                    while ($(item).hasClass('t-virtual-item')) {
                        if (key == 40) {
                            item = $(item).next();
                        } else {
                            item = $(item).prev();
                        }
                        if (!item) {
                            break;
                        }
                    }
                    if (item) {
                        this.select(item);
                        if (dropDown.isOpened()) {
                            this.xElement.hide(); //arrow up/down
                        }
                        dropDown.scrollTo(item);

                        if (!dropDown.isOpened()) trigger.change();
                    }
                }
            }

            if (key == 8 || key == 46) {
                var $text = this.$text;

                if ($text.val() != '') resetTimer(this); //reset and start filtering after delay

                setTimeout($.proxy(function () {
                    if ($text.val() == '') {
                        this.selectedIndex = -1;
                        this.$element.val('');
                    } else {
                        if (!this.autoFill) this.$element.val(this.$text.val());
                    }
                }, this), 0);
            }

            if (key == 13) {
                if (dropDown.isOpened()) e.preventDefault();

                var $selectedItems = dropDown.$items != null ? dropDown.$items.filter('.t-state-selected:first') : null;

                if ($selectedItems != null && $selectedItems.length > 0) {
                    this.select($selectedItems[0]);
                }
                else
                    if (!this.autoFill) this.$element.val(this.$text.val());

                trigger.change();
                if (!this.multiSelect) {
                    this.xElement.show(); //enter
                }
                trigger.close();
                $t.list.moveToEnd(this.$text[0]);
            }

            if (key == 9) {
                var dataItem = findItemByText(this.data, this.$text.val());
                if (dataItem) {
                    this.text(dataItem.Text);
                    this.$element.val(dataItem.Value || dataItem.Text);
                    if (!this.multiSelect) {
                        this.xElement.show(); //tab on fill text
                    } 
                }
                
                trigger.change();
                trigger.close();
            }

            if (key == 27) {
                if (this.multiSelect) {
                    this.text('');
                    this.$element.val('');
                } else {
                    if (this.isNativeComponent || !dropDown.isOpened()) {
                        this.text(this.previousText);
                        this._textChanged = false;
                        this.$element.val(this.previousValue);
                    }
                    if (!this.multiSelect && this.previousValue != '') {
                        this.xElement.show(); //esc
                    }
                }
                trigger.change();
                trigger.close();
                this.$text.blur();
            }
        }

        function paste(e) {
            if ((this.isNumeric == true)) {

                setTimeout($.proxy(function () {
                    var val = this.$text[0].value;
                    var parsedValue = parseInt(val, 10);
                    if (parsedValue == val && parsedValue >= this.minValue && parsedValue <= this.maxValue) {
                        this.val = parsedValue;
                    }
                    else {
                        this.$element.val(this.val);
                        this.text(this.val);
                    }
                }, this));
            }
        }

        function keypress(e) {
            this._textChanged = true;
            var key = e.keyCode || e.charCode;

            if (this.isNumeric == true) {
                if ((key == 0 || ($.inArray(key, $t.list.keycodes) != -1 && e.charCode == 0) || e.ctrlKey)) return true;
            }
            else {
                if (!e.shiftKey && (key == 0 || $.inArray(key, $t.list.keycodes) != -1 || e.ctrlKey)) return true;
            }

            // always set value. Select(item) will override it if needed.
            if ((this.isNumeric == true) && !(key >= 48 && key <= 57)) {
                return false;
            }
            else {
                if ((this.isNumeric == true)) {
                    setTimeout($.proxy(function () {
                        var parsedValue = parseInt(this.$text[0].value, 10);
                        if (parsedValue >= this.minValue && parsedValue <= this.maxValue) {
                            this.val = parsedValue;
                        }
                        else {
                            this.$element.val(this.val);
                            this.text(this.val);
                        }
                    }, this));
                }
            }

            resetTimer(this);
        }
    };

    function findItemByText(data, inputText, insensitive) {
        if (!inputText) {
            return;
        }

        if (!!insensitive) {
            inputText = inputText.toLowerCase();
        }
        if (data) {
            //find if text has exact match with one of data items.
            for (var i = 0, len = data.length; i < len; i++) {
                var dataItem = data[i],
                    text = dataItem.Text;

                if (!insensitive && text == inputText ||
                    !!insensitive && text.toLowerCase() == inputText) {
                    return dataItem;
                }
            }
        }
        if (!insensitive) {
            return findItemByText(data, inputText, 1);
        }
    }

    $.fn.tComboBox = function (options) {
        return $t.create(this, {
            name: 'tComboBox',
            init: function (element, options) {
                return new $t.combobox(element, options);
            },
            options: options
        });
    };

    // default options
    $.fn.tComboBox.defaults = {
        encoded: true,
        openOnFocus: false,
        multiSelect: false,
        effects: $t.fx.slide.defaults(),
        index: -1,
        autoFill: true,
        highlightFirst: true,
        filter: 0,
        delay: 400,
        minChars: 0,
        cache: true,
        queryString: {
            text: 'text'
        },
        val: "",
        maxValue: 0,
        minValue: 0,
        isNumeric: false
    };
})(jQuery);


(function ($) {

    var $t = $.telerik;

    $.fn.tComboBoxTemplateMode = function (options) {
        return $t.create(this, {
            name: 'tComboBox',
            init: function (element, options) {
                var combobox = new $t.combobox(element, options);
                return customizeCombobox(combobox);
            },
            options: options
        });
    };

    // default options
    $.fn.tComboBoxTemplateMode.defaults = {
        encoded: true,
        openOnFocus: false,
        multiSelect: false,
        effects: $t.fx.slide.defaults(),
        index: -1,
        autoFill: true,
        highlightFirst: true,
        filter: 0,
        delay: 400,
        minChars: 0,
        cache: true,
        queryString: {
            text: 'text'
        },
        val: "",
        maxValue: 0,
        minValue: 0,
        isNumeric: false
    };

    function customizeCombobox(combobox) {
        //select override
        combobox.select = $.proxy(function (item) {
            var index = this.highlight(item);

            if (index == -1) return index;

            var filteredDataIndexes = this.filteredDataIndexes;

            //set selected Index
            this.selectedIndex = (filteredDataIndexes && filteredDataIndexes.length > 0 && filteredDataIndexes.length > index) ? filteredDataIndexes[index] : index;
            var selectedItem = this.data[this.selectedIndex];
            this.selectedValue = selectedItem.Value;
            $t.list.updateTextAndValue(this, selectedItem.DropDownText != null ? selectedItem.Text : $(this.dropDown.$items[index]).text(), selectedItem.Value);

            this._textChanged = false;   
            // Создание блока для шаблона вывода: создается один единственный раз
            this.templateWrapper = this.$wrapper.find('div:first-child').find('div.combobox-template-wrapper');
            if (this.templateWrapper.length == 0) {
                this.templateWrapper = $("<div></div>").addClass('combobox-template-wrapper');
                this.templateWrapper.bind('click',
                    $.proxy(function() {
                            this.$text.focus();
                        },
                        this));
                this.templateWrapper
                    .mouseenter($.proxy(function() { this.$wrapper.find('div:first-child').addClass('t-input-hover'); },
                        this))
                    .mouseleave($.proxy(function() {
                            this.$wrapper.find('div:first-child').removeClass('t-input-hover');
                        },
                        this));
				this.templateWrapper.find(':first-child').remove();
				this.innerTemplateWrapper = $("<div></div>").addClass('combobox-inner-template-wrapper');
                this.templateWrapper.append(this.innerTemplateWrapper);
                this.$wrapper.find('div:first-child').append(this.templateWrapper);
                this.templateWrapper.hide();
            }
            this.previousText = this.text;
            // Формируем строку вывода по шаблону
            var selector = elma.EntitySelector.Manager.get(this.$element.attr('id'));
            var itemFormat = selector.initConfig.itemFormat;
            if (itemFormat.indexOf("item.EntityUrl") >= 0) {
                if (selectedItem.EntityUrl == null || selectedItem.EntityUrl == '') {
                    itemFormat = '<div class="combobox-default-template">{item.Text}</div>';
                }
            }
            var itemHtml = elma.repString(itemFormat, 'item', selectedItem, false);
            // Подменяем
			if(this.innerTemplateWrapper == undefined){
				this.innerTemplateWrapper = this.templateWrapper.find(':first-child');
			}
            this.innerTemplateWrapper.find(':first-child').remove();
            this.innerTemplateWrapper.append(itemHtml);
            
            if (!this.$text.is(':focus')) {
                this.$text.focus();
            }
        }, combobox);

        //text override
        combobox.text = $.proxy(function (text) {
            var result;
            if (!this.$element.val() || this.$element.val() == undefined) {
                result = '';
            } else if (this.$text.val() != '' && this.$text.val() !== undefined) {
                result = this.$text.val();
            } else {
                result = combobox.$wrapper.find('.combobox-template-text-element').text();
            }
            this.$text.val.apply(this.$text, arguments);
            return result;
        }, combobox);

        //override flag
        combobox.isNativeComponent = false;

        //override clearSelect
        combobox.clearSelect = function () {
            combobox.$element.val('');
            combobox.selectedValue = '';
            setTimeout($.proxy(function () {
                this.xElement.hide();
                this.templateWrapper.hide();
                this.editElement.hide();
                this.text('');
            }, combobox), 0);
        }

        combobox.editElement = combobox.$wrapper.find('div:first-child').find('span.combobox-template-edit-icon-wrapper');
        combobox.templateWrapper = combobox.$wrapper.find('div:first-child').find('div.combobox-template-wrapper');

        return combobox;
    }
})(jQuery);



(function($) {


var $t = $.telerik;
    
function makeMap(items) {
    var obj = {};
        
    for (var i = 0; i < items.length; i++)
        obj[items[i]] = true;
        
    return obj;
}

var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed'.split(','));
var blockElements = 'div,p,h1,h2,h3,h4,h5,h6,address,applet,blockquote,button,center,dd,dir,dl,dt,fieldset,form,frameset,hr,iframe,isindex,li,map,menu,noframes,noscript,object,ol,pre,script,table,tbody,td,tfoot,th,thead,tr,ul'.split(',');
var block = makeMap(blockElements);
var inline = makeMap('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(','));
var fillAttrs = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected'.split(','));


var normalize = function (node) {
    if (node.nodeType == 1)
        node.normalize();
}

if ($.browser.msie && parseInt($.browser.version) > 8) {
    normalize = function(parent) {
        if (parent.nodeType == 1 && parent.firstChild) {
            var prev = parent.firstChild,
                node = prev;
            
            while (node = node.nextSibling) {
                if (node.nodeType == 3 && prev.nodeType == 3) {
                    node.nodeValue = prev.nodeValue + node.nodeValue;
                    dom.remove(prev);
                }
                prev = node;
            }
        }
    }
}

function findNodeIndex(node) {
    var i = 0;
    while (node = node.previousSibling) i++;
    return i;
}

function isDataNode(node) {
    return node && node.nodeValue !== null && node.data !== null;
}

function isAncestorOf(parent, node) {
    try {
        return !isDataNode(parent) && ($.contains(parent, isDataNode(node) ? node.parentNode : node) || node.parentNode == parent);
    } catch (e) {
        return false;
    }
}

function isAncestorOrSelf(root, node) {
    return isAncestorOf(root, node) || root == node;
}

function findClosestAncestor(root, node) {
    if (isAncestorOf(root, node))
        while (node && node.parentNode != root)
            node = node.parentNode;

    return node;
}

function getNodeLength(node) {
    return isDataNode(node) ? node.length : node.childNodes.length;
}

function splitDataNode(node, offset) {
    var newNode = node.cloneNode(false);
    node.deleteData(offset, node.length);
    newNode.deleteData(0, offset);
    dom.insertAfter(newNode, node);
}

function attrEquals(node, attributes) {
    for (var key in attributes) {
        var value = node[key];

        if (key == 'float')
            value = node[$.support.cssFloat ? "cssFloat" : "styleFloat"];

        if (typeof value == 'object') {
            if (!attrEquals(value, attributes[key]))
                return false;
        } else if (value != attributes[key])
            return false;
    }

    return true;
}

var whitespace = /^\s+$/;
var rgb = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;
var cssAttributes = ('color,padding-left,padding-right,padding-top,padding-bottom,\
background-color,background-attachment,background-image,background-position,background-repeat,\
border-top-style,border-top-width,border-top-color,\
border-bottom-style,border-bottom-width,border-bottom-color,\
border-left-style,border-left-width,border-left-color,\
border-right-style,border-right-width,border-right-color,\
font-family,font-size,font-style,font-variant,font-weight,line-height'
).split(',');

var dom = {
    blockParentOrBody: function(node) {
        return dom.parentOfType(node, blockElements) || node.ownerDocument.body;
    },
    normalize: normalize,
    toHex: function (color) {
        var matches = rgb.exec(color);

        if (!matches) return color;

        return '#' + $.map(matches.slice(1), function (x) {
            return x = parseInt(x).toString(16), x.length > 1 ? x : '0' + x;
        }).join('');
    },

    encode: function (value) {
        return value.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\u00a0/g, '&nbsp;');
    },

    name: function (node) {
        return node.nodeName.toLowerCase();
    },
        
    significantChildNodes: function(node) {
        return $.grep(node.childNodes, function(child) {
            return child.nodeType != 3 || !dom.isWhitespace(child);
        });
    },
        
    lastTextNode: function(node) {
        if (node.nodeType == 3)
            return node;
            
        var result = null;
            
        for (var child = node.lastChild; child; child = child.previousSibling)
            if (result = dom.lastTextNode(child))
                return result;
                
        return result;
    },

    is: function (node, nodeName) {
        return dom.name(node) == nodeName;
    },
        
    isMarker: function(node) {
        return node.className == 't-marker';
    },
        
    isWhitespace: function(node) {
        return whitespace.test(node.nodeValue);
    },
        
    isBlock: function(node) {
        return block[dom.name(node)];
    },

    isEmpty: function(node) {
        return empty[dom.name(node)];
    },
        
    isInline: function(node) {
        return inline[dom.name(node)];
    },
        
    scrollTo: function (node) {
        node.ownerDocument.body.scrollTop = $(isDataNode(node) ? node.parentNode : node).offset().top;
    },

    insertAt: function (parent, newElement, position) {
        parent.insertBefore(newElement, parent.childNodes[position] || null);
    },

    insertBefore: function (newElement, referenceElement) {
        if (referenceElement.parentNode)
            return referenceElement.parentNode.insertBefore(newElement, referenceElement);
        else
            return referenceElement;
    },

    insertAfter: function (newElement, referenceElement) {
        return referenceElement.parentNode.insertBefore(newElement, referenceElement.nextSibling);
    },

    remove: function (node) {
        node.parentNode.removeChild(node);
    },

    trim: function (parent) {
        for (var i = parent.childNodes.length - 1; i >= 0; i--) {
            var node = parent.childNodes[i];
            if (isDataNode(node)) {
                if (node.nodeValue.replace(/\ufeff/g, '').length == 0)
                    dom.remove(node);
                if (dom.isWhitespace(node))
                    dom.insertBefore(node, parent);
            } else if (node.className != 't-marker') {
                dom.trim(node);
                if (node.childNodes.length == 0 && !dom.isEmpty(node))
                    dom.remove(node);
            }
        }

        return parent;
    },

    parentOfType: function (node, tags) {
        do {
            node = node.parentNode;
        } while (node && !(dom.ofType(node, tags)));

        return node;
    },

    ofType: function (node, tags) {
        return $.inArray(dom.name(node), tags) >= 0;
    },

    changeTag: function (referenceElement, tagName) {
        var newElement = dom.create(referenceElement.ownerDocument, tagName);
        var attributes = referenceElement.attributes;

        for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[i];
            if (attribute.specified) {
                // IE < 8 cannot set class or style via setAttribute
                var name = attribute.nodeName;
                var value = attribute.nodeValue;
                if (name == 'class')
                    newElement.className = value;
                else if (name == 'style')
                    newElement.style.cssText = referenceElement.style.cssText;
                else
                    newElement.setAttribute(name, value);
            }
        }

        while (referenceElement.firstChild)
            newElement.appendChild(referenceElement.firstChild);

        dom.insertBefore(newElement, referenceElement);
        dom.remove(referenceElement);
        return newElement;
    },

    wrap: function (node, wrapper) {
        dom.insertBefore(wrapper, node);
        wrapper.appendChild(node);
        return wrapper;
    },

    unwrap: function (node) {
        var parent = node.parentNode;
        while (node.firstChild)
            parent.insertBefore(node.firstChild, node);

        parent.removeChild(node);
    },

    create: function (document, tagName, attributes) {
        return dom.attr(document.createElement(tagName), attributes);
    },

    attr: function (element, attributes) {
        attributes = $.extend({}, attributes);

        if (attributes && 'style' in attributes) {
            dom.style(element, attributes.style);
            delete attributes.style;
        }
        return $.extend(element, attributes);
    },

    style: function (node, value) {
        $(node).css(value || {});
    },

    unstyle: function (node, value) {
        for (var key in value) {
            if (key == 'float')
                key = $.support.cssFloat ? "cssFloat" : "styleFloat";

            node.style[key] = '';
        }

        if (node.style.cssText == '')
            node.removeAttribute('style');
    },

    inlineStyle: function(document, name, attributes) {
        var span = dom.create(document, name, attributes);
        
        document.body.appendChild(span);
                
        var $span = $(span);
                
        var style = $.map(cssAttributes, function(value) {
            if ($.browser.msie && value == 'line-height' && $span.css(value) == "1px")
                return 'line-height:1.5';
            else
                return value + ':' + $span.css(value);
        }).join(';');
                
        $span.remove();
        
        return style;
    },

    commonAncestor: function () {
        var count = arguments.length;

        if (!count)
            return null;

        if (count == 1)
            return arguments[0];

        var paths = [];
        var minPathLength = Infinity;

        for (var i = 0; i < count; i++) {
            var ancestors = [];
            var node = arguments[i];
            while (node) {
                ancestors.push(node);
                node = node.parentNode;
            }
            paths.push(ancestors.reverse());
            minPathLength = Math.min(minPathLength, ancestors.length);
        }

        if (count == 1)
            return paths[0][0];

        var output = null;
        for (i = 0; i < minPathLength; i++) {
            var first = paths[0][i];

            for (var j = 1; j < count; j++)
                if (first != paths[j][i])
                    return output;

            output = first;
        }
        return output;
    }
}
var fontSizeMappings = 'xx-small,x-small,small,medium,large,x-large,xx-large'.split(','),
    quoteRe = /"/g

function domToXhtml(root) {
    var result = [];
    var tagMap = {
        'telerik:script': { start: function (node) { result.push('<script'); attr(node); result.push('>'); }, end: function () { result.push('</script>') } },
        b: { start: function () { result.push('<strong>') }, end: function () { result.push('</strong>') } },
        i: { start: function () { result.push('<em>') }, end: function () { result.push('</em>') } },
        u: { start: function () { result.push('<span style="text-decoration:underline;">') }, end: function () { result.push('</span>') } },
        font: {
            start: function (node) {
                result.push('<span style="');

                var color = node.getAttribute('color');
                var size = fontSizeMappings[node.getAttribute('size')];
                var face = node.getAttribute('face');

                if (color) {
                    result.push('color:')
                    result.push(dom.toHex(color));
                    result.push(';');
                }

                if (face) {
                    result.push('font-face:');
                    result.push(face);
                    result.push(';');
                }

                if (size) {
                    result.push('font-size:');
                    result.push(size);
                    result.push(';');
                }

                result.push('">');
            },
            end: function (node) {
                result.push('</span>');
            }
        }
    };

    function attr(node) {
        var specifiedAttributes = [],
            attributes = node.attributes,
            trim = $.trim;

        if (dom.is(node, 'img')) {
            var width = node.style.width,
                height = node.style.height,
                $node = $(node);

            if (width) {
                $node.attr('width', parseInt(width));
                dom.unstyle(node, { width: undefined });
            }

            if (height) {
                $node.attr('height', parseInt(height));
                dom.unstyle(node, { height: undefined });
            }
        }

        for (var i = 0, l = attributes.length; i < l; i++) {
            var attribute = attributes[i];
            var name = attribute.nodeName;
            // In IE < 8 the 'value' attribute is not returned as 'specified'. The same goes for type="text"
            if (attribute.specified || (name == 'value' && node.value != '') || (name == 'type' && attribute.nodeValue == 'text'))
                if (name.indexOf('_moz') < 0 && name != 'complete')
                    specifiedAttributes.push(attribute);
        }

        if (!specifiedAttributes.length)
            return;

        specifiedAttributes.sort(function (a, b) {
            return a.nodeName > b.nodeName ? 1 : a.nodeName < b.nodeName ? -1 : 0;
        });

        for (var i = 0, l = specifiedAttributes.length; i < l; i++) {
            var attribute = specifiedAttributes[i];
            var attributeName = attribute.nodeName;
            var attributeValue = attribute.nodeValue;

            result.push(' ');
            result.push(attributeName);
            result.push('="');
            if (attributeName == 'style') {
                // In IE < 8 the style attribute does not return proper nodeValue
                var css = trim(attributeValue || node.style.cssText).split(';');

                for (var cssIndex = 0, len = css.length; cssIndex < len; cssIndex++) {
                    var pair = css[cssIndex];
                    if (pair.length) {
                        var propertyAndValue = pair.split(':');
                        var property = trim(propertyAndValue[0].toLowerCase()),
                            value = trim(propertyAndValue[1]);

                        if (property.indexOf('color') >= 0)
                            value = dom.toHex(value);
                        
                        if (property.indexOf('font-family') >= 0) {
                            value = value.replace(quoteRe, "'");
                        }

                        result.push(property);
                        result.push(':');
                        result.push(value);
                        result.push(';');
                    }
                };
            } else if (attributeName == 'src' || attributeName == 'href') {
                result.push(node.getAttribute(attributeName, 2));
            } else {
                result.push(fillAttrs[attributeName] ? attributeName : attributeValue);
            }

            result.push('"');
        }
    }

    function children(node, skip) {
        for (var childNode = node.firstChild; childNode; childNode = childNode.nextSibling)
            child(childNode, skip);
    }

    function child(node, skip) {
        var nodeType = node.nodeType;
        if (nodeType == 1) {
            if (node.attributes['_moz_dirty'] && dom.is(node, 'br'))
                return;

            var tagName = dom.name(node);
            var mapper = tagMap[tagName];

            if (mapper) {
                mapper.start(node);
                children(node);
                mapper.end(node);
                return;
            }

            result.push('<');
            result.push(tagName);

            attr(node);

            if (empty[tagName]) {
                result.push(' />');
            } else {
                result.push('>');
                children(node, skip || dom.is(node, 'pre'));
                result.push('</');
                result.push(tagName);
                result.push('>');
            }
        } else if (nodeType == 3) {
            var value = node.nodeValue;
                
            if (!skip && $.support.leadingWhitespace) {
                var parent = node.parentNode;
                var previous = (dom.isInline(parent) ? parent : node).previousSibling;

                if (!previous || previous.innerHTML == '' || dom.isBlock(previous))
                    value = value.replace(/^[\r\n\v\f\t ]+/, '');
                    
                value = value.replace(/ +/, ' ');
            }
                
            result.push(dom.encode(value));
            
        } else if (nodeType == 4) {
            result.push('<![CDATA[');
            result.push(node.data);
            result.push(']]>');
        } else if (nodeType == 8) {
            if (node.data.indexOf('[CDATA[') < 0) {
                result.push('<!--');
                result.push(node.data);
                result.push('-->');
            } else {
                result.push('<!');
                result.push(node.data);
                result.push('>');
            }
        }
    }

    children(root);

    return result.join('');
}
var START_TO_START = 0,
    START_TO_END = 1,
    END_TO_END = 2,
    END_TO_START = 3;


function documentFromRange(range) {
    var startContainer = range.startContainer;
    return startContainer.nodeType == 9 ? startContainer : startContainer.ownerDocument;
}

function selectionFromWindow(window) {
    if ($.browser.msie) {
        return new W3CSelection(window.document);
    }
    
    return window.getSelection(); 
}

function selectionFromRange(range) {
    var document = documentFromRange(range);
    return selectionFromDocument(document);
}

function selectionFromDocument(document) {
    return selectionFromWindow(windowFromDocument(document));
}

function windowFromDocument(document) {
    return document.defaultView || document.parentWindow;
}

function split(range, node, trim) {
    function partition(start) {
        var partitionRange = range.cloneRange();
        partitionRange.collapse(start);
        partitionRange[start ? 'setStartBefore' : 'setEndAfter'](node);
        var contents = partitionRange.extractContents();
        if (trim)
            contents = dom.trim(contents);
        dom[start ? 'insertBefore' : 'insertAfter'](contents, node);
    }
    partition(true);
    partition(false);
}

function selectRange(range) {
    var image = RangeUtils.image(range);
    if (image) {
        range.setStartAfter(image);
        range.setEndAfter(image);
    }
    var selection = selectionFromRange(range);
    selection.removeAllRanges();
    selection.addRange(range);
}

function W3CRange(doc) {
    $.extend(this, {
        ownerDocument: doc, /* not part of the spec; used when cloning ranges, traversing the dom and creating fragments */
        startContainer: doc,
        endContainer: doc,
        commonAncestorContainer: doc,
        startOffset: 0,
        endOffset: 0,
        collapsed: true
    });
};

W3CRange.prototype = {
    // Positioning Methods

    setStart: function (node, offset) {
        this.startContainer = node;
        this.startOffset = offset;
        updateRangeProperties(this);
        fixIvalidRange(this, true);
    },

    setEnd: function (node, offset) {
        this.endContainer = node;
        this.endOffset = offset;
        updateRangeProperties(this);
        fixIvalidRange(this, false);
    },

    setStartBefore: function (node) {
        this.setStart(node.parentNode, findNodeIndex(node));
    },

    setStartAfter: function (node) {
        this.setStart(node.parentNode, findNodeIndex(node) + 1);
    },

    setEndBefore: function (node) {
        this.setEnd(node.parentNode, findNodeIndex(node));
    },

    setEndAfter: function (node) {
        this.setEnd(node.parentNode, findNodeIndex(node) + 1);
    },

    selectNode: function (node) {
        this.setStartBefore(node);
        this.setEndAfter(node);
    },

    selectNodeContents: function (node) {
        this.setStart(node, 0);
        this.setEnd(node, node[node.nodeType === 1 ? 'childNodes' : 'nodeValue'].length);
    },

    collapse: function (toStart) {
        if (toStart)
            this.setEnd(this.startContainer, this.startOffset);
        else
            this.setStart(this.endContainer, this.endOffset);
    },

    // Editing Methods

    deleteContents: function () {
        var range = this.cloneRange();

        if (this.startContainer != this.commonAncestorContainer)
            this.setStartAfter(findClosestAncestor(this.commonAncestorContainer, this.startContainer));

        this.collapse(true);

        (function deleteSubtree(iterator) {
            while (iterator.next())
                iterator.hasPartialSubtree() ? deleteSubtree(iterator.getSubtreeIterator())
                                            : iterator.remove();
        })(new RangeIterator(range));
    },
    
    cloneContents: function () {
        // clone subtree
        var document = documentFromRange(this);
        return (function cloneSubtree(iterator) {
                for (var node, frag = document.createDocumentFragment(); node = iterator.next(); ) {
                        node = node.cloneNode(!iterator.hasPartialSubtree());
                        if (iterator.hasPartialSubtree())
                                node.appendChild(cloneSubtree(iterator.getSubtreeIterator()));
                        frag.appendChild(node);
                }
                return frag;
        })(new RangeIterator(this));
    },

    extractContents: function () {
        var range = this.cloneRange();

        if (this.startContainer != this.commonAncestorContainer)
            this.setStartAfter(findClosestAncestor(this.commonAncestorContainer, this.startContainer));

        this.collapse(true);

        var self = this;

        var document = documentFromRange(this);

        return (function extractSubtree(iterator) {
            for (var node, frag = document.createDocumentFragment(); node = iterator.next(); ) {
                iterator.hasPartialSubtree() ? node = node.cloneNode(false) : iterator.remove(self.originalRange);

                if (iterator.hasPartialSubtree())
                    node.appendChild(extractSubtree(iterator.getSubtreeIterator()));

                frag.appendChild(node);
            }

            return frag;
        })(new RangeIterator(range));
    },

    insertNode: function (node) {
        if (isDataNode(this.startContainer)) {
            if (this.startOffset != this.startContainer.nodeValue.length)
                splitDataNode(this.startContainer, this.startOffset);

            dom.insertAfter(node, this.startContainer);
        } else {
            dom.insertAt(this.startContainer, node, this.startOffset);
        }

        this.setStart(this.startContainer, this.startOffset);
    },

    cloneRange: function () {
        // fast copy
        return $.extend(new W3CRange(this.ownerDocument), {
            startContainer: this.startContainer,
            endContainer: this.endContainer,
            commonAncestorContainer: this.commonAncestorContainer,
            startOffset: this.startOffset,
            endOffset: this.endOffset,
            collapsed: this.collapsed,

            originalRange: this /* not part of the spec; used to update the original range when calling extractContents() on clones */
        });
    },

    // used for debug purposes
    toString: function () {
        var startNodeName = this.startContainer.nodeName,
            endNodeName = this.endContainer.nodeName;

        return [startNodeName == "#text" ? this.startContainer.nodeValue : startNodeName, '(', this.startOffset, ') : ',
                endNodeName == "#text" ? this.endContainer.nodeValue : endNodeName, '(', this.endOffset, ')'].join('');
    }
}
/* can be used in Range.compareBoundaryPoints if we need it one day */
function compareBoundaries(start, end, startOffset, endOffset) {
    if (start == end)
        return endOffset - startOffset;

    // end is child of start
    var container = end;
    while (container && container.parentNode != start)
        container = container.parentNode;

    if (container)
        return findNodeIndex(container) - startOffset;

    // start is child of end
    container = start;
    while (container && container.parentNode != end)
        container = container.parentNode;

    if (container)
        return endOffset - findNodeIndex(container) - 1;

    // deep traversal
    var root = dom.commonAncestor(start, end);
    var startAncestor = start;

    while (startAncestor && startAncestor.parentNode != root)
        startAncestor = startAncestor.parentNode;

    if (!startAncestor)
        startAncestor = root;

    var endAncestor = end;
    while (endAncestor && endAncestor.parentNode != root)
        endAncestor = endAncestor.parentNode;

    if (!endAncestor)
        endAncestor = root;

    if (startAncestor == endAncestor)
        return 0;

    return findNodeIndex(endAncestor) - findNodeIndex(startAncestor);
}

function fixIvalidRange(range, toStart) {
    function isInvalidRange(range) {
        try {
            return compareBoundaries(range.startContainer, range.endContainer, range.startOffset, range.endOffset) < 0;
        } catch (ex) {
            // range was initially invalid (e.g. when cloned from invalid range) - it must be fixed
            return true;
        }
    }

    if (isInvalidRange(range)) {
        if (toStart) {
            range.commonAncestorContainer = range.endContainer = range.startContainer;
            range.endOffset = range.startOffset;
        } else {
            range.commonAncestorContainer = range.startContainer = range.endContainer;
            range.startOffset = range.endOffset;
        }

        range.collapsed = true;
    }
}

function updateRangeProperties(range) {
    range.collapsed = range.startContainer == range.endContainer && range.startOffset == range.endOffset;

    var node = range.startContainer;
    while (node && node != range.endContainer && !isAncestorOf(node, range.endContainer))
        node = node.parentNode;

    range.commonAncestorContainer = node;
}

function createRange(document) {
    if ($.browser.msie) {
        return new W3CRange(document);
    }
    
    return document.createRange();
}


function RangeIterator(range) {
    $.extend(this, {
        range: range,
        _current: null,
        _next: null,
        _end: null
    });

    if (range.collapsed)
        return;

    var root = range.commonAncestorContainer;

    this._next = range.startContainer == root && !isDataNode(range.startContainer) ?
    range.startContainer.childNodes[range.startOffset] :
    findClosestAncestor(root, range.startContainer);

    this._end = range.endContainer == root && !isDataNode(range.endContainer) ?
    range.endContainer.childNodes[range.endOffset] :
    findClosestAncestor(root, range.endContainer).nextSibling;
}

RangeIterator.prototype = {
    hasNext: function () {
        return !!this._next;
    },

    next: function () {
        var current = this._current = this._next;
        this._next = this._current && this._current.nextSibling != this._end ?
        this._current.nextSibling : null;

        if (isDataNode(this._current)) {
            if (this.range.endContainer == this._current)
                (current = current.cloneNode(true)).deleteData(this.range.endOffset, current.length - this.range.endOffset);

            if (this.range.startContainer == this._current)
                (current = current.cloneNode(true)).deleteData(0, this.range.startOffset);
        }

        return current;
    },

    traverse: function (callback) {
        function next() {
            this._current = this._next;
            this._next = this._current && this._current.nextSibling != this._end ? this._current.nextSibling : null;
            return this._current;
        }

        var current;

        while (current = next.call(this)) {
            if (this.hasPartialSubtree())
                this.getSubtreeIterator().traverse(callback);
            else
                callback(current)
        }

        return current;
    },

    remove: function (originalRange) {
        var inStartContainer = this.range.startContainer == this._current;
        var inEndContainer = this.range.endContainer == this._current;

        if (isDataNode(this._current) && (inStartContainer || inEndContainer)) {
            var start = inStartContainer ? this.range.startOffset : 0;
            var end = inEndContainer ? this.range.endOffset : this._current.length;
            var delta = end - start;

            if (originalRange && (inStartContainer || inEndContainer)) {
                if (this._current == originalRange.startContainer && start <= originalRange.startOffset)
                    originalRange.startOffset -= delta;

                if (this._current == originalRange.endContainer && end <= originalRange.endOffset)
                    originalRange.endOffset -= delta;
            }

            this._current.deleteData(start, delta);
        } else {
            var parent = this._current.parentNode;

            if (originalRange && (this.range.startContainer == parent || this.range.endContainer == parent)) {
                var nodeIndex = findNodeIndex(this._current);

                if (parent == originalRange.startContainer && nodeIndex <= originalRange.startOffset)
                    originalRange.startOffset -= 1;

                if (parent == originalRange.endContainer && nodeIndex < originalRange.endOffset)
                    originalRange.endOffset -= 1;
            }

            dom.remove(this._current);
        }
    },

    hasPartialSubtree: function () {
        return !isDataNode(this._current) &&
        (isAncestorOrSelf(this._current, this.range.startContainer) ||
            isAncestorOrSelf(this._current, this.range.endContainer));
    },

    getSubtreeIterator: function () {
        var subRange = this.range.cloneRange();
        subRange.selectNodeContents(this._current);

        if (isAncestorOrSelf(this._current, this.range.startContainer))
            subRange.setStart(this.range.startContainer, this.range.startOffset);
        if (isAncestorOrSelf(this._current, this.range.endContainer))
            subRange.setEnd(this.range.endContainer, this.range.endOffset);

        return new RangeIterator(subRange);
    }
};

function W3CSelection(doc) {
    this.ownerDocument = doc;
    this.rangeCount = 1;
};

W3CSelection.prototype = {
    addRange: function (range) {
        var textRange = this.ownerDocument.body.createTextRange();

        // end container should be adopted first in order to prevent selection with negative length
        adoptContainer(textRange, range, false);
        adoptContainer(textRange, range, true);

        textRange.select();
    },

    removeAllRanges: function () {
        this.ownerDocument.selection.empty();
    },

    getRangeAt: function () {
        var textRange, range = new W3CRange(this.ownerDocument), selection = this.ownerDocument.selection;

        try {
            textRange = selection.createRange();
        } catch (ex) {
            return range;
        }

        if (selection.type == 'Control') {
            range.selectNode(textRange.item(0));
        } else {
            adoptEndPoint(textRange, range, true);
            adoptEndPoint(textRange, range, false);

            if (range.startContainer.nodeType == 9)
                range.setStart(range.endContainer, range.startOffset);
                
            if (range.endContainer.nodeType == 9)
                range.setEnd(range.startContainer, range.endOffset);

            if (textRange.compareEndPoints('StartToEnd', textRange) == 0)
                range.collapse(false);
        }
        return range;
    }
}

function adoptContainer(textRange, range, start) {
    // find anchor node and offset
    var container = range[start ? 'startContainer' : 'endContainer'];
    var offset = range[start ? 'startOffset' : 'endOffset'], textOffset = 0;
    var anchorNode = isDataNode(container) ? container : container.childNodes[offset] || null;
    var anchorParent = isDataNode(container) ? container.parentNode : container;
    // visible data nodes need a text offset
    if (container.nodeType == 3 || container.nodeType == 4)
        textOffset = offset;

    // create a cursor element node to position range (since we can't select text nodes)
    var cursorNode = anchorParent.insertBefore(dom.create(range.ownerDocument, 'a'), anchorNode);

    var cursor = range.ownerDocument.body.createTextRange();
    cursor.moveToElementText(cursorNode);
    dom.remove(cursorNode);
    cursor[start ? 'moveStart' : 'moveEnd']('character', textOffset);
    cursor.collapse(false);
    textRange.setEndPoint(start ? 'StartToStart' : 'EndToStart', cursor);
}

function adoptEndPoint(textRange, range, start) {
    var cursorNode = dom.create(range.ownerDocument, 'a'), cursor = textRange.duplicate();
    cursor.collapse(start);
    var parent = cursor.parentElement();
    do {
        parent.insertBefore(cursorNode, cursorNode.previousSibling);
        cursor.moveToElementText(cursorNode);
    } while (cursor.compareEndPoints(start ? 'StartToStart' : 'StartToEnd', textRange) > 0 && cursorNode.previousSibling);

    cursor.setEndPoint(start ? 'EndToStart' : 'EndToEnd', textRange);

    var target = cursorNode.nextSibling;

    if (!target) {
        // at end of text node
        target = cursorNode.previousSibling;

        if (target && isDataNode(target)) { // in case of collapsed range in empty tag
            range.setEnd(target, target.nodeValue.length);
            dom.remove(cursorNode);
        } else {
            range.selectNodeContents(parent);
            dom.remove(cursorNode);
            range.endOffset -= 1; // cursorNode was in parent
        }

        return;
    }

    dom.remove(cursorNode);

    if (isDataNode(target))
        range[start ? 'setStart' : 'setEnd'](target, cursor.text.length);
    else
        range[start ? 'setStartBefore' : 'setEndBefore'](target);
}

 function RangeEnumerator(range) {
    this.enumerate = function () {
        var nodes = [];

        function visit(node) {
            if (dom.is(node, 'img') || (node.nodeType == 3 && !dom.isWhitespace(node))) {
                nodes.push(node);
            } else {
                node = node.firstChild;
                while (node) {
                    visit(node);
                    node = node.nextSibling;
                }
            }
        }

        new RangeIterator(range).traverse(visit);

        return nodes;
    }
}

function textNodes(range) {
    return new RangeEnumerator(range).enumerate();
}

function blockParents(nodes) {
    var blocks = [];

    for (var i = 0, len = nodes.length; i < len; i++) {
        var block = dom.parentOfType(nodes[i], blockElements);
        if (block && $.inArray(block, blocks) < 0)
            blocks.push(block);
    }

    return blocks;
}

function getMarkers(range) {
    var markers = [];

    new RangeIterator(range).traverse(function (node) {
        if (node.className == 't-marker')
            markers.push(node);
    });

    return markers;
}

function RestorePoint(range) {
    var rootNode = documentFromRange(range);

    this.body = rootNode.body;

    this.html = this.body.innerHTML;
        
    function index(node) {
        var result = 0, lastType = node.nodeType;

        while (node = node.previousSibling) {
            var nodeType = node.nodeType;
                
            if (nodeType != 3 || lastType != nodeType)
                result ++;
                
            lastType = nodeType;
        }
            
        return result;
    }

    function offset(node, value) {
        if (node.nodeType == 3) {
            while ((node = node.previousSibling) && node.nodeType == 3)
                value += node.nodeValue.length;
        }
        return value;
    }

    function nodeToPath(node) {
        var path = [];
            
        while (node != rootNode) {
            path.push(index(node));
            node = node.parentNode;
        }

        return path;
    }

    function pathToNode(path) {
        var node = rootNode, length = path.length;

        while (length--)
            node = node.childNodes[path[length]];

        return node;
    }

    this.startContainer = nodeToPath(range.startContainer);
    this.endContainer = nodeToPath(range.endContainer);
    this.startOffset = offset(range.startContainer, range.startOffset);
    this.endOffset = offset(range.endContainer, range.endOffset);

    this.toRange = function () {
        var result = range.cloneRange();

        result.setStart(pathToNode(this.startContainer), this.startOffset);
        result.setEnd(pathToNode(this.endContainer), this.endOffset);

        return result;
    }
}

function Marker() {
    var caret;

    this.addCaret = function (range) {
        caret = dom.create(documentFromRange(range), 'span', { className: 't-marker' });
        range.insertNode(caret);
        range.selectNode(caret);
        return caret;
    }

    this.removeCaret = function (range) {
        var previous = caret.previousSibling;
        var startOffset = 0;
            
        if (previous)
            startOffset = isDataNode(previous) ? previous.nodeValue.length : findNodeIndex(previous);

        var container = caret.parentNode;
        var containerIndex = previous ? findNodeIndex(previous) : 0;

        dom.remove(caret);
        normalize(container);

        var node = container.childNodes[containerIndex];
            
        if (isDataNode(node))
            range.setStart(node, startOffset);
        else if (node) {
            var textNode = dom.lastTextNode(node);
            if (textNode)
                range.setStart(textNode, textNode.nodeValue.length);
            else
                range[previous ? 'setStartAfter' : 'setStartBefore'](node);
        } else {
            if (!$.browser.msie && container.innerHTML == '')
                container.innerHTML = '<br _moz_dirty="" />';
                
            range.selectNodeContents(container);
        }
        range.collapse(true);
    }

    this.add = function (range, expand) {
        if (expand && range.collapsed) {
            this.addCaret(range);
            range = RangeUtils.expand(range);
        }

        var rangeBoundary = range.cloneRange();

        rangeBoundary.collapse(false);
        this.end = dom.create(documentFromRange(range), 'span', { className: 't-marker' });
        rangeBoundary.insertNode(this.end);

        rangeBoundary = range.cloneRange();
        rangeBoundary.collapse(true);
        this.start = this.end.cloneNode(true);
        rangeBoundary.insertNode(this.start);

        range.setStartBefore(this.start);
        range.setEndAfter(this.end);

        normalize(range.commonAncestorContainer);

        return range;
    }

    this.remove = function (range) {
        var start = this.start, end = this.end;

        normalize(range.commonAncestorContainer);

        while (!start.nextSibling && start.parentNode) start = start.parentNode;
        while (!end.previousSibling && end.parentNode) end = end.parentNode;

        var shouldNormalizeStart = (start.previousSibling && start.previousSibling.nodeType == 3)
                                && (start.nextSibling && start.nextSibling.nodeType == 3);

        var shouldNormalizeEnd = (end.previousSibling && end.previousSibling.nodeType == 3)
                                && (end.nextSibling && end.nextSibling.nodeType == 3);

        start = start.nextSibling;
        end = end.previousSibling;

        var collapsed = false;
        var collapsedToStart = false;
        // collapsed range
        if (start == this.end) {
            collapsedToStart = !!this.start.previousSibling;
            start = end = this.start.previousSibling || this.end.nextSibling;
            collapsed = true;
        }

        dom.remove(this.start);
        dom.remove(this.end);

        if (start == null || end == null) {
            range.selectNodeContents(range.commonAncestorContainer);
            range.collapse(true);
            return;
        }

        var startOffset = collapsed ? isDataNode(start) ? start.nodeValue.length : start.childNodes.length : 0;
        var endOffset = isDataNode(end) ? end.nodeValue.length : end.childNodes.length;

        if (start.nodeType == 3)
            while (start.previousSibling && start.previousSibling.nodeType == 3) {
                start = start.previousSibling;
                startOffset += start.nodeValue.length;
            }

        if (end.nodeType == 3)
            while (end.previousSibling && end.previousSibling.nodeType == 3) {
                end = end.previousSibling;
                endOffset += end.nodeValue.length;
            }
        var startIndex = findNodeIndex(start), startParent = start.parentNode;
        var endIndex = findNodeIndex(end), endParent = end.parentNode;

        for (var startPointer = start; startPointer.previousSibling; startPointer = startPointer.previousSibling)
            if (startPointer.nodeType == 3 && startPointer.previousSibling.nodeType == 3) startIndex--;

        for (var endPointer = end; endPointer.previousSibling; endPointer = endPointer.previousSibling)
            if (endPointer.nodeType == 3 && endPointer.previousSibling.nodeType == 3) endIndex--;

        normalize(startParent);

        if (start.nodeType == 3)
            start = startParent.childNodes[startIndex];

        normalize(endParent);
        if (end.nodeType == 3)
            end = endParent.childNodes[endIndex];

        if (collapsed) {
            if (start.nodeType == 3)
                range.setStart(start, startOffset);
            else
                range[collapsedToStart ? 'setStartAfter' : 'setStartBefore'](start);
                
            range.collapse(true);

        } else {
            if (start.nodeType == 3)
                range.setStart(start, startOffset);
            else
                range.setStartBefore(start);

            if (end.nodeType == 3)
                range.setEnd(end, endOffset);
            else
                range.setEndAfter(end);
        }
        if (caret)
            this.removeCaret(range);
    }
}

var boundary = /[\u0009-\u000d]|\u0020|\u00a0|\ufeff|\.|,|;|:|!|\(|\)|\?/;

var RangeUtils = {
    nodes: function(range) {
        var nodes = textNodes(range);
        if (!nodes.length) {
            range.selectNodeContents(range.commonAncestorContainer);
            nodes = textNodes(range);
            if (!nodes.length)
                nodes = dom.significantChildNodes(range.commonAncestorContainer);
        }
        return nodes;
    },

    image: function (range) {
        var nodes = [];

        new RangeIterator(range).traverse(function (node) {
            if (dom.is(node, 'img'))
                nodes.push(node);
        });

        if (nodes.length == 1)
            return nodes[0];
    },

    expand: function (range) {
        var result = range.cloneRange();

        var startContainer = result.startContainer.childNodes[result.startOffset == 0 ? 0 : result.startOffset - 1];
        var endContainer = result.endContainer.childNodes[result.endOffset];

        if (!isDataNode(startContainer) || !isDataNode(endContainer))
            return result;

        var beforeCaret = startContainer.nodeValue;
        var afterCaret = endContainer.nodeValue;

        if (beforeCaret == '' || afterCaret == '')
            return result;

        var startOffset = beforeCaret.split('').reverse().join('').search(boundary);
        var endOffset = afterCaret.search(boundary);

        if (startOffset == 0 || endOffset == 0)
            return result;

        endOffset = endOffset == -1 ? afterCaret.length : endOffset;
        startOffset = startOffset == -1 ? 0 : beforeCaret.length - startOffset;

        result.setStart(startContainer, startOffset);
        result.setEnd(endContainer, endOffset);

        return result;
    },

    isExpandable: function (range) {
        var node = range.startContainer;
        var document = documentFromRange(range);

        if (node == document || node == document.body)
            return false;

        var result = range.cloneRange();

        var value = node.nodeValue;
        if (!value)
            return false;

        var beforeCaret = value.substring(0, result.startOffset);
        var afterCaret = value.substring(result.startOffset);

        var startOffset = 0, endOffset = 0;

        if (beforeCaret != '')
            startOffset = beforeCaret.split('').reverse().join('').search(boundary);

        if (afterCaret != '')
            endOffset = afterCaret.search(boundary);

        return startOffset != 0 && endOffset != 0;
    }
};function Command(options) {
    var restorePoint = new RestorePoint(options.range);
    var marker = new Marker();

    this.formatter = options.formatter;

    this.getRange = function () {
        return restorePoint.toRange();
    }

    this.lockRange = function (expand) {
        return marker.add(this.getRange(), expand);
    }

    this.releaseRange = function (range) {
        marker.remove(range);
        selectRange(range);
    }

    this.undo = function () {
        restorePoint.body.innerHTML = restorePoint.html;
        selectRange(restorePoint.toRange());
    }

    this.redo = function () {
        this.exec();
    }

    this.exec = function () {
        var range = this.lockRange(true);
        this.formatter.editor = this.editor;
        this.formatter.toggle(range);
        this.releaseRange(range);
    }
}

function GenericCommand(startRestorePoint, endRestorePoint) {
    var body = startRestorePoint.body;

    this.redo = function () {
        body.innerHTML = endRestorePoint.html;
        selectRange(endRestorePoint.toRange());
    }

    this.undo = function () {
        body.innerHTML = startRestorePoint.html;
        selectRange(startRestorePoint.toRange());
    }
}

function InsertHtmlCommand(options) {
    Command.call(this, options);

    this.managesUndoRedo = true;

    this.exec = function () {
        var editor = this.editor;
        var range = editor.getRange();
        var startRestorePoint = new RestorePoint(range);

        editor.clipboard.paste(options.value || '');
        editor.undoRedoStack.push(new GenericCommand(startRestorePoint, new RestorePoint(editor.getRange())));

        editor.focus();
    }
}

function InsertHtmlTool() {
    Tool.call(this);

    this.command = function (commandArguments) {
        return new InsertHtmlCommand(commandArguments);
    }
    
    this.update = function($ui, nodes) {
        $ui.data('tSelectBox').close();
    }

    this.init = function($ui, initOptions) {
        var editor = initOptions.editor;
        
        $ui.tSelectBox({
            data: editor['insertHtml'],
            onItemCreate: function (e) {
                e.html = '<span unselectable="on">' + e.dataItem.Text + '</span>';
            },
            onChange: function (e) {
                Tool.exec(editor, 'insertHtml', e.value);
            },
            highlightFirst: false
        }).find('.t-input').html(editor.localization.insertHtml);
    }
}

function UndoRedoStack() {
    var stack = [], currentCommandIndex = -1;

    this.push = function (command) {
        stack = stack.slice(0, currentCommandIndex + 1);
        currentCommandIndex = stack.push(command) - 1;
    }

    this.undo = function () {
        if (this.canUndo())
            stack[currentCommandIndex--].undo();
    }

    this.redo = function () {
        if (this.canRedo())
            stack[++currentCommandIndex].redo();
    }

    this.canUndo = function () {
        return currentCommandIndex >= 0;
    }

    this.canRedo = function () {
        return currentCommandIndex != stack.length - 1;
    }
}

function TypingHandler(editor) {
    this.keydown = function (e) {
        var keyboard = editor.keyboard;
        var isTypingKey = keyboard.isTypingKey(e);

        if (isTypingKey && !keyboard.typingInProgress()) {
            var range = editor.getRange();
            this.startRestorePoint = new RestorePoint(range);

            keyboard.startTyping($.proxy(function () {
                editor.selectionRestorePoint = this.endRestorePoint = new RestorePoint(editor.getRange());
                editor.undoRedoStack.push(new GenericCommand(this.startRestorePoint, this.endRestorePoint));
            }, this));

            return true;
        }

        return false;
    }

    this.keyup = function (e) {
        var keyboard = editor.keyboard;

        if (keyboard.typingInProgress()) {
            keyboard.endTyping();
            return true;
        }

        return false;
    }
}

function SystemHandler(editor) {
    var systemCommandIsInProgress = false;

    this.createUndoCommand = function () {
        this.endRestorePoint = new RestorePoint(editor.getRange());
        editor.undoRedoStack.push(new GenericCommand(this.startRestorePoint, this.endRestorePoint));
        this.startRestorePoint = this.endRestorePoint;
    }

    this.changed = function () {
        if (this.startRestorePoint)
            return this.startRestorePoint.html != editor.body.innerHTML;

        return false;
    }

    this.keydown = function (e) {
        var keyboard = editor.keyboard;

        if (keyboard.isModifierKey(e)) {

            if (keyboard.typingInProgress())
                keyboard.endTyping(true);

            this.startRestorePoint = new RestorePoint(editor.getRange());
            return true;
        }

        if (keyboard.isSystem(e)) {
            systemCommandIsInProgress = true;

            if (this.changed()) {
                systemCommandIsInProgress = false;
                this.createUndoCommand();
            }

            return true;
        }

        return false;
    }

    this.keyup = function (e) {
        if (systemCommandIsInProgress && this.changed()) {
            systemCommandIsInProgress = false;
            this.createUndoCommand(e);
            return true;
        }

        return false;
    }
}

function Keyboard(handlers) {
    var typingInProgress = false;
    var timeout;
    var onEndTyping;

    function isCharacter(keyCode) {
        return (keyCode >= 48 && keyCode <= 90) || (keyCode >= 96 && keyCode <= 111) ||
            (keyCode >= 186 && keyCode <= 192) || (keyCode >= 219 && keyCode <= 222);
    }

    this.toolFromShortcut = function (tools, e) {
        var key = String.fromCharCode(e.keyCode);

        for (var toolName in tools) {
            var tool = tools[toolName];

            if ((tool.key == key || tool.key == e.keyCode) && !!tool.ctrl == e.ctrlKey && !!tool.alt == e.altKey && !!tool.shift == e.shiftKey)
                return toolName;
        }
    }

    this.isTypingKey = function (e) {
        var keyCode = e.keyCode;
        return (isCharacter(keyCode) && !e.ctrlKey && !e.altKey) || keyCode == 32 || keyCode == 13
        || keyCode == 8 || (keyCode == 46 && !e.shiftKey && !e.ctrlKey && !e.altKey);
    }

    this.isModifierKey = function (e) {
        var keyCode = e.keyCode;
        return (keyCode == 17 && !e.shiftKey && !e.altKey)
                || (keyCode == 16 && !e.ctrlKey && !e.altKey)
                || (keyCode == 18 && !e.ctrlKey && !e.shiftKey);
    }

    this.isSystem = function (e) {
        return e.keyCode == 46 && e.ctrlKey && !e.altKey && !e.shiftKey;
    }

    this.startTyping = function (callback) {
        onEndTyping = callback;
        typingInProgress = true;
    }

    function stopTyping() {
        typingInProgress = false;
        onEndTyping();
    }

    this.endTyping = function (force) {
        this.clearTimeout();
        if (force)
            stopTyping();
        else
            timeout = window.setTimeout(stopTyping, 1000);
    }

    this.typingInProgress = function () {
        return typingInProgress;
    }

    this.clearTimeout = function () {
        window.clearTimeout(timeout);
    }

    function notify(e, what) {
        for (var i = 0; i < handlers.length; i++)
            if (handlers[i][what](e))
                break;
    }

    this.keydown = function (e) {
        notify(e, 'keydown');
    }

    this.keyup = function (e) {
        notify(e, 'keyup');
    }
}

function Clipboard (editor) {
    var cleaners = [new MSWordFormatCleaner()];

    function htmlToFragment (html) {
        var container = dom.create(editor.document, 'div');
        container.innerHTML = html;
            
        var fragment = editor.document.createDocumentFragment();
            
        while (container.firstChild)
            fragment.appendChild(container.firstChild);
            
        return fragment;
    }

    function isBlock(html) {
        return /<(div|p|ul|ol|table|h[1-6])/i.test(html);
    }
        
    this.oncut = function(e) {
        var startRestorePoint = new RestorePoint(editor.getRange());
        setTimeout(function() {
            editor.undoRedoStack.push(new GenericCommand(startRestorePoint, new RestorePoint(editor.getRange())));
        });
    }

    this.onpaste = function(e) {
        var range = editor.getRange();
        var startRestorePoint = new RestorePoint(range);
            
        var clipboardNode = dom.create(editor.document, 'div', {className:'t-paste-container', innerHTML: '\ufeff'});

        editor.body.appendChild(clipboardNode);
            
        if (editor.body.createTextRange) {
            e.preventDefault();
            var r = editor.createRange();
            r.selectNodeContents(clipboardNode);
            editor.selectRange(r);
            var textRange = editor.body.createTextRange();
            textRange.moveToElementText(clipboardNode);
            $(editor.body).unbind('paste');
            textRange.execCommand('Paste');
            $(editor.body).bind('paste', arguments.callee);
        } else {
            var clipboardRange = editor.createRange();
            clipboardRange.selectNodeContents(clipboardNode);
            selectRange(clipboardRange);
        }
            
        setTimeout(function() {
            selectRange(range);
            dom.remove(clipboardNode);
                
            if (clipboardNode.lastChild && dom.is(clipboardNode.lastChild, 'br'))
                dom.remove(clipboardNode.lastChild);
                
            editor.clipboard.paste(clipboardNode.innerHTML);
            editor.undoRedoStack.push(new GenericCommand(startRestorePoint, new RestorePoint(editor.getRange())));
        });
    }

    function splittableParent(block, node) {
        if (block)
            return dom.parentOfType(node, ['p', 'ul', 'ol']) || node.parentNode;
            
        var parent = node.parentNode;
        var body = node.ownerDocument.body;
            
        if (dom.isInline(parent)) {
            while (parent.parentNode != body && !dom.isBlock(parent.parentNode))
                parent = parent.parentNode;
        }
            
        return parent;
    }

    this.paste = function (html) {
        for (var i = 0, l = cleaners.length; i < l; i++)
            if (cleaners[i].applicable(html))
                html = cleaners[i].clean(html);
            
        // It is possible in IE to copy just <li> tags
        html = html.replace(/^<li/i, '<ul><li').replace(/li>$/g, 'li></ul>');
            
        var block = isBlock(html);

        var range = editor.getRange();
        range.deleteContents();

        if (range.startContainer == editor.document)
            range.selectNodeContents(editor.body);
            
        var marker = new Marker();
        var caret = marker.addCaret(range)
            
        var parent = splittableParent(block, caret);
        var unwrap = false;
            
        if (!/body|td/.test(dom.name(parent)) && (block || dom.isInline(parent))) {
            range.selectNode(caret);
            split(range, parent, true);
            unwrap = true;
        }
            
        var fragment = htmlToFragment(html);
        range.insertNode(fragment);
                
        parent = splittableParent(block, caret);
        if (unwrap) {
            while (caret.parentNode != parent)
                dom.unwrap(caret.parentNode);
                
            dom.unwrap(caret.parentNode);
        }
            
        normalize(range.commonAncestorContainer);
        caret.style.display = 'inline';
        dom.scrollTo(caret);
        marker.removeCaret(range);
        selectRange(range);
    }
}

function MSWordFormatCleaner() {
    var replacements = [
        /<!--(.|\n)*?-->/g, '',
        /mso-[^;"]*;?/ig, '',
        /<\/?(meta|link|style|o:|v:)[^>]*>((?:.|\n)*?<\/(meta|link|style|o:|v:)[^>]*>)?/ig, ''
    ];
        
    this.applicable = function(html) {
        return /class="?Mso|style="[^"]*mso-/i.test(html);
    }
        
    function listType(html) {
        if (/^[\u2022\u00b7\u00a7\u00d8o\-]\u00a0+/.test(html))
            return 'ul';
            
        if (/^\s*\w+[\.\)]\u00a0{2,}/.test(html))
            return 'ol';
    }

    function lists(html) {
        var placeholder = dom.create(document, 'div', {innerHTML: html});
        var blockChildren = $(blockElements.join(','), placeholder);
            
        var lastMargin = -1, lastType, levels = {'ul':{}, 'ol':{}}, li = placeholder;
            
        for (var i = 0; i < blockChildren.length; i++) {
            var p = blockChildren[i];
            var html = p.innerHTML.replace(/<\/?\w+[^>]*>/g, '').replace(/&nbsp;/g, '\u00a0');      
            var type = listType(html);
                
            if (!type || dom.name(p) != 'p') { 
                if (p.innerHTML == '') {
                    dom.remove(p);
                } else {
                    levels = {'ul':{}, 'ol':{}};
                    li = placeholder;
                    lastMargin = -1;
                }
                continue;
            }
                
            var margin = parseFloat(p.style.marginLeft || 0);
            var list = levels[type][margin];

            if (margin > lastMargin || !list) {
                list = dom.create(document, type);
                    
                if (li == placeholder)
                    dom.insertBefore(list, p);
                else 
                    li.appendChild(list);
                    
                levels[type][margin] = list;
            }
                
            if (lastType != type) {
                for (var key in levels)
                    for (var child in levels[key])
                        if ($.contains(list, levels[key][child]))
                            delete levels[key][child];
            }

            dom.remove(p.firstChild);
            li = dom.create(document, 'li', {innerHTML:p.innerHTML});
            list.appendChild(li);
            dom.remove(p);
            lastMargin = margin;
            lastType = type;
        }
        return placeholder.innerHTML;
    }

    this.clean = function(html) {
        for (var i = 0, l = replacements.length; i < l; i+= 2)
            html = html.replace(replacements[i], replacements[i+1]);
            
        html = lists(html);

        html = html.replace(/\s+class="?[^"\s>]*"?/ig, '');
           
        return html;
    }
};function InlineFormatFinder(format) {
    function numberOfSiblings(referenceNode) {
        var count = 0;

        for (var node = referenceNode.parentNode.firstChild; node; node = node.nextSibling)
            if (node != referenceNode && node.className != 't-marker' && node.nodeType == 1)
                count++;

        return count;
    }

    this.findSuitable = function (sourceNode, skip) {
        if (!skip && numberOfSiblings(sourceNode) > 0)
            return null;

        return dom.parentOfType(sourceNode, format[0].tags);
    }

    this.findFormat = function (sourceNode) {
        for (var i = 0; i < format.length; i++) {
            var node = sourceNode;
            var tags = format[i].tags;
            var attributes = format[i].attr;

            if (node && dom.ofType(node, tags) && attrEquals(node, attributes))
                return node;

            while (node) {
                node = dom.parentOfType(node, tags);
                if (node && attrEquals(node, attributes))
                    return node;
            }
        }

        return null;
    }

    this.isFormatted = function (nodes) {
        for (var i = 0; i < nodes.length; i++)
            if (this.findFormat(nodes[i]))
                return true;

        return false;
    }
}

function InlineFormatter(format, values) {
    this.finder = new InlineFormatFinder(format);

    var attributes = $.extend({}, format[0].attr, values);

    var tag = format[0].tags[0];

    function wrap(node) {
        return dom.wrap(node, dom.create(node.ownerDocument, tag, attributes));
    }

    this.activate = function(range, nodes) {
        if (this.finder.isFormatted(nodes)) {
            this.split(range);
            this.remove(nodes);
        } else
            this.apply(nodes);
    }

    this.toggle = function (range) {
        var nodes = textNodes(range);

        if (nodes.length > 0)
            this.activate(range, nodes);
    }

    this.apply = function (nodes) {
        var formatNodes = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];

            var formatNode = this.finder.findSuitable(node);
            if (formatNode)
                dom.attr(formatNode, attributes);
            else
                formatNode = wrap(node);

            formatNodes.push(formatNode);
        }

        this.consolidate(formatNodes);
    }

    this.remove = function (nodes) {
        for (var i = 0, l = nodes.length; i < l; i++) {
            var formatNode = this.finder.findFormat(nodes[i]);
            if (formatNode)
                dom.unwrap(formatNode);
        }
    }

    this.split = function (range) {
        var nodes = textNodes(range);

        if (nodes.length > 0) {
            for (var i = 0, l = nodes.length; i < l; i++) {
                var formatNode = this.finder.findFormat(nodes[i]);
                if (formatNode)
                    split(range, formatNode, true);
            }
        }
    }

    this.consolidate = function (nodes) {
        while (nodes.length > 1) {
            var node = nodes.pop();
            var last = nodes[nodes.length - 1];

            if (node.previousSibling && node.previousSibling.className == 't-marker') {
                last.appendChild(node.previousSibling);
            }

            if (node.previousSibling == last && node.style.cssText == last.style.cssText) {
                while (node.firstChild)
                    last.appendChild(node.firstChild);
                dom.remove(node);
            }
        }
    }
}

function GreedyInlineFormatFinder(format, greedyProperty) {
    InlineFormatFinder.call(this, format);

    function getInlineCssValue(node) {
        var attributes = node.attributes,
            trim = $.trim;

        if (!attributes) return;

        for (var i = 0, l = attributes.length; i < l; i++) {
            var attribute = attributes[i],
                name = attribute.nodeName,
                attributeValue = attribute.nodeValue;

            if (attribute.specified && name == 'style') {
                
                var css = trim(attributeValue || node.style.cssText).split(';');

                for (var cssIndex = 0, len = css.length; cssIndex < len; cssIndex++) {
                    var pair = css[cssIndex];
                    if (pair.length) {
                        var propertyAndValue = pair.split(':');
                        var property = trim(propertyAndValue[0].toLowerCase()),
                            value = trim(propertyAndValue[1]);

                        if (property != greedyProperty)
                            continue;

                        return property.indexOf('color') >= 0 ? dom.toHex(value) : value;
                    }
                }
            }
        }

        return;
    }

    function getFormat (node) {
        var $node = $(isDataNode(node) ? node.parentNode : node);
        var parents = $node.parents().andSelf();

        for (var i = 0, len = parents.length; i < len; i++) {
            var value = greedyProperty == 'className' ? parents[i].className : getInlineCssValue(parents[i]);
            if (value)
                return value;
        }

        return 'inherit';
    }

    this.getFormat = function (nodes) {
        var result = getFormat(nodes[0]);

        for (var i = 1, len = nodes.length; i < len; i++)
            if (result != getFormat(nodes[i]))
                return '';

        return result;
    }

    this.isFormatted = function (nodes) {
        return this.getFormat(nodes) !== '';
    }
}

function GreedyInlineFormatter(format, values, greedyProperty) {
    InlineFormatter.call(this, format, values);

    this.finder = new GreedyInlineFormatFinder(format, greedyProperty)

    this.activate = function(range, nodes) {
        this.split(range);

        if (greedyProperty) {
            var camelCase = greedyProperty.replace(/-([a-z])/, function(all, letter){return letter.toUpperCase()});
            this[values.style[camelCase] == 'inherit' ? 'remove' : 'apply'](nodes);
        } else {
            this.apply(nodes);
        }
    }
}

function inlineFormatWillDelayExecution (range) {
    return range.collapsed && !RangeUtils.isExpandable(range);
}

function InlineFormatTool(options) {
    FormatTool.call(this, $.extend(options, {
        finder: new InlineFormatFinder(options.format),
        formatter: function () { return new InlineFormatter(options.format) }
    }));

    this.willDelayExecution = inlineFormatWillDelayExecution;
}

function FontTool(options){
    Tool.call(this, options);
    
    // IE has single selection hence we are using select box instead of combobox
    var type = $.browser.msie ? 'tSelectBox' : 'tComboBox',
        format = [{ tags: ['span'] }],
        finder = new GreedyInlineFormatFinder(format, options.cssAttr);

    this.command = function (commandArguments) {
        return new FormatCommand($.extend(commandArguments, {
            formatter: function () { 
                var style = {};
                style[options.domAttr] = commandArguments.value;

                return new GreedyInlineFormatter(format, { style: style }, options.cssAttr); 
            }
        }))        
    }

    this.willDelayExecution = inlineFormatWillDelayExecution;
    
    this.update = function($ui, nodes, pendingFormats) {
        var list = $ui.data(type);
        list.close();

        var pendingFormat = pendingFormats.getPending(this.name);

        var format = (pendingFormat && pendingFormat.params) ? pendingFormat.params.value : finder.getFormat(nodes)

        list.value(format);
    }

    this.init = function ($ui, initOptions) {
        var editor = initOptions.editor;

        $ui[type]({
            data: editor[options.name],
            onChange: function (e) {
                Tool.exec(editor, options.name, e.value);
            },
            highlightFirst: false
        });

        var component = $ui.data(type);
        component.value('inherit');
        component.dropDown.onItemCreate =
                function (e) {
                    e.html = '<span unselectable="on" style="' + options.cssAttr + ': ' + e.dataItem.Value + '">' + e.dataItem.Text + '</span>';
                };
    }
};

function ColorTool (options) {
    Tool.call(this, options);

    var format = [{ tags: ['span'] }],
        finder = new GreedyInlineFormatFinder(format, options.cssAttr);
    
    this.update = function($ui) {
        $ui.data('tColorPicker').close();
    }
    
    this.command = function (commandArguments) {

        return new FormatCommand($.extend(commandArguments, {
            formatter: function () { 
                var style = {};
                style[options.domAttr] = commandArguments.value;

                return new GreedyInlineFormatter(format, { style: style }, options.cssAttr); 
            }
        }))        
    }

    this.willDelayExecution = inlineFormatWillDelayExecution;

    this.init = function($ui, initOptions) {
        var editor = initOptions.editor;
        
        $ui.tColorPicker({
            selectedColor: '#000000',
            onChange: function (e) {
                Tool.exec(editor, options.name, e.value);
            }
        });
    }
}

function StyleTool() {
    Tool.call(this);
    var format = [{ tags: ['span'] }],
        finder = new GreedyInlineFormatFinder(format, 'className');
    
    this.command = function (commandArguments) {
        return new FormatCommand($.extend(commandArguments, {
            formatter: function () { 
                return new GreedyInlineFormatter(format, { className: commandArguments.value }); 
            }
        }));
    }
    
    this.update = function($ui, nodes) {
        var list = $ui.data('tSelectBox');
        list.close();
        list.value(finder.getFormat(nodes));
    }

    this.init = function($ui, initOptions) {
        var editor = initOptions.editor;
        
        $ui.tSelectBox({
            data: editor['style'],
            title: editor.localization.style,
            onItemCreate: function (e) {
                var style = dom.inlineStyle(editor.document, 'span', {className : e.dataItem.Value});
                
                e.html = '<span unselectable="on" style="display:block;' + style +'">' + e.html + '</span>';
            },
            onChange: function (e) {
                Tool.exec(editor, 'style', e.value);
            }
        });
    } 
};function BlockFormatFinder(format) {
    function contains(node, children) {
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (child == null || !isAncestorOrSelf(node, child))
                return false;
        }

        return true;
    }

    this.findSuitable = function (nodes) {
        var suitable = [];

        for (var i = 0; i < nodes.length; i++) {
            var candidate = dom.ofType(nodes[i], format[0].tags) ? nodes[i] : dom.parentOfType(nodes[i], format[0].tags);
            if (!candidate)
                return [];
            if ($.inArray(candidate, suitable) < 0)
                suitable.push(candidate);
        }

        for (var i = 0; i < suitable.length; i++)
            if (contains(suitable[i], suitable))
                return [suitable[i]];

        return suitable;
    }

    this.findFormat = function (sourceNode) {
        for (var i = 0; i < format.length; i++) {
            var node = sourceNode;
            var tags = format[i].tags;
            var attributes = format[i].attr;

            while (node) {
                if (dom.ofType(node, tags) && attrEquals(node, attributes))
                    return node;
                node = node.parentNode;
            }
        }
        return null;
    }

    this.getFormat = function (nodes) {
        var findFormat = $.proxy(function(node) { return this.findFormat(isDataNode(node) ? node.parentNode : node); }, this),
            result = findFormat(nodes[0]);

        if (!result)
            return '';

        for (var i = 1, len = nodes.length; i < len; i++)
            if (result != findFormat(nodes[i]))
                return '';

        return result.nodeName.toLowerCase();
    }

    this.isFormatted = function (nodes) {
        for (var i = 0; i < nodes.length; i++)
            if (!this.findFormat(nodes[i]))
                return false;

        return true;
    }
}

function BlockFormatter(format, values) {
    var finder = new BlockFormatFinder(format);

    function wrap(tag, attributes, nodes) {
        var commonAncestor = nodes.length == 1 ? dom.blockParentOrBody(nodes[0]) : dom.commonAncestor.apply(null, nodes);

        if (dom.isInline(commonAncestor))
            commonAncestor = dom.blockParentOrBody(commonAncestor);

        var ancestors = dom.significantChildNodes(commonAncestor);

        var position = findNodeIndex(ancestors[0]);

        var wrapper = dom.create(commonAncestor.ownerDocument, tag, attributes);

        for (var i = 0; i < ancestors.length; i++) {
            var ancestor = ancestors[i];
            if (dom.isBlock(ancestor)) {
                dom.attr(ancestor, attributes);

                if (wrapper.childNodes.length) {
                    dom.insertBefore(wrapper, ancestor);
                    wrapper = wrapper.cloneNode(false);
                }

                position = findNodeIndex(ancestor) + 1;

                continue;
            }

            wrapper.appendChild(ancestor);
        }

        if (wrapper.firstChild)
            dom.insertAt(commonAncestor, wrapper, position);
    }

    this.apply = function (nodes) {
        var formatNodes = dom.is(nodes[0], 'img') ? [nodes[0]] : finder.findSuitable(nodes);

        var formatToApply = formatNodes.length ? formatByName(dom.name(formatNodes[0]), format) : format[0];

        var tag = formatToApply.tags[0];
        var attributes = $.extend({}, formatToApply.attr, values);

        if (formatNodes.length)
            for (var i = 0; i < formatNodes.length; i++)
                dom.attr(formatNodes[i], attributes);
        else
            wrap(tag, attributes, nodes);
    }

    this.remove = function (nodes) {
        for (var i = 0, l = nodes.length; i < l; i++) {
            var formatNode = finder.findFormat(nodes[i]);
            if (formatNode)
                if (dom.ofType(formatNode, ['p', 'img', 'li']))
                    dom.unstyle(formatNode, formatByName(dom.name(formatNode), format).attr.style);
                else
                    dom.unwrap(formatNode);
        }
    }

    this.toggle = function (range) {
        var nodes = RangeUtils.nodes(range);
        if (finder.isFormatted(nodes))
            this.remove(nodes);
        else
            this.apply(nodes);
    }
}

function GreedyBlockFormatter(format, values) {
    var finder = new BlockFormatFinder(format);

    this.apply = function (nodes) {
        var blocks = blockParents(nodes);
        var formatTag = format[0].tags[0];
        if (blocks.length) {
            for (var i = 0, len = blocks.length; i < len; i++) {
                if (dom.is(blocks[i], 'li')) {
                    var list = blocks[i].parentNode;
                    var formatter = new ListFormatter(list.nodeName.toLowerCase(), formatTag);
                    var range = this.editor.createRange();
                    range.selectNode(blocks[i]);
                    formatter.toggle(range);
                } else {
                    dom.changeTag(blocks[i], formatTag);
                }
            }
        } else {
            new BlockFormatter(format, values).apply(nodes);
        }
    }

    this.toggle = function (range) {
        var nodes = textNodes(range);
        if (!nodes.length) {
            range.selectNodeContents(range.commonAncestorContainer);
            nodes = textNodes(range);
            if (!nodes.length)
                nodes = dom.significantChildNodes(range.commonAncestorContainer);
        }

        this.apply(nodes);
    }
}

function FormatCommand(options) {
    options.formatter = options.formatter();
    Command.call(this, options);
}

function BlockFormatTool (options) {
    FormatTool.call(this, $.extend(options, {
        finder: new BlockFormatFinder(options.format),
        formatter: function () { return new BlockFormatter(options.format) }
    }));
}

function FormatBlockTool() {
    Tool.call(this);
    var finder = new BlockFormatFinder([{ tags: blockElements }])

    this.command = function (commandArguments) {
        return new FormatCommand($.extend(commandArguments, {
            formatter: function () { return new GreedyBlockFormatter([{ tags: [commandArguments.value] }], {}); }
        }))
    }
    
    this.update = function($ui, nodes) {
        var list = $ui.data('tSelectBox');
        list.close();
        list.value(finder.getFormat(nodes));
    }

    this.init = function($ui, initOptions) {
        var editor = initOptions.editor;
        
        $ui.tSelectBox({
            data: editor.formatBlock,
            title: editor.localization.formatBlock,
            onItemCreate: function (e) {
                var tagName = e.dataItem.Value;
                e.html = '<' + tagName + ' unselectable="on" style="margin: .3em 0;' + dom.inlineStyle(editor.document, tagName) + '">' + e.dataItem.Text + '</' + tagName + '>';
            },
            onChange: function (e) {
                Tool.exec(editor, 'formatBlock', e.value);
            },
            highlightFirst: false
        });
    }
};function ParagraphCommand(options) {
    Command.call(this, options);

    this.exec = function () {
        var range = this.getRange(),
            document = documentFromRange(range),
            next,
            emptyParagraphContent = $.browser.msie ? '' : '<br _moz_dirty="" />';

        // necessary while the emptyParagraphContent is empty under IE
        var blocks = 'p,h1,h2,h3,h4,h5,h6'.split(','),
            startInBlock = dom.parentOfType(range.startContainer, blocks),
            endInBlock = dom.parentOfType(range.endContainer, blocks),
            shouldTrim = (startInBlock && !endInBlock) || (!startInBlock && endInBlock);

        range.deleteContents();

        var marker = dom.create(document, 'a');
        range.insertNode(marker);
        normalize(marker.parentNode);

        var li = dom.parentOfType(marker, ['li']),
            heading = dom.parentOfType(marker, 'h1,h2,h3,h4,h5,h6'.split(','));

        if (li) {
            var rng = range.cloneRange();
            rng.selectNode(li);

            if (textNodes(rng).length == 0) {
                // hitting 'enter' in empty li
                var paragraph = dom.create(document, 'p');

                if (li.nextSibling)
                    split(rng, li.parentNode);

                dom.insertAfter(paragraph, li.parentNode);
                dom.remove(li.parentNode.childNodes.length == 1 ? li.parentNode : li);
                paragraph.innerHTML = emptyParagraphContent;
                next = paragraph;
            }
        }
        else if (heading && !marker.nextSibling) {
            var paragraph = dom.create(document, 'p');

            dom.insertAfter(paragraph, heading);
            paragraph.innerHTML = emptyParagraphContent;
            dom.remove(marker);
            next = paragraph;
        }

        if (!next) {
            if (!(li || heading))
                new BlockFormatter([{ tags: ['p']}]).apply([marker]);

            range.selectNode(marker);

            var parent = dom.parentOfType(marker, [li ? 'li' : heading ? dom.name(heading) : 'p']);

            split(range, parent, shouldTrim);

            var previous = parent.previousSibling;

            if (dom.is(previous, 'li') && previous.firstChild && !dom.is(previous.firstChild, 'br'))
                previous = previous.firstChild;

            next = parent.nextSibling;

            if (dom.is(next, 'li') && next.firstChild && !dom.is(next.firstChild, 'br'))
                next = next.firstChild;

            dom.remove(parent);

            function clean(node) {
                if (node.firstChild && dom.is(node.firstChild, 'br'))
                    dom.remove(node.firstChild);

                if (isDataNode(node) && node.nodeValue == '')
                    node = node.parentNode;

                if (node && !dom.is(node, 'img') && node.innerHTML == '')
                    node.innerHTML = emptyParagraphContent;
            }

            clean(previous);
            clean(next);

            // normalize updates the caret display in Gecko
            normalize(previous);
        }

        normalize(next);

        if (!dom.is(next, 'img'))
            range.selectNodeContents(next);
        else
            range.setStartBefore(next);

        range.collapse(true);

        dom.scrollTo(next);

        selectRange(range);
    }
}

function NewLineCommand(options) {
    Command.call(this, options);

    this.exec = function () {
        var range = this.getRange();
        range.deleteContents();
        var br = dom.create(documentFromRange(range), 'br');
        range.insertNode(br);
        normalize(br.parentNode);
        
        if (!$.browser.msie && (!br.nextSibling || dom.isWhitespace(br.nextSibling))) { 
            //Gecko and WebKit cannot put the caret after only one br.
            var filler = br.cloneNode(true);
            filler.setAttribute('_moz_dirty', '');
            dom.insertAfter(filler, br);
        }
        range.setStartAfter(br);
        range.collapse(true);
        selectRange(range);
    }
};function ListFormatFinder(tag) {
    var tags = [tag == 'ul' ? 'ol' : 'ul', tag];
        
    BlockFormatFinder.call(this, [{ tags: tags}]);

    this.isFormatted = function (nodes) {
        var formatNodes = [], formatNode;
            
        for (var i = 0; i < nodes.length; i++)
            if ((formatNode = this.findFormat(nodes[i])) && dom.name(formatNode) == tag && $.inArray(formatNode, formatNodes) < 0)
                formatNodes.push(formatNode);

        return formatNodes.length == 1;
    }

    this.findSuitable = function (nodes) {
        var candidate = dom.parentOfType(nodes[0], tags)
        if (candidate && dom.name(candidate) == tag)
            return candidate;
        return null;
    }
}

function ListFormatter(tag, unwrapTag) {
    var finder = new ListFormatFinder(tag);

    function wrap(list, nodes) {
        var li = dom.create(list.ownerDocument, 'li');

        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];

            if (dom.is(node, 'li')) {
                list.appendChild(node);
                continue;
            }
            
            if (dom.is(node, "td")) {
                while (node.firstChild) {
                    li.appendChild(node.firstChild);
                }
                list.appendChild(li);
                node.appendChild(list);
                list = list.cloneNode(false);
                li = li.cloneNode(false);
                continue;
            }

            li.appendChild(node);

            if (dom.isBlock(node)) {
                list.appendChild(li);
                dom.unwrap(node);
                li = li.cloneNode(false);
            }
        }

        if (li.firstChild)
            list.appendChild(li);
    }

    function containsAny(parent, nodes) {
        for (var i = 0; i < nodes.length; i++)
            if (isAncestorOrSelf(parent, nodes[i]))
                return true;

        return false;
    }

    function suitable(candidate, nodes) {
        return containsAny(candidate, nodes) || dom.isInline(candidate) || candidate.nodeType == 3;
    }

    this.split = function (range) {
        var nodes = textNodes(range);
        if (nodes.length) {
            var start = dom.parentOfType(nodes[0], ['li']);
            var end = dom.parentOfType(nodes[nodes.length - 1], ['li'])
            range.setStartBefore(start);
            range.setEndAfter(end);

            for (var i = 0, l = nodes.length; i < l; i++) {
                var formatNode = finder.findFormat(nodes[i]);
                if (formatNode)
                    split(range, formatNode, true);
            }
        }
    }

    this.apply = function (nodes) {
        var commonAncestor = nodes.length == 1 ? dom.parentOfType(nodes[0], ['ul','ol']) : dom.commonAncestor.apply(null, nodes);
            
        if (!commonAncestor)
            commonAncestor = dom.parentOfType(nodes[0], ["td"]) || nodes[0].ownerDocument.body;

        if (dom.isInline(commonAncestor))
            commonAncestor = dom.blockParentOrBody(commonAncestor);

        var ancestors = [];

        var formatNode = finder.findSuitable(nodes);

        if (!formatNode)
            formatNode = new ListFormatFinder(tag == 'ul' ? 'ol' : 'ul').findSuitable(nodes);
        
        var childNodes = dom.significantChildNodes(commonAncestor);
        
        if (/table|tbody/.test(dom.name(commonAncestor))) {
            childNodes = $.map(nodes, function(node) { return dom.parentOfType(node, ["td"]) });
        }

        for (var i = 0; i < childNodes.length; i++) {
            var child = childNodes[i];
            var nodeName = dom.name(child);
            if (suitable(child, nodes) && (!formatNode || !isAncestorOrSelf(formatNode, child))) {

                if (formatNode && (nodeName == 'ul' || nodeName == 'ol')) {
                    // merging lists
                    $.each(child.childNodes, function () { ancestors.push(this) });
                    dom.remove(child);
                } else {
                    ancestors.push(child);
                }
            }
        }

        if (ancestors.length == childNodes.length && commonAncestor != nodes[0].ownerDocument.body && !/table|tbody|tr|td/.test(dom.name(commonAncestor)))
            ancestors = [commonAncestor];

        if (!formatNode) {
            formatNode = dom.create(commonAncestor.ownerDocument, tag);
            dom.insertBefore(formatNode, ancestors[0]);
        }

        wrap(formatNode, ancestors);

        if (!dom.is(formatNode, tag))
            dom.changeTag(formatNode, tag);
    }

    function unwrap(ul) {
        for (var li = ul.firstChild; li; li = li.nextSibling) {
            var p = dom.create(ul.ownerDocument, unwrapTag || 'p');
                
            while(li.firstChild) {
                var child = li.firstChild;
                if (dom.isBlock(child))
                    dom.insertBefore(child, ul);
                else
                    p.appendChild(child);
            }
            if (p.firstChild)
                dom.insertBefore(p, ul);
        }
            
        dom.remove(ul);
    }

    this.remove = function (nodes) {
        var formatNode;
        for (var i = 0, l = nodes.length; i < l; i++)
            if (formatNode = finder.findFormat(nodes[i]))
                unwrap(formatNode);
    }

    this.toggle = function (range) {
        var nodes = textNodes(range);
        if (!nodes.length) {
            range.selectNodeContents(range.commonAncestorContainer);
            nodes = textNodes(range);
            if (!nodes.length)
                nodes = dom.significantChildNodes(range.commonAncestorContainer);
        }
            
        if (finder.isFormatted(nodes)) {
            this.split(range);
            this.remove(nodes);
        } else
            this.apply(nodes);
    }
}

function ListCommand(options) {
    options.formatter = new ListFormatter(options.tag);
    Command.call(this, options);
}

function ListTool(options) {
    FormatTool.call(this, $.extend(options, {
        finder: new ListFormatFinder(options.tag)
    }));

    this.command = function (commandArguments) { 
        return new ListCommand($.extend(commandArguments, { tag: options.tag }));
    }
};function LinkFormatFinder() {
    this.findSuitable = function (sourceNode) {
        return dom.parentOfType(sourceNode, ['a']);
    }
}

function LinkFormatter() {
    this.finder = new LinkFormatFinder();

    this.apply = function (range, attributes) {
        var nodes = textNodes(range);
        if (attributes.innerHTML != undefined) {
            var markers = getMarkers(range);
            var document = documentFromRange(range);
            range.deleteContents();
            var a = dom.create(document, 'a', attributes);
            range.insertNode(a);

            if (markers.length > 1) {
                dom.insertAfter(markers[markers.length - 1], a);
                dom.insertAfter(markers[1], a);
                dom[nodes.length > 0 ? 'insertBefore' : 'insertAfter'](markers[0], a);
            }
        } else {
            var formatter = new InlineFormatter([{ tags: ['a']}], attributes);
            formatter.finder = this.finder;
            formatter.apply(nodes);
        }
    }
}

function UnlinkCommand(options) {
    options.formatter = {
        toggle : function(range) {
            new InlineFormatter([{ tags: ['a']}]).remove(textNodes(range));
        }
    };
    
    Command.call(this, options);
}

function LinkCommand(options) {
    Command.call(this, options);

    var attributes;

    this.async = true;

    var formatter = new LinkFormatter();

    this.exec = function () {
        var range = this.getRange();

        var collapsed = range.collapsed;

        range = this.lockRange(true);

        var nodes = textNodes(range);

        var initialText = null;

        var self = this;

        function apply(e) {
            var href = $('#t-editor-link-url', dialog.element).val();

            if (href && href != 'http://') {
                attributes = { href: href };

                var title = $('#t-editor-link-title', dialog.element).val();
                if (title)
                    attributes.title = title;

                var text = $('#t-editor-link-text', dialog.element).val();
                if (text !== initialText)
                    attributes.innerHTML = text;

                var target = $('#t-editor-link-target', dialog.element).is(':checked');
                if (target)
                    attributes.target = '_blank';

                formatter.apply(range, attributes);
            }
            close(e);
            if (self.change)
                self.change();
        }

        function close(e) {
            e.preventDefault();
            dialog.destroy();

            windowFromDocument(documentFromRange(range)).focus();

            self.releaseRange(range);
        }

        var a = nodes.length ? formatter.finder.findSuitable(nodes[0]) : null;

        var shouldShowText = nodes.length <= 1 || (nodes.length == 2 && collapsed);

        var dialog = $t.window.create($.extend({}, this.editor.dialogOptions, {
            title: "Insert link",
            html: new $.telerik.stringBuilder()
                .cat('<div class="t-editor-dialog">')
                    .cat('<ol>')
                        .cat('<li class="t-form-text-row"><label for="t-editor-link-url">Web address</label><input type="text" id="t-editor-link-url"/></li>')
                        .catIf('<li class="t-form-text-row"><label for="t-editor-link-text">Text</label><input type="text" id="t-editor-link-text"/></li>', shouldShowText)
                        .cat('<li class="t-form-text-row"><label for="t-editor-link-title">Tooltip</label><input type="text" id="t-editor-link-title"/></li>')
                        .cat('<li class="t-form-checkbox-row"><input type="checkbox" id="t-editor-link-target"/><label for="t-editor-link-target">Open link in new window</label></li>')
                    .cat('</ol>')
                    .cat('<div class="t-button-wrapper">')
                        .cat('<button class="t-dialog-insert t-button">Insert</button>')
                        .cat('&nbsp;or&nbsp;')
                        .cat('<a href="#" class="t-dialog-close t-link">Close</a>')
                    .cat('</div>')
                .cat('</div>')
                .string(),
            onClose: close
        }))
            .hide()
            .find('.t-dialog-insert').click(apply).end()
            .find('.t-dialog-close').click(close).end()
            .find('.t-form-text-row input').keydown(function (e) {
                if (e.keyCode == 13)
                    apply(e);
                else if (e.keyCode == 27)
                    close(e);
            }).end()
            // IE < 8 returns absolute url if getAttribute is not used
            .find('#t-editor-link-url').val(a ? a.getAttribute('href', 2) : 'http://').end()
            .find('#t-editor-link-text').val(nodes.length > 0 ? (nodes.length == 1 ? nodes[0].nodeValue : nodes[0].nodeValue + nodes[1].nodeValue) : '').end()
            .find('#t-editor-link-title').val(a ? a.title : '').end()
            .find('#t-editor-link-target').attr('checked', a ? a.target == '_blank' : false).end()
            .show()
            .data('tWindow')
            .center();

        if (shouldShowText && nodes.length > 0)
            initialText = $('#t-editor-link-text', dialog.element).val();

        $('#t-editor-link-url', dialog.element).focus().select();
    },

    this.redo = function () {
        var range = this.lockRange(true);
        formatter.apply(range, attributes);
        this.releaseRange(range);
    }
}

function UnlinkTool(options){
    Tool.call(this, $.extend(options, {command:UnlinkCommand}));
    
    var finder = new InlineFormatFinder([{tags:['a']}]);

    this.init = function($ui) {
        $ui.attr('unselectable', 'on')
           .addClass('t-state-disabled');
    }
    
    this.update = function ($ui, nodes) {
        $ui.toggleClass('t-state-disabled', !finder.isFormatted(nodes))
            .removeClass('t-state-hover');
    }
}
function ImageCommand(options) {
    Command.call(this, options);
    this.async = true;
    var attributes;

    function insertImage(img, range) {
        if (attributes.src && attributes.src != 'http://') {
            if (!img) {
                img = dom.create(documentFromRange(range), 'img', attributes);
                img.onload = img.onerror = function () {
                    img.removeAttribute('complete');
                    img.removeAttribute('width');
                    img.removeAttribute('height');
                }
                range.deleteContents();
                range.insertNode(img);
                range.setStartAfter(img);
                range.setEndAfter(img);
                selectRange(range);
                return true;
            } else
                dom.attr(img, attributes);
        }

        return false;
    }

    this.redo = function () {
        var range = this.lockRange();
        if (!insertImage(RangeUtils.image(range), range))
            this.releaseRange(range);
    }

    this.exec = function () {
        var range = this.lockRange();

        var applied = false;

        var img = RangeUtils.image(range);

        var self = this;

        function apply(e) {
            attributes = {
                src: $('#t-editor-image-url', dialog.element).val(),
                alt: $('#t-editor-image-title', dialog.element).val()
            };

            applied = insertImage(img, range);

            close(e);

            if (self.change)
                self.change();
        }

        function close(e) {
            e.preventDefault();
            dialog.destroy();

            windowFromDocument(documentFromRange(range)).focus();
            if (!applied)
                self.releaseRange(range);
        }

        var fileBrowser = this.editor.fileBrowser;
        var showBrowser = fileBrowser && fileBrowser.selectUrl !== undefined;
        
        function activate() {  
            if (showBrowser) {
                new $t.imageBrowser($(this).find(".t-image-browser"), $.extend(fileBrowser, { apply: apply, element: self.editor.element, localization: self.editor.localization }));
            }
        }        
        
        var dialog = $t.window.create($.extend({ width: 750 }, this.editor.dialogOptions, {
            title: "Insert image",
            html: new $.telerik.stringBuilder()
                        .cat('<div class="t-editor-dialog">')                        
                            .catIf('<div class="t-image-browser"></div>', showBrowser)
                            .cat('<ol>')
                                .cat('<li class="t-form-text-row"><label for="t-editor-image-url">Web address</label><input type="text" id="t-editor-image-url"/></li>')
                                .cat('<li class="t-form-text-row"><label for="t-editor-image-title">Tooltip</label><input type="text" id="t-editor-image-title"/></li>')
                            .cat('</ol>')
                            .cat('<div class="t-button-wrapper">')
                                .cat('<button class="t-dialog-insert t-button">Insert</button>')
                                .cat('&nbsp;or&nbsp;')
                                .cat('<a href="#" class="t-dialog-close t-link">Close</a>')
                            .cat('</div>')
                        .cat('</div>')
                    .string(),
            onClose: close,
            onActivate: activate
        }))
        .hide()
        .find('.t-dialog-insert').click(apply).end()
        .find('.t-dialog-close').click(close).end()
        .find('.t-form-text-row input').keydown(function (e) {
            if (e.keyCode == 13)
                apply(e);
            else if (e.keyCode == 27)
                close(e);
        }).end()                
        .toggleClass("t-imagebrowser", showBrowser)
        // IE < 8 returns absolute url if getAttribute is not used
        .find('#t-editor-image-url').val(img ? img.getAttribute('src', 2) : 'http://').end()
        .find('#t-editor-image-title').val(img ? img.alt : '').end()
        .show()
        .data('tWindow').center();

        $('#t-editor-image-url', dialog.element).focus().select();
    }
};/* select box */

$t.selectbox = function (element, options) {
    var selectedValue;
    var $element = $(element);
    var $text = $element.find('.t-input');

    var dropDown = this.dropDown = new $t.dropDown({
        effects: $t.fx.slide.defaults(),
        onItemCreate: options.onItemCreate,
        onClick: function (e) {
            select(options.data[$(e.item).index()].Value);
            options.onChange({ value: selectedValue })
        }
    });

    function fill() {
        if (!dropDown.$items)
            dropDown.dataBind(options.data);
    }

    function text(value) {
        $text.html(value ? value : '&nbsp;');
    }

    function select(item) {
        fill();
        var index = -1;

        for (var i = 0, len = options.data.length; i < len; i++) {
            if (options.data[i].Value == item) {
                index = i;
                break;
            }
        }

        if (index != -1) {

            dropDown.$items
                    .removeClass('t-state-selected')
                    .eq(index).addClass('t-state-selected');

            text($(dropDown.$items[index]).text());
            selectedValue = options.data[index].Value;
        }
    }

    this.value = function (value) {
        if (value == undefined)
            return selectedValue;

        select(value);

        if (selectedValue != value)
            text(options.title || value);       
    }

    this.close = function () {
        dropDown.close();
    }

    text(options.title || $text.text());

    $element.bind('click', function (e) {
        fill();
        if (dropDown.isOpened())
            dropDown.close();
        else
            dropDown.open({
                offset: $element.offset(),
                outerHeight: $element.outerHeight(),
                outerWidth: $element.outerWidth(),
                zIndex: $t.getElementZIndex($element[0])
            });
    })
            .find('*')
            .attr('unselectable', 'on');

    dropDown.$element.css('direction', $element.closest('.t-rtl').length > 0 ? 'rtl' : '');

    $(document.documentElement).bind('mousedown', $.proxy(function (e) {
        var $dropDown = dropDown.$element;
        var isDropDown = $dropDown && $dropDown.parent().length > 0;

        if (isDropDown && !$.contains(element, e.target) && !$.contains($dropDown.parent()[0], e.target)) {
            dropDown.close();
        }

    }, this));
}

$.fn.tSelectBox = function (options) {
    return $t.create(this, {
        name: 'tSelectBox',
        init: function (element, options) {
            return new $t.selectbox(element, options)
        },
        options: options
    });
};

$.fn.tSelectBox.defaults = {
    effects: $t.fx.slide.defaults()
};

/* color picker */

$t.colorpicker = function (element, options) {
    this.element = element;
    var $element = $(element);

    $.extend(this, options);

    $element.bind('click', $.proxy(this.click, this))
            .find('*')
            .attr('unselectable', 'on');
    
    if (this.selectedColor)
        $element.find('.t-selected-color').css('background-color', this.selectedColor);

    $(element.ownerDocument.documentElement)
        .bind('mousedown', $.proxy(function (e) {
            if (!$(e.target).closest('.t-colorpicker-popup').length)
                this.close();
        }, this));

    $t.bind(this, {
        change: this.onChange,
        load: this.onLoad
    });
}

$t.colorpicker.prototype = {
    select: function(color) {
        if (color) {
            color = dom.toHex(color);
            if (!$t.trigger(this.element, 'change', { value: color })) {
                this.value(color);
                this.close();
            }
        } else
            $t.trigger(this.element, 'change', { value: this.selectedColor })
    },

    open: function() {
        var $popup = this.popup();
        var $element = $(this.element);

        var elementPosition = $element.offset();
        elementPosition.top += $element.outerHeight();

        if ($element.closest('.t-rtl').length)
            elementPosition.left -= $popup.outerWidth() - $element.outerWidth();

        var zIndex = 'auto';

        $element.parents().andSelf().each(function () {
            zIndex = $(this).css('zIndex');
            if (Number(zIndex)) {
                zIndex = Number(zIndex) + 1;
                return false;
            }
        });

        $t.fx._wrap($popup).css($.extend({
            position: 'absolute',
            zIndex: zIndex
        }, elementPosition));
        
        $popup
            .find('.t-item').bind('click', $.proxy(function(e) {
                var color = $(e.target, e.target.ownerDocument).css('background-color');
                this.select(color);
            }, this));

        // animate
        $t.fx.play(this.effects, $popup, { direction: 'bottom' });
    },

    close: function() {
        if (!this.$popup) return;

        $t.fx.rewind(this.effects, this.$popup, { direction: 'bottom' }, $.proxy(function() {
            dom.remove(this.$popup[0].parentNode);
            this.$popup = null;
        }, this));
    },

    toggle: function() {
        if (!this.$popup || !this.$popup.is(':visible'))
            this.open();
        else
            this.close();
    },

    click: function(e) {
        if ($(e.target).closest('.t-tool-icon').length > 0)
            this.select();
        else
            this.toggle();
    },

    value: function(color) {
        if (!color)
            return this.selectedColor;

        color = dom.toHex(color);

        this.selectedColor = color;

        $('.t-selected-color', this.element)
            .css('background-color', color);
    },

    popup: function() {
        if (!this.$popup)
            this.$popup = $($t.colorpicker.buildPopup(this))
                    .hide()
                    .appendTo(document.body)
                    .find('*')
                    .attr('unselectable', 'on')
                    .end();

        return this.$popup;
    }
}

$.extend($t.colorpicker, {
    buildPopup: function(component) {
        var html = new $t.stringBuilder();

        html.cat('<div class="t-popup t-group t-colorpicker-popup">')
            .cat('<ul class="t-reset">');

        var data = component.data;
        var currentColor = (component.value() || '').substring(1);

        for (var i = 0, len = data.length; i < len; i++) {
            html.cat('<li class="t-item')
                .catIf(' t-selected', data[i] == currentColor)
                .cat('" style="background-color:#')
                .cat(data[i])
                .cat('"></li>');
        }

        html.cat('</ul></div>');

        return html.string();
    }
});

$.fn.tColorPicker = function (options) {
    return $t.create(this, {
        name: 'tColorPicker',
        init: function (element, options) {
            return new $t.colorpicker(element, options)
        },
        options: options
    });
};

$.fn.tColorPicker.defaults = {
    data: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7'.split(','),
    selectedColor: null,
    effects: $t.fx.slide.defaults()
};function IndentFormatter() {
    var finder = new BlockFormatFinder([{tags:blockElements}]);
    
    function margin(node) {
        return node.style.marginLeft || 0;
    }

    this.apply = function (nodes) {
        var formatNodes = finder.findSuitable(nodes);
        if (formatNodes.length) {
            var targets = [];
            for (var i = 0; i < formatNodes.length;i++)
                if (dom.is(formatNodes[i], 'li')) {
                    if ($(formatNodes[i]).index() == 0)
                        targets.push(formatNodes[i].parentNode);
                    else if ($.inArray(formatNodes[i].parentNode, targets) < 0)
                        targets.push(formatNodes[i]);
                }
                else
                    targets.push(formatNodes[i]);
            
            while (targets.length) {
                var formatNode = targets.shift();
                if (dom.is(formatNode, 'li')) {
                    var parentList = formatNode.parentNode;
                    var $sibling = $(formatNode).prev('li');
                    var nestedList = $sibling.find('>ul')[0];
                    
                    if (!nestedList) {
                        nestedList = dom.create(formatNode.ownerDocument, dom.name(parentList));
                        $sibling.append(nestedList);
                    }
                    
                    while (formatNode && formatNode.parentNode == parentList) {
                        nestedList.appendChild(formatNode);
                        formatNode = targets.shift();
                    }
                } else {
                    var marginLeft = parseInt(margin(formatNode)) + 30;
                    dom.style(formatNode, {marginLeft:marginLeft});
                }
            }
        } else {
            var formatter = new BlockFormatter([{tags:blockElements}], {style:{marginLeft:30}});

            formatter.apply(nodes);
        }
    }
    
    this.remove = function(nodes) {
        var formatNodes = finder.findSuitable(nodes);
        for (var i = 0; i < formatNodes.length; i++) {
            var $formatNode = $(formatNodes[i]);
            
            if ($formatNode.is('li')) {
                var $list = $formatNode.parent();
                var $listParent = $list.parent();
                        
                if ($listParent.is('li') && !margin($list[0])) {
                    var $siblings = $formatNode.nextAll('li');
                    if ($siblings.length)
                        $($list[0].cloneNode(false)).appendTo($formatNode).append($siblings);
                                        
                    $formatNode.insertAfter($listParent);
                    
                    if (!$list.children('li').length)
                        $list.remove();
                        
                    continue;
                } else {
                    $formatNode = $list;
                }
            }
                
            var marginLeft = parseInt(margin($formatNode[0])) - 30;
            dom[marginLeft <= 0 ? 'unstyle' : 'style']($formatNode[0], {marginLeft: marginLeft});
        }
    }
}

function IndentCommand(options) {
    options.formatter = {
        toggle : function(range) {
            new IndentFormatter().apply(RangeUtils.nodes(range));
        }
    };
    Command.call(this, options);
}

function OutdentCommand(options) {
    options.formatter = {
        toggle : function(range) {
            new IndentFormatter().remove(RangeUtils.nodes(range));
        }
    };
    
    Command.call(this, options);
}

function OutdentTool() {
    Tool.call(this, {command:OutdentCommand});
    
    var finder = new BlockFormatFinder([{tags:blockElements}]);  

    this.init = function($ui) {
        $ui.attr('unselectable', 'on')
           .addClass('t-state-disabled');
    }
    
    this.update = function ($ui, nodes) {
        var suitable = finder.findSuitable(nodes),
            isOutdentable, listParentsCount;

        for (var i = 0; i < suitable.length; i++) {
            isOutdentable = suitable[i].style.marginLeft;

            if (!isOutdentable) {
                listParentsCount = $(suitable[i]).parents('ul,ol').length;
                isOutdentable = (dom.is(suitable[i], 'li') && listParentsCount > 1)
                             || (dom.ofType(suitable[i], ['ul','ol']) && listParentsCount > 0);
            }

            if (isOutdentable) {
                $ui.removeClass('t-state-disabled');
                return;
            }
        }
    
        $ui.addClass('t-state-disabled').removeClass('t-state-hover');
    }
};function PendingFormats(editor) {
    this.editor = editor;
    this.formats = [];
}

PendingFormats.prototype = {
    apply: function(range) {
        if (!this.hasPending())
            return;
            
        var marker = new Marker();
        
        marker.addCaret(range);

        var caret = range.startContainer.childNodes[range.startOffset];

        var target = caret.previousSibling;

        /* under IE, target is a zero-length text node. go figure. */
        if (!target.nodeValue)
            target = target.previousSibling;

        range.setStart(target, target.nodeValue.length - 1);

        marker.add(range);

        if (textNodes(range).length == 0) {
            marker.remove(range);
            range.collapse(true);
            this.editor.selectRange(range);
            return;
        }

        var textNode = marker.end.previousSibling.previousSibling;

        var pendingFormat, formats = this.formats;

        for (var i = 0; i < formats.length; i++) {
            pendingFormat = formats[i];
            
            var command = pendingFormat.command($.extend({ range: range }, pendingFormat.params));
            command.editor = this.editor;
            command.exec();

            range.selectNode(textNode);
        }

        marker.remove(range);

        if (textNode.parentNode) {
            range.setStart(textNode, 1);
            range.collapse(true);
        }
        
        this.clear();

        this.editor.selectRange(range);
    },
    hasPending: function() {
        return this.formats.length > 0;
    },
    isPending: function(format) {
        return !!this.getPending(format);
    },
    getPending: function(format) {
        var formats = this.formats;
        for (var i = 0; i < formats.length; i++)
            if (formats[i].name == format)
                return formats[i];

        return;
    },
    toggle: function(format) {
        var formats = this.formats;

        for (var i = 0; i < formats.length; i++)
            if (formats[i].name == format.name) {
                if (formats[i].params && formats[i].params.value != format.params.value)
                    formats[i].params.value = format.params.value;
                else
                    formats.splice(i, 1);

                return;
            }

        formats.push(format);
    },
    clear: function() {
        this.formats = [];
    }
};
function createContentElement($textarea, stylesheets) {
    $textarea.hide();
    var iframe = $('<iframe />', { src: 'javascript:"<html></html>"', frameBorder: '0', className: 't-content' })
                    .css('display', '')
                    .insertBefore($textarea)[0];

    var window = iframe.contentWindow || iframe;
    var document = window.document || iframe.contentDocument;
        
    // <img>\s+\w+ creates invalid nodes after cut in IE
    var html = $textarea.val().replace(/(<\/?img[^>]*>)[\r\n\v\f\t ]+/ig, '$1');

    if (!html.length && $.browser.mozilla)
        html = '<br _moz_dirty="true" />';

    document.designMode = 'On';
    document.open();
    document.write(
        new $t.stringBuilder()
            .cat('<!DOCTYPE html><html><head>')
            .cat('<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />')
            .cat('<style type="text/css">')
                .cat('html,body{padding:0;margin:0;font-family:Verdana,Geneva,sans-serif;background:#fff;}')
                .cat('html{font-size:100%}body{font-size:.75em;line-height:1.5;padding-top:1px;margin-top:-1px;')
                    .catIf('direction:rtl;', $textarea.closest('.t-rtl').length)
                .cat('}')
                .cat('h1{font-size:2em;margin:.67em 0}h2{font-size:1.5em}h3{font-size:1.16em}h4{font-size:1em}h5{font-size:.83em}h6{font-size:.7em}')
                .cat('p{margin:0 0 1em;padding:0 .2em}.t-marker{display:none;}.t-paste-container{position:absolute;left:-10000px;width:1px;height:1px;overflow:hidden}')
                .cat('ul,ol{padding-left:2.5em}')
                .cat('a{color:#00a}')
                .cat('code{font-size:1.23em}')
            .cat('</style>')
            .cat($.map(stylesheets, function(href){ return ['<link type="text/css" href="', href, '" rel="stylesheet"/>'].join(''); }).join(''))
            .cat('</head><body spellcheck="false">')
            .cat(html)
            .cat('</body></html>')
        .string());
        
    document.close();

    return window;
};

function selectionChanged(editor) {
    $t.trigger(editor.element, 'selectionChange');
}

$t.editor = function (element, options) {
    /* suppress initialization in mobile webkit devices (w/o proper contenteditable support) */
    if (/Mobile.*Safari/.test(navigator.userAgent))
        return;

    var self = this;

    this.element = element;

    var $element = $(element);

    $element.closest('form').bind('submit', function () {
        self.update();
    });

    $.extend(this, options);

    $t.bind(this, {
        load: this.onLoad,
        selectionChange: this.onSelectionChange,
        change: this.onChange,
        execute: this.onExecute,
        error: this.onError
    });

    for (var id in this.tools)
        this.tools[id].name = id.toLowerCase();
        
    this.textarea = $element.find('textarea').attr('autocomplete', 'off')[0];
    this.window = createContentElement($(this.textarea), this.stylesheets);
    this.document = this.window.contentDocument || this.window.document;
    this.body = this.document.body;
    this.keyboard = new Keyboard([new TypingHandler(this), new SystemHandler(this)]);
        
    this.clipboard = new Clipboard(this);

    this.pendingFormats = new PendingFormats(this);
        
    this.undoRedoStack = new UndoRedoStack();

    function toolFromClassName(element) {
        var tool = $.grep(element.className.split(' '), function (x) {
            return !/^t-(widget|tool-icon|state-hover|header|combobox|dropdown|selectbox|colorpicker)$/i.test(x);
        });
        return tool[0] ? tool[0].substring(2) : 'custom';
    }

    function appendShortcutSequence(localizedText, tool) {
        if (!tool.key)
            return localizedText;

        return new $t.stringBuilder()
            .cat(localizedText)
            .cat(' (')
                .catIf('Ctrl + ', tool.ctrl)
                .catIf('Shift + ', tool.shift)
                .catIf('Alt + ', tool.alt)
                .cat(tool.key)
            .cat(')')
            .string();
    }

    $(this.window).bind('blur', function () {
        var old = self.textarea.value,
            value = self.encodedValue();
        self.update(value);

        if (value != old)
            $t.trigger(self.element, 'change');
    });

    var toolbarItems = '.t-editor-toolbar > li > *',
        buttons = '.t-editor-button .t-tool-icon',
        enabledButtons = buttons + ':not(.t-state-disabled)',
        disabledButtons = buttons + '.t-state-disabled';

    $element
        .delegate(enabledButtons, 'mouseenter', $t.hover)
        .delegate(enabledButtons, 'mouseleave', $t.leave)
        .delegate(buttons, 'mousedown', $t.preventDefault)
        .delegate(enabledButtons, 'click', $t.stopAll(function (e) {
            self.focus();
            self.exec(toolFromClassName(this));
        }))
        .delegate(disabledButtons, 'click', function(e) { e.preventDefault(); })
        .find(toolbarItems)
            .each(function () {
                var toolName = toolFromClassName(this),
                    tool = self.tools[toolName],
                    description = self.localization[toolName],
                    $this = $(this);

                if (!tool)
                    return;
                    
                if (toolName == 'fontSize' || toolName == 'fontName') {
                    var inheritText = self.localization[toolName + 'Inherit'] || localization[toolName + 'Inherit']
                    self[toolName][0].Text = inheritText;
                    $this.find('input').val(inheritText).end()
                         .find('span.t-input').text(inheritText).end();
                }

                tool.init($this, {
                    title: appendShortcutSequence(description, tool),
                    editor: self
                });

            }).end()
        .bind('selectionChange', function() {
            var range = self.getRange();
            self.selectionRestorePoint = new RestorePoint(range);
            var nodes = textNodes(range);
            if (!nodes.length)
                nodes = [range.startContainer];

            $element.find(toolbarItems).each(function () {
                    var tool = self.tools[toolFromClassName(this)];
                    if (tool)
                        tool.update($(this), nodes, self.pendingFormats);
                });
        });

    $(document)
        .bind('DOMNodeInserted', function(e) {
            if ($.contains(e.target, self.element) || self.element == e.target) {
                $(self.element).find('iframe').remove();
                self.window = createContentElement($(self.textarea), self.stylesheets);
                self.document = self.window.contentDocument || self.window.document;
                self.body = self.document.body;
            }
        });

    var isFirstKeyDown = true;

    $(this.document)
        .bind({
            keydown: function (e) {
                var toolName = self.keyboard.toolFromShortcut(self.tools, e);
                if (toolName) {
                    e.preventDefault();
                    self.exec(toolName);
                    return false;
                }

                if (self.keyboard.isTypingKey(e) && self.pendingFormats.hasPending()) {
                    if (isFirstKeyDown)
                        isFirstKeyDown = false;
                    else {
                        var range = self.getRange();
                        self.pendingFormats.apply(range);
                        self.selectRange(range);
                    } 
                }

                self.keyboard.clearTimeout();

                self.keyboard.keydown(e);
            },
            keyup: function (e) {
                var selectionCodes = [8, 9, 33, 34, 35, 36, 37, 38, 39, 40, 40, 45, 46];

                if ($.browser.mozilla && e.keyCode == 8)
                    fixBackspace(self, e);
                
                if ($.inArray(e.keyCode, selectionCodes) > -1 || (e.keyCode == 65 && e.ctrlKey && !e.altKey && !e.shiftKey)) {
                    self.pendingFormats.clear();
                    selectionChanged(self);
                }
                
                if (self.keyboard.isTypingKey(e)) {
                    var range = self.getRange();
                    self.pendingFormats.apply(range);
                    self.selectRange(range);
                } else
                    isFirstKeyDown = true;

                self.keyboard.keyup(e);
            },
            mousedown: function(e) {
                self.pendingFormats.clear();

                var target = $(e.target);

                if (!$.browser.gecko && e.which == 2 && target.is('a[href]'))
                    window.open(target.attr('href'), '_new');
            },
            mouseup: function () {
                selectionChanged(self);
            }
        });
    
    $(this.body)
        .bind('focusout', function(e) {
            if (self.keyboard.typingInProgress())
                self.keyboard.endTyping(true);
            try {
                if (!self.selectionRestorePoint) {
                    self.selectionRestorePoint = new RestorePoint(self.getRange());
                } 
            }
            catch (e) {
                
            }
        })
        .bind('cut paste', function (e) {
            self.clipboard['on' + e.type](e);
        });
};

function fixBackspace(editor, e) {

    var range = editor.getRange(),
        startContainer = range.startContainer;

	if (startContainer == editor.body.firstChild || !dom.isBlock(startContainer)
    || (startContainer.childNodes.length > 0 && !(startContainer.childNodes.length == 1 && dom.is(startContainer.firstChild, 'br'))))
        return;
			
	var previousBlock = startContainer.previousSibling;

	while (previousBlock && !dom.isBlock(previousBlock))
        previousBlock = previousBlock.previousSibling;

	if (!previousBlock)
        return;

	var walker = editor.document.createTreeWalker(previousBlock, NodeFilter.SHOW_TEXT, null, false);

    var textNode;

	while (textNode = walker.nextNode())
		previousBlock = textNode;

	range.setStart(previousBlock, isDataNode(previousBlock) ? previousBlock.nodeValue.length : 0);
	range.collapse(true);
	selectRange(range);

	dom.remove(startContainer);

    e.preventDefault();
}

$.extend($t.editor, {
    BlockFormatFinder: BlockFormatFinder,
    BlockFormatter: BlockFormatter,
    Dom: dom,
    FormatCommand: FormatCommand,
    GenericCommand: GenericCommand,
    GreedyBlockFormatter: GreedyBlockFormatter,
    GreedyInlineFormatFinder: GreedyInlineFormatFinder,
    GreedyInlineFormatter: GreedyInlineFormatter,
    ImageCommand: ImageCommand,
    IndentCommand: IndentCommand,
    IndentFormatter: IndentFormatter,
    InlineFormatFinder: InlineFormatFinder,
    InlineFormatter: InlineFormatter,
    InsertHtmlCommand: InsertHtmlCommand,
    Keyboard: Keyboard,
    LinkCommand: LinkCommand,
    LinkFormatFinder: LinkFormatFinder,
    LinkFormatter: LinkFormatter,
    ListCommand: ListCommand,
    ListFormatFinder: ListFormatFinder,
    ListFormatter: ListFormatter,
    MSWordFormatCleaner: MSWordFormatCleaner,
    Marker: Marker,
    NewLineCommand: NewLineCommand,
    OutdentCommand: OutdentCommand,
    ParagraphCommand: ParagraphCommand,
    PendingFormats: PendingFormats,
    RangeEnumerator: RangeEnumerator,
    RangeUtils: RangeUtils,
    RestorePoint: RestorePoint,
    SystemHandler: SystemHandler,
    TypingHandler: TypingHandler,
    UndoRedoStack: UndoRedoStack,
    UnlinkCommand: UnlinkCommand
});

// public api
$t.editor.prototype = {
    value: function (html) {
        var body = this.body;
        if (html === undefined) return domToXhtml(body);

        this.pendingFormats.clear();

        // Some browsers do not allow setting CDATA sections through innerHTML so we encode them as comments
        html = html.replace(/<!\[CDATA\[(.*)?\]\]>/g, '<!--[CDATA[$1]]-->');

        // Encode script tags to avoid execution and lost content (IE)
        html = html.replace(/<script([^>]*)>(.*)?<\/script>/ig, '<telerik:script $1>$2<\/telerik:script>');

        // Add <br/>s to empty paragraphs in mozilla
        if ($.browser.mozilla)
            html = html.replace(/<p([^>]*)>(\s*)?<\/p>/ig, '<p $1><br _moz_dirty="" /><\/p>');

        if ($.browser.msie && parseInt($.browser.version) < 9) {
            // Internet Explorer removes comments from the beginning of the html
            html = '<br/>' + html;

            var originalSrc = 'originalsrc',
                originalHref = 'originalhref';

            // IE < 8 makes href and src attributes absolute
            html = html.replace(/href\s*=\s*(?:'|")?([^'">\s]*)(?:'|")?/, originalHref + '="$1"');
            html = html.replace(/src\s*=\s*(?:'|")?([^'">\s]*)(?:'|")?/, originalSrc + '="$1"');

            body.innerHTML = html;
            dom.remove(body.firstChild);

            $(body).find('telerik\\:script,script,link,img,a').each(function () {
                var node = this;
                if (node[originalHref]) {
                    node.setAttribute('href', node[originalHref]);
                    node.removeAttribute(originalHref);
                }
                if (node[originalSrc]) {
                    node.setAttribute('src', node[originalSrc]);
                    node.removeAttribute(originalSrc);
                }
            });
        } else {
            body.innerHTML = html;
            if ($.browser.msie) {
                // having unicode characters creates denormalized DOM tree in IE9
                normalize(body);
            }
        }

        this.update();
    },

    focus: function () {
        this.window.focus();
    },

    update: function (value) {
        this.textarea.value = value || this.encoded ? this.encodedValue() : this.value();
    },

    encodedValue: function () {
        return dom.encode(this.value());
    },

    createRange: function (document) {
        return createRange(document || this.document);
    },

    getSelection: function () {
        return selectionFromDocument(this.document);
    },
        
    selectRange: function(range) {
        var selection = this.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
    },

    getRange: function () {
        var selection = this.getSelection();
        var range = selection.rangeCount > 0 ? selection.getRangeAt(0) : this.createRange();

        if (range.startContainer == this.document && range.endContainer == this.document && range.startOffset == 0 && range.endOffset == 0) {
            range.setStart(this.body, 0);
            range.collapse(true);
        }

        return range;
    },

    selectedHtml: function() {
        return domToXhtml(this.getRange().cloneContents());
    },
    
    paste: function (html) {
        this.clipboard.paste(html);
    },

    exec: function (name, params) {
        name = name.toLowerCase();
        var tool = '';

        for (var id in this.tools)
            if (id.toLowerCase() == name) {
                tool = this.tools[id];
                break;
            }

        if (tool) {
            var range = this.getRange();

            if (!/undo|redo/i.test(name) && tool.willDelayExecution(range)) {
                this.pendingFormats.toggle({ name: name, params: params, command: tool.command });
                selectionChanged(this);
                return;
            }

            var command = tool.command ? tool.command($.extend({ range: range }, params)) : null;

            $t.trigger(this.element, 'execute', { name: name, command: command });

            if (/undo|redo/i.test(name)) {
                this.undoRedoStack[name]();
            } else if (command) {
                if (!command.managesUndoRedo)
                    this.undoRedoStack.push(command);
                    
                command.editor = this;
                command.exec();

                if (command.async) {
                    command.change = $.proxy(function () { selectionChanged(this); }, this);
                    return;
                }
            }

            selectionChanged(this);
        }
    }
}

$.fn.tEditor = function (options) {
    return $t.create(this, {
        name: 'tEditor',
        init: function (element, options) {
            return new $t.editor(element, options);
        },
        options: options
    });
}

var formats = {
    bold: [
        { tags: ['strong'] },
        { tags: ['span'], attr: { style: { fontWeight: 'bold'}} }
    ],

    italic: [
        { tags: ['em'] },
        { tags: ['span'], attr: { style: { fontStyle: 'italic'}} }
    ],

    underline: [{ tags: ['span'], attr: { style: { textDecoration: 'underline'}}}],

    strikethrough: [
        { tags: ['del'] },
        { tags: ['span'], attr: { style: { textDecoration: 'line-through'}} }
    ],
    
    justifyLeft: [
        { tags: blockElements, attr: { style: { textAlign: 'left'}} },
        { tags: ['img'], attr: { style: { 'float': 'left'}} }
    ],

    justifyCenter: [
        { tags: blockElements, attr: { style: { textAlign: 'center'}} },
        { tags: ['img'], attr: { style: { display: 'block', marginLeft: 'auto', marginRight: 'auto'}} }
    ],

    justifyRight: [
        { tags: blockElements, attr: { style: { textAlign: 'right'}} },
        { tags: ['img'], attr: { style: { 'float': 'right'}} }
    ],

    justifyFull: [
        { tags: blockElements, attr: { style: { textAlign: 'justify'}} }
    ]
};

function formatByName(name, format) {
    for (var i = 0; i < format.length; i++)
        if ($.inArray(name, format[i].tags) >= 0)
            return format[i];
}

function Tool(options) {
    $.extend(this, options);

    this.init = function($ui, options) {
        $ui.attr({ unselectable: 'on', title: options.title });
    }

    this.command = function (commandArguments) {
        return new options.command(commandArguments);
    }

    this.update = function() {
    }

    this.willDelayExecution = function() {
        return false;
    }
}

Tool.exec = function (editor, name, value) {
    editor.focus();

    if (editor.selectionRestorePoint) {
        editor.selectRange(editor.selectionRestorePoint.toRange());
        editor.selectionRestorePoint = null;
    }
                    
    editor.exec(name, { value: value });
}

function FormatTool(options) {
    Tool.call(this, options);

    this.command = function (commandArguments) {
        return new FormatCommand($.extend(commandArguments, {
                formatter: options.formatter
            }));
    }

    this.update = function($ui, nodes, pendingFormats) {
        var isPending = pendingFormats.isPending(this.name),
            isFormatted = options.finder.isFormatted(nodes),
            isActive = isPending ? !isFormatted : isFormatted;

        $ui.toggleClass('t-state-active', isActive);
    }
}

var emptyFinder = function () { return { isFormatted: function () { return false } } };

var localization = {
    bold: 'Bold',
    italic: 'Italic',
    underline: 'Underline',
    strikethrough: 'Strikethrough',
    justifyCenter: 'Center text',
    justifyLeft: 'Align text left',
    justifyRight: 'Align text right',
    justifyFull: 'Justify',
    insertUnorderedList: 'Insert unordered list',
    insertOrderedList: 'Insert ordered list',
    indent: 'Indent',
    outdent: 'Outdent',
    createLink: 'Insert hyperlink',
    unlink: 'Remove hyperlink',
    insertImage: 'Insert image',
    insertHtml: 'Insert HTML',
    fontName: 'Select font family',
    fontNameInherit: '(inherited font)',
    fontSize: 'Select font size',
    fontSizeInherit: '(inherited size)',
    formatBlock: 'Format',
    style: 'Styles',
    emptyFolder: 'Empty Folder',
    uploadFile: 'Upload',
    orderBy: 'Arrange by:',
    orderBySize: 'Size',
    orderByName: 'Name',
    invalidFileType: "The selected file \"{0}\" is not valid. Supported file types are {1}.",
    deleteFile: 'Are you sure you want to delete "{0}"?',
    overwriteFile: 'A file with name "{0}" already exists in the current directory. Do you want to overwrite it?',
    directoryNotFound: 'A directory with this name was not found.'
};

$.fn.tEditor.defaults = {
    localization: localization,
    formats: formats,
    encoded: true,
    stylesheets: [],
    dialogOptions: {
        modal: true, resizable: false, draggable: true,
        effects: {list:[{name:'toggle'}]}
    },
    fontName: [
        { Text: localization.fontNameInherit,  Value: 'inherit' },
        { Text: 'Arial', Value: "Arial,Helvetica,sans-serif" },
        { Text: 'Courier New', Value: "'Courier New',Courier,monospace" },
        { Text: 'Georgia', Value: "Georgia,serif" },
        { Text: 'Impact', Value: "Impact,Charcoal,sans-serif" },
        { Text: 'Lucida Console', Value: "'Lucida Console',Monaco,monospace" },
        { Text: 'Tahoma', Value: "Tahoma,Geneva,sans-serif" },
        { Text: 'Times New Roman', Value: "'Times New Roman',Times,serif" },
        { Text: 'Trebuchet MS', Value: "'Trebuchet MS',Helvetica,sans-serif" },
        { Text: 'Verdana', Value: "Verdana,Geneva,sans-serif" }
    ],
    fontSize: [
        { Text: localization.fontSizeInherit,  Value: 'inherit' },
        { Text: '1 (8pt)',  Value: 'xx-small' },
        { Text: '2 (10pt)', Value: 'x-small' },
        { Text: '3 (12pt)', Value: 'small' },
        { Text: '4 (14pt)', Value: 'medium' },
        { Text: '5 (18pt)', Value: 'large' },
        { Text: '6 (24pt)', Value: 'x-large' },
        { Text: '7 (36pt)', Value: 'xx-large' }
    ],
    formatBlock: [
        { Text: 'Paragraph', Value: 'p' },
        { Text: 'Quotation', Value: 'blockquote' },
        { Text: 'Heading 1', Value: 'h1' },
        { Text: 'Heading 2', Value: 'h2' },
        { Text: 'Heading 3', Value: 'h3' },
        { Text: 'Heading 4', Value: 'h4' },
        { Text: 'Heading 5', Value: 'h5' },
        { Text: 'Heading 6', Value: 'h6' }
    ],
    tools: {
        bold: new InlineFormatTool({ key: 'B', ctrl: true, format: formats.bold}),
        italic: new InlineFormatTool({ key: 'I', ctrl: true, format: formats.italic}),
        underline: new InlineFormatTool({ key: 'U', ctrl: true, format: formats.underline}),
        strikethrough: new InlineFormatTool({format: formats.strikethrough}),
        undo: { key: 'Z', ctrl: true },
        redo: { key: 'Y', ctrl: true },
        insertLineBreak: new Tool({ key: 13, shift: true, command: NewLineCommand }),
        insertParagraph: new Tool({ key: 13, command: ParagraphCommand }),
        justifyCenter: new BlockFormatTool({format: formats.justifyCenter}),
        justifyLeft: new BlockFormatTool({format: formats.justifyLeft}),
        justifyRight: new BlockFormatTool({format: formats.justifyRight}),
        justifyFull: new BlockFormatTool({format: formats.justifyFull}),
        insertUnorderedList: new ListTool({tag:'ul'}),
        insertOrderedList: new ListTool({tag:'ol'}),
        createLink: new Tool({ key: 'K', ctrl: true, command: LinkCommand}),
        unlink: new UnlinkTool({ key: 'K', ctrl: true, shift: true}),
        insertImage: new Tool({ command: ImageCommand }),
        indent: new Tool({ command: IndentCommand }),
        outdent: new OutdentTool(),
        insertHtml: new InsertHtmlTool(),
        style: new StyleTool(),
        fontName: new FontTool({cssAttr:'font-family', domAttr: 'fontFamily', name:'fontName'}),
        fontSize: new FontTool({cssAttr:'font-size', domAttr:'fontSize', name:'fontSize'}),
        formatBlock: new FormatBlockTool(),
        foreColor: new ColorTool({cssAttr:'color', domAttr:'color', name:'foreColor'}),
        backColor: new ColorTool({cssAttr:'background-color', domAttr: 'backgroundColor', name:'backColor'})
    }
}
})(jQuery);



(function ($) {
    var undefined,
        $t = $.telerik,
        rFileExtension = /\.([^\.]+)$/;

    $t.upload = function (element, options) {
        $.extend(this, options);

        this.element = element;
        this.name = element.name;

        var activeInput = $(element);
        this.wrapper = activeInput.closest(".t-upload");
        if (this.wrapper.length == 0) {
            this.wrapper = this._wrapInput(activeInput);
        }

        this._setActiveInput(activeInput);
        this.toggle(this.enabled);

        activeInput.closest("form").bind({
            "submit": $.proxy(this._onParentFormSubmit, this),
            "reset": $.proxy(this._onParentFormReset, this)
        });

        if (this.async.saveUrl != undefined) {
            this._module = this._getSupportsFormData() ?
                new formDataUploadModule(this) :
                new iframeUploadModule(this);
        } else {
            this._module = new syncUploadModule(this);
        }

        if (this._getSupportsDrop()) {
            this._setupDropZone();
        }

        this.wrapper
            .delegate(".t-upload-action", "click", $.proxy(this._onFileAction, this))
            .delegate(".t-upload-selected", "click", $.proxy(this._onUploadSelected, this))
            .delegate(".t-file", "t:progress", $.proxy(this._onFileProgress, this))
            .delegate(".t-file", "t:upload-success", $.proxy(this._onUploadSuccess, this))
            .delegate(".t-file", "t:upload-error", $.proxy(this._onUploadError, this));

        $t.bind(this.wrapper, {
            load: this.onLoad,
            select: this.onSelect,
            upload: this.onUpload,
            success: this.onSuccess,
            error: this.onError,
            complete: this.onComplete,
            cancel: this.onCancel,
            remove: this.onRemove
        });

        // Load is triggered for the input by $t.bind,
        // but we need it to trigger for the wrapper
        $t.trigger(this.wrapper, 'load');
    };

    $t.upload.prototype = {
        enable: function() {
            this.toggle(true);
        },

        disable: function() {
            this.toggle(false);
        },

        toggle: function(enable) {
            this.wrapper.toggleClass("t-state-disabled", !enable);
        },

        _addInput: function(input) {
            input
                .insertAfter(this.element)
                .data("tUpload", this);

            $(this.element)
                .hide()
                .removeAttr("id");

            this._setActiveInput(input);
        },

        _setActiveInput: function(input) {
            var wrapper = this.wrapper;
            this.element = input;

            input
                .attr("multiple", this._getSupportsMultiple() ? this.multiple : false)
                .attr("autocomplete", "off")
                .click(function(e) {
                    if (wrapper.hasClass("t-state-disabled")) {
                        e.preventDefault();
                    }
                })
                .change($.proxy(this._onInputChange, this));
        },

        _onInputChange: function(e)
        {
            var input = $(e.target),
                prevented =
                    $t.trigger(this.wrapper, "select", {
                        files: getInputFiles(input)
                    });

            if (!prevented) {
                input.trigger("t:select");
            }
        },

        _enqueueFile: function(name, data) {
            var fileList =  $(".t-upload-files", this.wrapper);
            if (fileList.length == 0) {
                fileList = $("<ul class='t-upload-files t-reset'></ul>").appendTo(this.wrapper);
                if (!this.showFileList) {
                    fileList.hide();
                }
            }

            var existingFileEntries = $(".t-file", fileList);
            var fileEntry = $("<li class='t-file'><span class='t-icon'></span><span class='t-filename'>" + name + "</span></li>")
                .appendTo(fileList)
                .data(data);

            if (!this.multiple) {
                existingFileEntries.trigger("t:remove");
            }

            return fileEntry;
        },

        _removeFileEntry: function(fileEntry) {
            var fileList = fileEntry.closest(".t-upload-files");
            if ($(".t-file", fileList).length == 1) {
                fileList.remove();
                this._hideUploadButton();
            } else {
                fileEntry.remove();
            }
        },

        _setFileAction: function(fileElement, actionKey) {
            var classDictionary = { remove: "t-delete", cancel: "t-cancel", retry: "t-retry" };
            if (!classDictionary.hasOwnProperty(actionKey)) {
                return;
            }

            this._clearFileAction(fileElement);

            fileElement.append(
                this._renderAction(classDictionary[actionKey], this.localization[actionKey])
                .addClass("t-upload-action")
            );
        },

        _setFileState: function(fileEntry, stateKey) {
            var states = {
                uploading: {
                    cssClass: "t-loading",
                    text : this.localization.statusUploading
                },
                uploaded: {
                    cssClass: "t-success",
                    text : this.localization.statusUploaded
                },
                failed: {
                    cssClass: "t-fail",
                    text : this.localization.statusFailed
                }
            };

            var currentState = states[stateKey];
            if (currentState) {
                var icon = fileEntry.children(".t-icon").text(currentState.text);
                icon[0].className = "t-icon " + currentState.cssClass;
            }
        },

        _renderAction: function (actionClass, actionText) {
            if (actionClass != "") {
                return $(
                "<button type='button' class='t-button t-button-icontext'>" +
                    "<span class='t-icon " + actionClass + "'></span>" +
                    actionText +
                "</button>"
                )
            }
            else {
                return $(
                "<button type='button' class='t-button'>" +
                    actionText +
                "</button>"
                )
            }
        },

        _clearFileAction: function(fileElement) {
            fileElement
                .find(".t-upload-action").remove();
        },

        _onFileAction: function(e) {
            if (!this.wrapper.hasClass("t-state-disabled")) {
                var button = $(e.target).closest(".t-upload-action"),
                    icon = button.find(".t-icon"),
                    fileEntry = button.closest(".t-file"),
                    eventArgs = { files: fileEntry.data("fileNames") };

                if (icon.hasClass("t-delete")) {
                    if (!$t.trigger(this.wrapper, "remove", eventArgs)) {
                        fileEntry.trigger("t:remove");
                    }
                } else if (icon.hasClass("t-cancel")) {
                    $t.trigger(this.wrapper, "cancel", eventArgs);
                    fileEntry.trigger("t:cancel");
                } else if (icon.hasClass("t-retry")) {
                    fileEntry.trigger("t:retry");                    
                }
            }

            return false;
        },

        _onUploadSelected: function() {
            this.wrapper.trigger("t:saveSelected");
            return false;
        },

        _onFileProgress: function(e, percentComplete) {
            var progressBar = $(".t-progress-status", e.target);
            if (progressBar.length == 0) {
                progressBar =
                    $("<span class='t-progress'><span class='t-progress-status' style='width: 0;'></span></span>")
                        .appendTo($(".t-filename", e.target))
                        .find(".t-progress-status");
            }

            progressBar.width(percentComplete + "%");
        },

        _onUploadSuccess: function(e, response, xhr) {
            var fileEntry = getFileEntry(e);

            this._setFileState(fileEntry, "uploaded");

            $t.trigger(this.wrapper, "success", {
                files: fileEntry.data("fileNames"),
                response: response,
                operation: "upload",
                XMLHttpRequest: xhr
            });

            if (this._supportsRemove()) {
                this._setFileAction(fileEntry, "remove");
            } else {
                this._clearFileAction(fileEntry);
            }

            this._checkAllComplete();
        },

        _onUploadError: function(e, xhr) {
            var fileEntry = getFileEntry(e);

            this._setFileState(fileEntry, "failed");
            this._setFileAction(fileEntry, "retry");

            var prevented = $t.trigger(this.wrapper, "error", {
                operation: "upload",
                files: fileEntry.data("fileNames"),
                XMLHttpRequest: xhr
            });

            logToConsole("Server response: " + xhr.responseText);

            if (!prevented) {
                this._alert("Error! Upload failed. Unexpected server response - see console.");
            }

            this._checkAllComplete();
        },

        _showUploadButton: function() {
            var uploadButton = $(".t-upload-selected", this.wrapper);
            if (uploadButton.length == 0) {
                uploadButton =
                    this._renderAction("", this.localization["uploadSelectedFiles"])
                    .addClass("t-upload-selected");
            }

            this.wrapper.append(uploadButton);
        },

        _hideUploadButton: function() {
            $(".t-upload-selected", this.wrapper).remove();
        },

        _onParentFormSubmit: function() {
            this.element.trigger("t:abort");

            var upload = this;
            if (!this.element.value) {
                // Prevent submitting an empty input by clearing its name temporarily
                var emptyInput = $(this.element).attr("name", "");
                setTimeout(function() {
                    emptyInput.attr("name", upload.name);
                }, 0);
            }
        },

        _onParentFormReset: function() {
            $(".t-file", this.wrapper).trigger("t:remove");
        },

        _getSupportsFormData: function() {
            return typeof(FormData) != "undefined";
        },

        _getSupportsMultiple: function() {
            return !$.browser.opera;
        },

        _getSupportsDrop: function() {
            var userAgent = this._getUserAgent().toLowerCase(),
                isChrome = /chrome/.test(userAgent),
                isSafari = !isChrome && /safari/.test(userAgent),
                isWindowsSafari = isSafari && /windows/.test(userAgent);

            return !isWindowsSafari && this._getSupportsFormData();
        },

        _getUserAgent: function() {
            return navigator.userAgent;
        },

        _setupDropZone: function() {
            $(".t-upload-button", this.wrapper)
                .wrap("<div class='t-dropzone'></div>");

            var dropZone = $(".t-dropzone", this.wrapper)
                .append($("<em>" + this.localization["dropFilesHere"] + "</em>"))
                .bind({
                    "dragenter": stopEvent,
                    "dragover": function(e) { e.preventDefault(); },
                    "drop" : $.proxy(this._onDrop, this)
                });

            bindDragEventWrappers(dropZone,
                function() { dropZone.addClass("t-dropzone-hovered"); },
                function() { dropZone.removeClass("t-dropzone-hovered"); });

            bindDragEventWrappers($(document),
                function() { dropZone.addClass("t-dropzone-active"); },
                function() { dropZone.removeClass("t-dropzone-active"); });
        },

        _onDrop: function (e) {
			var dt = e.originalEvent.dataTransfer,
				files = dt.files;
				
			stopEvent(e);

            if (files.length > 0) {
                $(".t-dropzone", this.wrapper).trigger("t:select", [ files ]);
            }
        },

        _supportsRemove: function() {
            return this.async.removeUrl != undefined;
        },

        _submitRemove: function(fileNames, onSuccess, onError) {
            var params = {};
            params["fileNames"] = fileNames;
            if (this.async.removeUrl) {
                $.ajax({
                    type: "POST",
                    dataType: "json",
                    url: this.async.removeUrl,
                    traditional: true,
                    data: params,
                    success: onSuccess,
                    error: onError
                });
            }
        },

        _alert: function(message) {
            alert(message);
        },

        _wrapInput: function(input) {
            input.wrap("<div class='t-widget t-upload'><div class='t-button t-upload-button'></div></div>");
            input.closest(".t-button")
                .append("<span>" + this.localization.select + "</span>");

            return input.closest(".t-upload");
        },

        _checkAllComplete: function() {
            if ($(".t-file .t-icon.t-loading", this.wrapper).length == 0) {
                $t.trigger(this.wrapper, "complete");
            }
        }
    };

    $.fn.tUpload = function(options) {
        return $t.create(this, {
            name: "tUpload",
            init: function(element, options) {
                return new $t.upload(element, options);
            },
            options: options
        });
    };

    $.fn.tUpload.defaults = {
        enabled: true,
        multiple: true,
        showFileList: true,
        async: { }, // The async section defaults are always serialized.
        localization: {
            "select": "Select...",
            "cancel": "Cancel",
            "retry": "Retry",
            "remove": "Remove",
            "uploadSelectedFiles": "Upload files",
            "dropFilesHere": "drop files here to upload",
            "statusUploading": "uploading",
            "statusUploaded": "uploaded",
            "statusFailed": "failed" }
    };

    // Synchronous upload module
    var syncUploadModule = function(upload) {
        this.name = "syncUploadModule";
        this.element = upload.wrapper;
        this.upload = upload;
        this.element
            .bind("t:select", $.proxy(this.onSelect, this))
            .bind("t:remove", $.proxy(this.onRemove, this))
            .closest("form")
                .attr("enctype", "multipart/form-data")
                .attr("encoding", "multipart/form-data");
    };

    syncUploadModule.prototype = {
        onSelect: function(e) {
            var upload = this.upload;
            var sourceInput = $(e.target);
            upload._addInput(sourceInput.clone().val(""));
            var file = upload._enqueueFile(getFileName(sourceInput), { relatedInput : sourceInput });
            upload._setFileAction(file, "remove");
        },

        onRemove: function(e) {
            var fileEntry = getFileEntry(e);
            fileEntry.data("relatedInput").remove();

            this.upload._removeFileEntry(fileEntry);
        }
    };

    // Iframe upload module
    var iframeUploadModule = function(upload) {
        this.name = "iframeUploadModule";
        this.element = upload.wrapper;
        this.upload = upload;
        this.iframes = [];
        this.element
            .bind("t:select", $.proxy(this.onSelect, this))
            .bind("t:cancel", $.proxy(this.onCancel, this))
            .bind("t:retry", $.proxy(this.onRetry, this))
            .bind("t:remove", $.proxy(this.onRemove, this))
            .bind("t:saveSelected", $.proxy(this.onSaveSelected, this))
            .bind("t:abort", $.proxy(this.onAbort, this));
    };

    iframeUploadModule.prototype = {
        onSelect: function(e) {
            var upload = this.upload,
                sourceInput = $(e.target);

            var fileEntry = this.prepareUpload(sourceInput);

            if (upload.async.autoUpload) {
                this.performUpload(fileEntry);
            } else {
                if (upload._supportsRemove()) {
                    this.upload._setFileAction(fileEntry, "remove");
                }

                upload._showUploadButton();
            }
        },

        prepareUpload: function(sourceInput) {
            var upload = this.upload;
            var activeInput = $(upload.element);
            upload._addInput(sourceInput.clone().val(""));

            var iframe = this.createFrame(upload.name + "_" + this.iframes.length);
            this.registerFrame(iframe);

            var form = this.createForm(upload.async.saveUrl, iframe.attr("name"))
                .append(activeInput);

            var fileEntry = upload._enqueueFile(
                getFileName(sourceInput),
                { "frame": iframe, "relatedInput": activeInput, "fileNames": getInputFiles(sourceInput) });

            iframe
                .data({ "form": form, "file": fileEntry });

            return fileEntry;
        },

        performUpload: function(fileEntry) {
            var e = { files: fileEntry.data("fileNames") },
                iframe = fileEntry.data("frame"),
                upload = this.upload;

            if (!$t.trigger(upload.wrapper, "upload", e)) {
                upload._hideUploadButton();

                iframe.appendTo(document.body);

                var form = iframe.data("form")
                    .appendTo(document.body);

                var saveUrl = upload.async.saveUrl;
                if (e.data) {
                    form[0].action = saveUrl + (/\?/.test(saveUrl) ? "&" : "?") + $.param(e.data);
                }

                upload._setFileAction(fileEntry, "cancel");
                upload._setFileState(fileEntry, "uploading");

                iframe
                    .one("load", $.proxy(this.onIframeLoad, this));
                $(form).AddAntiForgeryToken().submit();
                form[0].submit();
            } else {
                upload._removeFileEntry(iframe.data("file"));
                this.cleanupFrame(iframe);
                this.unregisterFrame(iframe);
            }
        },

        onSaveSelected: function(e) {
            var module = this;

            $(".t-file", this.element).each(function() {
                var fileEntry = $(this),
                    started = isFileUploadStarted(fileEntry);

                if (!started) {
                    module.performUpload(fileEntry);
                }
            });
        },

        onIframeLoad: function(e) {
            var iframe = $(e.target);

            try {
                var responseText = iframe.contents().text();
            } catch (e) {
                responseText = "Error trying to get server response: " + e;
            }

            this.processResponse(iframe, responseText);
        },

        processResponse: function(iframe, responseText) {
            var fileEntry = iframe.data("file"),
                module = this,
                fakeXHR = {
                    responseText: responseText
                };

            tryParseJSON(responseText,
                function(jsonResult) {
                    $.extend(fakeXHR, { statusText: "OK", status: "200" });
                    fileEntry.trigger("t:upload-success", [ jsonResult, fakeXHR ]);
                    module.cleanupFrame(iframe);
                    module.unregisterFrame(iframe);
                },
                function() {
                    $.extend(fakeXHR, { statusText: "error", status: "500" });
                    fileEntry.trigger("t:upload-error", [ fakeXHR ]);
                }
            );
        },

        onCancel: function(e) {
            var iframe = $(e.target).data("frame");

            this.stopFrameSubmit(iframe);
            this.cleanupFrame(iframe);
            this.unregisterFrame(iframe);
            this.upload._removeFileEntry(iframe.data("file"));
        },

        onRetry: function(e) {
            var fileEntry = getFileEntry(e);
            this.performUpload(fileEntry); 
        },

        onRemove: function(e) {
            var fileEntry = getFileEntry(e);

            var iframe = fileEntry.data("frame");
            if (iframe)
            {
                this.unregisterFrame(iframe);
                this.upload._removeFileEntry(fileEntry);
                this.cleanupFrame(iframe);
            } else {
                removeUploadedFile(fileEntry, this.upload);
            }
        },

        onAbort: function() {
            var element = this.element,
                module = this;

            $.each(this.iframes, function() {
                $("input", this.data("form")).appendTo(element);
                module.stopFrameSubmit(this[0]);
                this.data("form").remove();
                this.remove();
            });

            this.iframes = [];
        },

        createFrame: function(id) {
            return $(
                "<iframe" +
                " name='" + id + "'" +
                " id='" + id + "'" +
                " style='display:none;' />"
            );
        },

        createForm: function(action, target) {
            return $(
                "<form enctype='multipart/form-data' method='POST'" +
                " action='" + action + "'" +
                " target='" + target + "'" +
                "/>");
        },

        stopFrameSubmit: function(frame) {
            if (typeof(frame.stop) != "undefined") {
                frame.stop();
            } else if (frame.document) {
                frame.document.execCommand("Stop");
                frame.contentWindow.location.href = frame.contentWindow.location.href;
            }
        },

        registerFrame: function(frame) {
            this.iframes.push(frame);
        },

        unregisterFrame: function(frame) {
            this.iframes = $.grep(this.iframes, function(value) {
                return value.attr("name") != frame.attr("name");
            });
        },

        cleanupFrame: function(frame) {
            var form = frame.data("form");
            frame.data("file").data("frame", null);

            setTimeout(function () {
                form.remove();
                frame.remove();
            }, 1);
        }
    };

    // FormData upload module
    var formDataUploadModule = function(upload) {
        this.name = "formDataUploadModule";
        this.element = upload.wrapper;
        this.upload = upload;
        this.element
            .bind("t:select", $.proxy(this.onSelect, this))
            .bind("t:cancel", $.proxy(this.onCancel, this))
            .bind("t:remove", $.proxy(this.onRemove, this))
            .bind("t:retry", $.proxy(this.onRetry, this))
            .bind("t:saveSelected", $.proxy(this.onSaveSelected, this))
            .bind("t:abort", $.proxy(this.onAbort, this));
    };

    formDataUploadModule.prototype = {
        onSelect: function(e, rawFiles) {
            var upload = this.upload,
                module = this,
                sourceElement = $(e.target),
                files = rawFiles ? getAllFileInfo(rawFiles) : this.getInputFiles(sourceElement),
                fileEntries = this.prepareUpload(sourceElement, files);

            $.each(fileEntries, function() {
                if (upload.async.autoUpload) {
                    module.performUpload(this);
                } else {
                    if (upload._supportsRemove()) {
                        upload._setFileAction(this, "remove");
                    }
                    upload._showUploadButton();
                }
            });
        },

        prepareUpload: function(sourceElement, files) {
            var fileEntries = this.enqueueFiles(files);

            if (sourceElement.is("input")) {
                $.each(fileEntries, function() {
                    $(this).data("relatedInput", sourceElement);
                });
                sourceElement.data("relatedFileEntries", fileEntries);
                this.upload._addInput(sourceElement.clone().val(""));                
            }

            return fileEntries;
        },

        enqueueFiles: function(arrFileInfo) {
            var upload = this.upload
                fileEntries = [];

            for (var i = 0; i < arrFileInfo.length; i++) {
                var currentFile = arrFileInfo[i],
                    name = currentFile.name;

                var fileEntry = upload._enqueueFile(name, { "fileNames": [ currentFile ] });
                fileEntry.data("formData", this.createFormData(arrFileInfo[i]));

                fileEntries.push(fileEntry);
            }

            return fileEntries;
        },

        getInputFiles: function(sourceInput) {
            return getInputFiles(sourceInput);
        },

        performUpload: function(fileEntry) {
            var upload = this.upload,
                formData = fileEntry.data("formData"),
                e = { files: fileEntry.data("fileNames") };

            if (!$t.trigger(this.element, "upload", e)) {
                upload._setFileAction(fileEntry, "cancel");
                upload._hideUploadButton();

                var saveUrl = this.upload.async.saveUrl;
                if (e.data) {
                    saveUrl += (/\?/.test(saveUrl) ? "&" : "?") + $.param(e.data);
                }

                upload._setFileState(fileEntry, "uploading");

                this.postFormData(saveUrl, formData, fileEntry);
            } else {
                this.removeFileEntry(fileEntry);
            }
        },

        onSaveSelected: function(e) {
            var module = this;

            $(".t-file", this.element).each(function() {
                var fileEntry = $(this),
                    started = isFileUploadStarted(fileEntry);

                if (!started) {
                    module.performUpload(fileEntry);
                }
            });
        },

        onCancel: function(e) {
            var fileEntry = getFileEntry(e);
            this.stopUploadRequest(fileEntry);
            this.removeFileEntry(fileEntry);
        },

        onRetry: function(e) {
            var fileEntry = getFileEntry(e);
            this.performUpload(fileEntry); 
        },

        onRemove: function(e) {
            var fileEntry = getFileEntry(e);

            if (fileEntry.children(".t-icon").is(".t-success")) {
                removeUploadedFile(fileEntry, this.upload);
            } else {
                this.removeFileEntry(fileEntry);
            }
        },

        postFormData: function(url, data, fileEntry) {
            var xhr = new XMLHttpRequest(),
                module = this;

            fileEntry.data("request", xhr);

            xhr.addEventListener("load", function(e) {
                module.onRequestSuccess.call(module, e, fileEntry);
            }, false);

            xhr.addEventListener("error", function(e) {
                module.onRequestError.call(module, e, fileEntry);
            }, false);

            xhr.upload.addEventListener("progress", function(e) {
                module.onRequestProgress.call(module, e, fileEntry);
            }, false);

            xhr.open("POST", url);
            xhr.send(data);
        },

        createFormData: function(fileInfo) {
            var formData = new FormData();

            formData.append(this.upload.name, fileInfo.rawFile);

            return formData;
        },

        onRequestSuccess: function(e, fileEntry) {
            var xhr = e.target,
                module = this;
            tryParseJSON(xhr.responseText,
                function(jsonResult) {
                    fileEntry.trigger("t:upload-success", [ jsonResult, xhr ]);
                    module.cleanupFileEntry(fileEntry);
                },
                function() {
                    fileEntry.trigger("t:upload-error", [ xhr ]);
                }
            );
        },

        onRequestError: function(e, fileEntry) {
            var xhr = e.target;
            fileEntry.trigger("t:upload-error", [ xhr ]);
        },

        cleanupFileEntry: function(fileEntry) {
            var relatedInput = fileEntry.data("relatedInput"),
                uploadComplete = true;

            if (relatedInput) {
                $.each(relatedInput.data("relatedFileEntries"), function() {
                    // Exclude removed file entries and self
                    if (this.parent().length > 0 && this[0] != fileEntry[0]) {
                        uploadComplete = uploadComplete && this.children(".t-icon").is(".t-success");
                    }
                });

                if (uploadComplete) {
                    relatedInput.remove();
                }
            }

            fileEntry.data("formData", null);
        },

        removeFileEntry: function(fileEntry) {
            this.cleanupFileEntry(fileEntry);
            this.upload._removeFileEntry(fileEntry);
        },

        onRequestProgress: function(e, fileEntry) {
            var percentComplete = Math.round(e.loaded * 100 / e.total);
            fileEntry.trigger("t:progress", [ percentComplete ]);
        },

        stopUploadRequest: function(fileEntry) {
            fileEntry.data("request").abort();
        }
    };

    // Helper functions
    function getFileName(input) {
        return $.map(getInputFiles(input), function (file) {
            return file.name;
        }).join(", ");
    }

    function getInputFiles($input) {
        var input = $input[0];
        if (input.files) {
            return getAllFileInfo(input.files);
        } else {
            return [{
                name: stripPath(input.value),
                extension: getFileExtension(input.value),
                size: null
            }];
        }
    }

    function getAllFileInfo(rawFiles) {
        return $.map(rawFiles, function (file) {
            return getFileInfo(file);
        });
    }

    function getFileInfo(rawFile) {
        // Older Firefox versions (before 3.6) use fileName and fileSize
        var fileName = rawFile.name || rawFile.fileName;
        return {
            name: fileName,
            extension: getFileExtension(fileName),
            size: rawFile.size || rawFile.fileSize,
            rawFile: rawFile
        };
    }

    function getFileExtension(fileName) {
        return fileName.match(rFileExtension)[0] || "";
    }

    function stripPath(name) {
        var slashIndex = name.lastIndexOf("\\");
        return (slashIndex != -1) ? name.substr(slashIndex + 1) : name;
    }

    function removeUploadedFile(fileEntry, upload) {
        var files = fileEntry.data("fileNames");
        var fileNames = $.map(files, function(file) { return file.name });

        upload._submitRemove(fileNames,
            function onSuccess(data, textStatus, xhr) {
                upload._removeFileEntry(fileEntry);

                $t.trigger(upload.wrapper, "success", {
                    operation: "remove",
                    files: files,
                    response: data,
                    XMLHttpRequest: xhr });
            },

            function onError(xhr, textStatus, textStatus) {
                var prevented = $t.trigger(upload.wrapper, "error", {
                    operation: "remove",
                    files: files,
                    XMLHttpRequest: xhr });

                logToConsole("Server response: " + xhr.responseText);

                if (!prevented) {
                    upload._alert("Error! Remove operation failed. Unexpected response - see console.");
                }
            }
        );
    }

    function tryParseJSON(input, onSuccess, onError) {
        try {
            var json = $.parseJSON(input);
            onSuccess(json);
        } catch (e) {
            onError();
        }
    }

    function stopEvent(e) {
        e.stopPropagation(); e.preventDefault();
    }

    function bindDragEventWrappers(element, onDragEnter, onDragLeave) {
        var hideInterval, lastDrag;

        element
            .bind("dragenter", function(e) {
                onDragEnter();
                lastDrag = new Date();

                if (!hideInterval) {
                    hideInterval = setInterval(function() {
                        var sinceLastDrag = new Date() - lastDrag;
                        if (sinceLastDrag > 100) {
                            onDragLeave();

                            clearInterval(hideInterval);
                            hideInterval = null;
                        }
                    }, 100);
                }
            })
            .bind("dragover", function(e) {
                lastDrag = new Date();
            });        
    }

    function isFileUploadStarted(fileEntry) {
        return fileEntry.children(".t-icon").is(".t-loading, .t-success, .t-fail");
    }

    function logToConsole(message) {
        if (typeof(console) != "undefined" && console.log) {
            console.log(message);
        }
    }

    function getFileEntry(e) {
        return $(e.target).closest(".t-file");
    }

})(jQuery);


(function ($, undefined) {

    var $t = $.telerik, q = $.telerik.query;

    $t.imageBrowser = function (element, options) {
        this.element = element;
        this.wrapper = $(element);

        var filter = options.filter || "*.png,*.gif,*.jpg,*.jpeg";
        var localization = options.localization;
        this.wrapper.append('<div class="t-floatwrap"><div class="t-widget t-combobox t-header t-breadcrumbs"><div class="t-dropdown-wrap t-state-default"><input type="text" class="t-input" /><div class="t-breadcrumbs-wrap"/><span class="t-select t-header"><span class="t-icon t-arrow-down">select</span></span></div></div><div class="t-widget t-combobox t-dropdown-wrap t-search-wrap" /></div>')
                    .append(toolBar(localization, options.uploadUrl, options.createDirectoryUrl, options.deleteFileUrl || options.deleteDirectoryUrl))
                    .append('<ul id="t-editor-image-list" class="t-reset t-floats t-tiles" />');

        var breadcrumbs = this.wrapper.find(".t-breadcrumbs");
        var listView = this.wrapper.find(".t-tiles");
        var searchBox = this.wrapper.find(".t-search-wrap");

        if (options.uploadUrl) {
            this.wrapper.find(".t-upload input").tUpload({
                async: {
                    saveUrl: options.uploadUrl,
                    autoUpload: true
                },
                multiple: false,
                onUpload: function (e) {
                    var rfilter = new RegExp(("(" + filter.split(",").join(")|(") + ")").replace(/\*\./g, ".*\."), "i");

                    var fileName = e.files[0].name;

                    if (rfilter.test(fileName)) {
                        e.data = { path: breadcrumbs.val() };

                        listView.trigger("t:upload", [{ name: fileName }, function () {
                            e.preventDefault();
                        } ]);
                    } else {
                        e.preventDefault();
                        alert($t.formatString(localization.invalidFileType, fileName, filter));
                    }
                },
                onError: function (e) {
                    e.preventDefault();
                    listView.trigger("t:errorFile", [e.files[0]]);

                    var xhr = e.XMLHttpRequest;
                    //if ($t.ajaxError(options.element, 'error', xhr, xhr.statusText))
                    elma.showajaxerror(xhr, e);
                    return;
                },
                onSuccess: function (e) {
                    listView.trigger("t:completeFile", [$.extend(e.response, { path: breadcrumbs.val() })]);
                }
            });
        }
        new $t.searchBox(searchBox[0]);

        new $t.fileListView(listView[0], { thumbnailUrl: options.thumbUrl, localization: localization });

        var dropDown = new $t.dropDown({
            effects: $t.fx.slide.defaults(),
            onClick: function (e) {
                $(element).find(".t-tiles-arrange a span:first").html($(e.item).text());
                dropDown.close();
                breadcrumbs.trigger("t:change");
            }
        });

        var arrangeBy = [{ Text: localization.orderByName, Value: "name" }, { Text: localization.orderBySize, Value: "size"}];

        dropDown.dataBind(arrangeBy);

        this.wrapper.find(".t-tiles-arrange a").click(function (e) {
            e.preventDefault();
            var a = $(this);
            dropDown.open({
                offset: a.offset(),
                outerHeight: a.outerHeight(),
                outerWidth: a.outerWidth(),
                zIndex: $t.getElementZIndex(this)
            });
        }).end().delegate(".t-button:not(.t-state-disabled):has(.t-delete)", "click", function () {
            var selected = listView.find(".t-state-selected");

            if (selected.length && confirm($t.formatString(localization.deleteFile, selected.find("strong").text()))) {
                $.ajax({
                    type: "POST",
                    url: selected.data("kind") == "f" ? options.deleteFileUrl : options.deleteDirectoryUrl,
                    data: { path: selected.data("url") },
                    error: function (xhr, status) {
                        //if ($t.ajaxError(options.element, 'error', xhr, status))
                        elma.showajaxerror(xhr, status);
                        return;
                    },
                    success: function () {
                        listView.trigger("t:delete");
                        $(element).find(".t-delete").parent().addClass("t-state-disabled");
                    }
                });
            }
        }).delegate(".t-button:not(.t-state-disabled):has(.t-addfolder)", "click", function () {
            listView.trigger("t:createDirectory", [function (name) {
                $.ajax({
                    type: "POST",
                    url: options.createDirectoryUrl,
                    data: { path: breadcrumbs.val(), name: name },
                    error: function (xhr, status) {
                        listView.trigger("t:errorDirectory", { name: name });
                        //if ($t.ajaxError(options.element, 'error', xhr, status))
                        elma.showajaxerror(xhr, status);
                        return;
                    },
                    success: function () {
                        listView.trigger("t:completeDirectory", { path: breadcrumbs.val(), name: name });
                    }
                });
            } ]);
        });

        $(document.documentElement).bind('mousedown', function (e) {
            var element = dropDown.$element[0];

            if (!$.contains(element, e.target)) {
                dropDown.close();
            }
        });

        var dataSource = new $t.dataSource({
            error: function (xhr, status) {
                var prevented = $t.trigger(options.element, "error",
                {
                    XMLHttpRequest: xhr,
                    textStatus: status
                });
                if (!prevented) {
                    if (status == 'error') {
                        if (xhr.status == '404') {
                            alert(options.localization.directoryNotFound);
                        } else if (xhr.status != '0') {
                            alert('Error! The requested URL returned ' + xhr.status + ' - ' + xhr.statusText);
                        }
                    } else if (status == 'timeout') {
                        alert('Error! Server timeout.');
                    }
                }
            },
            url: options.selectUrl,
            callback: function (data) {
                $(element).find(".t-delete").parent().addClass("t-state-disabled");

                if (!breadcrumbs.val()) {
                    new $t.breadcrumbs(breadcrumbs[0], { path: data.Path, roots: data.ContentPaths });
                }

                breadcrumbs.val(data.Path).trigger("t:refresh");
                var arrangeByText = $(element).find(".t-tiles-arrange a span:first").text();
                var sortOrder = $.map(arrangeBy, function (item) { if (item.Text == arrangeByText) return item.Value; })[0];
                var filter = searchBox.val();
                listView.trigger("t:refresh", [data, sortOrder, filter]);
            }
        });

        searchBox.bind("t:change", function () {
            breadcrumbs.trigger("t:change");
        });

        dataSource.get({ path: "" });

        listView.bind("t:select", function (args) {
            if (args.kind == "d") {
                dataSource.get({ path: args.url });
            } else {
                options.apply(args);
            }
        }).bind("t:change", function (args) {
            var deleteButton = $(element).find(".t-delete").parent().addClass("t-state-disabled");

            if (args.kind == "f") {
                var url = args.url;
                if (options.imageUrl) {
                    url = options.imageUrl + "?path=" + url;
                }
                $(element).parent().find('#t-editor-image-url').val(url);
            }

            if ((args.kind == "f" && options.deleteFileUrl) || (args.kind == "d" && options.deleteDirectoryUrl)) {
                deleteButton.removeClass("t-state-disabled");
            }
        });

        breadcrumbs.bind("t:change", function () {
            var value = $(this).val();
            if (!value.match(/\/$/)) {
                value = value + "/";
            }
            dataSource.get({ path: value });
        });
    };

    function toolBar(localization, canUpload, canAddFolder, canRemove) {
        var upload = !canUpload ? "" : '<div class="t-widget t-upload"><div class="t-button t-button-icontext t-button-bare t-upload-button"><span class="t-icon t-add"></span>' + localization.uploadFile + '<input type="file" name="file" /></div></div>',
            addFolder = !canAddFolder ? "" : '<button type="button" class="t-button t-button-icon t-button-bare"><span class="t-icon t-addfolder"></span></button>',
            remove = !canRemove ? "" : '<button type="button" class="t-button t-button-icon t-button-bare t-state-disabled"><span class="t-icon t-delete"></span></button>&nbsp;';

        return '<div class="t-tiles-toolbar t-floatwrap">' +
                        '<div class="t-tiles-buttons">' + upload + addFolder + remove +
                        '</div>' +
                        '<div class="t-tiles-arrange">' +
                                localization.orderBy + ' <a href="#" class="t-link"><span>' + localization.orderByName + '</span><span class="t-icon t-arrow-down"></span></a>' +
                        '</div>' +
                '</div>';
    }

    $t.fileInfoReader = function (options) {
        this._thumbnailUrl = options.thumbnailUrl || "";
    }

    $t.fileInfoReader.prototype = {
        read: function (key, data) {
            return data[key] || data[(key.charAt(0).toUpperCase() + key.substring(1))];
        },

        directories: function (data) {
            return this.read("directories", data);
        },
        files: function (data) {
            return this.read("files", data);
        },
        thumbUrl: function (path, name) {
            return this._thumbnailUrl + "/?path=" + path + name;
        },
        size: function (item) {
            var value = this.read("size", item);
            if (!value) {
                return "";
            }

            var suffix = " bytes";

            if (value >= 1073741824) {
                suffix = " GB";
                value /= 1073741824;
            } else if (value >= 1048576) {
                suffix = " MB";
                value /= 1048576;
            } else if (value >= 1024) {
                suffix = " KB";
                value /= 1024;
            }

            return Math.round(value * 100) / 100 + suffix;
        },
        name: function (item) {
            return this.read("name", item);
        },
        path: function (data) {
            return this.read("path", data);
        },
        concatPaths: function (path, name) {
            if (path === undefined || !path.match(/\/$/)) {
                path = (path || "") + "/";
            }
            return path + name;
        }
    };

    $t.fileListView = function (element, options) {
        this.element = element;
        this.wrapper = $(element);
        this._localization = options.localization;
        this._reader = options.reader || new $t.fileInfoReader({ thumbnailUrl: options.thumbnailUrl });

        this._pageSize = options.pageSize || 20;

        this.wrapper.bind({
            "t:refresh": $.proxy(this._refresh, this),
            "t:upload": $.proxy(this._upload, this),
            "t:completeFile": $.proxy(this._completeFile, this),
            "t:completeDirectory": $.proxy(this._completeDirectory, this),
            "t:delete": $.proxy(this._delete, this),
            "t:errorFile": $.proxy(this._errorFile, this),
            "t:errorDirectory": $.proxy(this._errorDirectory, this),
            "t:createDirectory": $.proxy(this._createDirectory, this),
            "scroll": $.proxy(this._scroll, this)
        })
                    .delegate("li[data-url]:not(.t-tile-empty)", "click", $.proxy(this._click, this))
                    .delegate("li[data-url]:not(.t-tile-empty)", "dblclick", $.proxy(this._dblclick, this));
    }

    function loadingHtml(item) {
        return '<li class="t-tile" data-filename="' + item.name + '">' +
                    '<div class="t-thumb">' +
                        '<span class="t-icon t-loading"></span>' +
                    '</div>' +
                    '<strong>' + item.name + '</strong>' +
                '</li>';
    }

    function emptyHtml(text) {
        return '<li class="t-tile-empty">' +
                  '<strong>' + text + '</strong>' +
               '</li>';
    }

    function fileHtml(item) {
        return '<li class="t-tile" data-filename="' + item.name + '" data-thumburl="' + item.thumbUrl + '" data-url="' + item.url + '" data-kind="' + item.kind + '">' +
                    '<div class="t-thumb">' +
                        '<span class="t-icon t-loading"></span>' +
                    '</div>' +
                    '<strong>' + item.name + '</strong>' +
                    '<span class="t-filesize">' + item.size + '</span>' +
        '</li>';
    }

    function directoryHtml(item) {
        return '<li class="t-tile" data-url="' + item.url + '" data-kind="' + item.kind + '">' +
                    '<div class="t-thumb">' +
                        '<span class="t-icon t-folder"></span>' +
                    '</div>' +
                    '<strong>' + item.name + '</strong>' +
                '</li>';
    }

    function newDirectoryHtml(name) {
        return '<li class="t-tile" data-kind="d">' +
                    '<div class="t-thumb">' +
                        '<span class="t-icon t-folder"></span>' +
                    "</div>" +
                    '<input class="t-input" value="' + name + '" />' +
                '</li>';
    }

    function load(li) {
        var element = $(li);
        var img = $("<img />", {
            src: element.data("thumburl"),
            alt: element.data("filename")
        })
            .hide()
            .bind("load", function () {
                $(this).prev().remove().end().fadeIn();
            });

        element.find(".t-loading").after(img);

        li.loaded = true;
    }

    if ($.browser.msie && parseFloat($.browser.version) < 8) {
        var offsetTop = function (element) {
            return element.offsetTop;
        }
    } else {
        var offsetTop = function (element) {
            return element.offsetTop - $(element).height();
        }
    }

    var rescape = /(\:|\^|\$|\/|\.|\+|\||\(|\)|\[|\]|\{|\}|\\)/g,
        rstar = /\*/g,
        rquestion = /\?/g;

    function wildcardToRegExp(value) {
        return new RegExp(value.replace(rescape, "\\$1").replace(rstar, ".*").replace(rquestion, ".?"), "ig");
    }

    $t.fileListView.prototype = {
        bindTo: function (data, orderBy, filter) {
            this._filter = filter;
            var reader = this._reader;
            this.wrapper.empty();

            var directories = q(this._reader.directories(data) || []);
            var files = q(this._reader.files(data) || []);

            if (filter) {
                var regex = wildcardToRegExp(filter);

                var where = function (item) {
                    return regex.test(reader.name(item));
                };

                directories = directories.where(where);
                files = files.where(where);
            }

            var selector = function (item) {
                return reader[orderBy](item);
            };

            this._data = this._process(this._reader.path(data),
                directories.orderBy(selector),
                files.orderBy(selector)
            );

            var html = this._data
                           .select(function (item) {
                               return item.kind == "f" ? fileHtml(item) : directoryHtml(item);
                           })
                           .toArray()
                           .join("");

            this.wrapper.append(html);

            this._tiles = this.wrapper.find("li[data-kind=f]");
            this._scroll();
            this._asEmpty();
        },

        _asEmpty: function () {
            if (!this._data.any() && !this._filter) {
                this.wrapper.append(emptyHtml(this._localization.emptyFolder));
            }
        },

        _completeFile: function (e, file) {
            var name = this._reader.name(file);
            var path = this._reader.path(file);

            var li = $(fileHtml({
                kind: "f",
                thumbUrl: this._reader.thumbUrl(path, name),
                url: this._reader.concatPaths(path, name),
                name: name,
                size: this._reader.size(file)
            }));

            this.wrapper.find("li").eq(this.fileIndex(name)).replaceWith(li);

            load(li[0]);

            li.click();
        },

        _completeDirectory: function (e, directory) {
            var name = this._reader.name(directory);
            var path = this._reader.path(directory);

            var li = $(directoryHtml({
                kind: "d",
                url: this._reader.concatPaths(path, name),
                name: name
            }));

            this.wrapper.find("li").eq(this.directoryIndex(name)).replaceWith(li);
        },

        _delete: function () {
            var selected = this.wrapper.find(".t-state-selected");
            if (selected.length) {
                var data = this._data.toArray();
                data.splice(selected.index(), 1);
                this._data = q(data);
                selected.remove();

                this._scroll();

                this._asEmpty();
            }
        },

        _scroll: function (e) {
            clearTimeout(this._timeout);

            this._timeout = setTimeout($.proxy(function () {
                var height = this.wrapper.outerHeight();
                var viewTop = this.wrapper.scrollTop();

                var viewBottom = viewTop + height;

                this._tiles.each(function () {
                    var top = offsetTop(this);
                    var bottom = top + this.offsetHeight;

                    if ((top >= viewTop && top < viewBottom) || (bottom >= viewTop && bottom < viewBottom)) {
                        load(this);
                    }

                    if (top > viewBottom) {
                        return false;
                    }
                });

                this._tiles = this._tiles.filter(function () {
                    return !this.loaded;
                });

            }, this), 250);
        },

        _upload: function (e, file, preventDefault) {
            var existingFileIndex = this.fileIndex(file.name);

            if (existingFileIndex > -1 && !confirm($t.formatString(this._localization.overwriteFile, file.name))) {
                preventDefault();
            } else {
                this.wrapper.find(".t-tile-empty").remove();

                var li = $(loadingHtml(file));

                if (existingFileIndex > -1) {
                    li.data("existing", true);
                    this.wrapper.find("li").eq(existingFileIndex).replaceWith(li);
                } else {

                    var firstFile = this.wrapper.find("li[data-kind=f]:first");

                    if (firstFile.length) {
                        firstFile.before(li);
                    } else {
                        this.wrapper.append(li);
                    }

                    var data = this._data.toArray();

                    data.splice(li.index(), 0, {
                        name: file.name,
                        kind: "f"
                    });
                }

                this.wrapper.scrollTop(li.attr("offsetTop") - this.element.offsetHeight);
            }
        },
        _nameDirectory: function () {
            var name = "New folder";

            var directoryNames = this._data.where(function (item) {
                return item.kind == "d" && item.name.indexOf(name) > -1;
            }).select(function (directory) {
                return directory.name;
            }).toArray();

            if ($.inArray(name, directoryNames) > -1) {
                var index = 2;

                do {
                    var candidate = name + " (" + index + ")";
                    index++;
                } while ($.inArray(candidate, directoryNames) > -1);

                name = candidate;
            }

            return name;
        },
        _createDirectory: function (e, callback) {
            var name = this._nameDirectory();

            var li = $(newDirectoryHtml(name));

            var firstFile = this.wrapper.find("li[data-kind=f]:first");

            if (firstFile.length) {
                firstFile.before(li);
            } else {
                this.wrapper.append(li);
            }
            var data = this._data.toArray();

            var input = li.addClass("t-state-selected")
              .siblings()
              .removeClass("t-state-selected")
              .end()
              .find("input").keydown(function (e) {
                  if (e.keyCode == 13) {
                      this.blur();
                  }
              }).blur($.proxy(function (e) {
                  var value = $.trim(e.target.value);

                  if (!value || this._data.any(function (item) {
                      return item.kind == "d" && item.name.toLowerCase() == value.toLowerCase();
                  })) {
                      value = this._nameDirectory();
                  }

                  data.splice(li.index(), 0, {
                      name: value,
                      kind: "d"
                  });

                  $(e.target).replaceWith("<strong>" + value + "</strong>");

                  callback(value);
              }, this));

            setTimeout(function () {
                input.select();
            })

            this.wrapper.find(".t-tile-empty").remove();
            this.wrapper.scrollTop(li.attr("offsetTop") - this.element.offsetHeight);
        },

        _errorFile: function (e, file) {
            var index = this.fileIndex(file.name);

            if (index > -1) {
                var li = this.wrapper.find("li").eq(index);
                if (li.data("existing")) {
                    var replacement = $(fileHtml(this._data.toArray()[index]));
                    li.replaceWith(replacement);
                    load(replacement[0]);
                } else {
                    li.remove();
                    this._data.toArray().splice(index, 1);
                }
                this._asEmpty();
            }
        },

        _errorDirectory: function (e, directory) {
            var index = this.directoryIndex(directory.name);
            if (index > -1) {
                this.wrapper.find("li").eq(index).remove();
                this._data.toArray().splice(index, 1);
                this._asEmpty();
            }
        },

        fileIndex: function (name) {
            return this._index("f", name);
        },

        directoryIndex: function (name) {
            return this._index("d", name);
        },

        _index: function (kind, name) {
            var result = -1,
                data = this._data ? this._data.toArray() : [];

            name = name.toLowerCase();

            $.each(data, function (index, item) {
                if (item.kind == kind && item.name.toLowerCase() == name) {
                    result = index;
                    return false;
                }
            });

            return result;
        },

        _raise: function (e, type) {
            var div = $(e.currentTarget);

            $t.trigger(this.wrapper, type, {
                kind: div.data("kind"),
                url: div.data("url")
            });
        },

        _click: function (e) {
            $(e.currentTarget).addClass("t-state-selected")
                              .siblings()
                              .removeClass("t-state-selected");

            this._raise(e, "t:change");
        },

        _dblclick: function (e) {
            // clear selection for IE
            if (document.selection && document.selection.empty) {
                document.selection.empty();
            }

            this._raise(e, "t:select");
        },

        _refresh: function (e, data, orderBy, filter) {
            this.bindTo(data, orderBy, filter);
        },

        _process: function (path, directories, files) {
            var reader = this._reader;

            var directories = directories.select(function (dir) {
                return {
                    url: reader.concatPaths(path, reader.name(dir)),
                    name: reader.name(dir),
                    kind: "d"
                };
            });

            var files = files.select(function (file) {
                var name = reader.name(file);
                return {
                    url: reader.concatPaths(path, name),
                    name: name,
                    kind: "f",
                    thumbUrl: reader.thumbUrl(path, name),
                    size: reader.size(file)
                };
            });

            return directories.concat(files);
        }
    }

    $t.dataSource = function (options) {
        this._url = options.url;
        this._callback = options.callback;
        this._error = options.error;
    }

    $t.dataSource.prototype = {
        _complete: function (data) {
            if (this._callback) {
                this._callback(data);
            }
        },
        get: function (args) {
            $.ajax({
                type: "POST",
                url: this._url,
                data: args,
                success: $.proxy(this._complete, this),
                error: this._error
            });
        }
    }

    $t.breadcrumbs = function (element, options) {
        this.element = element;
        this.wrapper = $(element);
        this._gap = options.gap || 50;

        this._initPaths(options.path);

        var dropDown = new $t.dropDown({
            effects: $t.fx.slide.defaults(),
            onClick: $.proxy(function (e) {
                var value = $(e.item).text();
                dropDown.close();
                this._initPaths(value);
                $(element).val(value).trigger("t:change");
            }, this)
        });

        dropDown.dataBind(options.roots);

        this.wrapper.delegate("input", "focus", $.proxy(this._focus, this))
                    .delegate("input", "blur", $.proxy(this._blur, this))
                    .delegate("input", "keydown", $.proxy(function (e) {
                        if (e.keyCode == 13) {
                            this._blur();
                        }
                    }, this))
                    .delegate("a:not(.t-first)", "click", $t.stopAll(this._click, this))
                    .delegate(".t-select", "click", function () {
                        var a = $(element);
                        dropDown.open({
                            offset: a.offset(),
                            outerHeight: a.outerHeight(),
                            outerWidth: a.outerWidth(),
                            zIndex: $t.getElementZIndex(this)
                        });
                    })
                    .bind("t:refresh", $.proxy(this.refresh, this));

        $(document.documentElement).bind('mousedown', function (e) {
            var element = dropDown.$element[0];

            if (!$.contains(element, e.target)) {
                dropDown.close();
            }
        });

        this.value(options.path);
    }

    $t.breadcrumbs.prototype = {
        _initPaths: function (path) {
            this._basePath = (path || "").replace(/\/{2,}/g, "/").replace(/\/$/, "");

            path = this._basePath.split("/");
            path.pop();

            this._root = path.join("/");
        },
        _html: function () {
            var baseIndex = this._basePath.split("/").length - 1;

            var val = this.value();
            if (val === undefined || !val.match(/^\//)) {
                val = "/" + (val || "");
            }
            return '<div class="t-dropdown-wrap t-state-default">' +
                '<input type="text" class="t-input" />' +
                '<div class="t-breadcrumbs-wrap">' +
                $.map(val.split("/"), function (segment, index) {
                    if (segment && index >= baseIndex) {
                        return '<a class="t-link" href="#">' + segment + '</a>';
                    }
                }).join('<span class="t-icon t-arrow-next">&gt;</span>') +
                "</div>" +
                '<span class="t-select t-header"><span class="t-icon t-arrow-down">select</span></span>' +
                "</div>";
        },

        _path: function (trail) {
            return this._root + "/" + $.map(trail, function (breadcrumb) {
                return $(breadcrumb).text();
            }).join("/");
        },

        _update: function (path) {
            path = path.charAt(0) === "/" ? path : "/" + path;

            var change = this.value() != path;

            this.value(path);

            if (change) {
                this.wrapper.trigger("t:change");
            }
        },

        value: function (path) {
            if (path !== undefined) {
                this.wrapper.val(path.replace(/\/{2,}/g, "/"));
                this.refresh();
            } else {
                return this.wrapper.val();
            }
        },

        _click: function (e) {
            this._update(this._path($(e.target).prevAll("a").andSelf()));
        },

        refresh: function () {
            //this.wrapper.empty().append(this._html());
            try { this.wrapper.empty(); } catch (e) { }
            this.wrapper.append(this._html());

            var width = this.wrapper.width() - this._gap;

            var links = this.wrapper.find("a");

            links.each(function (index) {
                var a = $(this);

                if (a.parent().width() > width) {
                    if (index == links.length - 1) {
                        a.width(width);
                    } else {
                        a.prev().andSelf().hide();
                    }
                }
            });
        },

        _focus: function () {
            var input = this.wrapper.find(".t-breadcrumbs-wrap").hide()
                            .end().find("input").val(this.value());

            setTimeout(function () {
                input.select();
            });
        },

        _blur: function () {
            var value = this.wrapper.find("input").val().replace(/\/{2,}/g, "/");

            if (!value || value.toLowerCase().indexOf(this._basePath.toLowerCase()) < 0) {
                value = this._basePath;
            }

            this._update(value);
        }
    }

    $t.searchBox = function (element) {
        this.element = element;
        this.wrapper = $(element);

        this.wrapper.delegate("input", "focus", $.proxy(this._focus, this))
                    .delegate("input", "blur", $.proxy(this._blur, this))
                    .delegate("input", "keydown", $.proxy(function (e) {
                        if (e.keyCode == 13) {
                            this._blur();
                        }
                    }, this))
                    .delegate("a", "click", $t.stopAll(this._click, this));

        this._render();
    }

    $t.searchBox.prototype = {
        _render: function () {
            var html = '<label for="t-imagebrowser-search">Поиск</label>' +
                       '<input type="text" id="t-imagebrowser-search" class="t-input" />' +
                       '<a href="#" class="t-icon t-search">search</a>';

            this.wrapper.empty().append($(html));
        },
        _focus: function () {
            this.wrapper.find("label").hide();
        },
        _blur: function () {
            this._update(this.wrapper.find("input").val());

            if (this.value() == "") {
                this.wrapper.find("label").show();
            }
        },
        _update: function (val) {
            var change = this.value() != val;

            this.value(val);

            if (change) {
                this.wrapper.trigger("t:change");
            }
        },
        value: function (val) {
            if (val !== undefined) {
                this.wrapper.val(val);
            } else {
                return this.wrapper.val();
            }
        },
        _click: function () {
            this._blur();
        }
    };

})(jQuery);



(function ($) {

    var $t = $.telerik,
        keycodes = [8, // backspace
                    9, // tab
                    37, // left arrow
                    38, // up arrow
                    39, // right arrow
                    40, // down arrow
                    46, // delete
                    35, // end
                    36, // home
                    44], //","
        styles = ["font-family",
                  "font-size",
                  "font-stretch",
                  "font-style",
                  "font-weight",
                  "letter-spacing",
                  "line-height",
                  "color",
                  "text-align",
                  "text-decoration",
                  "text-indent",
                  "text-transform"];

    function getStyles(input) {
        var retrievedStyles = {};
        for (var i = 0, length = styles.length; i < length; i++) {
            var style = styles[i],
                value = input.css(style);

            if (value) {
                if (styles[i] != "font-style" && value != "normal") {
                    retrievedStyles[style] = value;
                }
            }
        }
        return retrievedStyles;
    }

    $t.textbox = function (element, options) {
        if (element.nodeName.toLowerCase() !== "input" && element.type.toLowerCase() !== "text") {
            throw "Target element is not a INPUT";
        }

        $.extend(this, options);
        this.element = element;
        var $element = this.$element = $(element)
            .bind({
                focus: function (e) {
                    var input = e.target;
                    setTimeout(function () {
                        if ($.browser.msie) {
                            input.select();
                        } else {
                            input.selectionStart = 0;
                            input.selectionEnd = input.value.length;
                        }
                    }, 0);
                },
                keydown: $.proxy(this._keydown, this),
                keypress: $.proxy(this._keypress, this),
                keyup: $.proxy(this._keyup, this)
            })
            .bind("paste", $.proxy(this._paste, this));

        var builder = new $t.stringBuilder();

        if (element.parentNode.nodeName.toLowerCase() !== "div") {
            $element.addClass('t-input')
                    .wrap($('<div class="t-widget t-numerictextbox"></div>'));

            if (this.showIncreaseButton) {
                builder.cat('<a class="t-link t-icon t-arrow-up" href="#" tabindex="-1" title="')
                       .cat(this.increaseButtonTitle)
                       .cat('">Increment</a>');
            }

            if (this.showDecreaseButton) {
                builder.cat('<a class="t-link t-icon t-arrow-down" href="#" tabindex="-1" title="')
                       .cat(this.decreaseButtonTitle)
                       .cat('">Decrement</a>');
            }

            if (builder.buffer.length > 0) {
                $(builder.string()).insertAfter($element);
            }
        }

        this.$wrapper = $element.closest('.t-numerictextbox')
            .find('.t-arrow-up, .t-arrow-down')
                .bind({
                    click: $t.preventDefault,
                    dragstart: $t.preventDefault
                })
            .end()
            .click(function (e) {
                element.focus();
            })
            .bind({
                focusin: $.proxy(this._focus, this),
                focusout: $.proxy(this._blur, this)
            });

        this.enabled = !$element.is('[disabled]');

        builder.buffer = [];
        builder.cat('[ |')
               .cat(this.groupSeparator)
               .catIf('|' + this.symbol, this.symbol)
               .cat(']');
        this.replaceRegExp = new RegExp(builder.string(), 'g');

        var inputValue = $element.attr('value');

        builder.buffer = [];
        builder.cat('<div class="t-formatted-value')
               .cat((inputValue == '' && this.enabled) ? ' t-state-empty' : '')
               .cat('">')
               .cat(inputValue || (this.enabled ? this.text : ''))
               .cat('</div>');

        this.$text = $(builder.string())
                        .insertBefore($element)
                        .css(getStyles($element))
                        .click(function (e) {
                            element.focus();
                        });

        // Focus & hover
        applyInputBorders(this.$element, this.$wrapper);

        //set text color to the background-color.
        this._blur();
        this[this.enabled ? 'enable' : 'disable']();
        
        this.numFormat = this.numFormat === undefined ? this.type.charAt(0) : this.numFormat;
        var separator = this.separator;
        this.step = this.parse(this.step, separator);
        this.val = this.parse(this.val, separator);
        this.minValue = this.parse(this.minValue, separator);
        this.maxValue = this.parse(this.maxValue, separator);
        this.decimals = { '190': '.', '191': '.', '188': ',', '110': separator };

        this.value(inputValue || this.val);
        
        $t.bind(this, {
            load: this.onLoad,
            valueChange: this.onChange
        });
    }

    $t.textbox.prototype = {
        _paste: function (e) {
            e.preventDefault();
            if (!e.originalEvent)
                return false;
            var pastedText = undefined;
            if (window.clipboardData && window.clipboardData.getData) { // IE
                pastedText = window.clipboardData.getData('Text');
            } else if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
                pastedText = e.originalEvent.clipboardData.getData('text/plain');
            }
            if (!pastedText)
                return false;
            if (pastedText == '-')
                return true;
            
            pastedText = this.parse(pastedText, this.separator);
            if (!pastedText)
                return false;
            pastedText = parseFloat(pastedText.toFixed(this.digits));
            if (pastedText || pastedText == 0) {
                this._update(pastedText);
                $(this.element).trigger('change');
            }
        },
        
        _keydown: function (e) {
            var key = e.keyCode,
                $element = this.$element,
                separator = this.separator,
                value = $element.val();
            setTimeout($.proxy(function () {
                $element.toggleClass('t-state-error', !this.inRange(this.parse($element.val(), this.separator), this.minValue, this.maxValue));
            }, this));

            // Allow decimal
            var decimalSeparator = this.decimals[key];
            if (decimalSeparator) {
                if (this.digits == 0)
                    return false;
                if (key != '110' && decimalSeparator == separator
                && this.digits > 0
                && value.indexOf(separator) == -1) {
                    return true;
                } else {
                    e.preventDefault();
                    if (value.indexOf(separator) == -1) {
                        var start = e.currentTarget.selectionStart;
                        var startValue = value.substr(0, start);
                        var newVal = startValue + this.separator;
                        if (start < value.length) {
                            newVal += value.substr(start);
                            var parsedValue = this.parse(newVal);
                            parsedValue = parseFloat(parsedValue.toFixed(this.digits));
                            $element.val(this.formatEdit(parsedValue));
                        } else {
                            $element.val(newVal);
                        }
                            
                    }
                }
            }

            if (key == 8 || key == 46) { //backspace and delete
                setTimeout($.proxy(function () {
                    this._update(this.parse($element.val()));
                }, this));
                return true;
            }

            if (key == 38 || key == 40) {
                var direction = key == 38 ? 1 : -1;
                this._modify(direction * this.step);
                return true;
            }

            if (key == 222) e.preventDefault();
        },

        _keypress: function (e) {
            var $element = $(e.target),
                value = $element.val(),
                key = e.keyCode || e.which,
                keyValue = String.fromCharCode(key);
            if (e.shiftKey && key != 45) {
                return false;
            }

            if (key == 0 || $.inArray(key, keycodes) != -1 || e.ctrlKey || (e.shiftKey && key == 45))
                return true;

            if (((this.minValue !== null ? this.minValue < 0 : true)
                    && keyValue == "-"
                    && $t.caretPos($element[0]) == 0
                    && value.indexOf("-") == -1)
                || (keyValue >= "0" && keyValue <= "9")) {

                return true;
            }

            e.preventDefault();
        },

        _keyup: function (e) {
            var $element = $(e.target),
                value = $element.val(),
                separator = this.separator;

            if (value.indexOf(separator) != -1 && (value.length - value.indexOf(separator) - 1 > this.digits)) {
                var parsedValue = this.parse(value);
                parsedValue = parseFloat(parsedValue.toFixed(this.digits));
                $element.val(this.formatEdit(parsedValue));
                return false;
            }
            return true;
        },

        _focus: function () {
            this.$element
                .css('color', this.$text.css("color"));

            this.$text.hide();
        },

        _blur: function () {
            this.$element
                .css('color', this.$element.css('background-color'))
                .removeClass('t-state-error');

            if (this.enabled) {
                this.$text.show();
            }
            
            var min = this.minValue,
                max = this.maxValue,
                parsedValue = this.parse(this.$element.val());

            if (parsedValue != null) {
                if (min != null && parsedValue < min) {
                    parsedValue = min;                    
                } else if (max != null && parsedValue > max) {
                    parsedValue = max;                    
                }
                parsedValue = parseFloat(parsedValue.toFixed(this.digits));
            } else {
                parsedValue = this.nullable ? null : this.defaultval;
            }
            this._update(parsedValue);

            if (this.needChangeTrigger) {
                $(this.element).trigger('change');
                this.needChangeTrigger = false;
            }            
        },

        _clearTimer: function (e) {
            clearTimeout(this.timeout);
            clearInterval(this.timer);
            clearInterval(this.acceleration);
        },

        _stepper: function (e, stepMod) {
            if (e.which == 1) {

                var step = this.step;

                this._modify(stepMod * step);

                this.timeout = setTimeout($.proxy(function () {
                    this.timer = setInterval($.proxy(function () {
                        this._modify(stepMod * step);
                    }, this), 80);

                    this.acceleration = setInterval(function () { step += 1; }, 1000);
                }, this), 200);
            }
        },

        _modify: function (step) {
            var value = this.parse(this.element.value),
                min = this.minValue,
                max = this.maxValue;

            value = value ? value + step : step;

            if (min !== null && value < min) {
                value = min;
            } else if (max !== null && value > max) {
                value = max;
            }

            this._update(parseFloat(value.toFixed(this.digits)));
        },

        _update: function (val) {
            if (this.val != val) {
                if ($t.trigger(this.element, 'valueChange', { oldValue: this.val, newValue: val })) {
                    val = this.val; //revert changes
                }
            }
            this._value(val);
        },

        _value: function (value) {
            var parsedValue = (typeof value === "number") ? value : this.parse(value, this.separator),
                text = this.enabled ? this.text : '',
                isNull = parsedValue === null;

            if (parsedValue != null) {
                parsedValue = parseFloat(parsedValue.toFixed(this.digits));
            }

            this.val = parsedValue;
            var currentV = this.$element.val();
            var formattedV = isNull ? '' : this.formatEdit(parsedValue);
            if (currentV !== formattedV) {
                this.$element.val(formattedV);
            }
            this.$text.html(isNull ? text : this.format(parsedValue));
            if (isNull) {
                this.$text.addClass('t-state-empty');
            } else {
                this.$text.removeClass('t-state-empty');
            }
        },

        enable: function () {
            var $buttons = this.$wrapper.find('.t-arrow-up, .t-arrow-down'),
                clearTimerProxy = $.proxy(this._clearTimer, this);

            this.enabled = true;
            this.$element.removeAttr("disabled");

            if (!this.val && this.val != 0) {
                this.$text
                    .addClass('t-state-empty')
                    .html(this.text);
            } else if (true == $.browser.msie) {
                this.$text.show();
            } else {
                this.$element.css('color', this.$element.css('background-color'))
            }

            this.$wrapper.removeClass('t-state-disabled');
            $buttons.unbind('mouseup').unbind('mouseout').unbind('dblclick')
                    .bind({
                        mouseup: clearTimerProxy,
                        mouseout: clearTimerProxy,
                        dblclick: clearTimerProxy
                    });

            var eventName = "mousedown";
            $buttons.eq(0)
                    .unbind(eventName)
                    .bind(eventName, $.proxy(function (e) {
                        this._stepper(e, 1);
                    }, this));

            $buttons.eq(1)
                    .unbind(eventName)
                    .bind(eventName, $.proxy(function (e) {
                        this._stepper(e, -1);
                    }, this));
        },

        disable: function () {
            this.enabled = false;

            this.$wrapper
                .addClass('t-state-disabled')
                .find('.t-icon')
                    .unbind('mousedown')
                    .bind('mousedown', $t.preventDefault);

            this.$element
                .attr('disabled', 'disabled')

            if (!this.val && this.val != 0)
                this.$text.html('');
            else if (true == $.browser.msie)
                this.$text.hide();
            else
                this.$element.css('color', this.$element.css('background-color'))
        },

        value: function (value) {
            if (value === undefined) {
                return this.val;
            }

            var parsedValue = (typeof value === "number") ? value : this.parse(value, this.separator);
            if (!this.inRange(parsedValue, this.minValue, this.maxValue)) {
                parsedValue = this.nullable ? null : this.defaultval;
            }

            this._value(parsedValue);
        },

        formatEdit: function (value) {
            var separator = this.separator;
            if (value && separator != '.')
                value = value.toString().replace('.', separator);
            return value;
        },

        format: function (value) {
            return $t.textbox.formatNumber(value,
                                           this.numFormat,
                                           this.digits,
                                           this.separator,
                                           this.groupSeparator,
                                           this.groupSize,
                                           this.positive,
                                           this.negative,
                                           this.symbol,
                                           true);
        },

        inRange: function (key, min, max) {
            return key === null || ((min !== null ? key >= min : true) && (max !== null ? key <= max : true));
        },

        parse: function (value, separator) {            
            var result = null;
            if (value || value == "0") {
                if (typeof value == typeof 1) return value;

                value = value.replace(this.replaceRegExp, '');
                var sep = separator ? separator : this.separator;
                if (sep && sep != '.')
                    value = value.replace(sep, '.');

                var negativeFormatPattern = $.fn.tTextBox.patterns[this.type].negative[this.negative]
                        .replace(/(\(|\))/g, '\\$1').replace('*', '').replace('n', '([\\d|\\.]*)'),
                    negativeFormatRegEx = new RegExp(negativeFormatPattern);

                if (negativeFormatRegEx.test(value))
                    result = -parseFloat(negativeFormatRegEx.exec(value)[1]);
                else
                    result = parseFloat(value);
            }
            return isNaN(result) ? null : result;
        }
    }

    $.fn.tTextBox = function (options) {
        var type = 'numeric';
        if (options && options.type) {
            type = options.type;
        }

        var defaults = $.fn.tTextBox.defaults[type];
        defaults.digits = $t.cultureInfo[type + 'decimaldigits'];
        defaults.separator = $t.cultureInfo[type + 'decimalseparator'];
        defaults.groupSeparator = $t.cultureInfo[type + 'groupseparator'];
        defaults.groupSize = $t.cultureInfo[type + 'groupsize'];
        defaults.positive = $t.cultureInfo[type + 'positive'];
        defaults.negative = $t.cultureInfo[type + 'negative'];
        defaults.symbol = $t.cultureInfo[type + 'symbol'];

        options = $.extend({}, defaults, options);
        options.type = type;

        return this.each(function () {
            var $element = $(this);
            options = $.meta ? $.extend({}, options, $element.data()) : options;

            if (!$element.data('tTextBox')) {
                $element.data('tTextBox', new $t.textbox(this, options));
                $t.trigger(this, 'load');
            }
        });
    };

    var commonDefaults = {
        val: null,
        text: '',
        step: 1,
        inputAttributes: '',
        increaseButtonTitle: "Increase value",
        decreaseButtonTitle: "Decrease value",
        showIncreaseButton: true,
        showDecreaseButton: true
    };

    $.fn.tTextBox.defaults = {
        numeric: $.extend(commonDefaults, {
            minValue: -100,
            maxValue: 100
        }),
        currency: $.extend(commonDefaults, {
            minValue: 0,
            maxValue: 1000
        }),
        percent: $.extend(commonDefaults, {
            minValue: 0,
            maxValue: 100
        })
    };

    // * - placeholder for the symbol
    // n - placeholder for the number
    $.fn.tTextBox.patterns = {
        numeric: {
            negative: ['(n)', '-n', '- n', 'n-', 'n -']
        },
        currency: {
            positive: ['*n', 'n*', '* n', 'n *'],
            negative: ['(*n)', '-*n', '*-n', '*n-', '(n*)', '-n*', 'n-*', 'n*-', '-n *', '-* n', 'n *-', '* n-', '* -n', 'n- *', '(* n)', '(n *)']
        },
        percent: {
            positive: ['n *', 'n*', '*n'],
            negative: ['-n *', '-n*', '-*n']
        }
    };

    if (!$t.cultureInfo.numericnegative)
        $.extend($t.cultureInfo, { //default en-US settings
            currencydecimaldigits: 2,
            currencydecimalseparator: '.',
            currencygroupseparator: ',',
            currencygroupsize: 3,
            currencynegative: 0,
            currencypositive: 0,
            currencysymbol: '$',
            numericdecimaldigits: 2,
            numericdecimalseparator: '.',
            numericgroupseparator: ',',
            numericgroupsize: 3,
            numericnegative: 1,
            percentdecimaldigits: 2,
            percentdecimalseparator: '.',
            percentgroupseparator: ',',
            percentgroupsize: 3,
            percentnegative: 0,
            percentpositive: 0,
            percentsymbol: '%'
        });

    var customFormatRegEx = /[0#?]/;

    function reverse(str) {
        return str.split('').reverse().join('');
    }

    function injectInFormat(val, format, appendExtras) {
        var i = 0, j = 0,
            fLength = format.length,
            vLength = val.length,
            builder = new $t.stringBuilder();

        while (i < fLength && j < vLength && format.substring(i).search(customFormatRegEx) >= 0) {

            if (format.charAt(i).match(customFormatRegEx))
                builder.cat(val.charAt(j++));
            else
                builder.cat(format.charAt(i));

            i++;
        }

        builder.catIf(val.substring(j), j < vLength && appendExtras)
               .catIf(format.substring(i), i < fLength);

        var result = reverse(builder.string()),
            zeroIndex;

        if (result.indexOf('#') > -1)
            zeroIndex = result.indexOf('0');

        if (zeroIndex > -1) {
            var first = result.slice(0, zeroIndex),
                second = result.slice(zeroIndex, result.length);
            result = first.replace(/#/g, '') + second.replace(/#/g, '0');
        } else {
            result = result.replace(/#/g, '');
        }

        if (result.indexOf(',') == 0)
            result = result.replace(/,/g, '');

        return appendExtras ? result : reverse(result);
    }

    $t.textbox.formatNumber = function (number,
                                        format,
                                        digits,
                                        separator,
                                        groupSeparator,
                                        groupSize,
                                        positive,
                                        negative,
                                        symbol,
                                        isTextBox) {

        if (!format) return number;

        var type, customFormat, negativeFormat, zeroFormat, sign = number < 0;

        format = format.split(':');
        format = format.length > 1 ? format[1].replace('}', '') : format[0];

        var isCustomFormat = format.search(customFormatRegEx) != -1;

        if (isCustomFormat) {
            format = format.split(';');
            customFormat = format[0];
            negativeFormat = format[1];
            zeroFormat = format[2];
            format = (sign && negativeFormat ? negativeFormat : customFormat).indexOf('%') != -1 ? 'p' : 'n';
        }

        switch (format.toLowerCase()) {
            case 'd':
                return Math.round(number).toString();
            case 'c':
                type = 'currency'; break;
            case 'n':
                type = 'numeric'; break;
            case 'p':
                type = 'percent';
                if (!isTextBox) number = Math.abs(number) * 100;
                break;
            default:
                return number.toString();
        }

        var zeroPad = function (str, count, left) {
            for (var l = str.length; l < count; l++)
                str = left ? ('0' + str) : (str + '0');

            return str;
        }

        var addGroupSeparator = function (number, groupSeperator, groupSize) {
            if (groupSeparator && groupSize != 0) {
                var regExp = new RegExp('(-?[0-9]+)([0-9]{' + groupSize + '})');
                while (regExp.test(number)) {
                    number = number.replace(regExp, '$1' + groupSeperator + '$2');
                }
            }
            return number;
        }

        var cultureInfo = cultureInfo || $t.cultureInfo,
            patterns = $.fn.tTextBox.patterns,
            undefined;

        //define Number Formating info.
        digits = digits || digits === 0 ? digits : cultureInfo[type + 'decimaldigits'];
        separator = separator !== undefined ? separator : cultureInfo[type + 'decimalseparator'];
        groupSeparator = groupSeparator !== undefined ? groupSeparator : cultureInfo[type + 'groupseparator'];
        groupSize = groupSize || groupSize == 0 ? groupSize : cultureInfo[type + 'groupsize'];
        negative = negative || negative === 0 ? negative : cultureInfo[type + 'negative'];
        positive = positive || positive === 0 ? positive : cultureInfo[type + 'positive'];
        symbol = symbol || cultureInfo[type + 'symbol'];

        var exponent, left, right;

        if (isCustomFormat) {
            var splits = (sign && negativeFormat ? negativeFormat : customFormat).split('.'),
                leftF = splits[0],
                rightF = splits.length > 1 ? splits[1] : '',
                lastIndexZero = $t.lastIndexOf(rightF, '0'),
                lastIndexSharp = $t.lastIndexOf(rightF, '#');
            digits = (lastIndexSharp > lastIndexZero ? lastIndexSharp : lastIndexZero) + 1;
        }

        var factor = Math.pow(10, digits);
        var rounded = (Math.round(number * factor) / factor);
        number = isFinite(rounded) ? rounded : number;

        var split = number.toString().split(/e/i);
        exponent = split.length > 1 ? parseInt(split[1]) : 0;
        split = split[0].split('.');

        left = split[0];
        left = sign ? left.replace('-', '') : left;

        right = split.length > 1 ? split[1] : '';

        if (exponent) {
            if (!sign) {
                right = zeroPad(right, exponent, false);
                left += right.slice(0, exponent);
                right = right.substr(exponent);
            } else {
                left = zeroPad(left, exponent + 1, true);
                right = left.slice(exponent, left.length) + right;
                left = left.slice(0, exponent);
            }
        }

        var rightLength = right.length;
        if (digits < 1 || (isCustomFormat && lastIndexZero == -1 && rightLength === 0))
            right = ''
        else
            right = rightLength > digits ? right.slice(0, digits) : zeroPad(right, digits, false);

        var result;
        if (isCustomFormat) {
            if (left == 0) left = '';

            left = injectInFormat(reverse(left), reverse(leftF), true);
            left = leftF.indexOf(',') != -1 ? addGroupSeparator(left, groupSeparator, groupSize) : left;

            right = right && rightF ? injectInFormat(right, rightF) : '';

            result = number === 0 && zeroFormat ? zeroFormat
                : (sign && !negativeFormat ? '-' : '') + left + (right.length > 0 ? separator + right : '');

        } else {

            left = addGroupSeparator(left, groupSeparator, groupSize)
            patterns = patterns[type];
            var pattern = sign ? patterns['negative'][negative]
                        : symbol ? patterns['positive'][positive]
                        : null;

            var numberString = left + (right.length > 0 ? separator + right : '');

            result = pattern ? pattern.replace('n', numberString).replace('*', symbol) : numberString;
        }
        return result;
    }

    $.extend($t.formatters, {
        number: $t.textbox.formatNumber
    });
})(jQuery);



(function ($) {
    var $t = $.telerik,
        replaceUrlRegExp = /{0:?/,
        dateFormatRegExp = /{0:?(\S|\s)*}/;

    function defineViewedMonth(selectedValue, minValue, maxValue) {
        var today = new $t.datetime();
        if (selectedValue) {
            today = new $t.datetime(selectedValue);
        }

        if (minValue > today.value) {
            today = new $t.datetime(minValue);
        } else if (maxValue < today.value) {
            today = new $t.datetime(maxValue);
        }
        return $t.datetime.firstDayOfMonth(today);
    }

    $.extend($t, {
        calendar: function (element, options) {
            this.element = element;

            $.extend(this, options);

            var minDate = new $t.datetime(this.minDate);
            var maxDate = new $t.datetime(this.maxDate);

            this.currentView = $t.calendar.views[0];
            this.viewedMonth = defineViewedMonth(this.selectedDate, this.minDate, this.maxDate);

            var header = new $t.stringBuilder()
                         .cat('<a href="#" class="t-link t-nav-prev ')
                         .catIf('t-state-disabled', this.currentView.compare(this.viewedMonth, minDate, false) <= 0)
                         .cat('">')
			             .cat('<span class="t-icon t-arrow-prev"></span></a><a href="#" class="t-link t-nav-fast">')
			             .cat(this.currentView.title(this.viewedMonth))
			             .cat('</a>')
			             .cat('<a href="#" class="t-link t-nav-next ')
                         .catIf('t-state-disabled', this.currentView.compare(this.viewedMonth, maxDate, true) >= 0)
                         .cat('"><span class="t-icon t-arrow-next"></span></a>');

            $('.t-header', this.element).html(header.string());

            /* header */
            $('.t-nav-next:not(.t-state-disabled)', element)
			    .live('click', $.proxy(this.navigateToFuture, this));

            $('.t-nav-prev:not(.t-state-disabled)', element)
			    .live('click', $.proxy(this.navigateToPast, this));

            $('.t-nav-fast:not(.t-state-disabled)', element)
			    .live('click', $.proxy(this.navigateUp, this));

            $('.t-link.t-state-disabled', element)
			    .live('click', $t.preventDefault);

            $('td:not(.t-state-disabled):has(.t-link)', element)
				.live('mouseenter', $t.hover)
			    .live('mouseleave', $t.leave)
			    .live('click', $.proxy(this.navigateDown, this));

            $t.bind(this, {
                change: this.onChange,
                load: this.onLoad
            });
        }
    });

    $t.calendar.prototype = {
        stopAnimation: false, // used by tests

        updateSelection: function () {
            var firstDayOfMonth = $t.datetime.firstDayOfMonth(this.viewedMonth).toDate();
            var lastDayOfMonth = new $t.datetime(firstDayOfMonth).date(32).date(0).toDate();

            if (this.selectedDate === null || !$t.calendar.isInRange(this.selectedDate, firstDayOfMonth, lastDayOfMonth)) {
                var viewedMonth = defineViewedMonth(this.selectedDate, this.minDate, this.maxDate);
                this.goToView(0, viewedMonth);
            }

            var me = this;
            var days = $('.t-content td:not(.t-other-month)', this.element)
		                .removeClass('t-state-selected');

            if (this.selectedDate !== null) {
                days.filter(function () {
                    return (parseInt($(this).text(), 10) == me.selectedDate.getDate());
                })
		        .addClass('t-state-selected');
            }
        },

        value: function () {
            if (arguments.length == 0)
                return this.selectedDate;
            if (arguments.length == 1)
                this.selectedDate = arguments[0] === null ? null : new Date(arguments[0].value ? arguments[0].value : arguments[0]);
            else if (arguments.length > 1)
                this.selectedDate = new Date(arguments[0], arguments[1], arguments[2]);

            this.updateSelection();

            return this;
        },

        overlay: function (show) {
            if (!show)
                return $('.t-overlay', this.element).remove();

            $('<div/>')
		        .addClass('t-overlay')
		        .css({
		            opacity: 0,
		            width: this.element.offsetWidth,
		            height: this.element.offsetHeight,
		            position: 'absolute',
		            top: 0,
		            left: 0,
		            zIndex: 3,
		            backgroundColor: '#fff'
		        })
		        .appendTo(this.element);
        },

        goToView: function (viewIndex, viewedMonth) {
            if (viewIndex < 0 || $t.calendar.views.length <= viewIndex)
                return;

            var minDate = new $t.datetime(this.minDate);
            var maxDate = new $t.datetime(this.maxDate);

            if (typeof viewedMonth != 'undefined') {
                viewedMonth = viewedMonth.value ? viewedMonth : new $t.datetime(viewedMonth);
                this.viewedMonth = $t.datetime.firstDayOfMonth(viewedMonth);
            }

            this.currentView = $t.calendar.views[viewIndex];
            $('.t-nav-prev', this.element)
				.toggleClass('t-state-disabled', this.currentView.compare(viewedMonth, minDate, false) <= 0);

            $('.t-nav-next', this.element)
				.toggleClass('t-state-disabled', this.currentView.compare(viewedMonth, maxDate, true) >= 0);

            $('.t-nav-fast', this.element)
                .html(this.currentView.title(viewedMonth))
                .toggleClass('t-state-disabled', viewIndex == $t.calendar.views.length - 1);

            if (this.updateDates) {
                this.updateDates(this, this.viewedMonth.toDate(), function (calendar) {
                    $('.t-content', calendar.element)
                        .html(calendar.currentView.body(viewedMonth, minDate, maxDate, calendar.selectedDate ? new $t.datetime(calendar.selectedDate) : null, calendar.urlFormat, calendar.dates))
                        .toggleClass('t-meta-view', viewIndex == 1 || viewIndex == 2);
                });
            } else {
                $('.t-content', this.element)
                .html(this.currentView.body(viewedMonth, minDate, maxDate, this.selectedDate ? new $t.datetime(this.selectedDate) : null, this.urlFormat, this.dates))
                .toggleClass('t-meta-view', viewIndex == 1 || viewIndex == 2);
            }

            return this;
        },

        navigateVertically: function (viewIndex, viewedMonth, plunge, target) {
            viewedMonth = new $t.datetime(viewedMonth);
            this.viewedMonth = $t.datetime.firstDayOfMonth(viewedMonth);

            this.currentView = $t.calendar.views[viewIndex];

            this.overlay(true);

            var minDate = new $t.datetime(this.minDate);
            var maxDate = new $t.datetime(this.maxDate);

            var oldView = $('.t-content', this.element);

            var oldViewWidth = oldView.outerWidth();
            var oldViewHeight = oldView.outerHeight();
            var oldViewFontSize = oldView.css('font-size');
            var oldViewLineHeight = oldView.css('line-height');

            if (oldViewLineHeight === 'normal') oldViewLineHeight = parseInt(oldViewFontSize) * 1.5;

            oldView.find('td').removeClass('t-state-hover');

            $('.t-nav-fast', this.element)
		        .html(this.currentView.title(viewedMonth))
		        .toggleClass('t-state-disabled', viewIndex == $t.calendar.views.length - 1);

            $('.t-nav-prev', this.element)
		        .toggleClass('t-state-disabled', this.currentView.compare(this.viewedMonth, minDate, false) <= 0);

            $('.t-nav-next', this.element)
		        .toggleClass('t-state-disabled', this.currentView.compare(this.viewedMonth, maxDate, true) >= 0);

            var newView = $('<table class="t-content" cellspacing="0"></table>')
		                    .html(this.currentView.body(viewedMonth, minDate, maxDate, this.selectedDate ? new $t.datetime(this.selectedDate) : null, this.urlFormat, this.dates))
		                    .toggleClass('t-meta-view', viewIndex == 1 || viewIndex == 2);

            var me = this;

            var maximizedViewProperties = {
                fontSize: oldViewFontSize,
                lineHeight: oldViewLineHeight,
                top: 0, left: 0,
                width: oldViewWidth,
                height: oldViewHeight,
                opacity: 1
            };

            var outerAnimationContainer;
            this.stopAnimation = true;
            if (plunge) {
                outerAnimationContainer =
		            $t.fx._wrap(oldView)
		                 .css({
		                     overflow: 'hidden',
		                     position: 'relative'
		                 });
                newView.wrap($('<div/>')
		               .addClass('t-animation-container')
		               .css($.extend({
		                   position: 'absolute',
		                   zIndex: 1,
		                   fontSize: 1,
		                   lineHeight: 1,
		                   width: target.outerWidth(),
		                   height: target.outerHeight(),
		                   opacity: 0
		               }, target.position())))
		               .parent()
		               .insertAfter(oldView);

                if (!this.stopAnimation) {
                    newView.parent()
		                   .animate({
		                       fontSize: oldViewFontSize,
		                       lineHeight: oldViewLineHeight,
		                       top: 0, left: 0,
		                       width: oldViewWidth,
		                       height: oldViewHeight,
		                       opacity: 1
		                   }, 'normal', function () {
		                       newView.appendTo(me.element);
		                       outerAnimationContainer.remove();
		                       me.overlay(false);
		                   });
                } else { //animation is stopped for test purposes
                    oldView.remove();
                    newView.appendTo(me.element);
                    outerAnimationContainer.remove();
                    me.overlay(false);
                    $(".t-footer", me.element).appendTo(me.element);
                }
            } else {

                newView.insertBefore(oldView);

                outerAnimationContainer =
		            $t.fx._wrap(newView)
		                 .css({
		                     overflow: 'hidden',
		                     position: 'relative'
		                 });

                var coordinatesMod;
                if (viewIndex != 0)
                    coordinatesMod = $t.calendar.views[viewIndex].verticalDate(this.viewedMonth);

                var collapseCoordinates = {
                    top: (Math.floor(coordinatesMod / 4.0) * oldViewHeight) / 3.0,
                    left: ((coordinatesMod % 4) * oldViewWidth) / 4.0
                };

                oldView.wrap($('<div/>')
		               .addClass('t-animation-container')
		               .css($.extend({
		                   position: 'absolute'
		               }, maximizedViewProperties)))
		               .parent()
		               .insertAfter(newView)

                if (!this.stopAnimation) {
                    oldView.parent()
		                   .animate($.extend({
		                       fontSize: 1,
		                       lineHeight: 1,
		                       width: 48,
		                       height: 54,
		                       opacity: 0
		                   }, collapseCoordinates), 'normal', function () {
		                       newView.appendTo(me.element);
		                       outerAnimationContainer.remove();
		                       me.overlay(false);
		                   });
                } else {//animation is stopped for test purposes
                    oldView.remove();
                    newView.appendTo(me.element);
                    outerAnimationContainer.remove();
                    me.overlay(false);
                    $(".t-footer", me.element).appendTo(me.element);
                }
            }
            $t.trigger(this.element, 'navigate', {
                direction: plunge
            });
        },

        navigateHorizontally: function (viewIndex, viewedMonth, forward) {
            viewedMonth = new $t.datetime(viewedMonth);

            var minDate = new $t.datetime(this.minDate);
            var maxDate = new $t.datetime(this.maxDate);
            this.viewedMonth = $t.datetime.firstDayOfMonth($t.calendar.fitDateToRange(viewedMonth, minDate, maxDate));

            this.currentView = $t.calendar.views[viewIndex];

            $('.t-nav-fast', this.element)
		        .html(this.currentView.title(viewedMonth))
		        .toggleClass('t-state-disabled', viewIndex == $t.calendar.views.length - 1);

            $('.t-nav-prev', this.element)
		        .toggleClass('t-state-disabled', this.currentView.compare(this.viewedMonth, minDate, false) <= 0);

            $('.t-nav-next', this.element)
		        .toggleClass('t-state-disabled', this.currentView.compare(this.viewedMonth, maxDate, true) >= 0);

            this.overlay(true);

            var newView = $('<table class="t-content" cellspacing="0"></table>')
		                      .html(this.currentView.body(viewedMonth, minDate, maxDate, this.selectedDate ? new $t.datetime(this.selectedDate) : null, this.urlFormat, this.dates))
		                      .toggleClass('t-meta-view', viewIndex == 1 || viewIndex == 2);

            var oldView = $('.t-content', this.element);

            var viewWidth = oldView.outerWidth();

            oldView.add(newView);
            //.css({ width: viewWidth, 'float': 'left' });

            var animationContainer =
		           $t.fx._wrap(oldView)
		                .css({
		                    position: 'relative',
		                    width: viewWidth * 2,
		                    'float': 'left',
		                    left: (forward ? 0 : -200)
		                });

            newView[forward ? 'insertAfter' : 'insertBefore'](oldView);

            var me = this;
            this.stopAnimation = true;
            if (!this.stopAnimation) {
                animationContainer.animate({ left: (forward ? -200 : 0) }, 'normal', function () {
                    newView.appendTo(me.element);
                    animationContainer.remove();
                    me.overlay(false);
                    $(".t-footer", me.element).appendTo(me.element);
                });
            } else { //animation is stopped for test purposes
                oldView.remove();
                newView.appendTo(me.element);
                animationContainer.remove();
                me.overlay(false);
                $(".t-footer", me.element).appendTo(me.element);
            }
            $t.trigger(this.element, 'navigate', {
                direction: forward
            });
        },

        navigateUp: function (e) {
            if (e) e.preventDefault();
            var currentViewIndex = this.currentView.index;
            this.navigateVertically(currentViewIndex + 1, this.viewedMonth.toDate(), false);
        },

        navigateDown: function (e, target, viewIndex) {
            var $target = $($(e.target).hasClass('t-input') ? target : e.target);
            var clickedText = $target.text();
            var currentViewIndex = viewIndex || this.currentView.index;

            var href = $target.attr('href');
            if (href && (href.charAt(href.length - 1) == '#'))
                e.preventDefault();

            if (currentViewIndex == 0) {
                var date = parseInt(clickedText, 10);

                var month = this.viewedMonth.month();

                if ($target.parent().hasClass('t-other-month'))
                    month += (date < 15 ? 1 : -1);

                var newlySelectedDate = new Date(this.viewedMonth.year(), month, date);

                {
                    if ($t.trigger(this.element, 'change', {
                        previousDate: this.selectedDate,
                        date: newlySelectedDate
                    }))
                        return this;

                    this.selectedDate = newlySelectedDate;
                }

                this.updateSelection();
            } else {
                if (currentViewIndex != 0)
                    $t.calendar.views[currentViewIndex].verticalDate(this.viewedMonth, clickedText);

                this.viewedMonth = $t.calendar.fitDateToRange(this.viewedMonth, new $t.datetime(this.minDate), new $t.datetime(this.maxDate));
                if (this.updateDates) {
                    this.updateDates(this, this.viewedMonth.toDate(), function (calendar) {
                        calendar.navigateVertically(currentViewIndex - 1, calendar.viewedMonth.toDate(), true, $target.add($target.parent()).filter('td'));
                    });
                } else {
                    this.navigateVertically(currentViewIndex - 1, this.viewedMonth.toDate(), true, $target.add($target.parent()).filter('td'));
                }
            }
        },

        navigateToPast: function (e) {
            if (e) e.preventDefault();
            var currentViewIndex = this.currentView.index;

            if (currentViewIndex == 0) {
                this.viewedMonth.date(1).date(-1);
            } else
                this.viewedMonth.addYear(-Math.pow(10, currentViewIndex - 1));
            if (this.updateDates) {
                this.updateDates(this, this.viewedMonth.toDate(), function (calendar) {
                    calendar.navigateHorizontally(currentViewIndex, calendar.viewedMonth.toDate(), false);
                });
            } else {
                this.navigateHorizontally(currentViewIndex, this.viewedMonth.toDate(), false);
            }
        },

        navigateToFuture: function (e) {
            if (e) e.preventDefault();
            var currentViewIndex = this.currentView.index;

            if (currentViewIndex == 0)
                this.viewedMonth.date(32).date(1);
            else
                this.viewedMonth.addYear(Math.pow(10, currentViewIndex - 1));

            if (this.updateDates) {
                this.updateDates(this, this.viewedMonth.toDate(), function (calendar) {
                    calendar.navigateHorizontally(currentViewIndex, calendar.viewedMonth.toDate(), true);
                });
            } else {
                this.navigateHorizontally(currentViewIndex, this.viewedMonth.toDate(), true);
            }
        }
    }

    $.fn.tCalendar = function (options) {
        return $t.create(this, {
            name: 'tCalendar',
            init: function (element, options) {
                return new $t.calendar(element, options);
            },
            options: options
        });
    };

    $.fn.tCalendar.defaults = {
        selectedDate: null,
        minDate: new Date(1899, 11, 31),
        maxDate: new Date(2100, 0, 1)
    };

    $.extend($t.calendar, {
        views: [{
            /* Month */
            index: 0,
            title: function (viewedMonth) {
                return new $t.stringBuilder()
			        .cat($t.cultureInfo.months[viewedMonth.month()])
			        .cat(' ')
			        .cat(viewedMonth.year()).string();
            },
            body: function (viewedMonth, minDate, maxDate, selectedDate, urlFormat, dates) {
                var html = (new $t.stringBuilder())
			               .cat('<thead><tr class="t-week-header">');

                var firstDayIndex = $t.cultureInfo.firstDayOfWeek;
                var days = $t.cultureInfo.days;
                var abbrDays = $t.cultureInfo.abbrDays;
                var today = new $t.datetime();
                days = days.slice(firstDayIndex).concat(days.slice(0, firstDayIndex));
                abbrDays = abbrDays.slice(firstDayIndex).concat(abbrDays.slice(0, firstDayIndex));

                if ((firstDayIndex == 0 || firstDayIndex == 1) && (elma.ShowCalendarWeekNumber)) {
                    html.cat('<th scope="col" class="t-alternative-item" title="#">#</th>')
                }
                for (var i = 0; i < 7; i++) {
                    var dayIndex = (i + firstDayIndex) % 7;
                    html.cat('<th scope="col"')
			            .cat(' class="t-' + (i % 2 == 0 ? "item" : "alternative-item") + (dayIndex == 0 || dayIndex == 6 ? " t-holiday" : "") + '"')
                        .cat(' abbr="')
                        .cat(abbrDays[i].toLocaleUpperCase())
                        .cat('" title="')
                        .cat(days[i])
                        .cat('">')
                        .cat(abbrDays[i].toLocaleUpperCase())
                        .cat('</th>');
                }

                html.cat('</tr></thead><tbody>');

                var currentDayInCalendar = $t.datetime.firstVisibleDay(viewedMonth);
                var month = viewedMonth.month();

                var selectedDateInViewedMonth = selectedDate === null ? false :
                                                viewedMonth.year() == selectedDate.year();
                var cellClass;

                for (var weekRow = 0; weekRow < 6; weekRow++) {

                    html.cat('<tr')
			            .cat(' class="t-' + (weekRow % 2 == 0 ? "item" : "alternative-item") + '"')
                        .cat('>');
                    if ((firstDayIndex == 0 || firstDayIndex == 1) && (elma.ShowCalendarWeekNumber)) {
                        var format = SR.T('d [MMMM] [ yyyy]{ - d MMMM yyyy}');
                        var endDate = new Date(currentDayInCalendar.value);
                        var daysTitle = endDate.getDay();
                        endDate = endDate.addDays(6 - daysTitle + firstDayIndex);
                        var startDate = new Date(currentDayInCalendar.value);
                        html.cat('<td style="cursor:default; border-right:1px solid #D0D5DA"')
                                .cat(' class="t-item' + (currentDayInCalendar.month() != month ?  " t-other-month" : ""))
                                .cat('">');
                        var weekFirstDayIsInRange = maxDate.toDate() < new Date(2100, 1, 0);
                        var tt = Date.dateTimePickerTitleFormatDates(startDate, endDate, format);
                        var translationMode = typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled();
                        tt = !translationMode ? tt : elma.ProcessTranslationHtmlElement(null, format, tt);
                        if (weekFirstDayIsInRange) {
                            html.cat('<a href="');
                            var url = '#';
                            if (urlFormat) {
                                url = $t.calendar.formatUrl(urlFormat, currentDayInCalendar);
                            }
                            html.cat(url)
			                    .cat('" class="t-link')
			                    .cat(dates && $t.calendar.isInCollection(currentDayInCalendar, dates) ? ' t-action-link' : '')
                                .cat('" title="')
                                .cat(tt)
			                    .cat('">')
			                    .cat(startDate.getWeekNum())
			                    .cat('</a>');
                        } else {
                            html.cat('<span class="t-state-disabled"  title="')
                                .cat(tt)
                                .cat('">')
                                .cat(startDate.getWeekNum())
                                .cat('</span>');
                            html.cat('</td>');
                        }
                    }

                    for (var day = 0; day < 7; day++) {
                        var dayIndex = (day + firstDayIndex) % 7;
                        var isInRange = $t.calendar.isInRange(currentDayInCalendar.toDate(), minDate.toDate(), maxDate.toDate());
                        cellClass =
			            currentDayInCalendar.month() != month ? 't-other-month' :
			            (selectedDateInViewedMonth
			            && currentDayInCalendar.month() == selectedDate.month()
			            && currentDayInCalendar.date() == selectedDate.date()) ? ' t-state-selected' : '';

                        if (currentDayInCalendar.year() == today.year() && currentDayInCalendar.month() == today.month() && currentDayInCalendar.date() == today.date()) {
                            cellClass += ' t-today-day';
                        }
                        if (dayIndex == 0 || dayIndex == 6) {
                            cellClass += ' t-holiday';
                        }

                        //if (!isInRange) {
                        //    cellClass += ' no-pointer';
                        //}

                        html.cat('<td')
			                .cat(' class="t-' + (day % 2 == 0 ? "item" : "alternative-item"))
			                .catIf(' ' + cellClass, cellClass)
			                .cat('">');

                        if (isInRange) {
                            html.cat('<a href="');
                            var url = '#';
                            if (urlFormat) {
                                url = $t.calendar.formatUrl(urlFormat, currentDayInCalendar);
                                //if (dates && !$t.calendar.isInCollection(currentDayInCalendar, dates)) {
                                //    url = '#';
                                //}
                            }

                            html.cat(url)
			                    .cat('" class="t-link')
			                    .cat(dates && $t.calendar.isInCollection(currentDayInCalendar, dates) ? ' t-action-link' : '')
                                .cat('" title="')
                                .cat($t.datetime.format(currentDayInCalendar.toDate(), $t.cultureInfo.longDate))
			                    .cat('">')
			                    .cat(currentDayInCalendar.date())
			                    .cat('</a>');
                        } else {
                            //html.cat('&nbsp;');
                            html.cat('<span class="t-state-disabled"  title="')
                                .cat($t.datetime.format(currentDayInCalendar.toDate(), $t.cultureInfo.longDate))
			                    .cat('">')
                                .cat(currentDayInCalendar.date())
                                .cat('</span>');
                        }
                        html.cat('</td>');

                        $t.datetime.modify(currentDayInCalendar, $t.datetime.msPerDay);
                    }

                    html.cat('</tr>');
                }
                html.cat('</tbody>');
                return html.string();
            },
            compare: function (date1, date2) {
                var result;
                var date1Month = date1.month();
                var date1Year = date1.year();
                var date2Month = date2.month();
                var date2Year = date2.year();

                if (date1Year > date2Year)
                    result = 1;
                else if (date1Year < date2Year)
                    result = -1;
                else // date1Year == date2Year
                    result = date1Month == date2Month ? 0 :
			                 date1Month > date2Month ? 1 : -1;
                return result;
            },
            firstLastDay: function (date, isFirstDay, calendar) {
                return isFirstDay ? $t.datetime.firstDayOfMonth(date) : new $t.datetime(date.year(), date.month() + 1, 0);
            },
            navCheck: function (date1, date2, isBigger) {
                if (isBigger) {
                    return new $t.datetime(date2.year(), date2.month() + 1, date2.date()).value - date1.value <= 0;
                } else {
                    return this.compare(date1, date2) === -1;
                }
            }
        },
			 {   /*Year*/
			     index: 1,
			     title: function (viewedMonth) { return viewedMonth.year(); },
			     body: function (viewedMonth, minDate, maxDate) {
			         return $t.calendar.metaView(true, viewedMonth, function () {
			             var result = [];

			             var startMonth = 0;
			             var endMonth = 11;

			             if (minDate.year() == maxDate.year()) {
			                 startMonth = minDate.month();
			                 endMonth = maxDate.month();
			             }
			             else if (viewedMonth.year() == minDate.year())
			                 startMonth = minDate.month();
			             else if (viewedMonth.year() == maxDate.year())
			                 endMonth = maxDate.month();

			             for (var i = 0; i < 12; i++) {
			                 if (i >= startMonth && i <= endMonth)
			                     result.push($t.cultureInfo.abbrMonths[i]);
			                 else
			                     result.push('&nbsp;');
			             }

			             return result;
			         });
			     },
			     compare: function (date1, date2) {
			         return date1.year() > date2.year() ? 1 : date1.year() < date2.year() ? -1 : 0;
			     },
			     verticalDate: function (date, clickedText) {
			         if (!clickedText)
			             return date.month();
			         date.month($.inArray(clickedText, $t.cultureInfo.abbrMonths));
			     },
			     firstLastDay: function (date, isFirstDay) {
			         return new $t.datetime(date.year(), isFirstDay ? 0 : 11, 1);
			     },
			     navCheck: function (date1, date2, isBigger) {
			         var tmp = this.compare(date1, date2);
			         return isBigger ? tmp == 1 : tmp == -1;
			     }
			 },
			 {   /*Decade*/
			     index: 2,
			     title: function (viewedMonth) {
			         var firstYearInDecade = viewedMonth.year() - viewedMonth.year() % 10;
			         return firstYearInDecade + '-' + (firstYearInDecade + 9);
			     },
			     body: function (viewedMonth, minDate, maxDate) {
			         return $t.calendar.metaView(false, viewedMonth, function () {
			             var result = [];
			             var minYear = minDate.year();
			             var maxYear = maxDate.year();
			             var year = viewedMonth.year() - viewedMonth.year() % 10 - 1;

			             for (var i = 0; i < 12; i++)
			                 result.push(year + i >= minYear && year + i <= maxYear ? year + i : '&nbsp;');

			             return result;
			         });
			     },
			     compare: function (date1, date2, checkBigger) {
			         var year = date1.year();
			         var minDecade = (year - year % 10);
			         var maxDecade = (year - year % 10 + 9);
			         return $t.calendar.check(minDecade, maxDecade, date2, checkBigger);
			     },
			     verticalDate: function (date, clickedText) {
			         if (!clickedText)
			             return date.year() % 10 + 1;
			         date.year(clickedText);
			     },
			     firstLastDay: function (date, isFirstDay) {
			         return new $t.datetime(date.year() - date.year() % 10 + (isFirstDay ? 0 : 9), 0, 1);
			     },
			     navCheck: function (date1, date2, isBigger) {
			         var tmp = this.compare(date2, date1, isBigger);
			         return isBigger ? tmp == -1 : tmp == 1;
			     }
			 },
			 {   /*Century*/
			     index: 3,
			     title: function (viewedMonth) {
			         var firstYearInCentury = viewedMonth.year() - viewedMonth.year() % 100;

			         return firstYearInCentury + '-' + (firstYearInCentury + 99);
			     },
			     body: function (viewedMonth, minDate, maxDate) {
			         return $t.calendar.metaView(false, viewedMonth, function () {
			             var firstYearInCentury = viewedMonth.year() - viewedMonth.year() % 100;

			             var result = [];

			             for (var i = -1; i < 11; i++) {
			                 var firstYearInCenturyTemp = firstYearInCentury + i * 10;
			                 if ((firstYearInCenturyTemp + 10) >= minDate.year() && firstYearInCenturyTemp <= maxDate.year())
			                     result.push(firstYearInCenturyTemp + '-<br />' +
			                     (firstYearInCenturyTemp + 9) + '&nbsp;');
			                 else
			                     result.push('&nbsp;<br />&nbsp;');
			             }
			             return result;
			         });
			     },
			     compare: function (date1, date2, checkBigger) {
			         var year = date1.year();
			         var minCentury = (year - year % 100);
			         var maxCentury = (year - year % 100 + 99);
			         return $t.calendar.check(minCentury, maxCentury, date2, checkBigger);
			     },
			     verticalDate: function (date, clickedText) {
			         if (!clickedText)
			             return Math.ceil(date.year() / 10) % 10 + 1;

			         date.year(clickedText.substring(0, clickedText.indexOf('-')));
			     },
			     firstLastDay: function (date, isFirstDay) {
			         return isFirstDay ? new $t.datetime(date.year() - (date.year() % 100), 0, 1) :
			                new $t.datetime(date.year() - (date.year() % 100) + 99, 0, 1);
			     },
			     navCheck: function (date1, date2, isBigger) {
			         var tmp = this.compare(date2, date1, isBigger);
			         return isBigger ? tmp == -1 : tmp == 1;
			     }
			 }],

        check: function (value1, value2, date, checkBigger) {
            var check = function (val) {
                return val < date.year() ? -1 :
			 val > date.year() ? 1 : 0;
            }
            return checkBigger ? check(value2) : check(value1);
        },

        html: function (viewedMonth, selectedDate, minDate, maxDate, urlFormat, dates) {
            viewedMonth = viewedMonth || new $t.datetime();
            minDate = minDate || new $t.datetime($.fn.tCalendar.defaults.minDate);
            maxDate = maxDate || new $t.datetime($.fn.tCalendar.defaults.maxDate);
            var currentDateStr = $.telerik.formatString('{0:' + $.telerik.cultureInfo.shortDate + '}', new Date())
            return new $t.stringBuilder().cat('<div class="t-widget t-calendar">')
			                             .cat('<div class="t-header">')
			                             .cat('<a href="#" class="t-link t-nav-prev">')
			                             .cat('<span class="t-icon t-arrow-prev"></span></a><a href="#" class="t-link t-nav-fast">')
			                             .cat($t.calendar.views[0].title(viewedMonth))
			                             .cat('</a>')
			                             .cat('<a href="#" class="t-link t-nav-next"><span class="t-icon t-arrow-next"></span></a>')
			                             .cat('</div>')
			                             .cat('<table class="t-content" cellspacing="0">')
			                             .cat($t.calendar.views[0].body(viewedMonth, minDate, maxDate, selectedDate, urlFormat, dates))
			                             .cat('</table>')
                                         .cat('<div class="t-footer">')
                                         .cat('<button type="button" class="b-today t-button" title="' + currentDateStr + ' (' + SR.T("Пробел") + ')"><span class="t-today-title">' + SR.T("Сегодня") + '</span> ' + currentDateStr + '</button>')
			                             .cat('</div></div>')
			                             .string();
        },

        metaView: function (isYearView, viewedMonth, getCollection) {
            var html = new $t.stringBuilder();

            var collection = getCollection();

            html.cat('<tr>');

            // build 4x3 table
            for (var i = 0, len = collection.length; i < len; i++) {

                html.catIf('</tr><tr>', i > 0 && i % 4 == 0)
			        .cat('<td')
			        .catIf(' class="t-other-month"', (i == 0 || i == len - 1) && isYearView == false)
			        .cat('>');

                if (collection[i] !== '&nbsp;' && collection[i] !== '&nbsp;<br />&nbsp;')
                    html.cat('<a href="#" class="t-link">')
			            .cat(collection[i]).cat('</a>')
                else
                    html.cat(collection[i]);

                html.cat('</td>');
            }

            html.cat('</tr>');

            return html.string();
        },

        isInRange: function (date, minDate, maxDate) {
            if (!date) return false;

            var d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            var min = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
            var max = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());

            return min - d <= 0 && max - d >= 0;
        },

        fitDateToRange: function (date, minDate, maxDate) {
            if (date.value < minDate.value) date = new $t.datetime(minDate.value)
            if (date.value > maxDate.value) date = new $t.datetime(maxDate.value)
            return date;
        },

        isInCollection: function (date, dates) {
            var months = dates[date.year()];
            if (months) {
                var days = months[date.month()];
                if (days && $.inArray(date.date(), days) != -1)
                    return true;
            }
            return false;
        },

        findTarget: function (focusedDate, viewedIndex, calendar, isFuture) {
            focusedDate = focusedDate.value ? focusedDate : new $t.datetime(focusedDate);
            var findTarget = function (collection, searchedText) {
                return $.grep(collection, function (item) {
                    return $(item).children().eq(0).text().indexOf(searchedText) > -1;
                })[0];
            }

            var selector = isFuture ? 'last' : 'first';
            var cells = $('.t-content:' + selector + ' td:has(> .t-link)', calendar).removeClass('t-state-focus');

            var $target;
            if (viewedIndex == 0) {
                $target = $(findTarget(cells.filter(':not(.t-other-month)'), focusedDate.date()));
            } else if (viewedIndex == 1) {
                $target = $(findTarget(cells, $t.cultureInfo.abbrMonths[focusedDate.month()]));
            } else if (viewedIndex == 2 || viewedIndex == 3) {
                var year = focusedDate.year();
                $target = $(findTarget(cells, viewedIndex == 2 ? year : year - (year % 10)));
                if ($target.length == 0 && viewedIndex == 3)
                    $target = $(findTarget(cells, year - (year % 10) + 99));
            }
            return $target;
        },

        focusDate: function (focusedDate, viewedIndex, calendar, isFuture) {
            $t.calendar.findTarget(focusedDate, viewedIndex, calendar, isFuture).addClass('t-state-focus');
        },

        formatUrl: function (urlFormat, date) {
            var format = urlFormat.match(dateFormatRegExp);
            if (format) {
                format = format[0];
                var dateFormat = format === "{0}" ? $t.cultureInfo.generalDateTime : format.replace(replaceUrlRegExp, "").replace("}", "");

                return urlFormat.replace(format, $t.datetime.format(date.toDate(), dateFormat));
            }
            return urlFormat;
        }
    });

    $.extend($t.formatters, {
        date: $t.datetime.format
    });
})(jQuery);


(function ($) {

    var $t = $.telerik;

    $t.timeView = function (options) {
        $.extend(this, options);

        var dropDown = this.dropDown = new $t.dropDown({
            attr: this.dropDownAttr,
            effects: this.effects,
            onClick: function (e) {
                var item = e.item;
                options.onChange(item.innerText || item.textContent);
            }
        });

        dropDown.$element
                .addClass('t-time-popup')
                .css('direction', this.isRtl ? 'rtl' : '');
    }

    $t.timeView.prototype = {
        _ensureItems: function () {
            if (!this.dropDown.$items)
                this.bind()
        },

        open: function (position) {
            this._ensureItems();
            this.dropDown.open(position);
        },

        close: function () {
            this.dropDown.close();
        },

        bind: function () {
            var getTimeMilliseconds = $t.timeView.getTimeMilliseconds;

            var availableHours = [];
            var format = this.format;
            var interval = this.interval;
            var tmpDate = new $t.datetime(this.minValue);
            var msMinTime = getTimeMilliseconds(tmpDate);
            var msMaxTime = getTimeMilliseconds(this.maxValue);
            var msInterval = interval * $t.datetime.msPerMinute;

            var records = parseInt($t.datetime.msPerDay / (interval * $t.datetime.msPerMinute));

            if (msMinTime != msMaxTime) {
                var result = msMinTime < msMaxTime ?
                             msMaxTime - msMinTime :
                             msMaxTime + $t.datetime.msPerDay - msMinTime;

                records = parseInt(result / msInterval) + 1;
            }

            var add = $t.datetime.add;
            var formater = $t.datetime.format;
            for (var i = 0; i < records; i++) {
                if (getTimeMilliseconds(tmpDate) != 0 || i == 0)
                    availableHours[i] = formater(tmpDate.toDate(), format);
                tmpDate = add(tmpDate, msInterval);
            }

            if (getTimeMilliseconds(tmpDate) - msInterval - msMaxTime != 0 && msMinTime != msMaxTime && msMaxTime > 0)
                availableHours[records] = formater(this.maxValue, format);

            this.dropDown.dataBind(availableHours);
        },

        isOpened: function () {
            return this.dropDown.isOpened();
        },

        value: function (value) {
            this._ensureItems();
            var dropDown = this.dropDown;

            if (value === undefined)
                return dropDown.$items.filter('.t-state-selected').text();

            var $items = dropDown.$items;
            if (!$items) return;

            $items.removeClass('t-state-selected');
            if (value) {
                dropDown.highlight($.grep($items, function (li) {
                    return (li.innerText || li.textContent) == value;
                }));
            }
        },

        navigate: function (e) {
            var key = e.keyCode || e.which;

            if (key == 38 || key == 40)
                e.preventDefault();

            this._ensureItems();
            var dropDown = this.dropDown;
            var $items = dropDown.$items;
            var $selectedItem = $items.filter('.t-state-selected');

            var $item = $selectedItem.length == 0 || $items.length == 1
                            ? $items.first()
                            : (key == 38) ? $selectedItem.prev() // up
                            : (key == 40) ? $selectedItem.next() // down
                            : [];

            if ($item.length) {
                var text = $item.text();
                dropDown.scrollTo($item[0]);
                dropDown.highlight($item[0]);
                if (!dropDown.isOpened())
                    this.onChange(text);
                else
                    this.onNavigateWithOpenPopup(text);
            }
        }
    }

    $.each(["min", "max"], $.proxy(function (index, method) {
        $t.timeView.prototype[method] =
            function (value) {
                var propertyName = method + 'Value';
                if (value === undefined)
                    return this[propertyName];

                this[propertyName] = new Date(value.value ? value.value : value);
                this.bind();
            };
    }, this));

    $.extend($t.timeView, {
        isInRange: function (value, minValue, maxValue) {
            if (value === null) return true;

            var getTimeMilliseconds = $t.timeView.getTimeMilliseconds;
            var msPerDay = $t.datetime.msPerDay;
            var msValue = getTimeMilliseconds(value);
            var msMinTime = getTimeMilliseconds(minValue);
            var msMaxTime = getTimeMilliseconds(maxValue);

            msValue = msMinTime > msValue
                    ? msValue + msPerDay
                    : msValue;

            msMaxTime = msMinTime > msMaxTime
                        ? msMaxTime + msPerDay
                        : msMaxTime;

            return msMinTime - msMaxTime == 0 || msValue >= msMinTime && msValue <= msMaxTime;
        },

        getTimeMilliseconds: function (value) {
            value = value.value ? value : new $t.datetime(value);
            return ((value.hours() * 60) + value.minutes()) * $t.datetime.msPerMinute + value.seconds() * 1000 + value.milliseconds();
        }
    });

    $t.timepicker = function (element, options) {

        $.extend(this, options);

        if (element.nodeName.toLowerCase() !== "input" && element.type.toLowerCase() !== "text") {
            throw "Target element is not a INPUT";
        }

        this.element = element;
        var $element = this.$element = $(element)
                    .addClass('t-input')
                    .attr('autocomplete', 'off')
                    .bind({
                        keydown: $.proxy(this._keydown, this),
                        focus: $.proxy(function (e) {
                            if (this.openOnFocus) {
                                this._open();
                            }
                            this.$element.removeClass('t-state-error');
                        }, this)
                    });


        if (!$element.parent().hasClass('t-picker-wrap')) {

            $element.wrap('<div class="t-widget t-timepicker"><div class="t-picker-wrap"></div></div>');

            if (options.showButton) {
                var builder = new $t.stringBuilder(),
                title = options.buttonTitle;

                $(builder
                    .cat('<span class="t-select">')
                    .cat('<span class="t-icon t-icon-clock" ')
                    .catIf('title="', title)
                    .catIf(title, title)
                    .cat('"></span></span>')
                    .string())
                .insertAfter($element);
            }
        }

        this.timeView = new $t.timeView({
            effects: this.effects,
            dropDownAttr: this.dropDownAttr,
            format: this.format,
            interval: this.interval,
            isRtl: $element.closest('.t-rtl').length,
            minValue: this.minValue,
            maxValue: this.maxValue,
            onNavigateWithOpenPopup: $.proxy(function (value) {
                this.$element.val(value);
            }, this),
            onChange: $.proxy(function (value) {
                if (value != this.inputValue) {
                    this._update(value);
                }
                this._close();
            }, this)
        });

        this.inputValue = $element.val();

        var value = this.selectedValue || this.inputValue;
        if (value) {
            this._value(this.parse(value));
        }

        var clickHandler = this.enabled
                         ? $.proxy(this._togglePopup, this)
                         : $t.preventDefault;

        this.$wrapper = $element.closest('.t-timepicker')
            .find('.t-icon')
            .bind('click', clickHandler)
            .end();

        // Focus & hover
        applyInputBorders(this.$element, this.$wrapper.find('> .t-picker-wrap'));

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var val = this.$element.val();

            if (val.indexOf("_") != -1)
                val = '';

            if (val != this.inputValue) {
                this._update(val);
            }

            var $dropDown = this.timeView.dropDown.$element;
            var isDropDown = $dropDown && $dropDown.parent().length > 0;

            if (!isDropDown
            || $.contains(this.$wrapper[0], e.target)
            || $.contains($dropDown.parent()[0], e.target))
                return;

            this._close();

        }, this));

        $t.bind(this, {
            open: this.onOpen,
            close: this.onClose,
            valueChange: this.onChange,
            load: this.onLoad
        });
    }

    $t.timepicker.prototype = {
        _close: function () {
            var dropDown = this.timeView.dropDown;
            if (!dropDown.$element.is(':animated') && dropDown.isOpened())
                this._trigger('close');
        },

        _open: function () {
            if (!this.timeView.isOpened())
                this._trigger('open');
        },

        _trigger: function (methodName) {
            if (!$t.trigger(this.element, methodName))
                this[methodName]();
        },

        _togglePopup: function () {
            if (this.timeView.isOpened()) {
                this._close();
            } else {
                this.element.focus();
                this._open();
            }
        },

        _update: function (val) {

            //if (val == '__:__')
            //    val = '';
            var minValue = this.minValue,
                maxValue = this.maxValue,
                parsedValue = this.parse(val),
                selectedValue = this.selectedValue;
            if (val != undefined && val != null && val != '' && parsedValue == null) {
                parsedValue = this.selectedValue;
            }

            if (parsedValue != null && !$t.timeView.isInRange(parsedValue, minValue, maxValue)) {
                var getTimeMilliseconds = $t.timeView.getTimeMilliseconds,
                    msValue = getTimeMilliseconds(parsedValue),
                    minDiff = Math.abs(getTimeMilliseconds(minValue) - msValue),
                    maxDiff = Math.abs(getTimeMilliseconds(maxValue) - msValue);

                parsedValue = new Date(minDiff < maxDiff ? minValue : maxValue);
            }

            var formattedSelectedValue = selectedValue ? $t.datetime.format(selectedValue, this.format) : '',
                formattedValue = parsedValue ? $t.datetime.format(parsedValue, this.format) : '';

            if (formattedValue != formattedSelectedValue) {
                if ($t.trigger(this.element, 'valueChange', { previousValue: selectedValue, value: parsedValue })) {
                    parsedValue = new Date(selectedValue);
                }
            }

            this._value(parsedValue);

            if (formattedValue != formattedSelectedValue) {
                $(this.element).trigger('afterChange', { previousValue: selectedValue, value: parsedValue, formattedValue: formattedValue });
            }
        },

        _value: function (value) {
            var text = this.$element.val();
            if (text.indexOf("_") != -1 || this.parse(text) == null)
                text = '';
            var isNull = value === null;

            this.selectedValue = value;
            this.timeView.value(isNull ? null : $t.datetime.format(value, this.format));

            if (!isNull)
                text = $t.datetime.format(value, this.format);

            this.inputValue = text;
            this.$element.toggleClass('t-state-error', isNull && text != '')
                         .val(text);
        },

        _keydown: function (e) {
            var key = e.keyCode || e.which;

            if (e.altKey) {
                if (key == 40) {
                    this._open();
                } else if (key == 38) {
                    this._close();
                }
                return;
            }

            if (!e.shiftKey && (key === 38 || key === 40)) {
                this.timeView.navigate(e);
                return;
            }

            if (key == 9 || key == 13 || key == 27) {
                this._update(this.$element.val());
                this._close();
            }
        },

        enable: function () {
            this.$element.attr('disabled', false);
            this.$wrapper.removeClass('t-state-disabled')
                         .find('.t-icon')
                         .unbind('click')
                         .bind('click', $.proxy(this._togglePopup, this));
        },

        disable: function (e) {
            this.$element.attr('disabled', true);
            this.$wrapper.addClass('t-state-disabled')
                         .find('.t-icon')
                         .unbind('click')
                         .bind('click', $t.preventDefault);
        },

        value: function (val) {
            if (val === undefined)
                return this.selectedValue;

            var parsedValue = this.parse(val);
            parsedValue = $t.timeView.isInRange(parsedValue, this.minValue, this.maxValue) ? parsedValue : null;

            if (parsedValue === null)
                this.$element.removeClass('t-state-error').val('');

            this._value(parsedValue);

            return this;
        },

        parse: function (value) {
            if (value === null || value.getDate)
                return value;

            var result = $t.datetime.parse({
                AM: $t.cultureInfo.AM,
                PM: $t.cultureInfo.PM,
                value: value,
                format: this.format,
                baseDate: this.selectedValue ? new $t.datetime(this.selectedValue) : new $t.datetime()
            });
            return result != null ? result.toDate() : null;
        },

        open: function () {
            var $element = this.$element;
            var offset = $element.offset();
            offset.left -= 1;
            offset.top += 1;
            this.timeView.open({
                offset: offset,
                outerHeight: $element.outerHeight(),
                outerWidth: $element.parent().outerWidth(),
                zIndex: $t.getElementZIndex($element[0])
            });
        },

        close: function () {
            this.timeView.close();
        }
    }

    $.each(["min", "max"], $.proxy(function (index, method) {
        $t.timepicker.prototype[method] =
            function (value) {
                var propertyName = method + 'Value';
                if (value === undefined)
                    return this[propertyName];

                var parsedValue = this.parse(value);
                if (parsedValue !== null) {
                    this[propertyName] = parsedValue;
                    this.timeView[method](parsedValue);
                    if (!$t.timeView.isInRange(this.selectedValue, this.minValue, this.maxValue))
                        this.value(parsedValue);
                }
            };
    }, this));

    $.fn.tTimePicker = function (options) {
        return $t.create(this, {
            name: 'tTimePicker',
            init: function (element, options) {
                return new $t.timepicker(element, options);
            },
            options: options
        });
    };

    $.fn.tTimePicker.defaults = {
        effects: $t.fx.slide.defaults(),
        minValue: new $t.datetime().hours(0).minutes(0).seconds(0).toDate(),
        maxValue: new $t.datetime().hours(0).minutes(0).seconds(0).toDate(),
        selectedValue: null,
        format: $t.cultureInfo.shortTime,
        interval: 30,
        showButton: true,
        buttonTitle: 'Open the calendar',
        enabled: true,
        openOnFocus: false
    };

})(jQuery);


(function ($) {

    var $t = $.telerik,
        keycodes = [8, // backspace
                    9, // tab
                    37, // left arrow
                    38, // up arrow
                    39, // right arrow
                    40, // down arrow
                    46, // delete
                    35, // end
                    36, // home
                    44], //","
        styles = ["font-family",
                  "font-size",
                  "font-stretch",
                  "font-style",
                  "font-weight",
                  "letter-spacing",
                  "line-height",
                  "color",
                  "text-align",
                  "text-decoration",
                  "text-indent",
                  "text-transform"];

    function getStyles(input) {
        var retrievedStyles = {};
        for (var i = 0, length = styles.length; i < length; i++) {
            var style = styles[i],
                value = input.css(style);

            if (value) {
                if (styles[i] != "font-style" && value != "normal") {
                    retrievedStyles[style] = value;
                }
            }
        }
        return retrievedStyles;
    }

    $t.textbox = function (element, options) {
        if (element.nodeName.toLowerCase() !== "input" && element.type.toLowerCase() !== "text") {
            throw "Target element is not a INPUT";
        }

        $.extend(this, options);
        this.element = element;
        var $element = this.$element = $(element)
            .bind({
                focus: function (e) {
                    var input = e.target;
                    setTimeout(function () {
                        if ($.browser.msie) {
                            input.select();
                        } else {
                            input.selectionStart = 0;
                            input.selectionEnd = input.value.length;
                        }
                    }, 0);
                },
                keydown: $.proxy(this._keydown, this),
                keypress: $.proxy(this._keypress, this),
                keyup: $.proxy(this._keyup, this)
            })
            .bind("paste", $.proxy(this._paste, this));

        var builder = new $t.stringBuilder();

        if (element.parentNode.nodeName.toLowerCase() !== "div") {
            $element.addClass('t-input')
                    .wrap($('<div class="t-widget t-numerictextbox"></div>'));

            if (this.showIncreaseButton) {
                builder.cat('<a class="t-link t-icon t-arrow-up" href="#" tabindex="-1" title="')
                       .cat(this.increaseButtonTitle)
                       .cat('">Increment</a>');
            }

            if (this.showDecreaseButton) {
                builder.cat('<a class="t-link t-icon t-arrow-down" href="#" tabindex="-1" title="')
                       .cat(this.decreaseButtonTitle)
                       .cat('">Decrement</a>');
            }

            if (builder.buffer.length > 0) {
                $(builder.string()).insertAfter($element);
            }
        }

        this.$wrapper = $element.closest('.t-numerictextbox')
            .find('.t-arrow-up, .t-arrow-down')
                .bind({
                    click: $t.preventDefault,
                    dragstart: $t.preventDefault
                })
            .end()
            .click(function (e) {
                element.focus();
            })
            .bind({
                focusin: $.proxy(this._focus, this),
                focusout: $.proxy(this._blur, this)
            });

        this.enabled = !$element.is('[disabled]');

        builder.buffer = [];
        builder.cat('[ |')
               .cat(this.groupSeparator)
               .catIf('|' + this.symbol, this.symbol)
               .cat(']');
        this.replaceRegExp = new RegExp(builder.string(), 'g');

        var inputValue = $element.attr('value');

        builder.buffer = [];
        builder.cat('<div class="t-formatted-value')
               .cat((inputValue == '' && this.enabled) ? ' t-state-empty' : '')
               .cat('">')
               .cat(inputValue || (this.enabled ? this.text : ''))
               .cat('</div>');

        this.$text = $(builder.string())
                        .insertBefore($element)
                        .css(getStyles($element))
                        .click(function (e) {
                            element.focus();
                        });

        // Focus & hover
        applyInputBorders(this.$element, this.$wrapper);

        //set text color to the background-color.
        this._blur();
        this[this.enabled ? 'enable' : 'disable']();
        
        this.numFormat = this.numFormat === undefined ? this.type.charAt(0) : this.numFormat;
        var separator = this.separator;
        this.step = this.parse(this.step, separator);
        this.val = this.parse(this.val, separator);
        this.minValue = this.parse(this.minValue, separator);
        this.maxValue = this.parse(this.maxValue, separator);
        this.decimals = { '190': '.', '191': '.', '188': ',', '110': separator };

        this.value(inputValue || this.val);
        
        $t.bind(this, {
            load: this.onLoad,
            valueChange: this.onChange
        });
    }

    $t.textbox.prototype = {
        _paste: function (e) {
            e.preventDefault();
            if (!e.originalEvent)
                return false;
            var pastedText = undefined;
            if (window.clipboardData && window.clipboardData.getData) { // IE
                pastedText = window.clipboardData.getData('Text');
            } else if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
                pastedText = e.originalEvent.clipboardData.getData('text/plain');
            }
            if (!pastedText)
                return false;
            if (pastedText == '-')
                return true;
            
            pastedText = this.parse(pastedText, this.separator);
            if (!pastedText)
                return false;
            pastedText = parseFloat(pastedText.toFixed(this.digits));
            if (pastedText || pastedText == 0) {
                this._update(pastedText);
                $(this.element).trigger('change');
            }
        },
        
        _keydown: function (e) {
            var key = e.keyCode,
                $element = this.$element,
                separator = this.separator,
                value = $element.val();
            setTimeout($.proxy(function () {
                $element.toggleClass('t-state-error', !this.inRange(this.parse($element.val(), this.separator), this.minValue, this.maxValue));
            }, this));

            // Allow decimal
            var decimalSeparator = this.decimals[key];
            if (decimalSeparator) {
                if (this.digits == 0)
                    return false;
                if (key != '110' && decimalSeparator == separator
                && this.digits > 0
                && value.indexOf(separator) == -1) {
                    return true;
                } else {
                    e.preventDefault();
                    if (value.indexOf(separator) == -1) {
                        var start = e.currentTarget.selectionStart;
                        var startValue = value.substr(0, start);
                        var newVal = startValue + this.separator;
                        if (start < value.length) {
                            newVal += value.substr(start);
                            var parsedValue = this.parse(newVal);
                            parsedValue = parseFloat(parsedValue.toFixed(this.digits));
                            $element.val(this.formatEdit(parsedValue));
                        } else {
                            $element.val(newVal);
                        }
                            
                    }
                }
            }

            if (key == 8 || key == 46) { //backspace and delete
                setTimeout($.proxy(function () {
                    this._update(this.parse($element.val()));
                }, this));
                return true;
            }

            if (key == 38 || key == 40) {
                var direction = key == 38 ? 1 : -1;
                this._modify(direction * this.step);
                return true;
            }

            if (key == 222) e.preventDefault();
        },

        _keypress: function (e) {
            var $element = $(e.target),
                value = $element.val(),
                key = e.keyCode || e.which,
                keyValue = String.fromCharCode(key);
            if (e.shiftKey && key != 45) {
                return false;
            }

            if (key == 0 || $.inArray(key, keycodes) != -1 || e.ctrlKey || (e.shiftKey && key == 45))
                return true;

            if (((this.minValue !== null ? this.minValue < 0 : true)
                    && keyValue == "-"
                    && $t.caretPos($element[0]) == 0
                    && value.indexOf("-") == -1)
                || (keyValue >= "0" && keyValue <= "9")) {

                return true;
            }

            e.preventDefault();
        },

        _keyup: function (e) {
            var $element = $(e.target),
                value = $element.val(),
                separator = this.separator;

            if (value.indexOf(separator) != -1 && (value.length - value.indexOf(separator) - 1 > this.digits)) {
                var parsedValue = this.parse(value);
                parsedValue = parseFloat(parsedValue.toFixed(this.digits));
                $element.val(this.formatEdit(parsedValue));
                return false;
            }
            return true;
        },

        _focus: function () {
            this.$element
                .css('color', this.$text.css("color"));

            this.$text.hide();
        },

        _blur: function () {
            this.$element
                .css('color', this.$element.css('background-color'))
                .removeClass('t-state-error');

            if (this.enabled) {
                this.$text.show();
            }
            
            var min = this.minValue,
                max = this.maxValue,
                parsedValue = this.parse(this.$element.val());

            if (parsedValue != null) {
                if (min != null && parsedValue < min) {
                    parsedValue = min;                    
                } else if (max != null && parsedValue > max) {
                    parsedValue = max;                    
                }
                parsedValue = parseFloat(parsedValue.toFixed(this.digits));
            } else {
                parsedValue = this.nullable ? null : this.defaultval;
            }
            this._update(parsedValue);

            if (this.needChangeTrigger) {
                $(this.element).trigger('change');
                this.needChangeTrigger = false;
            }            
        },

        _clearTimer: function (e) {
            clearTimeout(this.timeout);
            clearInterval(this.timer);
            clearInterval(this.acceleration);
        },

        _stepper: function (e, stepMod) {
            if (e.which == 1) {

                var step = this.step;

                this._modify(stepMod * step);

                this.timeout = setTimeout($.proxy(function () {
                    this.timer = setInterval($.proxy(function () {
                        this._modify(stepMod * step);
                    }, this), 80);

                    this.acceleration = setInterval(function () { step += 1; }, 1000);
                }, this), 200);
            }
        },

        _modify: function (step) {
            var value = this.parse(this.element.value),
                min = this.minValue,
                max = this.maxValue;

            value = value ? value + step : step;

            if (min !== null && value < min) {
                value = min;
            } else if (max !== null && value > max) {
                value = max;
            }

            this._update(parseFloat(value.toFixed(this.digits)));
        },

        _update: function (val) {
            if (this.val != val) {
                if ($t.trigger(this.element, 'valueChange', { oldValue: this.val, newValue: val })) {
                    val = this.val; //revert changes
                }
            }
            this._value(val);
        },

        _value: function (value) {
            var parsedValue = (typeof value === "number") ? value : this.parse(value, this.separator),
                text = this.enabled ? this.text : '',
                isNull = parsedValue === null;

            if (parsedValue != null) {
                parsedValue = parseFloat(parsedValue.toFixed(this.digits));
            }

            this.val = parsedValue;
            var currentV = this.$element.val();
            var formattedV = isNull ? '' : this.formatEdit(parsedValue);
            if (currentV !== formattedV) {
                this.$element.val(formattedV);
            }
            this.$text.html(isNull ? text : this.format(parsedValue));
            if (isNull) {
                this.$text.addClass('t-state-empty');
            } else {
                this.$text.removeClass('t-state-empty');
            }
        },

        enable: function () {
            var $buttons = this.$wrapper.find('.t-arrow-up, .t-arrow-down'),
                clearTimerProxy = $.proxy(this._clearTimer, this);

            this.enabled = true;
            this.$element.removeAttr("disabled");

            if (!this.val && this.val != 0) {
                this.$text
                    .addClass('t-state-empty')
                    .html(this.text);
            } else if (true == $.browser.msie) {
                this.$text.show();
            } else {
                this.$element.css('color', this.$element.css('background-color'))
            }

            this.$wrapper.removeClass('t-state-disabled');
            $buttons.unbind('mouseup').unbind('mouseout').unbind('dblclick')
                    .bind({
                        mouseup: clearTimerProxy,
                        mouseout: clearTimerProxy,
                        dblclick: clearTimerProxy
                    });

            var eventName = "mousedown";
            $buttons.eq(0)
                    .unbind(eventName)
                    .bind(eventName, $.proxy(function (e) {
                        this._stepper(e, 1);
                    }, this));

            $buttons.eq(1)
                    .unbind(eventName)
                    .bind(eventName, $.proxy(function (e) {
                        this._stepper(e, -1);
                    }, this));
        },

        disable: function () {
            this.enabled = false;

            this.$wrapper
                .addClass('t-state-disabled')
                .find('.t-icon')
                    .unbind('mousedown')
                    .bind('mousedown', $t.preventDefault);

            this.$element
                .attr('disabled', 'disabled')

            if (!this.val && this.val != 0)
                this.$text.html('');
            else if (true == $.browser.msie)
                this.$text.hide();
            else
                this.$element.css('color', this.$element.css('background-color'))
        },

        value: function (value) {
            if (value === undefined) {
                return this.val;
            }

            var parsedValue = (typeof value === "number") ? value : this.parse(value, this.separator);
            if (!this.inRange(parsedValue, this.minValue, this.maxValue)) {
                parsedValue = this.nullable ? null : this.defaultval;
            }

            this._value(parsedValue);
        },

        formatEdit: function (value) {
            var separator = this.separator;
            if (value && separator != '.')
                value = value.toString().replace('.', separator);
            return value;
        },

        format: function (value) {
            return $t.textbox.formatNumber(value,
                                           this.numFormat,
                                           this.digits,
                                           this.separator,
                                           this.groupSeparator,
                                           this.groupSize,
                                           this.positive,
                                           this.negative,
                                           this.symbol,
                                           true);
        },

        inRange: function (key, min, max) {
            return key === null || ((min !== null ? key >= min : true) && (max !== null ? key <= max : true));
        },

        parse: function (value, separator) {            
            var result = null;
            if (value || value == "0") {
                if (typeof value == typeof 1) return value;

                value = value.replace(this.replaceRegExp, '');
                var sep = separator ? separator : this.separator;
                if (sep && sep != '.')
                    value = value.replace(sep, '.');

                var negativeFormatPattern = $.fn.tTextBox.patterns[this.type].negative[this.negative]
                        .replace(/(\(|\))/g, '\\$1').replace('*', '').replace('n', '([\\d|\\.]*)'),
                    negativeFormatRegEx = new RegExp(negativeFormatPattern);

                if (negativeFormatRegEx.test(value))
                    result = -parseFloat(negativeFormatRegEx.exec(value)[1]);
                else
                    result = parseFloat(value);
            }
            return isNaN(result) ? null : result;
        }
    }

    $.fn.tTextBox = function (options) {
        var type = 'numeric';
        if (options && options.type) {
            type = options.type;
        }

        var defaults = $.fn.tTextBox.defaults[type];
        defaults.digits = $t.cultureInfo[type + 'decimaldigits'];
        defaults.separator = $t.cultureInfo[type + 'decimalseparator'];
        defaults.groupSeparator = $t.cultureInfo[type + 'groupseparator'];
        defaults.groupSize = $t.cultureInfo[type + 'groupsize'];
        defaults.positive = $t.cultureInfo[type + 'positive'];
        defaults.negative = $t.cultureInfo[type + 'negative'];
        defaults.symbol = $t.cultureInfo[type + 'symbol'];

        options = $.extend({}, defaults, options);
        options.type = type;

        return this.each(function () {
            var $element = $(this);
            options = $.meta ? $.extend({}, options, $element.data()) : options;

            if (!$element.data('tTextBox')) {
                $element.data('tTextBox', new $t.textbox(this, options));
                $t.trigger(this, 'load');
            }
        });
    };

    var commonDefaults = {
        val: null,
        text: '',
        step: 1,
        inputAttributes: '',
        increaseButtonTitle: "Increase value",
        decreaseButtonTitle: "Decrease value",
        showIncreaseButton: true,
        showDecreaseButton: true
    };

    $.fn.tTextBox.defaults = {
        numeric: $.extend(commonDefaults, {
            minValue: -100,
            maxValue: 100
        }),
        currency: $.extend(commonDefaults, {
            minValue: 0,
            maxValue: 1000
        }),
        percent: $.extend(commonDefaults, {
            minValue: 0,
            maxValue: 100
        })
    };

    // * - placeholder for the symbol
    // n - placeholder for the number
    $.fn.tTextBox.patterns = {
        numeric: {
            negative: ['(n)', '-n', '- n', 'n-', 'n -']
        },
        currency: {
            positive: ['*n', 'n*', '* n', 'n *'],
            negative: ['(*n)', '-*n', '*-n', '*n-', '(n*)', '-n*', 'n-*', 'n*-', '-n *', '-* n', 'n *-', '* n-', '* -n', 'n- *', '(* n)', '(n *)']
        },
        percent: {
            positive: ['n *', 'n*', '*n'],
            negative: ['-n *', '-n*', '-*n']
        }
    };

    if (!$t.cultureInfo.numericnegative)
        $.extend($t.cultureInfo, { //default en-US settings
            currencydecimaldigits: 2,
            currencydecimalseparator: '.',
            currencygroupseparator: ',',
            currencygroupsize: 3,
            currencynegative: 0,
            currencypositive: 0,
            currencysymbol: '$',
            numericdecimaldigits: 2,
            numericdecimalseparator: '.',
            numericgroupseparator: ',',
            numericgroupsize: 3,
            numericnegative: 1,
            percentdecimaldigits: 2,
            percentdecimalseparator: '.',
            percentgroupseparator: ',',
            percentgroupsize: 3,
            percentnegative: 0,
            percentpositive: 0,
            percentsymbol: '%'
        });

    var customFormatRegEx = /[0#?]/;

    function reverse(str) {
        return str.split('').reverse().join('');
    }

    function injectInFormat(val, format, appendExtras) {
        var i = 0, j = 0,
            fLength = format.length,
            vLength = val.length,
            builder = new $t.stringBuilder();

        while (i < fLength && j < vLength && format.substring(i).search(customFormatRegEx) >= 0) {

            if (format.charAt(i).match(customFormatRegEx))
                builder.cat(val.charAt(j++));
            else
                builder.cat(format.charAt(i));

            i++;
        }

        builder.catIf(val.substring(j), j < vLength && appendExtras)
               .catIf(format.substring(i), i < fLength);

        var result = reverse(builder.string()),
            zeroIndex;

        if (result.indexOf('#') > -1)
            zeroIndex = result.indexOf('0');

        if (zeroIndex > -1) {
            var first = result.slice(0, zeroIndex),
                second = result.slice(zeroIndex, result.length);
            result = first.replace(/#/g, '') + second.replace(/#/g, '0');
        } else {
            result = result.replace(/#/g, '');
        }

        if (result.indexOf(',') == 0)
            result = result.replace(/,/g, '');

        return appendExtras ? result : reverse(result);
    }

    $t.textbox.formatNumber = function (number,
                                        format,
                                        digits,
                                        separator,
                                        groupSeparator,
                                        groupSize,
                                        positive,
                                        negative,
                                        symbol,
                                        isTextBox) {

        if (!format) return number;

        var type, customFormat, negativeFormat, zeroFormat, sign = number < 0;

        format = format.split(':');
        format = format.length > 1 ? format[1].replace('}', '') : format[0];

        var isCustomFormat = format.search(customFormatRegEx) != -1;

        if (isCustomFormat) {
            format = format.split(';');
            customFormat = format[0];
            negativeFormat = format[1];
            zeroFormat = format[2];
            format = (sign && negativeFormat ? negativeFormat : customFormat).indexOf('%') != -1 ? 'p' : 'n';
        }

        switch (format.toLowerCase()) {
            case 'd':
                return Math.round(number).toString();
            case 'c':
                type = 'currency'; break;
            case 'n':
                type = 'numeric'; break;
            case 'p':
                type = 'percent';
                if (!isTextBox) number = Math.abs(number) * 100;
                break;
            default:
                return number.toString();
        }

        var zeroPad = function (str, count, left) {
            for (var l = str.length; l < count; l++)
                str = left ? ('0' + str) : (str + '0');

            return str;
        }

        var addGroupSeparator = function (number, groupSeperator, groupSize) {
            if (groupSeparator && groupSize != 0) {
                var regExp = new RegExp('(-?[0-9]+)([0-9]{' + groupSize + '})');
                while (regExp.test(number)) {
                    number = number.replace(regExp, '$1' + groupSeperator + '$2');
                }
            }
            return number;
        }

        var cultureInfo = cultureInfo || $t.cultureInfo,
            patterns = $.fn.tTextBox.patterns,
            undefined;

        //define Number Formating info.
        digits = digits || digits === 0 ? digits : cultureInfo[type + 'decimaldigits'];
        separator = separator !== undefined ? separator : cultureInfo[type + 'decimalseparator'];
        groupSeparator = groupSeparator !== undefined ? groupSeparator : cultureInfo[type + 'groupseparator'];
        groupSize = groupSize || groupSize == 0 ? groupSize : cultureInfo[type + 'groupsize'];
        negative = negative || negative === 0 ? negative : cultureInfo[type + 'negative'];
        positive = positive || positive === 0 ? positive : cultureInfo[type + 'positive'];
        symbol = symbol || cultureInfo[type + 'symbol'];

        var exponent, left, right;

        if (isCustomFormat) {
            var splits = (sign && negativeFormat ? negativeFormat : customFormat).split('.'),
                leftF = splits[0],
                rightF = splits.length > 1 ? splits[1] : '',
                lastIndexZero = $t.lastIndexOf(rightF, '0'),
                lastIndexSharp = $t.lastIndexOf(rightF, '#');
            digits = (lastIndexSharp > lastIndexZero ? lastIndexSharp : lastIndexZero) + 1;
        }

        var factor = Math.pow(10, digits);
        var rounded = (Math.round(number * factor) / factor);
        number = isFinite(rounded) ? rounded : number;

        var split = number.toString().split(/e/i);
        exponent = split.length > 1 ? parseInt(split[1]) : 0;
        split = split[0].split('.');

        left = split[0];
        left = sign ? left.replace('-', '') : left;

        right = split.length > 1 ? split[1] : '';

        if (exponent) {
            if (!sign) {
                right = zeroPad(right, exponent, false);
                left += right.slice(0, exponent);
                right = right.substr(exponent);
            } else {
                left = zeroPad(left, exponent + 1, true);
                right = left.slice(exponent, left.length) + right;
                left = left.slice(0, exponent);
            }
        }

        var rightLength = right.length;
        if (digits < 1 || (isCustomFormat && lastIndexZero == -1 && rightLength === 0))
            right = ''
        else
            right = rightLength > digits ? right.slice(0, digits) : zeroPad(right, digits, false);

        var result;
        if (isCustomFormat) {
            if (left == 0) left = '';

            left = injectInFormat(reverse(left), reverse(leftF), true);
            left = leftF.indexOf(',') != -1 ? addGroupSeparator(left, groupSeparator, groupSize) : left;

            right = right && rightF ? injectInFormat(right, rightF) : '';

            result = number === 0 && zeroFormat ? zeroFormat
                : (sign && !negativeFormat ? '-' : '') + left + (right.length > 0 ? separator + right : '');

        } else {

            left = addGroupSeparator(left, groupSeparator, groupSize)
            patterns = patterns[type];
            var pattern = sign ? patterns['negative'][negative]
                        : symbol ? patterns['positive'][positive]
                        : null;

            var numberString = left + (right.length > 0 ? separator + right : '');

            result = pattern ? pattern.replace('n', numberString).replace('*', symbol) : numberString;
        }
        return result;
    }

    $.extend($t.formatters, {
        number: $t.textbox.formatNumber
    });
})(jQuery);



(function ($) {
    var $t = $.telerik;

    $t.reordering = {};

    $t.reordering.initialize = function (grid) {

        grid.$reorderDropCue = $('<div class="t-reorder-cue"><div class="t-icon t-arrow-down"></div><div class="t-icon t-arrow-up"></div></div>');

        var lastColumnIndex = grid.$header.children("th").length - 1;

        var reorderColumn = function (destIndex, column) {
            var sourceIndex = $.inArray(column, grid.columns);
            
            grid.columns.splice(sourceIndex, 1);
            
            grid.columns.splice(destIndex, 0, column);

            reorder(grid.$columns(), sourceIndex, destIndex);

            reorder(grid.$tbody.parent().find('> colgroup > col:not(.t-group-col,.t-hierarchy-col)'), sourceIndex, destIndex);
            
            reorder(grid.$headerWrap.find('table').find('> colgroup > col:not(.t-group-col,.t-hierarchy-col)'), sourceIndex, destIndex);

            var footerWrap = grid.$footer.find('table');
            reorder(footerWrap.find('> colgroup > col:not(.t-group-col,.t-hierarchy-col)'), sourceIndex, destIndex);            
            reorder(footerWrap.find('> tbody > tr.t-footer-template > td:not(.t-group-cell,.t-hierarchy-cell)')
                .add(grid.$footer.find('tr.t-footer-template > td:not(.t-group-cell,.t-hierarchy-cell)')), sourceIndex, destIndex);

            $.each(grid.$tbody.children(), function () {
                reorder($(this).find(' > td:not(.t-group-cell, .t-hierarchy-cell, .t-detail-cell)'), sourceIndex, destIndex);
            });
        }

        grid.reorderColumn = reorderColumn;

        function setLastColumnClass($source, sourceIndex, $dest, destIndex) {
            switchClasses($source, sourceIndex, $dest, destIndex, "th", "t-last-header");
            switchClasses($source, sourceIndex, $dest, destIndex, "td", "t-last");
        }

        function switchClasses($source, sourceIndex, $dest, destIndex, selector, className) {                

            if ($dest.is(selector) && destIndex == lastColumnIndex) {
                $source.addClass(className);
                $dest.removeClass(className);
            }

            if ($source.is(selector) && sourceIndex == lastColumnIndex) {                
                $source.removeClass(className)
                       .prev(selector)
                       .addClass(className);                
            }
        }

        function reorder(selector, sourceIndex, destIndex) {
            var $source = selector.eq(sourceIndex);
            var $dest = selector.eq(destIndex);

            setLastColumnClass($source, sourceIndex, $dest, destIndex);
            
            $source[sourceIndex > destIndex ? 'insertBefore' : 'insertAfter']($dest);
        }

        var onColumnReorder = function (grid) {
            var colOrders = {};
            for (var i = 0; i < grid.columns.length; i++) {
                var column = grid.columns[i];
                if (column.uniquename)
                    colOrders[column.uniquename] = i;
            }

            $.ajax({
                url: '/SDK.Action/GridSettings/SetColumnOrder',
                type: "POST",
                dataType: 'json',
                data: {
                        'gridId': $(grid.element).attr('id'),
                        'columnOrders': JSON.stringify(colOrders),
                        'provider': $(grid.element).attr('provider')
                },
                cache: false,
                success: function (data) {

                }
            });
        }

        new $t.draggable({
            owner: grid.$header,
            selector: '.t-header:not(.t-group-cell,.t-hierarchy-cell)',
            scope: grid.element.id + '-reodering',
            cue: function(e) {
                return $t.dragCue(e.$draggable.text());
            },
            destroy: function(e) {
                e.$cue.remove();
            }
        });

        new $t.droppable({
            owner: grid.$header,
            scope: grid.element.id + '-reodering',
            selector: '.t-header:not(.t-group-cell,.t-hierarchy-cell)',
            over: function(e) {
                var same = $.trim(e.$draggable.text()) == $.trim(e.$droppable.text());
                $t.dragCueStatus(e.$cue, same? 't-denied' : 't-add');
                
                var top = 0; 
                
                $('> .t-grid-top, > .t-grouping-header', grid.element).each(function() {
                    top += $(this).outerHeight();
                });
                
                if (!same)
                    grid.$reorderDropCue.css({
                         height: e.$droppable.outerHeight(),
                         top: top,
                         left: function() {
                                return e.$droppable.position().left + ((e.$droppable.index() > e.$draggable.index()) ? e.$droppable.outerWidth() : 0)
                            }
                         })
                         .appendTo(grid.element);
            },
            out: function(e) {
                grid.$reorderDropCue.remove();
                $t.dragCueStatus(e.$cue, 't-denied');
            },
            drop: function(e) {
                grid.$reorderDropCue.remove();
                if (e.$cue.find('.t-drag-status').is('.t-add')) {
                    var column = grid.columnFromTitle($.trim(e.$draggable.text()));
                    var position = grid.$columns().index(e.$droppable);                    
                    $t.trigger(grid.element, 'columnReorder', {
                        column: column,
                        oldIndex: $.inArray(column, grid.columns),
                        newIndex: position
                    });
                    reorderColumn(position, column);
                    onColumnReorder(grid);
                    //пересчитать положение grips
                    $t.resizing.initialize(grid);
                    $t.trigger(grid.element, 'repaint');
                }
            }
        });
    }
})(jQuery);



(function ($) {

    var $t = $.telerik;

    function getButtonHtml(type, titleText) {
        var builderHtml = new $t.stringBuilder();
        return builderHtml.cat('<span class="t-icon t-icon-')
                                      .cat(type)
                                      .cat('" ')
                                      .catIf('title="', titleText)
                                      .catIf(titleText, titleText)
                                      .cat('"></span>')
                                      .string();
    }

    $t.datetimepicker = function (element, options) {
        $.extend(this, options);

        if (element.nodeName.toLowerCase() !== "input" && element.type.toLowerCase() !== "text") {
            throw "Target element is not a INPUT";
        }

        this.element = element;
        var $element = this.$element = $(element)
                    .addClass('t-input')
                    .attr('autocomplete', 'off')
                    .bind({
                        keydown: $.proxy(this._keydown, this),
                        focus: $.proxy(function (e) {
                            this.$element.removeClass('t-state-error');
                        }, this)
                    });

        if (!$element.parent().hasClass('t-picker-wrap')) {

            $element.wrap('<div class="t-widget t-datetimepicker"><div class="t-picker-wrap"></div></div>');

            if (options.showCalendarButton || options.showTimeButton) {
                $(new $t.stringBuilder()
                    .cat('<span class="t-select">')
                    .catIf(getButtonHtml('calendar', options.calendarButtonTitle), options.showCalendarButton)
                    .cat(getButtonHtml('clock', options.timeButtonTitle), options.showTimeButton)
                    .cat('</span>')
                    .string())
                .insertAfter($element);
            }
        }

        this.$wrapper = $element.closest('.t-datetimepicker')
                    .find('.t-icon-clock')
                    .bind('click', this.enabled ? $.proxy(this._toggleTimeView, this) : $t.preventDefault)
                    .end()
                    .find('.t-icon-calendar')
                    .bind('click', this.enabled ? $.proxy(this._toggleDateView, this) : $t.preventDefault)
                    .end();

        this.timeView = new $t.timeView({
            effects: this.effects,
            dropDownAttr: this.dropDownAttr,
            format: this.timeFormat,
            interval: this.interval,
            isRtl: $element.closest('.t-rtl').length,
            minValue: this.startTimeValue,
            maxValue: this.endTimeValue,
            onNavigateWithOpenPopup: $.proxy(function (value) {
                var date = this.parse(value, this.timeFormat);
                this.$element.val($t.datetime.format(date, this.format));
            }, this),
            onChange: $.proxy(function (value) {
                this._update(this.parse(value, this.timeFormat));
                this._close('time');
            }, this)
        });

        this.dateView = new $t.dateView({
            selectedValue: this.selectedValue,
            minValue: this.minValue,
            maxValue: this.maxValue,
            effects: this.effects,
            isRtl: $element.closest('.t-rtl').length,
            onChange: $.proxy(function (value) {
                this._update(value);
                this._close('date');
            }, this)
        });

        this.inputValue = $element.val();
        var value = this.selectedValue || this.inputValue;
        if (value) {
            var parsedValue = this.parse(value);
            this.dateView.selectedValue = parsedValue; //should set it if dateView has never been open;
            this._value(this.parse(value));
        }

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var val = this.$element.val();
            if (val != this.inputValue) {
                this._update(val);
            }
            
            var $calendar = this.dateView.$calendar;
            if (!$calendar) return;

            var $dropDown = this.timeView.dropDown.$element;
            var isDropDown = $dropDown && $dropDown.parent().length > 0;
            var associatedDateView = $calendar.data('associatedDateView');

            var target = e.target;
            if ($.contains(this.$wrapper[0], target)
            || (associatedDateView && associatedDateView == this.dateView && $.contains($calendar[0], target))
            || (isDropDown && $.contains($dropDown.parent()[0], target)))
                return;

            this._close('date');
            this._close('time');

        }, this));

        $t.bind(this, {
            open: this.onOpen,
            close: this.onClose,
            valueChange: this.onChange,
            load: this.onLoad
        });
    }

    $t.datetimepicker.prototype = {
        _update: function (val) {
            val = this.parse(val);

            if (val != null) {
                if (val - this.minValue <= 0) {
                    val = this.minValue;
                }
                else if (val - this.maxValue >= 0) {
                    val = this.maxValue;
                }
            }

            var selectedValue = this.selectedValue,
                formattedSelectedValue = selectedValue ? $t.datetime.format(selectedValue, this.format) : '',
                formattedValue = val ? $t.datetime.format(val, this.format) : '';

            if (formattedValue != formattedSelectedValue) {
                var data = {
                    previousValue: selectedValue,
                    value: val
                };

                if ($t.trigger(this.element, 'valueChange', data)) {
                    val = new Date(selectedValue);
                }
            }

            this._value(val);
        },

        _value: function (value) {
            var text = this.$element.val();
            var isNull = value === null;
            var dateView = this.dateView;
            var associatedDateView = dateView.$calendar.data('associatedDateView');

            this.selectedValue = value;
            this.timeView.value(isNull ? null : $t.datetime.format(value, this.timeFormat));
            if (associatedDateView && associatedDateView == dateView)
                dateView.value(value);

            if (!isNull)
                text = $t.datetime.format(value, this.format);

            this.inputValue = text;
            this.$element.toggleClass('t-state-error', isNull && text != '')
                         .val(text);
        },

        _open: function (popup) {
            if (!this[popup == "time" ? 'timeView' : 'dateView'].isOpened())
                this._trigger(popup, 'open');
        },

        _close: function (popup) {
            var dateView = this.dateView;
            var dropDown = this.timeView.dropDown;

            if ((popup == "time" && !dropDown.$element.is(':animated') && dropDown.isOpened())
            || (!dateView.$calendar.is(':animated') && dateView.isOpened()))
                this._trigger(popup, 'close');
        },

        _trigger: function (popup, methodName) {
            if (!$t.trigger(this.element, methodName, { popup: popup }))
                this[methodName](popup)
        },

        _keydown: function (e) {
            var keyCode = e.keyCode,
                isDateViewOpened = this.dateView.isOpened();

            if (keyCode == 9 || keyCode == 27 || (keyCode == 13 && this.inputValue != this.$element.val())) {
                this._update(this.$element.val());
                this._close('date');
                this._close('time');
                return;
            }

            if (e.altKey) {
                if (keyCode == 40) {
                    this._close(isDateViewOpened ? 'date' : 'time');
                    this._open(isDateViewOpened ? 'time' : 'date');
                } else if (keyCode == 38) {
                    this._close(isDateViewOpened ? 'date' : 'time');
                }
                return;
            }

            if (isDateViewOpened) {
                this.dateView.navigate(e);
                return;
            }

            if (this.timeView.isOpened() && (keyCode === 38 || keyCode === 40)) {
                this.timeView.navigate(e);
                return;
            }
        },

        _toggleDateView: function () {
            if (this.dateView.isOpened()) {
                this._close('date')
            } else {
                this.element.focus();
                this._open('date')
                this._close('time')
            }
        },

        _toggleTimeView: function () {
            if (this.timeView.isOpened()) {
                this._close('time')
            } else {
                this.element.focus();
                this._open('time');
                this._close('date');
            }
        },

        enable: function () {
            this.$element.attr('disabled', false);
            this.$wrapper
                .removeClass('t-state-disabled')
                .find('.t-icon-clock')
                .unbind('click')
                .bind('click', $.proxy(this._toggleTimeView, this))
                .end()
                .find('.t-icon-calendar')
                .unbind('click')
                .bind('click', $.proxy(this._toggleDateView, this));
        },

        disable: function (e) {
            this.$element.attr('disabled', true);
            this.$wrapper
                .addClass('t-state-disabled')
                .find('.t-icon')
                .unbind('click')
                .bind('click', $t.preventDefault);
        },

        open: function (popup) {
            var $element = this.$element;
            var position = {
                offset: $element.offset(),
                outerHeight: $element.outerHeight(),
                outerWidth: $element.outerWidth(),
                zIndex: $t.getElementZIndex($element[0])
            }

            this[popup == "time" ? 'timeView' : 'dateView'].open(position);
        },

        close: function (popup) {
            this[popup == "time" ? 'timeView' : 'dateView'].close();
        },

        value: function (val) {
            if (val === undefined)
                return this.selectedValue;

            var parsedValue = this.parse(val);
            parsedValue = $t.datepicker.isInRange(parsedValue, this.minValue, this.maxValue) ? parsedValue : null;

            if (parsedValue === null)
                this.$element.removeClass('t-state-error').val('');

            this._value(parsedValue);

            return this;
        },

        parse: function (value, format) {
            if (value === null || value.getDate)
                return value;

            format = format || this.format;

            var result = $t.datetime.parse({
                AM: $t.cultureInfo.AM,
                PM: $t.cultureInfo.PM,
                value: value,
                format: format,
                baseDate: this.selectedValue ? new $t.datetime(this.selectedValue) : new $t.datetime()
            });

            return result != null ? result.toDate() : null;
        }
    }

    $.each(["min", "max"], $.proxy(function (index, method) {
        $t.datetimepicker.prototype[method] =
        function (value) {
            var propertyName = method + 'Value';
            if (value === undefined)
                return this[propertyName];

            var parsedValue = this.parse(value);

            if (parsedValue !== null) {
                var oldValue = this[propertyName];
                this[propertyName] = parsedValue;

                if (this.minValue > this.maxValue) {
                    this[propertyName] = oldValue;
                    return;
                }

                this.dateView[method](parsedValue);
                if (!$t.datepicker.isInRange(this.selectedValue, this.minValue, this.maxValue))
                    this.value(parsedValue);
            }
        };
    }, this));

    $.each(["startTime", "endTime"], $.proxy(function (index, method) {
        $t.datetimepicker.prototype[method] =
            function (value) {
                var propertyName = method + 'Value';
                if (value === undefined)
                    return this[propertyName];

                var parsedValue = this.parse(value, $t.cultureInfo.shortTime);
                if (parsedValue !== null) {
                    this[propertyName] = parsedValue;
                    method == 'startTime' ? this.timeView.min(parsedValue) : this.timeView.max(parsedValue)
                    if (!$t.timeView.isInRange(this.selectedValue, this.minValue, this.maxValue))
                        this.value(parsedValue);
                }
            };
    }, this));

    $.fn.tDateTimePicker = function (options) {
        $.fn.tDateTimePicker.defaults.timeFormat = $t.cultureInfo.shortTime;

        return $t.create(this, {
            name: 'tDateTimePicker',
            init: function (element, options) {
                return new $t.datetimepicker(element, options);
            },
            options: options
        });
    };

    $.fn.tDateTimePicker.defaults = {
        effects: $t.fx.slide.defaults(),
        selectedValue: null,
        format: $t.cultureInfo.generalDateShortTime,
        focusedDate: new $t.datetime(),
        minValue: new Date(1899, 11, 31),
        maxValue: new Date(2100, 0, 1),
        startTimeValue: new $t.datetime().hours(0).minutes(0).seconds(0).toDate(),
        endTimeValue: new $t.datetime().hours(0).minutes(0).seconds(0).toDate(),
        calendarButtonTitle: "Open the calendar",
        timeButtonTitle: "Open the time view",
        showCalendarButton: true,
        showTimeButton: true,
        shortYearCutOff: 30,
        enabled: true,
        interval: 30
    };

})(jQuery);


(function ($) {

    var $t = $.telerik;

    var sharedCalendar = null;

    $t.datetime.parseByToken = function (value, today) {
        if (value === null || value === '') return null;

        today = today || new $t.datetime(); // required for unit tests
        var firstToken = null;
        var secondToken = null;
        var tokenType = null;
        var pos = 0;

        var Matches = function (name) {
            var token = null;
            if (name && value.substring(pos, pos + name.length).toLowerCase() == name.toLowerCase()) {
                token = name;
            }
            return token;
        }

        var searchForDayMonth = function () {
            var token = null;
            $.each(['days', 'abbrDays', 'months', 'abbrMonths'], function (index, key) {
                if (token !== null) return;

                $.each($t.cultureInfo[key], function (index, name) {
                    if (token !== null) return;
                    token = Matches(name);
                });

                tokenType = key;
            });
            return token;
        }

        var adjustDate = function () {
            var gap;
            var modifyDate = function (mod, isday) {
                today[isday ? 'date' : 'month']
                    (today[isday ? 'date' : 'month']()
                     + (gap != 0 ? ((gap + ((gap > 0 ? 1 : -1) * mod)) % mod) : 0)
                        + (secondToken ?
                            (firstToken == $t.cultureInfo['next'] ? 1 : -1) * mod : 0));
            }
            var arrayPosition = $.inArray(secondToken || firstToken, $t.cultureInfo[tokenType]);
            if (tokenType.toLowerCase().indexOf('day') > -1) {
                gap = (arrayPosition == 0 ? 7 : arrayPosition) - today.day();
                modifyDate(7, true)
            } else {
                gap = arrayPosition - today.month();
                modifyDate(12, false)
            }
        }

        var adjustDateBySecondToken = function () {
            var gapDiff = function (possition) {
                var gap;
                switch (secondToken) {
                    case 'year': gap = possition == 1 ? 1 : 0; break;
                    case 'month': gap = possition == 2 ? 1 : 0; break;
                    case 'week': gap = possition == 3 ? 7 : 0; break;
                    case 'day': gap = possition == 3 ? 1 : 0; break;
                }
                return gap;
            }
            var direction = (firstToken == $t.cultureInfo['next'] ? 1 : -1);
            today.year(
                    today.year() + gapDiff(1) * direction,
                    today.month() + gapDiff(2) * direction,
                    today.date() + gapDiff(3) * direction
                );
        }

        // search for first token
        $.each(['today', 'tomorrow', 'yesterday', 'next', 'last'], function (index, name) {
            if (firstToken !== null) return;
            firstToken = Matches($t.cultureInfo[name]);
        })

        if (firstToken !== null) {
            pos += firstToken.length;

            if (/[^\s\d]\s+[^\s\d]/i.test(value)) {
                pos++;
                $.each(['year', 'month', 'week', 'day'], function (index, name) {
                    if (secondToken !== null) return;
                    secondToken = Matches($t.cultureInfo[name]);
                })
                tokenType = null;

                if (secondToken === null) {
                    secondToken = searchForDayMonth();
                }
                if (secondToken === null)
                    return null; // invalid date.
            } else {
                switch (firstToken) {
                    case $t.cultureInfo['today']: break;
                    case $t.cultureInfo['tomorrow']:
                        today.date(today.date() + 1);
                        break;
                    case $t.cultureInfo['yesterday']:
                        today.date(today.date() - 1);
                        break;
                    default:
                        today = null; // incorrect token
                        break;
                }

                return today;
            }

        } else {
            firstToken = searchForDayMonth();
            if (firstToken != null) {
                adjustDate();
                return today;
            } else {
                return null;
            }
        }

        // first and second tokens are not null
        if (tokenType !== null)
            adjustDate();
        else // second token is year, month, week, day
            adjustDateBySecondToken();

        return today;
    };

    function defineFocusedDate(focusedValue, selectedValue, minValue, maxValue) {
        if (selectedValue) {
            focusedValue = new Date(selectedValue);
        }

        if (minValue > focusedValue) {
            focusedValue = new Date(minValue);
        } else if (maxValue < focusedValue) {
            focusedValue = new Date(maxValue);
        }

        return focusedValue;
    }

    /*
    options.minValue
    options.maxValue
    options.selectedValue
    options.effects
    options.onChange
    options.isRtl
    options.zIndex
    */

    $t.dateView = function (options) {
        $.extend(this, options);
        this.isValueChanged = false;

        this.focusedValue = defineFocusedDate(new Date(), this.selectedValue, this.minValue, this.maxValue);

        this.$calendar = this._createSharedCalendar();
    }

    $t.dateView.prototype = {
        _createSharedCalendar: function () {
            if (!sharedCalendar) {
                sharedCalendar = $($t.calendar.html(new $t.datetime(this.focusedValue), this.selectedValue ? new $t.datetime(this.selectedValue) : null, new $t.datetime(this.minValue), new $t.datetime(this.maxValue)))
                                .hide()
                                .addClass('t-datepicker-calendar')
                                .bind('click', function (e) { e.stopPropagation(); })
                                .appendTo(document.body)
                                .tCalendar({
                                    selectedValue: this.selectedValue,
                                    minDate: this.minValue,
                                    maxDate: this.maxValue
                                });

                $t.fx._wrap(sharedCalendar).css('display', 'none');

                if ($.browser.msie && $.browser.version <= 6)
                    $('<iframe class="t-iframe-overlay" src="javascript:false;"></iframe>')
                        .prependTo(sharedCalendar)
                        .height(sharedCalendar.height());
            }

            return sharedCalendar;
        },

        _getCalendar: function () {
            return sharedCalendar.data('tCalendar');
        },

        _reassignSharedCalendar: function () {
            var calendar = this._getCalendar();

            if (sharedCalendar.data('associatedDateView') != this) {
                sharedCalendar.stop(true, true);

                this.focusedValue = defineFocusedDate(this.focusedValue, this.selectedValue, this.minValue, this.maxValue);

                calendar.minDate = this.minValue;
                calendar.maxDate = this.maxValue;
                calendar.selectedValue = this.selectedValue;
                calendar.goToView(0, this.focusedValue);

                sharedCalendar
                    .unbind('change')
                    .bind('change', $.proxy(function (e) {
                        var selectedValue = this.selectedValue;
                        var newValue = new $t.datetime(e.date);
                        if (selectedValue !== null)
                            newValue.hours(selectedValue.getHours())
                                    .minutes(selectedValue.getMinutes())
                                    .seconds(selectedValue.getSeconds())
                                    .milliseconds(selectedValue.getMilliseconds());
                        this.onChange(newValue.toDate());
                    }, this))
                    .unbind('navigate')
                    .bind('navigate', $.proxy(function (e) {
                        var focusedValue = this.focusedValue;
                        var viewedMonth = calendar.viewedMonth;
                        var viewIndex = calendar.currentView.index;

                        focusedValue.setFullYear(viewedMonth.year(), viewedMonth.month(), focusedValue.getDate());

                        $t.calendar.focusDate(focusedValue, viewIndex, sharedCalendar, e.direction);
                    }, this))
                    .data('associatedDateView', this);

                $('.b-today', sharedCalendar).unbind('click').bind('click', $.proxy(function (e) {
                    this.onChange(new Date());
                }, this));
                if (this.selectedValue)
                    calendar.value(this.selectedValue);

                $t.calendar.focusDate(this.focusedValue, calendar.currentView.index, sharedCalendar);
            }
        },

        open: function (position) {
            if (this.isOpened())
                return;

            this._reassignSharedCalendar();

            var isRtl = this.isRtl;
            var $calendar = this.$calendar;

            // reposition & rewire the shared calendar
            elementPosition = position.offset;
            elementPosition.top += position.outerHeight + 7;
            elementPosition.left -= 1;

            if (isRtl)
                elementPosition.left -= (sharedCalendar.outerWidth() || sharedCalendar.parent().outerWidth()) - position.outerWidth;

            $t.fx._wrap(sharedCalendar).css($.extend({
                position: 'absolute',
                direction: isRtl ? 'rtl' : '',
                display: sharedCalendar.is(':visible') ? '' : 'none'
            }, elementPosition));

            var calendar = this._getCalendar();
            var viewIndex = calendar.currentView.index;

            if (!sharedCalendar.is(':visible') && calendar.viewedMonth.value - this.focusedValue != 0) {
                calendar.goToView(viewIndex, this.focusedValue)
                        .value(this.selectedValue);
            }
            if (this.minValue > new Date()) {
                $('.b-today', sharedCalendar).attr('disabled', 'disabled');
            } else {
                $('.b-today', sharedCalendar).removeAttr('disabled');
            }

            $t.calendar.focusDate(this.focusedValue, calendar.currentView.index, sharedCalendar);

            $t.fx._wrap($calendar).css('zIndex', position.zIndex).show();

            $t.fx.play(this.effects, $calendar, { direction: 'bottom' });
        },

        close: function () {
            if (this.isOpened())
                $t.fx.rewind(this.effects, this.$calendar, { direction: 'bottom' }, function () {
                    if (sharedCalendar)
                        $t.fx._wrap(sharedCalendar).hide();
                });
        },

        isOpened: function () {
            return sharedCalendar && sharedCalendar.data('associatedDateView') == this && sharedCalendar.is(':visible');
        },

        value: function (value) {
            if (value === undefined)
                return this.selectedValue;

            var isNull = value === null;
            var calendar = this._getCalendar();

            //set selected date
            if (!isNull)
                value = value.value ? new Date(value.value) : value;

            calendar.value(value);
            this.selectedValue = value;

            //update focused date;
            if (isNull)
                value = new Date();

            this.focusedValue = new Date(value);
            $t.calendar.focusDate(value, calendar.currentView.index, sharedCalendar);
        },

        navigate: function (e) {
            if (this.isOpened() && $('.t-overlay', sharedCalendar).length > 0)
                return;

            var isFuture;
            var isNavProcessed = false;
            var $calendar = this.$calendar;
            var calendar = this._getCalendar();
            var viewedMonth = calendar.viewedMonth;
            var currentView = calendar.currentView;
            var viewIndex = currentView.index;
            var date = new $t.datetime(this.focusedValue);

            var navigate = function (className, method, futureNav) {
                if (!$(className, $calendar).hasClass('t-state-disabled')) {
                    if ('navigateUp' == method) viewIndex += 1;
                    isFuture = futureNav || false;
                    calendar[method]();
                    return true;
                }
                else return false;
            }

            var navigateDown = function () {
                var target = $t.calendar.findTarget(date, viewIndex, $calendar, false)[0];
                calendar.navigateDown(e, target, viewIndex);
                viewIndex = viewIndex == 0 ? 0 : viewIndex - 1;
                isFuture = true;
            }

            var navPrevNext = function (className, method, futureNav) {
                var diff = !futureNav ? -1 : 1;
                if (!navigate(className, method, futureNav)) return false;
                if (viewIndex == 0)
                    date.addMonth(diff);
                else
                    date.addYear(diff * (viewIndex == 1 ? 1 : viewIndex == 2 ? 10 : 100));
                return true;
            }

            var adjustDate = $t.datepicker.adjustDate;

            if ($calendar.is(':visible') && !e.shiftKey) {
                isNavProcessed = true;
                switch (e.keyCode) {
                    case 37: // left arrow
                        if (e.ctrlKey) {
                            if (!navPrevNext('.t-nav-prev', 'navigateToPast')) return;
                        } else {
                            adjustDate(viewIndex, date, -1, -1); // date modified by reference
                            if (currentView.navCheck(date, viewedMonth, false))
                                if (!navigate('.t-nav-prev', 'navigateToPast')) return;
                        }
                        break;
                    case 38: // up arrow
                        if (e.ctrlKey) {
                            navigate('.t-nav-fast', 'navigateUp');
                        } else {
                            adjustDate(viewIndex, date, -7, -4); // date modified by reference
                            if (currentView.navCheck(date, viewedMonth, false))
                                if (!navigate('.t-nav-prev', 'navigateToPast')) return;
                        }
                        break;
                    case 39: // right arrow
                        if (e.ctrlKey) {
                            if (!navPrevNext('.t-nav-next', 'navigateToFuture', true)) return;
                        } else {
                            adjustDate(viewIndex, date, 1, 1); // date modified by reference
                            if (currentView.navCheck(date, viewedMonth, true))
                                if (!navigate('.t-nav-next', 'navigateToFuture', true)) return;
                        }
                        break;
                    case 40: //down arrow
                        if (e.ctrlKey) {
                            navigateDown();
                        } else {
                            adjustDate(viewIndex, date, 7, 4); // date modified by reference
                            if (currentView.navCheck(date, viewedMonth, true))
                                if (!navigate('.t-nav-next', 'navigateToFuture', true)) return;
                        }
                        break;
                    case 32: // space
                        if ($('.b-today', sharedCalendar).is(':visible') && !$('.b-today', sharedCalendar).attr('disabled'))
                            this.onChange(new Date());
                        break;
                    case 33: // page up
                        if (!navPrevNext('.t-nav-prev', 'navigateToPast')) return;
                        break;
                    case 34: //page down
                        if (!navPrevNext('.t-nav-next', 'navigateToFuture', true)) return;
                        break;
                    case 35: //end
                        date = $t.calendar.views[viewIndex].firstLastDay(date, false, calendar);
                        break;
                    case 36: //home
                        date = $t.calendar.views[viewIndex].firstLastDay(date, true, calendar);
                        break;
                    case 13: // enter
                        e.stopPropagation();

                        if (viewIndex == 0)
                            this.onChange(this.focusedValue);
                        else
                            navigateDown();
                        break;
                    default:
                        isNavProcessed = false;
                        break;
                }
            }

            if (isNavProcessed) {
                e.preventDefault();
                date = $t.calendar.fitDateToRange(date, new $t.datetime(this.minValue), new $t.datetime(this.maxValue));

                $t.calendar.focusDate(date.toDate(), viewIndex, $calendar, isFuture);
                this.focusedValue = date.toDate();
            }
        }
    }

    $.each(['min', 'max'], $.proxy(function (index, method) {
        $t.dateView.prototype[method] =
            function (value) {
                var propertyName = method + 'Value';
                if (value === undefined)
                    return this[propertyName];

                this[propertyName] = new Date(value.value ? value.value : value);
                sharedCalendar.data("associatedDateView", null);
                this._reassignSharedCalendar();
            };
    }, this));

    $t.datepicker = function (element, options) {
        $.extend(this, options);

        if (element.nodeName.toLowerCase() !== "input" && element.type.toLowerCase() !== "text") {
            throw "Target element is not a INPUT";
        }

        this.element = element;
        var $element = this.$element = $(element)
                    .addClass('t-input')
                    .attr('autocomplete', 'off')
                    .bind({
                        keydown: $.proxy(this._keydown, this),
                        focus: $.proxy(function (e) {
                            if (this.openOnFocus) {
                                this._open();
                            }
                            this.$element.removeClass('t-state-error');
                        }, this)
                    }); ;

        if (!$element.parent().hasClass('t-picker-wrap')) {

            $element.wrap('<div class="t-widget t-datepicker"><div class="t-picker-wrap"></div></div>');

            if (options.showButton) {
                var builder = new $t.stringBuilder(),
                    title = options.buttonTitle;

                $(builder
                    .cat('<span class="t-select">')
                    .cat('<span class="t-icon t-icon-calendar" ')
                    .catIf('title="', title)
                    .catIf(title, title)
                    .cat('"></span></span>')
                    .string())
                .insertAfter($element);
            }
        }

        this.dateView = new $t.dateView({
            selectedValue: this.selectedValue,
            minValue: this.minValue,
            maxValue: this.maxValue,
            effects: this.effects,
            isRtl: $element.closest('.t-rtl').length,
            onChange: $.proxy(function (value) {
                this._update(value);
                this._close();
            }, this)
        });

        this.inputValue = $element.val();
        var value = this.selectedValue || this.inputValue;
        if (value) {
            this._value(this.parse(value));
        }

        var clickHandler = this.enabled
                         ? $.proxy(this._togglePopup, this)
                         : $t.preventDefault;

        this.$wrapper = $element.closest('.t-datepicker')
            .find('.t-icon')
            .bind('click', clickHandler)
            .end();

        // Focus & hover
        applyInputBorders(this.$element, this.$wrapper.find('> .t-picker-wrap'));

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var val = this.$element.val();
            if (val.indexOf("_") != -1)
                val = '';

            if (val != this.inputValue) {
                this._update(val);
            }

            if (!sharedCalendar) return;

            var associatedDateView = sharedCalendar.data('associatedDateView');
            if (!associatedDateView || associatedDateView != this.dateView) {
                return;
            }

            if (!$.contains(this.$wrapper[0], e.target) && !$.contains(sharedCalendar[0], e.target)) {
                this._close();
            }
        }, this));

        $t.bind(this, {
            open: this.onOpen,
            close: this.onClose,
            valueChange: this.onChange,
            load: this.onLoad
        });
    }

    $t.datepicker.prototype = {
        _togglePopup: function () {
            if (this.dateView.isOpened()) {
                this._close();
            } else {
                this.element.focus();
                this._open();
            }
        },

        _close: function () {
            if (!sharedCalendar.is(':animated') && this.dateView.isOpened())
                this._trigger('close');
        },

        _open: function () {
            if (!this.dateView.isOpened())
                this._trigger('open');
        },

        _trigger: function (methodName) {
            if (!$t.trigger(this.element, methodName))
                this[methodName]();
        },

        _update: function (val) {
            parseVal = this.parse(val); // || this.selectedValue;
            if (val != undefined && val != null && val != '' && parseVal == null) {
                val = this.selectedValue;
            } else {
                val = parseVal;
            }

            if (val != null) {
                if (val - this.minValue <= 0) {
                    val = this.minValue;
                }
                else if (val - this.maxValue >= 0) {
                    val = this.maxValue;
                }
            }

            var selectedValue = this.selectedValue,
                formattedSelectedValue = selectedValue ? $t.datetime.format(selectedValue, this.format) : '',
                formattedValue = val ? $t.datetime.format(val, this.format) : '';

            if (formattedValue != formattedSelectedValue) {
                var data = {
                    previousValue: selectedValue,
                    value: val,
                    previousDate: selectedValue,
                    date: val
                };

                if ($t.trigger(this.element, 'valueChange', data)) {
                    val = new Date(selectedValue);
                }
            }

            this._value(val);

            if (formattedValue != formattedSelectedValue) {
                $(this.element).trigger('afterChange', { previousValue: selectedValue, value: val, formattedValue: formattedValue });
            }
        },

        _keydown: function (e) {
            var keyCode = e.keyCode;

            if (keyCode == 9 || (keyCode == 13 && this.inputValue != this.$element.val())) {
                this._update(this.$element.val());
                this._close();
            } else if (keyCode == 27) {
                this._close();
            } else if (e.altKey) {
                if (keyCode == 40) {
                    this._open();
                } else if (keyCode == 38) {
                    this._close();
                }
            } else {
                this.dateView.navigate(e);
            }
        },

        enable: function () {
            this.$element.attr('disabled', false);
            this.$wrapper
                .removeClass('t-state-disabled')
                .find('.t-icon')
                .unbind('click')
                .bind('click', $.proxy(this._togglePopup, this));
        },

        disable: function (e) {
            this.$element.attr('disabled', true);
            this.$wrapper
                .addClass('t-state-disabled')
                .find('.t-icon')
                .unbind('click')
                .bind('click', $t.preventDefault);
        },

        _value: function (value) {
            var text = this.$element.val();
            if (text.indexOf("_") != -1 || this.parse(text) == null)
                text = '';
            var isNull = value === null;

            this.selectedValue = value;

            this.dateView.value(value);

            if (!isNull) {
                text = $t.datetime.format(value, this.format);
            }

            this.inputValue = text;
            this.$element.toggleClass('t-state-error', isNull && text != '')
                         .val(text);
        },

        value: function (val) {
            if (val === undefined)
                return this.selectedValue;

            var parsedValue = this.parse(val);
            parsedValue = $t.datepicker.isInRange(parsedValue, this.minValue, this.maxValue) ? parsedValue : null;

            if (parsedValue === null) {
                this.$element.removeClass('t-state-error').val('');
            }

            this._value(parsedValue);

            return this;
        },

        //obsolete
        showPopup: function () {
            this.open();
        },

        //obsolete
        hidePopup: function () {
            this.close();
        },

        open: function () {
            var $element = this.$element;

            this.dateView.open({
                offset: $element.offset(),
                outerHeight: $element.outerHeight(),
                outerWidth: $element.outerWidth(),
                zIndex: $t.getElementZIndex($element[0])
            });
        },

        close: function () {
            this.dateView.close();
        },

        parse: function (value, format) {
            if (value === null || value.getDate)
                return value;

            var result = $t.datetime.parse({
                value: value,
                format: format || this.format,
                shortYearCutOff: this.shortYearCutOff
            });
            return result != null ? result.toDate() : null;

        }
    }

    $.each(["min", "max"], $.proxy(function (index, method) {
        $t.datepicker.prototype[method] =
        function (value) {
            var propertyName = method + 'Value';
            if (value === undefined)
                return this[propertyName];

            var parsedValue = this.parse(value);

            if (parsedValue !== null) {
                var oldValue = this[propertyName];
                this[propertyName] = parsedValue;

                if (this.minValue > this.maxValue) {
                    this[propertyName] = oldValue;
                    return;
                }

                this.dateView[method](parsedValue);
                if (!$t.datepicker.isInRange(this.selectedValue, this.minValue, this.maxValue))
                    this.value(parsedValue);
            }
        };
    }, this));

    $.extend($t.datepicker, {
        adjustDate: function (viewIndex, date, monthValue, otherViewValue) {
            if (viewIndex == 0)
                $t.datetime.modify(date, $t.datetime.msPerDay * monthValue);
            else if (viewIndex == 1)
                date.addMonth(otherViewValue);
            else
                date.addYear((viewIndex == 2 ? otherViewValue : 10 * otherViewValue));
        },

        isInRange: function (date, minDate, maxDate) {
            if (!date) return false;
            return minDate - date <= 0 && maxDate - date >= 0;
        }
    });

    $.fn.tDatePicker = function (options) {
        return $t.create(this, {
            name: 'tDatePicker',
            init: function (element, options) {
                return new $t.datepicker(element, options);
            },
            options: options
        });
    };

    $.fn.tDatePicker.defaults = {
        effects: $t.fx.slide.defaults(),
        selectedValue: null,
        format: $t.cultureInfo.shortDate,
        minValue: new Date(1899, 11, 31),
        maxValue: new Date(2100, 0, 1),
        shortYearCutOff: 30,
        showButton: true,
        buttonTitle: 'Open the calendar',
        enabled: true,
        openOnFocus: false
    };

})(jQuery);



(function ($) {

    var $t = $.telerik;

    $t.autocomplete = function (element, options) {
        $.extend(this, options);

        var pasteMethod = $.browser.msie ? 'paste' : 'input';
        var $element = this.$element = $(element)
                                    .addClass('t-widget t-autocomplete t-input')
                                    .attr('autocomplete', 'off')
                                    .bind(pasteMethod, $.proxy(function (e) {
                                        resetTimer(this);
                                    }, this));

        this.$text = $element;
        this.element = element;
        this.trigger = new $t.list.trigger(this);
        this.trigger.change = function () {
            var text = this.component.text();
            var previousValue = this.component.previousValue;

            if (previousValue == undefined || text != previousValue)
                $t.trigger(this.component.element, 'valueChange', { value: text });

            this.component.previousValue = text;
        }

        this.loader = new $t.list.loader(this);
        this.loader.showBusy = function () {
            this.busyTimeout = setTimeout($.proxy(function () {
                this.component.$element.addClass('t-loading');
            }, this), 100);
        }
        this.loader.hideBusy = function () {
            clearTimeout(this.busyTimeout);
            this.component.$element.removeClass('t-loading');
        }

        this.filtering = new $t.list.filtering(this);
        this.filtering.autoFill = function (component, itemText) {
            if (component.autoFill && (component.lastKeyCode != 8 && component.lastKeyCode != 46)) {

                var input = component.$text[0];
                var textBoxValue = input.value;
                var separator = component.separator;

                var endIndex = $t.caretPos(input);

                var lastSeparatorIndex = separator ? $t.lastIndexOf(textBoxValue.substring(0, endIndex), separator) : -1;

                var startIndex = lastSeparatorIndex != -1 ? lastSeparatorIndex + separator.length : 0;

                var filterString = textBoxValue.substring(startIndex, endIndex);

                var matchIndex = itemText.toLowerCase().indexOf(filterString.toLowerCase());

                if (matchIndex != -1) {

                    var stringToAppend = itemText.substring(matchIndex + filterString.length);
                    var wordIndex = valueArrayIndex(input, separator);
                    var split = textBoxValue.split(separator);
                    split[wordIndex] = filterString + stringToAppend;
                    input.value = split.join(separator) + (component.multiple && wordIndex != 0 && wordIndex == split.length - 1 ? separator : '');

                    $t.list.selection(input, endIndex, endIndex + stringToAppend.length);
                }
            }
        }
        this.filtering.multiple = $.proxy(function (text) {
            if (this.multiple) {
                text = text.split(this.separator);
                text = text[valueArrayIndex(this.$text[0], this.separator)];
            }
            return text;
        }, this);

        this.dropDown = new $t.dropDown({
            outerHeight: $element.outerHeight(),
            outerWidth: $element.outerWidth(),
            zIndex: $t.list.getZIndex($element),
            attr: this.dropDownAttr,
            effects: this.effects,
            onOpen: $.proxy(function () {
                var dropDown = this.dropDown;
                var offset = $element.offset();

                dropDown.zIndex = $t.list.getZIndex($element);

                dropDown.position(offset.top, offset.left);
                if (!dropDown.outerHeight) dropDown.outerHeight = $element.outerHeight();
                if (!dropDown.outerWidth && dropDown.$element[0].style.width == '0px') {
                    dropDown.outerWidth = $element.outerWidth();
                    dropDown.$element.css('width', dropDown.outerWidth - 2);
                }
                return true;
            }, this),
            onClick: $.proxy(function (e) {
                this.select(e.item);
                this.trigger.change();
                this.trigger.close();
            }, this)
        });
        this.extendData = null;
        this.fill = function (callback) {
            function highlightItem(component) {
                var $item = component.highlightFirst ? dropDown.$items.first() : null;
                if ($item) $item.addClass('t-state-selected');
            }

            var loader = this.loader;
            var dropDown = this.dropDown;
            var minChars = this.minChars;
            var textValue = this.text();
            var textValueLength = textValue.length;

            if (!dropDown.$items && !loader.ajaxError) {
                if (loader.isAjax() && textValueLength >= minChars) {

                    var postData = this.extendData || {};
                    postData[this.queryString.text] = textValue;

                    loader.ajaxRequest(function (data) {
                        this.dataBind(data);
                        highlightItem(this);

                        $t.trigger(this.element, 'dataBound');
                        this.trigger.change();

                        if (callback) callback();
                    },
                    { data: postData });
                }
                else {
                    this.dataBind(this.data);
                    highlightItem(this);
                    if (callback) callback();
                }
            }
        }

        this.text = function (text) {
            return this.$text.val(text);
        }

        this.value = function () {
            return this.text.apply(this, arguments);
        }

        this.select = function (item) {

            var index = this.highlight(item);

            if (index == -1) return index;

            var filteredDataIndexes = this.filteredDataIndexes;
            var itemIndex = (filteredDataIndexes && filteredDataIndexes.length) > 0 ? filteredDataIndexes[index] : index;

            var item = this.data[itemIndex];
            var dataText = item.Text ? item.Text : item;
            var value = dataText;

            if (this.multiple) {

                var $element = this.$element
                var separator = this.separator;
                var wordIndex = valueArrayIndex($element[0], separator);

                value = $element.val().split(separator);
                value[wordIndex] = dataText;
                value = value.join(separator) + (wordIndex == value.length - 1 ? separator : '');
            }

            this.$text.val(value);
        }

        $t.list.common.call(this);
        $t.list.filters.call(this);
        $t.list.initialize.call(this);

        $element
            .bind({
                focus: $.proxy(function (e) { e.stopPropagation(); }, this),
                keydown: $.proxy(keydown, this),
                keypress: $.proxy(function (e) {
                    var key = e.keyCode || e.charCode;

                    if (key == 0 || $.inArray(key, $t.list.keycodes) != -1 || e.ctrlKey) return true;

                    resetTimer(this); //reset and start filtering after delay

                }, this)
            });

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var $parent = this.dropDown.$element.parent();
            var parentLength = $parent.length;

            if ((!parentLength && element !== e.target) || (parentLength && !$.contains(element, e.target) && !$.contains($parent[0], e.target))) {
                this.trigger.change();
                this.trigger.close();
            }
        }, this));

        //PRIVATE
        function valueArrayIndex(input, separator) {
            return input.value.substring(0, $t.caretPos(input)).split(separator).length - 1;
        }

        function resetTimer(component) {
            clearTimeout(component.timeout);
            component.timeout = setTimeout(function () { component.filtering.filter(component) }, component.delay);
        }

        function keydown(e) {
            var trigger = this.trigger;
            var dropDown = this.dropDown;
            var key = e.keyCode || e.which;
            this.lastKeyCode = key;

            if (!e.shiftKey && key > 36 && key < 41 && key != 37 && key != 39) {

                e.preventDefault();

                if (dropDown.isOpened()) {

                    if (!dropDown.$items) this.fill();

                    var $items = dropDown.$items;

                    var $selectedItem = $items.filter('.t-state-selected:first');

                    var $item = [];

                    if (key == 38) {
                        var prevItem = $selectedItem.prev();
                        $item = prevItem.length ? prevItem : $items.last();
                    } else if (key == 40) {
                        var nextItem = $selectedItem.next();
                        $item = nextItem.length ? nextItem : $items.first();
                    }

                    if ($item.length) {
                        var item = $item[0];

                        this.highlight(item);
                        dropDown.scrollTo(item);

                        this.filtering.autoFill(this, $item.text());
                    }
                }
            }

            if (key == 8 || key == 46) {
                var $element = this.$element;

                if ($element.val() != '') resetTimer(this); //reset and start filtering after delay

                setTimeout($.proxy(function () {
                    if ($element.val() == '') {
                        trigger.close();
                    }
                }, this), 0);
            }

            if (key == 13) {

                if (dropDown.isOpened()) e.preventDefault();

                if (dropDown.$items) {
                    var $selectedItems = dropDown.$items.filter('.t-state-selected:first');

                    if ($selectedItems.length > 0) {
                        this.select($selectedItems[0]);
                    }
                }
                trigger.change();
                trigger.close();
                $t.list.moveToEnd(this.element);
            }

            if (key == 27 || key == 9) {
                trigger.change();
                trigger.close();
            }
        }
    }

    // jQuery extender
    $.fn.tAutoComplete = function (options) {
        return $t.create(this, {
            name: 'tAutoComplete',
            init: function (element, options) {
                return new $t.autocomplete(element, options)
            },
            options: options
        });
    };

    // default options
    $.fn.tAutoComplete.defaults = {
        encoded: true,
        effects: $t.fx.slide.defaults(),
        filter: 1,
        delay: 200,
        minChars: 1,
        cache: true,
        autoFill: false,
        highlightFirst: false,
        queryString: {
            text: 'text'
        },
        multiple: false,
        separator: ', '
    };
})(jQuery);



/*Copyright(c)2009,www.supersite.me*/
var imageUrl = '/Modules/EleWise.ELMA.CRM.Web/Content/Images/color.png';

function iColorShow(id, id2) {
    var eICP = jQuery("#" + id2).offset();
    if ($("#"+id).attr('readonly') != 'readonly') {
        jQuery("#iColorPicker").css({ 'top': eICP.top + (jQuery("#" + id).outerHeight()) + "px", 'left': (eICP.left) + "px", 'position': 'absolute' }).fadeIn("fast");
    }
    jQuery("#iColorPickerBg").css({ 'position': 'fixed', 'top': 0, 'left': 0, 'width': '100%', 'height': '100%' }).fadeIn("fast");
    var def = jQuery("#" + id).val(); jQuery('#colorPreview span').text(def);
    jQuery('#colorPreview').css('background', def); jQuery('#color').val(def);
    var hxs = jQuery('#iColorPicker');
    for (var i = 0; i < hxs.length; i++) {
        var tbl = document.getElementById('hexSection' + i);
        var tblChilds = tbl.childNodes;
        for (j = 0; j < tblChilds.length; j++) {
            var tblCells = tblChilds[j].childNodes;
            for (k = 0; k < tblCells.length; k++) {
                jQuery(tblChilds[j].childNodes[k]).unbind().mouseover(function(a) {
                    var aaa = "#" + jQuery(this).attr('hx');
                    jQuery('#colorPreview').css('background', aaa);
                    jQuery('#colorPreview span').text(aaa);
                }).click(function() {
                    var aaa = "#" + jQuery(this).attr('hx');
                    jQuery("#" + id).val(aaa).css({ "background": aaa, "color": contrastColor(aaa) });
                    jQuery("#iColorPickerBg").hide();
                    jQuery("#iColorPicker").fadeOut();
                    jQuery(this);
                });
            }
        }

    }
}

this.iColorPicker = function () {

    jQuery("input.iColorPicker").each(function (i) {
        if ($(this).next('#icp_' + this.id).length == 0) {
            if (i == 0 && $('body').children('#iColorPicker').length == 0) {
                jQuery(document.createElement("div")).attr("id", "iColorPicker").css('display', 'none').html('<table class="pickerTable" id="pickerTable0"><thead id="hexSection0"><tr><td style="background:#f00;" hx="f00"></td><td style="background:#ff0" hx="ff0"></td><td style="background:#0f0" hx="0f0"></td><td style="background:#0ff" hx="0ff"></td><td style="background:#00f" hx="00f"></td><td style="background:#f0f" hx="f0f"></td><td style="background:#fff" hx="fff"></td><td style="background:#ebebeb" hx="ebebeb"></td><td style="background:#e1e1e1" hx="e1e1e1"></td><td style="background:#d7d7d7" hx="d7d7d7"></td><td style="background:#cccccc" hx="cccccc"></td><td style="background:#c2c2c2" hx="c2c2c2"></td><td style="background:#b7b7b7" hx="b7b7b7"></td><td style="background:#acacac" hx="acacac"></td><td style="background:#a0a0a0" hx="a0a0a0"></td><td style="background:#959595" hx="959595"></td></tr><tr><td style="background:#ee1d24" hx="ee1d24"></td><td style="background:#fff100" hx="fff100"></td><td style="background:#00a650" hx="00a650"></td><td style="background:#00aeef" hx="00aeef"></td><td style="background:#2f3192" hx="2f3192"></td><td style="background:#ed008c" hx="ed008c"></td><td style="background:#898989" hx="898989"></td><td style="background:#7d7d7d" hx="7d7d7d"></td><td style="background:#707070" hx="707070"></td><td style="background:#626262" hx="626262"></td><td style="background:#555" hx="555"></td><td style="background:#464646" hx="464646"></td><td style="background:#363636" hx="363636"></td><td style="background:#262626" hx="262626"></td><td style="background:#111" hx="111"></td><td style="background:#000" hx="000"></td></tr><tr><td style="background:#f7977a" hx="f7977a"></td><td style="background:#fbad82" hx="fbad82"></td><td style="background:#fdc68c" hx="fdc68c"></td><td style="background:#fff799" hx="fff799"></td><td style="background:#c6df9c" hx="c6df9c"></td><td style="background:#a4d49d" hx="a4d49d"></td><td style="background:#81ca9d" hx="81ca9d"></td><td style="background:#7bcdc9" hx="7bcdc9"></td><td style="background:#6ccff7" hx="6ccff7"></td><td style="background:#7ca6d8" hx="7ca6d8"></td><td style="background:#8293ca" hx="8293ca"></td><td style="background:#8881be" hx="8881be"></td><td style="background:#a286bd" hx="a286bd"></td><td style="background:#bc8cbf" hx="bc8cbf"></td><td style="background:#f49bc1" hx="f49bc1"></td><td style="background:#f5999d" hx="f5999d"></td></tr><tr><td style="background:#f16c4d" hx="f16c4d"></td><td style="background:#f68e54" hx="f68e54"></td><td style="background:#fbaf5a" hx="fbaf5a"></td><td style="background:#fff467" hx="fff467"></td><td style="background:#acd372" hx="acd372"></td><td style="background:#7dc473" hx="7dc473"></td><td style="background:#39b778" hx="39b778"></td><td style="background:#16bcb4" hx="16bcb4"></td><td style="background:#00bff3" hx="00bff3"></td><td style="background:#438ccb" hx="438ccb"></td><td style="background:#5573b7" hx="5573b7"></td><td style="background:#5e5ca7" hx="5e5ca7"></td><td style="background:#855fa8" hx="855fa8"></td><td style="background:#a763a9" hx="a763a9"></td><td style="background:#ef6ea8" hx="ef6ea8"></td><td style="background:#f16d7e" hx="f16d7e"></td></tr><tr><td style="background:#ee1d24" hx="ee1d24"></td><td style="background:#f16522" hx="f16522"></td><td style="background:#f7941d" hx="f7941d"></td><td style="background:#fff100" hx="fff100"></td><td style="background:#8fc63d" hx="8fc63d"></td><td style="background:#37b44a" hx="37b44a"></td><td style="background:#00a650" hx="00a650"></td><td style="background:#00a99e" hx="00a99e"></td><td style="background:#00aeef" hx="00aeef"></td><td style="background:#0072bc" hx="0072bc"></td><td style="background:#0054a5" hx="0054a5"></td><td style="background:#2f3192" hx="2f3192"></td><td style="background:#652c91" hx="652c91"></td><td style="background:#91278f" hx="91278f"></td><td style="background:#ed008c" hx="ed008c"></td><td style="background:#ee105a" hx="ee105a"></td></tr><tr><td style="background:#9d0a0f" hx="9d0a0f"></td><td style="background:#a1410d" hx="a1410d"></td><td style="background:#a36209" hx="a36209"></td><td style="background:#aba000" hx="aba000"></td><td style="background:#588528" hx="588528"></td><td style="background:#197b30" hx="197b30"></td><td style="background:#007236" hx="007236"></td><td style="background:#00736a" hx="00736a"></td><td style="background:#0076a4" hx="0076a4"></td><td style="background:#004a80" hx="004a80"></td><td style="background:#003370" hx="003370"></td><td style="background:#1d1363" hx="1d1363"></td><td style="background:#450e61" hx="450e61"></td><td style="background:#62055f" hx="62055f"></td><td style="background:#9e005c" hx="9e005c"></td><td style="background:#9d0039" hx="9d0039"></td></tr><tr><td style="background:#790000" hx="790000"></td><td style="background:#7b3000" hx="7b3000"></td><td style="background:#7c4900" hx="7c4900"></td><td style="background:#827a00" hx="827a00"></td><td style="background:#3e6617" hx="3e6617"></td><td style="background:#045f20" hx="045f20"></td><td style="background:#005824" hx="005824"></td><td style="background:#005951" hx="005951"></td><td style="background:#005b7e" hx="005b7e"></td><td style="background:#003562" hx="003562"></td><td style="background:#002056" hx="002056"></td><td style="background:#0c004b" hx="0c004b"></td><td style="background:#30004a" hx="30004a"></td><td style="background:#4b0048" hx="4b0048"></td><td style="background:#7a0045" hx="7a0045"></td><td style="background:#7a0026" hx="7a0026"></td></tr></thead><tbody><tr><td style="border:1px solid #000;background:#fff;cursor:pointer;height:60px;-moz-background-clip:-moz-initial;-moz-background-origin:-moz-initial;-moz-background-inline-policy:-moz-initial;" colspan="16" align="center" id="colorPreview"><span style="color:#000;border:1px solid rgb(0, 0, 0);padding:5px;background-color:#fff;font:11px Arial, Helvetica, sans-serif;"></span></td></tr></tbody></table><style>#iColorPicker input{margin:2px}</style>').appendTo("body");
                jQuery(document.createElement("div")).attr("id", "iColorPickerBg").click(function () {
                    jQuery("#iColorPickerBg").hide();
                    jQuery("#iColorPicker").fadeOut();
                }).appendTo("body");
                jQuery('table.pickerTable td').css({ 'width': '12px', 'height': '14px', 'border': '1px solid #000', 'cursor': 'pointer' });
                jQuery('#iColorPicker table.pickerTable').css({ 'border-collapse': 'collapse' });
                jQuery('#iColorPicker').css({ 'border': '1px solid #ccc', 'background': '#333', 'padding': '5px', 'color': '#fff', 'z-index': 10005 });
            }
            jQuery('#colorPreview').css({ 'height': '50px' });
            if ($(this).attr('readonly') != 'readonly') {
                jQuery(this).css({ "backgroundColor": jQuery(this).val(), "color": contrastColor(jQuery(this).val()) }).after('<a href="javascript:void(null)" id="icp_' + this.id + '" onclick="iColorShow(\'' + this.id + '\',\'icp_' + this.id + '\')"><img src="' + imageUrl + '" style="border:0;margin:-2px 0 0 3px" align="absmiddle" ></a>');
            } else {
                jQuery(this).css({ "backgroundColor": jQuery(this).val(), "color": contrastColor(jQuery(this).val()) }).after('');
            }
        }
    });
};

function contrastColor(a) {
    var r, g, b, hsp;

    if (a.match(/^rgb/)) {
        a = a.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
        r = a[1];
        g = a[2];
        b = a[3];
    } else {
        a = +("0x" + a.slice(1).replace(
            a.length < 5 && /./g, '$&$&'
          )
        );
        r = a >> 16;
        g = a >> 8 & 255;
        b = a & 255;
    }
    hsp = Math.sqrt(
      0.299 * (r * r) +
      0.587 * (g * g) +
      0.114 * (b * b)
    );
    if (hsp > 127.5) {
        return "black";
    } else {
        return "white";
    }
};


var ELMA = {};

/**
 * Subscribes to events
 *
 * @param evt
 * @param handler
 */
ELMA.bind = function (evt, handler) {
    jQuery().bind(evt, handler);
};

/**
 * Unbind an event
 *
 * @param evt
 * @param handler
 */
ELMA.unbind = function (evt, handler) {
    jQuery().unbind(evt, handler);
};

// This is here so that we find bugs like JRA-19245 ASAP
//jQuery.noConflict();
jQuery.ajaxSettings.traditional = true;

/**
 * Tries to run a function and return its value and if it throws an exception, returns the default value instead
 *
 * @param f the function to try
 * @param defaultVal the default value to return in case of an error
 */
function tryIt(f, defaultVal) {
    try {
        return f();
    } catch (ex) {
        return defaultVal;
    }
}

/**
* @function begetObject
* @return {Object} cloned object
*/
function begetObject (obj) {
    var f = function () {
    };
    f.prototype = obj;
    return new f();
};

/**
* @method copyObject
* @param {Object} object - to copy
* @param {Boolean} deep - weather to copy objects within object
*/
function copyObject (object, deep) {
    var copiedObject = {};

    $.each(object, function (name, property) {
        if (typeof property !== "object" || property === null || property instanceof $) {
            copiedObject[name] = property;
        } else if (deep !== false) {
            copiedObject[name] = copyObject(property, deep);
        }
    });

    return copiedObject;
};

/*
* Submits an element's form if the enter key is pressed
*/
function submitOnEnter(e) {
    if (e.keyCode == 13) {
        return false;
    }
    else {
        return true;
    }
};


(function ($) {

    if (document.selection) {
        var B = function (C) {
            return C.replace(/\u000D/g, "")
        };
        $.fn.selection = function (F) {
            var E = this[0];
            this.focus();
            if (!E) {
                return false
            }
            if (F == null) {
                return document.selection.createRange().text
            } else {
                var D = E.scrollTop;
                var C = document.selection.createRange();
                C.text = F;
                C.select();
                E.focus();
                E.scrollTop = D
            }
        };
        $.fn.selectionRange = function (C, F) {
            var G = this[0];
            this.focus();
            var I = document.selection.createRange();
            if (C == null) {
                var K = this.val(),
                    J = K.length,
                    E = I.duplicate();
                E.moveToElementText(G);
                E.setEndPoint("StartToEnd", I);
                var D = J - B(E.text).length;
                E.setEndPoint("StartToStart", I);
                var H = J - B(E.text).length;
                if (D != H && K.charAt(D + 1) == "\n") {
                    D += 1
                }
                return {
                    end: D,
                    start: H,
                    text: K.substring(H, D),
                    textBefore: K.substring(0, H),
                    textAfter: K.substring(D)
                }
            } else {
                I.moveToElementText(G);
                I.collapse(true);
                I.moveStart("character", C);
                I.moveEnd("character", F - C);
                I.select()
            }
        }
    }

    else {
        $.fn.selection = function (E) {
            var D = this[0];
            if (!D) {
                return false
            }
            if (E == null) {
                if (D.setSelectionRange) {
                    return D.value.substring(D.selectionStart, D.selectionEnd)
                }
                else {
                    return false
                }
            }
            else {
                var C = D.scrollTop;
                if (!!D.setSelectionRange) {
                    var F = D.selectionStart;
                    D.value = D.value.substring(0, F) + E + D.value.substring(D.selectionEnd);
                    D.selectionStart = F;
                    D.selectionEnd = F + E.length
                }
                D.focus();
                D.scrollTop = C
            }
        };
        $.fn.selectionRange = function (F, C) {
            if (F == null) {
                var D = { start: this[0].selectionStart, end: this[0].selectionEnd };
                var E = this.val();
                D.text = E.substring(D.start, D.end);
                D.textBefore = E.substring(0, D.start);
                D.textAfter = E.substring(D.end);
                return D
            }
            else {
                this[0].selectionStart = F;
                this[0].selectionEnd = C;
            }
        }
    }

    $.fn.wrapSelection = function (C, D) {
        this.selection(C + this.selection() + (D || ""))
    }

})($);


/**
* jQuery AOP - jQuery plugin to add features of aspect-oriented programming (AOP) to jQuery.
* http://jquery-aop.googlecode.com/
*
* Licensed under the MIT license:
* http://www.opensource.org/licenses/mit-license.php
*
* Version: 1.3
*
* Cross-frame type detection based on Daniel Steigerwald's code (http://daniel.steigerwald.cz)
* http://gist.github.com/204554
*
*/

(function() {

	var _after			= 1;
	var _afterThrow		= 2;
	var _afterFinally	= 3;
	var _before			= 4;
	var _around			= 5;
	var _intro			= 6;
	var _regexEnabled = true;
	var _arguments = 'arguments';
	var _undef = 'undefined';

	var getType = (function() {
	 
		var toString = Object.prototype.toString,
			toStrings = {},
			nodeTypes = { 1: 'element', 3: 'textnode', 9: 'document', 11: 'fragment' },
			types = 'Arguments Array Boolean Date Document Element Error Fragment Function NodeList Null Number Object RegExp String TextNode Undefined Window'.split(' ');
	 
		for (var i = types.length; i--; ) {
			var type = types[i], constructor = window[type];
			if (constructor) {
				try { toStrings[toString.call(new constructor)] = type.toLowerCase(); }
				catch (e) { }
			}
		}
	 
		return function(item) {
			return item == null && (item === undefined ? _undef : 'null') ||
				item.nodeType && nodeTypes[item.nodeType] ||
				typeof item.length == 'number' && (
					item.callee && _arguments ||
					item.alert && 'window' ||
					item.item && 'nodelist') ||
				toStrings[toString.call(item)];
		};
	 
	})();

	var isFunc = function(obj) { return getType(obj) == 'function'; };

	/**
	 * Private weaving function.
	 */
	var weaveOne = function(source, method, advice) {

		var old = source[method];

		// Work-around IE6/7 behavior on some native method that return object instances
		if (advice.type != _intro && !isFunc(old)) {
			var oldObject = old;
			old = function() {
				var code = arguments.length > 0 ? _arguments + '[0]' : '';

				for (var i=1;i<arguments.length;i++) {
					code += ',' + _arguments + '[' + i + ']';
				}

				return eval('oldObject(' + code + ');');
			};
		}

		var aspect;
		if (advice.type == _after || advice.type == _afterThrow || advice.type == _afterFinally)
			aspect = function() {
				var returnValue, exceptionThrown = null;

				try {
					returnValue = old.apply(this, arguments);
				} catch (e) {
					exceptionThrown = e;
				}

				if (advice.type == _after)
					if (exceptionThrown == null)
						returnValue = advice.value.apply(this, [returnValue, method]);
					else
						throw exceptionThrown;
				else if (advice.type == _afterThrow && exceptionThrown != null)
					returnValue = advice.value.apply(this, [exceptionThrown, method]);
				else if (advice.type == _afterFinally)
					returnValue = advice.value.apply(this, [returnValue, exceptionThrown, method]);

				return returnValue;
			};
		else if (advice.type == _before)
			aspect = function() {
				advice.value.apply(this, [arguments, method]);
				return old.apply(this, arguments);
			};
		else if (advice.type == _intro)
			aspect = function() {
				return advice.value.apply(this, arguments);
			};
		else if (advice.type == _around) {
			aspect = function() {
				var invocation = { object: this, args: Array.prototype.slice.call(arguments) };
				return advice.value.apply(invocation.object, [{ arguments: invocation.args, method: method, proceed : 
					function() {
						return old.apply(invocation.object, invocation.args);
					}
				}] );
			};
		}

		aspect.unweave = function() { 
			source[method] = old;
			pointcut = source = aspect = old = null;
		};

		source[method] = aspect;

		return aspect;

	};

	/**
	 * Private method search
	 */
	var search = function(source, pointcut, advice) {
		
		var methods = [];

		for (var method in source) {

			var item = null;

			// Ignore exceptions during method retrival
			try {
				item = source[method];
			}
			catch (e) { }

			if (item != null && method.match(pointcut.method) && isFunc(item))
				methods[methods.length] = { source: source, method: method, advice: advice };

		}

		return methods;
	};

	/**
	 * Private weaver and pointcut parser.
	 */
	var weave = function(pointcut, advice) {

		var source = typeof(pointcut.target.prototype) != _undef ? pointcut.target.prototype : pointcut.target;
		var advices = [];

		// If it's not an introduction and no method was found, try with regex...
		if (advice.type != _intro && typeof(source[pointcut.method]) == _undef) {

			// First try directly on target
			var methods = search(pointcut.target, pointcut, advice);

			// No method found, re-try directly on prototype
			if (methods.length == 0)
				methods = search(source, pointcut, advice);

			for (var i in methods)
				advices[advices.length] = weaveOne(methods[i].source, methods[i].method, methods[i].advice);

		} 
		else
		{
			// Return as an array of one element
			advices[0] = weaveOne(source, pointcut.method, advice);
		}

		return _regexEnabled ? advices : advices[0];

	};

	jQuery.aop = 
	{
		/**
		 * Creates an advice after the defined point-cut. The advice will be executed after the point-cut method 
		 * has completed execution successfully, and will receive one parameter with the result of the execution.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.after( {target: window, method: 'MyGlobalMethod'}, function(result) { 
		 *                alert('Returned: ' + result); 
		 *                return result;
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.after( {target: String, method: 'indexOf'}, function(index) { 
		 *                alert('Result found at: ' + index + ' on:' + this); 
		 *                return index;
		 *          } );
		 * @result Array<Function>
		 *
		 * @name after
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called after the execution of the point-cut. It receives one parameter
		 *                        with the result of the point-cut's execution. The function can choose to return this same value or a different one.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		after : function(pointcut, advice)
		{
			return weave( pointcut, { type: _after, value: advice } );
		},

		/**
		 * Creates an advice after the defined point-cut only for unhandled exceptions. The advice will be executed 
		 * after the point-cut method only if the execution failed and an exception has been thrown. It will receive one 
		 * parameter with the exception thrown by the point-cut method.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.afterThrow( {target: String, method: 'indexOf'}, function(exception) { 
		 *                alert('Unhandled exception: ' + exception); 
		 *                return -1;
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.afterThrow( {target: calculator, method: 'Calculate'}, function(exception) { 
		 *                console.log('Unhandled exception: ' + exception);
		 *                throw exception;
		 *          } );
		 * @result Array<Function>
		 *
		 * @name afterThrow
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called after the execution of the point-cut. It receives one parameter
		 *                        with the exception thrown by the point-cut method.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		afterThrow : function(pointcut, advice)
		{
			return weave( pointcut, { type: _afterThrow, value: advice } );
		},

		/**
		 * Creates an advice after the defined point-cut. The advice will be executed after the point-cut method 
		 * regardless of its success or failure, and it will receive two parameters: one with the 
		 * result of a successful execution or null, and another one with the exception thrown or null.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.afterFinally( {target: window, method: 'MyGlobalMethod'}, function(result, exception) {
		 *                if (exception == null)
		 *                    return 'Returned: ' + result;
		 *                else
		 *                    return 'Unhandled exception: ' + exception;
		 *          } );
		 * @result Array<Function>
		 *
		 * @name afterFinally
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called after the execution of the point-cut regardless of its success or failure.
		 *                        It receives two parameters, the first one with the result of a successful execution or null, and the second one with the 
		 *                        exception or null.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		afterFinally : function(pointcut, advice)
		{
			return weave( pointcut, { type: _afterFinally, value: advice } );
		},


		/**
		 * Creates an advice before the defined point-cut. The advice will be executed before the point-cut method 
		 * but cannot modify the behavior of the method, or prevent its execution.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.before( {target: window, method: 'MyGlobalMethod'}, function() { 
		 *                alert('About to execute MyGlobalMethod'); 
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.before( {target: String, method: 'indexOf'}, function(index) {
		 *                alert('About to execute String.indexOf on: ' + this);
		 *          } );
		 * @result Array<Function>
		 *
		 * @name before
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called before the execution of the point-cut.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		before : function(pointcut, advice)
		{
			return weave( pointcut, { type: _before, value: advice } );
		},


		/**
		 * Creates an advice 'around' the defined point-cut. This type of advice can control the point-cut method execution by calling
		 * the functions '.proceed()' on the 'invocation' object, and also, can modify the arguments collection before sending them to the function call.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.around( {target: window, method: 'MyGlobalMethod'}, function(invocation) {
		 *                alert('# of Arguments: ' + invocation.arguments.length); 
		 *                return invocation.proceed(); 
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.around( {target: String, method: 'indexOf'}, function(invocation) { 
		 *                alert('Searching: ' + invocation.arguments[0] + ' on: ' + this); 
		 *                return invocation.proceed(); 
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.around( {target: window, method: /Get(\d+)/}, function(invocation) {
		 *                alert('Executing ' + invocation.method); 
		 *                return invocation.proceed(); 
		 *          } );
		 * @desc Matches all global methods starting with 'Get' and followed by a number.
		 * @result Array<Function>
		 *
		 *
		 * @name around
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called around the execution of the point-cut. This advice will be called with one
		 *                        argument containing one function '.proceed()', the collection of arguments '.arguments', and the matched method name '.method'.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		around : function(pointcut, advice)
		{
			return weave( pointcut, { type: _around, value: advice } );
		},

		/**
		 * Creates an introduction on the defined point-cut. This type of advice replaces any existing methods with the same
		 * name. To restore them, just unweave it.
		 * This function returns an array with only one weaved aspect (Function).
		 *
		 * @example jQuery.aop.introduction( {target: window, method: 'MyGlobalMethod'}, function(result) {
		 *                alert('Returned: ' + result);
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.introduction( {target: String, method: 'log'}, function() {
		 *                alert('Console: ' + this);
		 *          } );
		 * @result Array<Function>
		 *
		 * @name introduction
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved.
		 * @param Function advice Function containing the code that will be executed on the point-cut. 
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		introduction : function(pointcut, advice)
		{
			return weave( pointcut, { type: _intro, value: advice } );
		},
		
		/**
		 * Configures global options.
		 *
		 * @name setup
		 * @param Map settings Configuration options.
		 * @option Boolean regexMatch Enables/disables regex matching of method names.
		 *
		 * @example jQuery.aop.setup( { regexMatch: false } );
		 * @desc Disable regex matching.
		 *
		 * @type Void
		 * @cat Plugins/General
		 */
		setup: function(settings)
		{
			_regexEnabled = settings.regexMatch;
		}
	};

})();



/**
 * Creates a dropdown list from a JSON object
 *
 * @constructor ELMA.Dropdown
 * @deprecated
 * @author Scott Harwood
 *
 * NOTE: Please use @see AJS.Dropdown instead of this for future dropdown implementations.
 */
ELMA.Dropdown = function() {

    // private

    var instances = [];

    return {

        // public

        /**
         * Adds this instance to private var <em>instances</em>
         * This reference can be used to access all instances
         * @function {public} addInstance
         */
        addInstance: function() {
            instances.push(this);
        },


        /**
         * Calls the hideList method on all instances of <em>dropdown</em>
         * @function {public} hideInstances
         */
        hideInstances: function() {
            var that = this;
            jQuery(instances).each(function(){
                if (that !== this) {
                    this.hideDropdown();
                }
            });
        },

        
        getHash: function () {
            if (!this.hash) {
                this.hash = {
                    container: this.dropdown,
                    hide: this.hideDropdown,
                    show: this.displayDropdown
                };
            }
            return this.hash;
        },

        /**
         * Calls <em>hideInstances</em> method to hide all other dropdowns.
         * Adds <em>active</em> class to <em>dropdown</em> and styles to make it visible.
         * @function {public} displayDropdown
         */
        displayDropdown: function() {
            if (ELMA.Dropdown.current === this) {
                return;
            }
            
            this.hideInstances();
            ELMA.Dropdown.current = this;

            this.dropdown.css({ display: "block" });
            //that.responseContainer.scrollTop(0);
            this.displayed = true;

            /*
            var dd = this.dropdown;
            if (!window.top.ELMA.Dialog.current) {
                setTimeout(function() {
                    // Scroll dropdown into view
                    var win = jQuery(window);
                    var minScrollTop = dd.offset().top + dd.attr("offsetHeight") - win.height() + 10;

                    if (win.scrollTop() < minScrollTop) {
                        jQuery("html,body").animate({scrollTop: minScrollTop}, 300, "linear");
                    }
                }, 100);
            }*/
        },

        /**
         *
         * Removes <em>active</em> class from <em>dropdown</em> and styles to make it hidden.
         * @function {public} hideDropdown
         */
        hideDropdown: function() {
            if (this.displayed === false) {
                return;
            }

            ELMA.Dropdown.current = null;
            this.dropdown.css({display: "none"});

            this.displayed = false;
        },

        /**
         * Initialises instance by, applying primary handler, user options and a Internet Explorer hack.
         * function {public} init
         * @param {HTMLElement} trigger
         * @param {HTMLElement} dropdown
         */
        init: function(trigger, dropdown) {

            var that = this;

            this.addInstance(this);
            this.dropdown = jQuery(dropdown);

            this.dropdown.css({display: "none"});

            // hide dropdown on tab
            jQuery(document).keydown(function(e){
                if(e.keyCode === 9) {
                    that.hideDropdown();
                }
            });

            // this instance is triggered by a method call
            if (trigger.target) {
                jQuery.aop.before(trigger, function(){
                    if (!that.displayed) {
                        that.displayDropdown();
                    }
                });

            // this instance is triggered by a click event
            } else {
                that.dropdown.css("top",jQuery(trigger).outerHeight() + "px");
                trigger.click(function(e){
                    if (!that.displayed) {
                        that.displayDropdown();
                        e.stopPropagation();
                        // lets not follow the link (if it is a link)
                    } else {
                        that.hideDropdown();
                    }
                    e.preventDefault();
                });
            }

            // hide dropdown when click anywhere other than on this instance
            jQuery(document.body).click(function(){
                if (that.displayed) {
                    that.hideDropdown();
                }
            });
        }
    };

}();

/**
 * Standard dropdown constructor
 * @constucter Standard
 * @param {HTMLElement} trigger
 * @param {HTMLElement} dropdown
 * @return {Object} - instance
 */
ELMA.Dropdown.AutoComplete = function(trigger, dropdown) {

    var that = begetObject(ELMA.Dropdown);

    that.init = function(trigger, dropdown) {

        this.addInstance(this);
        this.dropdown = jQuery(dropdown).click(function(e){
            // lets not hide dropdown when we click on it
            e.stopPropagation();
        });
        this.dropdown.css({display: "none"});

        // this instance is triggered by a method call
        if (trigger.target) {
            jQuery.aop.before(trigger, function(){
                if (!that.displayed) {
                    that.displayDropdown();
                }
            });

        // this instance is triggered by a click event
        } else {
            trigger.click(function(e){
                if (!that.displayed) {
                    that.displayDropdown();
                    e.stopPropagation();
                }
            });
        }

        // hide dropdown when click anywhere other than on this instance
        jQuery(document.body).click(function(){
            if (that.displayed) {
                that.hideDropdown();
            }
        });
    };

    that.init(trigger, dropdown);

    return that;
};





ELMA.AutoComplete = function () {

    var inFocus;

    /**
    * Calls a callback after specified delay
    * @method {private} delay
    * @param {Number} l - length of delay in <em>seconds</em>
    * @param {Function} callback - function to call after delay
    */
    var delay = function (callback, l) {
        if (delay.t) {
            clearTimeout(delay.t);
            delay.t = undefined;
        }
        delay.t = setTimeout(callback, l * 1000);
    };

    var INVALID_KEYS = {
        9: true,
        13: true,
        14: true,
        25: true,
        27: true,
        38: true,
        40: true,
        224: true
    };

    return {

        /**
        * Checks whether a saved version (cached) of the request exists, if not performs a request and saves response,
        * then dispatches saved response to <em>renderSuggestions</em> method.
        *
        * @method {public} dispatcher
        */
        dispatcher: function () { },

        // получение кэшированного запроса по сущностям
        getSavedEntitiesResponse: function (val) {
            if (!this.requestedEntities) {
                this.requestedEntities = {};
            }
            return this.requestedEntities[val];
        },

        // кэширование запроса по сущностям
        saveEntitiesResponse: function (val, response) {
            if (typeof val === "string" && typeof response === "object") {
                if (!this.requestedEntities) {
                    this.requestedEntities = {};
                }
                this.requestedEntities[val] = response;
            }
        },

        /*// получение кэшированного запроса по значениям
        getSavedValuesResponse: function (val) {
            if (!this.requestedValues) {
                this.requestedValues = {};
            }
            return this.requestedValues[val];
        },

        // кэширование запроса по значениям
        saveValuesResponse: function (val, response) {
            if (typeof val === "string" && typeof response === "object") {
                if (!this.requestedValues) {
                    this.requestedValues = {};
                }
                this.requestedValues[val] = response;
            }
        },*/

        // получение кэшированного запроса по данным
        getSavedDataResponse: function (val) {
            if (!this.requestedData) {
                this.requestedData = {};
            }
            return this.requestedData[val];
        },

        // кэширование запроса по данным
        saveDataResponse: function (val, response) {
            if (typeof val === "string" && typeof response === "object") {
                if (!this.requestedData) {
                    this.requestedData = {};
                }
                this.requestedData[val] = response;
            }
        },

        /**
        * Called to render suggestions. Used to define interface only.
        * Rendering is difficult to make generic, best to leave this to extending prototypes.
        *
        * @method {public} renderSuggestions
        * @param {Object} res - results object
        */
        renderSuggestions: function () { },

        /**
        * Disables autocomplete. Useful for shared inputs.
        * i.e The selection of a radio button may disable the instance
        * @method {Public} disable
        */
        disable: function () {
            this.disabled = true;
        },

        /**
        * Enables autocomplete. Useful for shared inputs.
        * i.e The selection of a radio button may disable the instance
        * @method {Public} enable
        */
        enable: function () {
            this.disabled = false;
        },

        /**
        * Sets instance variables from options object
        * to do: make function create getters and setters
        * @method {public} set
        * @param {Object} options
        */
        set: function (options) {
            for (var name in options) {
                // safeguard to stop looping up the inheritance chain
                if (options.hasOwnProperty(name)) {
                    this[name] = options[name];
                }
            }
        },

        /**
        * Adds value to input field
        * @method {public} completeField
        * @param {String} value
        */
        completeField: function (value) {
            if (value) {
                this.field.val(value).focus();
                this.field.trigger("change");
            }
        },

        /**
        * Returns the text from the start of the field up to the end of
        * the position where suggestions are generated from.
        */
        textToSuggestionCursorPosition: function () {
            return this.field.val();
        },


        /**
        * An ajax request filter that only allows one request at a time. If there is another it will abort then issue
        * the new request.
        *
        * @param options - jQuery formatted ajax options
        */
        _makeRequest: function (options) {
            var that = this,
                requestParams = copyObject(options);

            // if we have we are still waiting for an old request, lets abort it as we are firing a new
            if (this.pendingRequest) {
                this.pendingRequest.abort();
            }

            requestParams.complete = function () {
                that.pendingRequest = null;
            };

            requestParams.error = function (xhr) {

                // We abort stale requests and this subsequently throws an error so we need to check if the request is aborted first.
                // We detect this using xhr.aborted property for native XHR requests but for "Microsoft.XMLHTTP" we use the status code, which is 0.
                // Status code is set to 0 when it is an unknown error so sense to fail silently.
                if (!xhr.aborted && xhr.status !== 0 && options.error) {
                    options.error.apply(this, arguments);
                }
            };

            return this.pendingRequest = ELMA.SmartAjax.makeRequest(requestParams);
        },

        /**
        * Allows users to navigate/select suggestions using the keyboard
        * @method {public} addSuggestionControls
        */
        addSuggestionControls: function (suggestionNodes) {

            // reference to this for closures
            var that = this;

            /**
            * Make sure the index is within the threshold
            * Looks ugly! Has to be a better way.
            * @method {private} evaluateIndex
            * @param {Integer} idx
            * @param {Integer} max
            * @return {Integer} valid threshold
            */
            var evaluateIndex = function (idx, max) {
                var minBoundary = (that.autoSelectFirst === false) ? -1 : 0;
                if (that.allowArrowCarousel) {
                    if (idx > max) {
                        return minBoundary;
                    } else if (idx < minBoundary) {
                        return max;
                    } else {
                        return idx;
                    }
                }
                else {
                    if (idx > max) {
                        return max;
                    } else if (idx < minBoundary) {
                        that.responseContainer.scrollTop(0);
                        return minBoundary;
                    } else {
                        return idx;
                    }
                }
            };

            /**
            * Highlights focused node and removes highlight from previous.
            * Actual highlight styles to come from css, adding and removing classes here.
            * @method {private} setActive
            * @param {Integer} idx - Index of node to be highlighted
            */
            var setActive = function (idx) {

                // if nothing is selected, select the first suggestion
                if (that.selectedIndex !== undefined && that.selectedIndex > -1) {
                    that.suggestionNodes[that.selectedIndex][0].removeClass("active");
                }
                that.selectedIndex = evaluateIndex(idx, that.suggestionNodes.length - 1);
                if (that.selectedIndex > -1) {
                    that.suggestionNodes[that.selectedIndex][0].addClass("active");
                }
            };

            /**
            * Checks to see if there is actually a suggestion in focus before attempting to use it
            * @method {private} evaluateIfActive
            * @returns {boolean}
            */
            var evaluateIfActive = function () {
                return that.suggestionNodes && that.suggestionNodes[that.selectedIndex] &&
                       that.suggestionNodes[that.selectedIndex][0].hasClass("active");
            };


            /**
            * When the responseContainer (dropdown) is visible listen for keyboard events
            * that represent focus or selection.
            * @method {private} keyPressHandler
            * @param {Object} e - event object
            */
            var keyPressHandler = function (e) {
                // only use keyboard events if dropdown is visible
                if (that.responseContainer.is(":visible")) {
                    // if enter key is pressed check that there is a node selected, then hide dropdown and complete field
                    if (e.keyCode === 13) {
                        if (evaluateIfActive() && !that.pendingRequest) {
                            that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                        }
                        e.preventDefault();
                        // hack - stop propagation to prevent dialog from submitting. Looking for eg ELMA.Dropdown.current doesn't work.
                        e.stopPropagation();
                    }
                }
            };

            /**
            * sets focus on suggestion nodes using the "up" and "down" arrows
            * These events need to be fired on mouseup as modifier keys don't register on keypress
            * @method {private} keyUpHandler
            * @param {Object} e - event object
            */
            var keyboardNavigateHandler = function (e) {

                // only use keyboard events if dropdown is visible
                if (that.responseContainer.is(":visible")) {

                    // keep cursor inside input field
                    if (that.field[0] !== document.activeElement) {
                        that.field.focus();
                    }
                    // move selection down when down arrow is pressed
                    if (e.keyCode === 40) {
                        setActive(that.selectedIndex + 1);
                        if (that.selectedIndex >= 0) {
                            // move selection up when up arrow is pressed
                            var containerHeight = that.responseContainer.height();
                            var bottom = that.suggestionNodes[that.selectedIndex][0].position().top + that.suggestionNodes[that.selectedIndex][0].outerHeight();

                            if (bottom - containerHeight > 0) {
                                that.responseContainer.scrollTop(that.responseContainer.scrollTop() + bottom - containerHeight + 2);
                            }
                        } else {
                            that.responseContainer.scrollTop(0);
                        }
                        e.preventDefault();
                    } else if (e.keyCode === 38) {
                        setActive(that.selectedIndex - 1);
                        if (that.selectedIndex >= 0) {
                            // if tab key is pressed check that there is a node selected, then hide dropdown and complete field
                            var top = that.suggestionNodes[that.selectedIndex][0].position().top;
                            if (top < 0) {
                                that.responseContainer.scrollTop(that.responseContainer.scrollTop() + top - 2);
                            }
                        }
                        e.preventDefault();
                    } else if (e.keyCode === 9) {
                        if (evaluateIfActive()) {
                            that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                            e.preventDefault();
                        } else {
                            that.dropdownController.hideDropdown();
                        }
                    }
                }
            };

            if (suggestionNodes.length) {

                this.selectedIndex = 0;
                this.suggestionNodes = suggestionNodes;

                for (var i = 0; i < that.suggestionNodes.length; i++) {
                    var eventData = { instance: this, index: i };
                    this.suggestionNodes[i][0]
                        .bind("mouseover", eventData, activate)
                        .bind("mouseout", eventData, deactivate)
                        .bind("click", eventData, complete);
                }

                // make sure we don't bind more than once
                if (!this.keyboardHandlerBinded) {
                    jQuery(this.field).keypress(keyPressHandler);
                    if (jQuery.browser.mozilla) {
                        jQuery(this.field).keypress(keyboardNavigateHandler);
                    } else {
                        jQuery(this.field).keydown(keyboardNavigateHandler);
                    }
                    this.keyboardHandlerBinded = true;
                }

                // automatically select the first in the list
                if (that.autoSelectFirst === false) {
                    setActive(-1);
                } else {
                    setActive(0);
                }

                // sets the autocomplete singleton infocus var to this instance
                // is used to toggle event propagation. In short, the instance that it is set to will not hide the
                // dropdown each time you click the input field
                inFocus = this;
            }

            function activate(event) {
                if (that.dropdownController.displayed) {
                    setActive(event.data.index);
                }
            }
            function deactivate(event) {
                if (event.data.index === 0) {
                    that.selectedIndex = -1;
                }
                jQuery(this).removeClass("active");
            }
            function complete(event) {
                that.completeField(that.suggestionNodes[event.data.index][1]);
            }
        },


        /**
        * Uses jquery empty command, this is VERY important as it unassigns handlers
        * used for mouseover, click events which expose an opportunity for memory leaks
        * @method {public} clearResponseContainer
        */
        clearResponseContainer: function () {
            this.responseContainer.empty();
            this.suggestionNodes = undefined;
        },

        /**
        * function {Privileged} delay
        * @param response
        */
        delay: delay,

        /**
        * Builds HTML container for suggestions.
        * Positions container top position to be that of the field height
        * @method {public} buildResponseContainer
        */
        buildResponseContainer: function () {
            var inputParent = this.field.parent().addClass('elma-autocomplete');
            this.responseContainer = jQuery(document.createElement("div"));
            this.responseContainer
                .addClass("suggestions")
                .css({ top: this.field.outerHeight() + "px", width: this.field.innerWidth() + "px" })
                .appendTo(inputParent);
        },

        /**
        * Validates the keypress by making sure the field value is beyond the set threshold and the key was either an
        * up or down arrow
        * @method {public} keyUpHandler
        * @param {Object} e - event object
        */
        keyUpHandler: (function () {
            var isIe8 = jQuery.browser.msie && jQuery.browser.version == 8;
            function callback() {
                if (!this.responseContainer) {
                    this.buildResponseContainer();
                }
                // send value to dispatcher to check if we have already got the response or if we need to go
                // back to the server
                this.dispatcher(this.field.val());
            }

            return function (e) {
                // only initialises once the field length is past set length
                if (this.field.val().length >= this.minQueryLength) {
                    // don't do anything if the key pressed is "enter" or "down" or "up" or "right" "left"
                    if (!(e.keyCode in INVALID_KEYS) || (this.responseContainer && !this.responseContainer.is(":visible") && (e.keyCode == 38 || e.keyCode == 40))) {
                        if (isIe8) {
                            // Performance workaround for IE8 (but not IE7): excessive DOM manipulation (JRADEV-3142)
                            delay(jQuery.proxy(callback, this), 0.200);
                        } else {
                            callback.call(this);
                        }
                    }
                }
                return e;
            };
        })(),

        /**
        * Adds in methods via AOP to handle multiple selections
        * @method {Public} addMultiSelectAdvice
        */
        addMultiSelectAdvice: function (delim) {

            // reference to this for closures
            var that = this;

            /**
            * Alerts user if value already exists
            * @method {private} alertUserValueAlreadyExists
            * @param {String} val - value that already exists, will be displayed in message to user.
            */
            var alertUserValueAlreadyExists = function (val) {

                // check if there is an existing alert before adding another
                if (!alertUserValueAlreadyExists.isAlerting) {

                    alertUserValueAlreadyExists.isAlerting = true;

                    // create alert node and append it to the input field's parent, fade it in then out with a short
                    // delay in between.
                    //TODO: JRA-1800 - Needs i18n!  
                    var userAlert = jQuery(document.createElement("div"))
                    .css({ "float": "left", display: "none" })
                    .addClass("warningBox")
                    .html("Oops! You have already entered the value <em>" + val + "</em>")
                    .appendTo(that.field.parent())
                    .show("fast", function () {
                        // display message for 4 seconds before fading out
                        that.delay(function () {
                            userAlert.hide("fast", function () {
                                // removes element from dom
                                userAlert.remove();
                                alertUserValueAlreadyExists.isAlerting = false;
                            });
                        }, 4);
                    });
                }
            };

            // rather than request the entire field return the last comma seperated value
            jQuery.aop.before({ target: this, method: "dispatcher" }, function (innvocation) {
                // matches everything after last comma
                var val = this.field.val();
                innvocation[0] = jQuery.trim(val.slice(val.lastIndexOf(delim) + 1));
                return innvocation;
            });

            // rather than replacing this field just append the new value
            jQuery.aop.before({ target: this, method: "completeField" }, function (args) {
                var valueToAdd = args[0],
                // create array of values
                untrimmedVals = this.field.val().split(delim);
                // trim the values in the array so we avoid extra spaces being appended to the usernames - see JRA-20657
                var trimmedVals = jQuery(untrimmedVals).map(function () {
                    return jQuery.trim(this);
                }).get();
                // check if the value to append already exists. If it does then call alert to to tell user and sets
                // the last value to "". The value to add will either appear:
                // 1) at the start of the string
                // 2) after some whitespace; or
                // 3) directly after the delimiter
                // It is assumed that the value is delimited by the delimiter character surrounded by any number of spaces.
                if (!this.allowDuplicates && new RegExp("(?:^|[\\s" + delim + "])" + valueToAdd + "\\s*" + delim).test(this.field.val())) {
                    alertUserValueAlreadyExists(valueToAdd);
                    trimmedVals[trimmedVals.length - 1] = "";
                } else {
                    // add the new value to the end of the array and then an empty value so we
                    // can get an extra delimiter at the end of the joined string
                    trimmedVals[trimmedVals.length - 1] = valueToAdd;
                    trimmedVals[trimmedVals.length] = "";
                }

                // join the array of values with the delimiter plus an extra space to make the list of values readable
                args[0] = trimmedVals.join(delim.replace(/([^\s]$)/, "$1 "));

                return args;
            });
        },


        /**
        * Adds and manages state of dropdown control
        * @method {Public} addDropdownAdvice
        */
        addDropdownAdvice: function () {
            var that = this;

            // add dropdown functionality to response container
            jQuery.aop.after({ target: this, method: "buildResponseContainer" }, function (args) {
                this.dropdownController = ELMA.Dropdown.AutoComplete({ target: this, method: "renderSuggestions" }, this.responseContainer);

                if ($.browser.msie) { // We need to remove this class for IE as it has position relative which causes content further down the dom to show through the suggestions
                    jQuery.aop.before({ target: this.dropdownController, method: "displayDropdown" }, function () {
                        that.field.parent().addClass("elma-autocomplete");
                    });

                    jQuery.aop.after({ target: this.dropdownController, method: "hideDropdown" }, function () {
                        that.field.parent().removeClass("elma-autocomplete");
                    });
                }

                jQuery.aop.after({ target: this.dropdownController, method: "hideDropdown" }, function () {
                    this.dropdown.removeClass("dropdown-ready");
                });
                return args;
            });

            // display dropdown afer suggestions are updated
            jQuery.aop.after({ target: this, method: "renderSuggestions" }, function (args) {
                if (args && args.length > 0) {
                    this.dropdownController.displayDropdown();

                    if (this.maxHeight && this.dropdownController.dropdown.attr("scrollHeight") > this.maxHeight) {
                        this.dropdownController.dropdown.css({
                            height: this.maxHeight,
                            overflowX: "visible",
                            overflowY: "scroll"
                        });
                    } else if (this.maxHeight) {
                        this.dropdownController.dropdown.css({
                            height: "",
                            overflowX: "",
                            overflowY: ""
                        });
                    }
                    this.dropdownController.dropdown.addClass("dropdown-ready");
                } else {
                    this.dropdownController.hideDropdown();
                }
                return args;
            });

            // hide dropdown after suggestion value is applied to field
            jQuery.aop.after({ target: this, method: "completeField" }, function (args) {
                if (!in_array(this.field.val().slice(-1), ['.', '('])) {
                    this.dropdownController.hideDropdown();
                }
                return args;
            });

            jQuery.aop.after({ target: this, method: "keyUpHandler" }, function (e) {
                // only initialises once the field length is past set length
                if ((!(this.field.val().length >= this.minQueryLength) || e.keyCode === 27)
                        && this.dropdownController && this.dropdownController.displayed) {
                    this.dropdownController.hideDropdown();
                    if (e.keyCode === 27) {
                        e.stopPropagation();
                    }
                }
                return e;
            });
        },

        /**
        * Initialises autocomplete by setting options, and assigning event handler to input field.
        * @method {public} init
        * @param {Object} options
        */
        init: function (options) {
            var that = this;
            this.set(options);
            this.field = this.field || jQuery("#" + this.fieldId);
            // turn off browser default autocomplete
            this.field.attr("autocomplete", "off")
            .keyup(function (e) {
                if (!that.disabled) {
                    that.keyUpHandler(e);
                }
            })
            .keydown(function (e) {
                var ESC_KEY = 27;
                // do not clear field in IE
                if (e.keyCode === ESC_KEY && that.responseContainer && that.responseContainer.is(":visible")) {
                    e.preventDefault();
                }
            })
            // this will stop the dropdown with the suggestions hiding whenever you click the field
            .click(function (e) {
                if (inFocus === that) {
                    e.stopPropagation();
                }
            })
            .blur(function () {
                // we don't want the request to come back and show suggestions if we have already moved away from field
                if (that.pendingRequest) {
                    that.pendingRequest.abort();
                }
            });

            this.addDropdownAdvice();

            if (options.delimChar) {
                this.addMultiSelectAdvice(options.delimChar);
            }
        }
    };

} ();




var eql_operators = [{ value: "=", displayName: "=" }, { value: "<>", displayName: "<>" }, { value: "<=", displayName: "<=" }, { value: ">=", displayName: ">=" }, { value: ">", displayName: ">" }, { value: "<", displayName: "<" }, { value: "like", displayName: "like" }, { value: "in", displayName: "in" }, { value: "is", displayName: "is" }];
var eql_logical_operators = [{ value: "AND", displayName: "AND" }, { value: "OR", displayName: "OR" }];
var empty_operand = [{ value: "NULL", displayName: "NULL", types: ["Object"] }];
var empty_list = [{ value: "EMPTY", displayName: "EMPTY", types: ["Object"] }];
var eql_not_logical_operator = [{ value: "NOT", displayName: "NOT" }];
var eql_prefix_parent = [{ value: "PARENT", displayName: "PARENT", types: ["Object"] }];
var eql_prefix_root = [{ value: "ROOT", displayName: "ROOT", types: ["Object"] }];
var eql_predicates_from = [{ value: "FROM", displayName: "FROM", types: ["Object"] }];
var eql_predicates_select = [{ value: "SELECT", displayName: "SELECT", types: ["Object"] }];
var eql_predicates_where = [{ value: "WHERE", displayName: "WHERE", types: ["Object"] }];
var eql_dot = [{ value: ".", displayName: "." }];
var eql_prefix_operands = eql_prefix_parent.concat(eql_prefix_root);
var eql_count_function = [{ value: "COUNT", displayName: "COUNT" }];

var reserved_word = ["and", "or", "empty", "not", "parent", "root", "from", "select", "where", "count"];

var REGEXP_ANDS = /^AND\s/i;
var REGEXP_ORS = /^OR\s/i;
var REGEXP_NOTS = /^NOT\s/i;
var REGEXP_WHITESPACE = /^\s/;
var REGEXP_UNICODE = /^u[a-fA-F0-9]{4}/;
var REGEXP_TOKEN_CHAR = /[^=!~<>(),'‘’`\s&|]/;
var REGEXP_SPECIAL_CHAR = /[*\/%+$#@?;\][]!|&/;
var REGEXP_QUOTE_CHAR = /('|`|‘|’)/;
var REGEXP_SPACE_OR_ELSE = /[\s(]/;
var REGEXP_CHARS_TO_ESCAPE = /[^trn"'\\\s]/;
var REGEXP_START_QUERY = /^(FROM|SELECT)$/i;
var REGEXP_SELECT = /^SELECT$/i;
var REGEXP_FROM = /^FROM\s/i;
var REGEXP_WHERE = /^WHERE\s/i;
var REGEXP_PARENT = /^(PARENT.?)+?$/i;
var REGEXP_ROOT = /^ROOT.?$/i;
var REGEXP_COMMA_DELIMITER = /^\s*,/;
var REGEXP_DOT = /\.$/;
var REGEXP_PREFIX_NOT_DOT = /(PARENT|ROOT)$/i;
var REGEXP_PREFIX_FIELD = /^(PARENT|ROOT)$/i;
var REGEXP_PREFIX_DOT = /^((PARENT.)+?|ROOT.)/i;
var REGEXP_COUNT = /^COUNT/i;

ELMA.EQLAutoComplete = function (options) {
    var eql_fields_initial;
    var eql_fields;
    var eql_fieldoperators;
    var eql_functions_initial;
    var eql_functions;
    var eql_entities_initial;
    var eql_entities;
    var eql_entity_fields;
    var eql_entity_functions;
    var that = begetObject(ELMA.AutoComplete);
    var serverDataUrl = options.serverDataUrl;
    //serverValuesUrl = options.serverValuesUrl;
    var serverEntitiesUrl = options.serverEntitiesUrl;
    var result;
    var suggestionCount = 0;
    var fieldId = options.fieldId;
    var entityUid = options.entityUid;
    var objectUid = options.objectUid;

    var parseGoodImg = jQuery('#eqlgood' + options.postfix);
    var parseErrorImg = jQuery('#eqlerror' + options.postfix);
    var parseErrorMsg = jQuery('#AC-ParseErrorMsg' + options.postfix);

    that.Description = {
        postfix: options.postfix,
        fieldQueryNameValue: options.fieldQueryNameValue,
        objectUidFunc: options.objectUidFunc,
        fieldTypeNameValue: options.fieldTypeNameValue
    };

    var data = { objectUid: options.objectUid, needOperators: true };
    // проверка кэша не требуется (первый запрос данных)
    $.ajax({
        url: serverDataUrl,
        async: false,
        data: data,
        dataType: "json",
        type: "GET",
        success: function (response) {
            if (response != null && response.fields != null) {
                eql_fields_initial = response.fields;
                eql_fields = response.fields;
                eql_fieldoperators = response.operators;
                eql_functions_initial = response.functions;
                eql_functions = response.functions;
                eql_entities_initial = response.entity;
                eql_entities = response.entity;
            }
            else {
                eql_fields_initial = [];
                eql_fields = [];
                eql_fieldoperators = [];
                eql_functions_initial = [];
                eql_functions = [];
            }
            that.saveDataResponse(options.objectUid, response); // кэширование
        },
        error: function () {
        }
    });

    that.MyParser = function (eqlReservedWords) {

        var eql_reserved_words = eqlReservedWords;
        var lastFieldType;
        var lastOperator;

        var isSubQueryField = false;

        return {

            parse: function (input) {
                var token = that.Token();

                token.init(input);
                this.eql(token);
                return token;
            },

            eql: function (token) {
                this.orClause(token);
            },

            orClause: function (token) {
                while (!token.isComplete() && !this.startsWithIgnoreCase(")", token.remainingString())) {
                    this.chewWhitespace(token);
                    token.getResult().resetLogicalOperators();
                    this.andClause(token);
                    if (!token.isComplete() && token.getResult().getLastLogicalOperator() == null) {
                        // Look for an OR clause
                        var remainingString = token.remainingString();
                        if (remainingString != null && (REGEXP_ORS.test(remainingString))) {
                            token.getResult().setLastLogicalOperator("OR", token.getTokenStringIdx());
                            token.consumeCharacters(2);
                            token.getResult().resetTerminalClause();
                            if (token.isComplete()) {
                                token.setParseError();
                            }
                            token.getResult().setNeedsField();
                        }
                            // This block of code is very confusing. The reason it is here is that when we are in a nested
                            // block of '('s it is the terminalClause that handles the parens and it calls off to this orClause.
                            // The orClause needs to ignore the close paren so that the terminalClause can handle it, BUT only
                            // when we are currently in a set of parens. So, ff the remaining character is a close paren and
                            // we are not in parens then we are NOT in error, otherwise we are
                        else if (!this.startsWithIgnoreCase(")", remainingString) || !token.getInParens()) {
                            this.chewWhitespace(token);
                            var errorIdx = (remainingString == null) ? token.getMaxTokenStringIdx() : token.getMaxTokenStringIdx() - remainingString.length;
                            // let's tokenise this to simplify space handling
                            var tokens;
                            if (remainingString != null) {
                                tokens = remainingString.split(" ");
                                token.getResult().setLastLogicalOperator(tokens[0], errorIdx);
                                token.getResult().setNeedsLogicalOperator();
                            }
                            token.setParseError();
                        }
                    }
                }

                if (token.isComplete() && token.getResult().getNeedsField() == null && token.remainingString() == null) {
                    token.getResult().setNeedsField();
                }

            },

            andClause: function (token) {
                this.chewWhitespace(token);
                this.notClause(token);
                if (!token.isComplete() && token.getResult().getLastLogicalOperator() == null) {
                    // Look for an AND clause
                    this.chewWhitespace(token);

                    var remainingString = token.remainingString();
                    if (remainingString != null && (REGEXP_ANDS.test(remainingString))) {
                        token.getResult().setLastLogicalOperator("AND", token.getTokenStringIdx());
                        token.consumeCharacters(3);
                        token.getResult().resetTerminalClause();
                        if (token.isComplete()) {
                            token.setParseError();
                        }
                        token.getResult().setNeedsField();
                    }
                    else {
                        token.getResult().setNeedsLogicalOperator();
                        // This is a special case for when we are about to place a logical operator into an existing string
                        // so that we will have a null place-holder token for the logical operator we expect.
                        if (token.isComplete()) {
                            token.getResult().setLastLogicalOperator(null, token.getMaxTokenStringIdx());
                        }
                    }
                }
            },

            notClause: function (token) {
                this.chewWhitespace(token);
                if (!token.isComplete()) {
                    // Look for a NOT clause
                    this.chewWhitespace(token);
                    var remainingString = token.remainingString();
                    if (remainingString != null && (REGEXP_NOTS.test(remainingString))) {
                        // This is a bit of a hack that makes it so that you do not get a suggestion for a field until
                        // after you have typed a space after the NOT
                        token.getResult().needsField = false;
                        token.getResult().setLastLogicalOperator("NOT", token.getTokenStringIdx());
                        token.consumeCharacters(3);
                        token.getResult().resetTerminalClause();
                        if (token.isComplete()) {
                            token.setParseError();
                        }
                        token.getResult().setNeedsField();
                    }
                    else {
                        this.terminalClause(token);
                    }
                }
                else {
                    // Let the terminal clause set all the error conditions and needs
                    this.terminalClause(token);
                    token.setParseError();
                }
            },

            terminalClause: function (token) {
                result = token.getResult();
                // Lets always reset the last field variables
                var inCount = result.getCountFunc();
                result.resetTerminalClause();
                if (inCount)
                    result.setCountFunc(true);
                this.chewWhitespace(token);

                var remainingString = token.remainingString();
                // If we see a ( then we need to hand off to the or clause again
                if (this.startsWithIgnoreCase("(", remainingString)) {
                    result.setNeedsOpenParen(false);
                    if (token.isComplete())
                        token.setParseError();

                    result.addToken('(');
                    token.setInParens();
                    result.resetCountExpression();

                    if (lastFieldType != null || result.getCountFunc()) {
                        if (isSubQueryField) {
                            token.setParenType(1); // 1 = скобки подзапроса
                        }
                        else {
                            token.setParenType(0); // 0 = не скобки подзапроса
                        }
                    }
                    token.consumeCharacter();
                    this.orClause(token);
                    this.chewWhitespace(token);
                    remainingString = token.remainingString();
                    if (this.startsWithIgnoreCase(")", remainingString)) {
                        result.addToken(')');
                        token.consumeCharacter();
                        token.setOutOfParens();
                        token.parenIdx--;
                        if (token.getParenType() == 1) { // если закрылась скобка подзапроса
                            token.setOutOfSubQueryParens();
                            if (!inCount) {
                                // восстанавливаем родительские поля и функции после ввода закрывающей скобки подзапроса
                                if (token.getInSubQueryParens()) {
                                    eql_fields = token.getParent().fields;
                                    eql_functions = token.getParent().functions;
                                }
                                    // восстанавливаем начальные поля и функции
                                else {
                                    eql_fields = eql_fields_initial;
                                    eql_functions = eql_functions_initial;
                                }
                                token.deleteTopParent();
                            }
                            else {
                                token.deleteTopLastUid();
                            }

                            token.getResult().setNeedsFieldOrOperand(0);
                            token.getResult().resetLastField();
                            token.getResult().lastFieldCountPrefix = 0;
                        }

                        if (token.isComplete()) {
                            // We don't want to suggest a logical operator to the user if the query parses
                            token.getResult().resetLogicalOperators();
                        }
                    }
                    else {
                        token.setParseError();
                    }

                }
                else {
                    // field -> operator -> operand / subquery / from -> entity -> select -> entityField -> where -> clouse ...
                    if (!token.getInSubQueryParens()) {
                        eql_fields = eql_fields_initial;
                    }

                    token.getResult().setCountExpression();
                    this.field(token);
                    lastFieldType = token.getResult().getLastFieldType();
                    if (lastFieldType) {
                        token.setLastUid(lastFieldType[0]);
                    }
                    if (token.getResult().getNeedsFieldOrOperand() == 2) {
                        token.backTrackToIdx(token.getTokenStringIdx() - token.getResult().getLastFieldName().length - 1);
                        this.operand(token);
                        token.deleteTopLastUid();
                        // This will only happen when we have seen a list operand that is properly closed
                        if (token.getResult().getOperandComplete()) {
                            token.getResult().setNeedsNothing();
                            token.backTrackToIdx(token.getTokenStringIdx() - 1);
                        } else if (token.isComplete() && !token.getResult().getNeedsListComma() && !token.getResult().getCountFunc()) {
                            // This is not a parse error since we have found everything we were looking for
                            token.getResult().setNeedsOperand();
                        }
                    }
                    else if (token.getResult().getIsQuery()) {
                        if (!token.isComplete()) {
                            this.expressionQuery(token);
                        }
                        else {
                            token.setParseError();
                        }
                    }
                    else if (token.getResult().getCountFunc()) {
                        if (!token.isComplete() && !lastFieldType) {
                            this.expressionQuery(token);
                        }
                        else {
                            return;
                        }
                    }
                    else if (!token.isComplete()) {
                        this.oper(token);
                        lastOperator = token.getResult().getLastOperator();
                        if (!token.isComplete()) {
                            isSubQueryField = false;
                            // проверка  поля, поддерживает ли подзапросы
                            if (lastOperator === 'in' && lastFieldType != null && (lastFieldType[2] === entityUid || lastFieldType[1] == 4 || that.FieldIsId(eql_fields, lastFieldType[0]))) {
                                this.subquery(token); // подзапрос
                            }
                            else {
                                this.operand(token);
                                // This will only happen when we have seen a list operand that is properly closed
                                if (token.getResult().getOperandComplete()) {
                                    token.getResult().setNeedsNothing();
                                }
                            }
                        }
                        else {
                            if (!token.getResult().getOperandComplete()) {
                                token.getResult().setNeedsOperator();
                                token.setParseError();
                            }
                        }
                    }
                    else {
                        if (!token.getResult().getNeedsOperand() && !token.getResult().getNeedsOperator() && !token.getResult().getNeedsLogicalOperator()) {
                            token.getResult().setNeedsField();
                        }
                        token.setParseError();
                    }
                }
            },

            field: function (token) {
                this.chewWhitespace(token);
                var field = null;
                var fieldName = this.fieldOrFunctionName(token);
                var fieldType = null;
                var result = token.getResult();

                if (fieldName.length != 0) {
                    if (REGEXP_PREFIX_DOT.test(fieldName)) {
                        result.setLastFieldHavePrefix();
                    }
                    result.setLastFieldCountPrefix(fieldName);

                    if (REGEXP_COUNT.test(fieldName)) {
                        result.setCountFunc(true);
                        result.setNeedsField();

                        this.subquery(token); // подзапрос
                        if (!token.isComplete()) {
                            var countType = ["{D90A59AF-7E47-48C5-8C4C-DAD04834E6E3}", null, "{00000000-0000-0000-0000-000000000000}"];
                            var countField = {
                                auto: true,
                                description: "",
                                displayName: "",
                                value: "count()",
                                types: countType
                            };
                            result.setLastField(countField);
                            result.lastFieldType = countType;
                            result.operandComplete = null;
                        }

                        return;
                    }

                    if (REGEXP_START_QUERY.test(fieldName)) {
                        result.setNeedsEntity();
                        result.setIsQuery();
                        if (REGEXP_SELECT.test(fieldName)) {
                            result.setReversQuery();
                        }
                    }
                    else if (REGEXP_ROOT.test(fieldName) || REGEXP_PARENT.test(fieldName)) {
                        var levelSubQuery = REGEXP_ROOT.test(fieldName) ? 0 : token.inSubQueryParens - token.countWhere - 1;
                        var currentSubQuery = token.parents[levelSubQuery];

                        for (var i = 0; i < currentSubQuery.fields.length; i++) {
                            if (this.equalsIgnoreCase(currentSubQuery.fields[i].types[0], currentSubQuery.uid)) {
                                field = currentSubQuery.fields[i];
                                fieldType = currentSubQuery.fields[i].types;
                                break;
                            }
                        }

                        if (REGEXP_ROOT.test(fieldName)) {
                            result.setPrefixRoot();
                        }

                        if (REGEXP_DOT.test(fieldName)) {
                            result.setNeedsChilds();
                        }
                        else {
                            result.setNeedsDot();
                        }

                        result.setNeedsFieldOrOperand(1);
                    }
                    else {
                        if (token.inSubQueryParens > 0 && result.getNeedsFieldOrOperand() != 1) {
                            var numberLastUid = token.inSubQueryParens - token.countWhere - 1;
                            var entities = that.getSavedEntitiesResponse(token.getLastUid(numberLastUid) + ":");
                            if (entities != undefined) {
                                var parentFields = token.getParent().fields;
                                for (var i = 0; i < entities.length; i++) {
                                    if (entities[i].value == this.valueWithoutSquareBrackets(fieldName)) {
                                        for (var j = 0; j < parentFields.length; j++) {
                                            if (parentFields[j].types[0] == token.getLastUid(numberLastUid)) {
                                                field = parentFields[j];
                                                fieldType = parentFields[j].types;
                                                break;
                                            }
                                        }
                                        result.setNeedsFieldOrOperand(2);
                                        break;
                                    }
                                }
                            }

                            if (field == null && eql_functions && eql_functions.length > 0 && token.parents.length > 0) {
                                var numberLastUid = token.inSubQueryParens - token.countWhere - 1;
                                var parentFields = token.getParent().fields;
                                for (var i = 0; i < eql_functions.length; i++) {
                                    if (fieldName == /[^=!~<>(),\s&|]*/.exec(eql_functions[i].value)[0]) {
                                        for (var j = 0; j < parentFields.length; j++) {
                                            if (parentFields[j].types[0] == token.getLastUid(numberLastUid)) {
                                                field = parentFields[j];
                                                fieldType = parentFields[j].types;
                                                if (eql_functions[i].isInFunction == true) {
                                                    if (token.getInSubQueryParens()) {
                                                        eql_fields = token.getParent().fields;
                                                        eql_functions = token.getParent().functions;
                                                    }
                                                    else {
                                                        eql_fields = eql_fields_initial;
                                                        eql_functions = eql_functions_initial;
                                                    }
                                                    token.deleteTopParent();
                                                    token.setOutOfSubQueryParens();
                                                }
                                                break;
                                            }
                                        }

                                        result.setNeedsFieldOrOperand(2);
                                        break;
                                    }
                                }
                            }
                        }

                        var curFieldName = result.getStringAfterDot(fieldName);
                        var curEqlFields = token.getParentByLastFieldType();

                        if (curEqlFields) {
                            for (var i = 0; i < curEqlFields.length; i++) {
                                if (this.equalsIgnoreCase(result.getUnquotedString(curEqlFields[i].value), this.valueWithoutSquareBrackets(curFieldName))) {
                                    field = curEqlFields[i];
                                    fieldType = curEqlFields[i].types;
                                    result.setNeedsFieldOrOperand(1);
                                    break;
                                }
                            }
                        }
                    }

                    if (fieldType == null) {
                        result.setNeedsFieldOrOperand(0);
                    }

                    result.setLastFieldName(fieldName, fieldType, token);
                    if (field != null) {
                        result.setLastField(field);
                    }
                }
                else if (result.getLastFieldName() == null) {
                    var remainingString = token.remainingString();
                    result.setLastFieldName(remainingString, null, token);
                    result.setNeedsField();
                    result.setNeedsFieldOrOperand(0);
                    token.setParseError();
                }
            },

            oper: function (token) {
                this.chewWhitespace(token);
                var remainingString = token.remainingString();
                var operator = this.getLongestOperatorMatch(remainingString, eql_operators);

                if (operator != null) {
                    // We found an operator, record it and consume the right amount of characters
                    token.getResult().setLastOperator(operator, token.getTokenStringIdx());
                    token.consumeCharacters(operator.length);
                    // If we are one of the word operators we need to enforce a space here
                    if (operator == "in" || operator == "is") {
                        // We need a space or else
                        var currentChar = token.currentCharacter();
                        if (currentChar != null && !REGEXP_SPACE_OR_ELSE.test(currentChar)) {
                            token.setParseError();
                        }
                    }
                    token.getResult().setNeedsOperand();
                }
                else if (token.getResult().getLastOperator() == null) {
                    if (!this.startsWithIgnoreCase(")", remainingString)) {
                        var errorIdx = (remainingString == null) ? token.getMaxTokenStringIdx() : token.getMaxTokenStringIdx() - remainingString.length;
                        token.getResult().setLastOperator(remainingString, errorIdx);
                        token.getResult().setNeedsOperator();
                        token.setParseError();
                    }
                }
            },

            subquery: function (token) {
                var uid = lastFieldType != null ? lastFieldType[0] : objectUid;
                var parentUid = token.getInSubQueryParens() ? token.getLastUid(token.inSubQueryParens - 1) : that.objectUid;

                isSubQueryField = true;
                if (!token.getResult().getCountFunc()) {
                    token.setParent({ fields: eql_fields, functions: eql_functions, uid: parentUid }); // запоминаем поля и функции текущей сущности (для восстановления лексики после закрывающей скобки подзапроса)
                }

                token.getResult().setNeedsOpenParen(true);
                token.getResult().setNeedsFrom(true);
                token.setInSubQueryParens();

                if (token.getResult().getLastField()) {
                    // проверка кэша
                    var data;
                    var fieldType = token.getResult().getLastField().types;
                    if (fieldType && fieldType[2] == entityUid) {
                        if (!that.getSavedDataResponse(uid)) {
                            // запрос данных подсущности
                            data = { objectUid: uid, needOperators: false }; // objectUid - Uid типа объекта автокомплита
                            $.ajax({
                                url: serverDataUrl,
                                async: false,
                                data: data,
                                dataType: "json",
                                type: "GET",
                                success: function (response) {
                                    if (response != null && response.fields != null) {
                                        eql_fields = response.fields;
                                        eql_functions = response.functions;
                                    }
                                    else {
                                        eql_fields = [];
                                        eql_functions = [];
                                    }
                                    that.saveDataResponse(uid, response); // кэширование
                                },
                                error: function () {
                                }
                            });
                        }
                        else { // получение кэшированного запроса
                            var cachedResponse = that.getSavedDataResponse(uid);
                            eql_fields = cachedResponse.fields;
                            eql_functions = cachedResponse.functions;
                        }

                        // предлагаем сущности в качестве операндов
                        data = { Uid: uid, entityValue: "" };
                        var entityUidValueKey = fieldType[0] + ":";
                        // проверка кэша
                        if (!that.getSavedEntitiesResponse(entityUidValueKey)) {
                            that.dropdownController.dropdown.removeClass("dropdown-ready");
                            $.ajax({
                                url: serverEntitiesUrl,
                                async: false,
                                data: data,
                                dataType: "json",
                                type: "GET",
                                success: function (response) {
                                    var results;
                                    if (response != null && response.results != null) {
                                        results = response.results;
                                    }
                                    else {
                                        results = [];
                                    }
                                    // кэширование
                                    that.saveEntitiesResponse(entityUidValueKey, results);
                                },
                                error: function () {
                                }
                            });
                        }
                        else { // получение кэшированного запроса
                        }
                    }
                    else {
                        //eql_fields = [];
                        //eql_functions = [];
                        token.getResult().setNeedsFieldOrOperand(2);
                    }
                }
                this.terminalClause(token);
            },

            operand: function (token) {
                var result = token.getResult();
                var operand;
                this.chewWhitespace(token);

                // If we have and in operator then we need either a function or an open paren
                if (result.getLastOperator() == 'in') {
                    result.setNeedsOpenParen(true);
                }
                operand = this.listOperand(token, true);
                if (operand.length == 0) {
                    operand = this.functionOperand(token);
                    if (operand.length == 0) {
                        operand = this.singleValueOperand(token);
                    }
                    else {
                        // We were handled by a function so we no longer need the open paren
                        result.setNeedsOpenParen(false);
                    }
                }
                else {
                    // We were handled by a list so we no longer need the open paren
                    result.setNeedsOpenParen(false);
                }
                if (REGEXP_COUNT.test(operand)) {
                    result.setCountFunc(true);
                    result.setNeedsField();

                    this.subquery(token); // подзапрос
                }
                if (operand == null || operand.length == 0) {
                    var remainingString = token.remainingString();
                    result.setLastOperand(remainingString, token);
                    result.setNeedsOperand();
                    token.setParseError();
                }
                if (operand && operand.length != 0) {
                    return operand;
                }
                return "";
            },

            // одиночный операнд
            singleValueOperand: function (token) {
                var operand = this.stringValue(token);
                var result = token.getResult();

                if (operand.length != 0) {
                    result.setLastFieldCountPrefix(operand);
                    result.setLastOperand(operand, token);
                    // Lets exclude empty and null, even though it is reserved
                    if (operand.toLowerCase() != "empty" && operand.toLowerCase() != "null" && this.isReservedWord(operand.toLowerCase())) {
                        // These are reserved words
                        token.setParseError();
                    }

                    if (REGEXP_PREFIX_DOT.test(operand)) {
                        result.setLastFieldHavePrefix();
                    }

                    if (REGEXP_ROOT.test(operand) || REGEXP_PARENT.test(operand)) {
                        if (REGEXP_ROOT.test(operand)) {
                            result.setPrefixRoot();
                        }

                        if (REGEXP_DOT.test(operand)) {
                            result.setNeedsChilds();
                        }
                        else {
                            result.setNeedsDot();
                        }
                    }
                    //check for string quotes match
                    if ((REGEXP_QUOTE_CHAR.test(operand[0]) && (operand[operand.length - 1] != operand[0])))
                        token.setParseError();
                    return operand;
                }
                return "";
            },

            // операнд-функция
            functionOperand: function (token) {
                var startIdx = token.getTokenStringIdx();
                var functionName = this.fieldOrFunctionName(token);
                // There can be whitespace between function name and arguments
                this.chewWhitespace(token);
                var listArguments = this.listOperand(token, false);

                if (functionName.length != 0 && listArguments.length != 0) {
                    var operand = functionName + listArguments;
                    if (REGEXP_COUNT.test(functionName)) {
                        token.getResult().setLastOperand(functionName, token);
                        token.backTrackToIdx(startIdx + functionName.length);

                        return functionName;
                    }
                    // read in the whole value until we reach a close )
                    token.getResult().setLastOperand(operand, token);

                    return operand;
                }
                else {
                    // back track
                    token.backTrackToIdx(startIdx);
                    return "";
                }
            },

            // операнд-список
            listOperand: function (token, treatAsOperands) {
                if (token.currentCharacter() == '(') {
                    token.consumeCharacter();
                    var listValue = this.collectListValues(token, treatAsOperands);
                    var operandVal = "(" + listValue;

                    this.chewWhitespace(token);
                    if (token.currentCharacter() == ')') {
                        token.consumeCharacter();
                        operandVal += ")";
                        if (operandVal == "()" && treatAsOperands) {
                            // Special case of an empty list which is still valid
                            token.getResult().setLastOperand(operandVal, token);
                        }
                        if (treatAsOperands) {
                            token.getResult().setOperandComplete();
                        }
                    }
                    else {
                        token.setParseError();
                    }
                    return operandVal;
                }
                else {
                    return "";
                }
            },

            // получение аргументов для списка
            collectListValues: function (token, treatAsOperands) {
                if (treatAsOperands) {
                    token.getResult().setNeedsOperand();
                }
                this.chewWhitespace(token);

                // grab the contents of the list, they should be singleValueOperands separated by commas, we only
                // need to keep track of the last encountered operand.
                var currentOperand = (treatAsOperands) ? this.operand(token) : this.stringValue(token);

                if (currentOperand.length != 0) {
                    // If there is whitespace then lets remember we need a comma
                    if (this.chewWhitespace(token) && treatAsOperands) {
                        token.getResult().setNeedsListComma();
                    }
                    if (token.currentCharacter() == ',') {
                        // Consume the comma and recurse so we can collect the other values
                        token.consumeCharacter();
                        var nextValue = this.collectListValues(token, treatAsOperands);
                        if (nextValue.length == 0) {
                            token.setParseError();
                        }

                        return currentOperand + ", " + nextValue;
                    }
                    else {
                        return currentOperand;
                    }
                }
                else {
                    return "";
                }
            },

            // проверка начал строк на равество (без учета регистра)
            startsWithIgnoreCase: function (startStr, str) {
                if (str == null || startStr == null || str.length < startStr.length) {
                    return false;
                }
                else {
                    return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
                }
            },

            // проверка строк на равество (без учета регистра)
            equalsIgnoreCase: function (str1, str2) {
                if (str1 == null || str2 == null || str1.length != str2.length) {
                    return false;
                }
                else {
                    return str1.toLowerCase() == str2.toLowerCase();
                }
            },

            // функция пропуска произвольного кол-ва пробелов
            chewWhitespace: function (token) {
                var foundWhiteSpace = false;
                var currentChar = token.currentCharacter();
                while (currentChar != null && REGEXP_WHITESPACE.test(currentChar)) {
                    currentChar = token.nextCharacter();
                    foundWhiteSpace = true;
                }
                return foundWhiteSpace;
            },

            // поиск оператора из списка по введенному значению
            getLongestOperatorMatch: function (value, listOfValues) {
                var longestMatch = null;
                for (var i = 0; i < listOfValues.length; i++) {
                    if (this.startsWithIgnoreCase(listOfValues[i].value, value)) {
                        // We found a match
                        if (longestMatch == null || eql_operators[i].value.length > longestMatch) {
                            longestMatch = eql_operators[i].value;
                        }
                    }
                }
                return longestMatch;
            },

            // получение значения без лишних пробелов
            getValueMinusExtraWhitespace: function (value) {
                if (value == null) {
                    return null;
                }
                var newValue = "";
                var firstWhitespace = true;
                var valueArr = value.split("");
                for (var i = 0; i < valueArr.length; i++) {
                    var currentChar = valueArr[i];
                    if (REGEXP_WHITESPACE.test(currentChar)) {
                        // We want to ignore extra whitespace, keeping only the first
                        if (firstWhitespace) {
                            firstWhitespace = false;
                            newValue = newValue + currentChar;
                        }
                    }
                    else {
                        // If we encounter a non-whitespace then we want to reset our firstWhitespace test
                        firstWhitespace = true;
                        newValue = newValue + currentChar;
                    }
                }
                return newValue;
            },

            // получение названия введенного поля/функции
            fieldOrFunctionName: function (token) {
                var stringValue = this.stringValue(token);
                // Field or function names can not be the empty string
                if (stringValue == "\"\"" || stringValue == "''") {
                    token.setParseError();
                }
                if (this.isReservedWord(stringValue.toLowerCase())) {
                    // These are reserved words
                    token.setParseError();
                }

                return stringValue;
            },

            // является ли зарезервированным словом (исключается из парсинга)
            isReservedWord: function (word) {
                return jQuery.inArray(word, eql_reserved_words) != -1;
            },

            // получение строкового операнда
            stringValue: function (token) {
                var stringValue = "";
                var inString = false;
                var currentChar = token.currentCharacter();

                //сheck first character for the quotation mark
                if (REGEXP_QUOTE_CHAR.test(currentChar)) {
                    inString = true;
                    stringValue += currentChar;
                    currentChar = token.nextCharacter();
                }

                while (currentChar != null && (inString || REGEXP_TOKEN_CHAR.test(currentChar))) {
                    // Check for illegal characters and kill the whole parse
                    if (REGEXP_SPECIAL_CHAR.test(currentChar) && !inString) {
                        token.setParseError();
                        break;
                    }

                    //Check absence escape chars before single quote 
                    if (REGEXP_QUOTE_CHAR.test(currentChar)) {
                        stringValue += currentChar;
                        if (REGEXP_QUOTE_CHAR.test(token.nextCharacter())) {
                            currentChar = token.currentCharacter();
                            if (stringValue[stringValue.length - 1] != currentChar) token.setParseError();
                        }
                        else {
                            inString = !inString;
                            break;
                        }
                    }
                    
                    stringValue += currentChar;
                    currentChar = token.nextCharacter();
                }//end while

                if (inString)
                    token.setParseError();
                return stringValue;
            },

            expressionQuery: function (token) {
                result = token.getResult();
                if (result.getCountFunc()) {
                    //имя сущности FROM ...
                    this.entity(token);
                    if (result.getLastField()) {
                        if (!token.isComplete()) {
                            this.getEntityFieldAjax(token);
                            result.setNeedsWhere();
                            //WHERE
                            this.entityOper(token);
                            if (!token.isComplete()) {
                                //выражение(подзапрос) после WHERE ...
                                this.whereSubquery(token);
                            }
                        }
                    }
                }
                else if (result.getReversQuery()) {
                    result.setNeedsEntityField();
                    //имя поля сущности SELECT ...
                    this.entityField(token);
                    if (result.getEntityField()) {
                        if (!token.isComplete()) {
                            this.entityOper(token);
                            //имя сущности FROM ...
                            this.entity(token);
                            if (result.getLastField()) {
                                if (!token.isComplete()) {
                                    result.setNeedsWhere();
                                    //WHERE
                                    this.entityOper(token);
                                    if (!token.isComplete()) {
                                        //выражение(подзапрос) после WHERE ...
                                        this.whereSubquery(token);
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    //имя сущности FROM ...
                    this.entity(token);
                    if (result.getLastField()) {
                        if (!token.isComplete()) {
                            result.setNeedsSelect();
                            //SELECT
                            this.entityOper(token);
                            if (!token.isComplete()) {
                                result.setNeedsEntityField();
                                //имя поля сущности SELECT ...
                                this.entityField(token);
                                if (result.getEntityField()) {
                                    if (!token.isComplete()) {
                                        result.setNeedsWhere();
                                        //WHERE
                                        this.entityOper(token);
                                        if (!token.isComplete()) {
                                            //выражение(подзапрос) после WHERE ...
                                            this.whereSubquery(token);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        token.setParseError();
                    }
                }


            },

            entityOper: function (token) {
                this.chewWhitespace(token);
                var entityName = this.fieldOrFunctionName(token);
                var result = token.getResult();

                if (entityName.length > 0) {
                    if (!REGEXP_SELECT.test(entityName) && !REGEXP_WHERE.test(entityName) && !REGEXP_FROM.test(entityName)) {
                        result.setLastFieldName(entityName, null, token);
                        result.setLastField(null);
                    }
                }
                else {
                    var remainingString = token.remainingString();
                    result.setLastFieldName(remainingString, null, token);
                    result.setLastField(null);
                    token.setParseError();
                }
            },

            entity: function (token) {
                this.chewWhitespace(token);
                var entity = null;
                var entityName = this.fieldOrFunctionName(token);
                var entityType = null;
                var result = token.getResult();

                if (entityName.length > 0) {
                    var curEqlEntities = eql_entities;

                    for (var i = 0; i < curEqlEntities.length; i++) {
                        if (this.equalsIgnoreCase(result.getUnquotedString(curEqlEntities[i].value), this.valueWithoutSquareBrackets(entityName))) {
                            entity = curEqlEntities[i];
                            entityType = curEqlEntities[i].types;
                            token.setLastUid(entityType[0]);
                            break;
                        }
                    }

                    result.setLastFieldName(entityName, entityType, token);
                    result.setLastField(entity);
                }
                else if (result.getEntityName() == null) {
                    var remainingString = token.remainingString();
                    result.setLastFieldName(remainingString, null, token);
                    result.setLastField(null);
                    token.setParseError();
                }
            },

            entityField: function (token) {
                this.chewWhitespace(token);
                var entityField = null;
                var entityFieldName = this.fieldOrFunctionName(token);
                var result = token.getResult();

                if (entityFieldName.length > 0) {
                    if (result.getReversQuery()) {
                        entityField = {
                            auto: true,
                            description: "",
                            displayName: "",
                            value: entityFieldName
                        };
                    }
                    else {
                        this.getEntityFieldAjax(token);

                        for (var i = 0; i < eql_entity_fields.length; i++) {
                            if (this.equalsIgnoreCase(result.getUnquotedString(eql_entity_fields[i].value), this.valueWithoutSquareBrackets(entityFieldName))) {
                                entityField = eql_entity_fields[i];
                                break;
                            }
                        }
                    }

                    result.setEntityField(entityField);
                    result.setEntityName(entityFieldName, token);
                }
                else if (result.getEntityName() == null) {
                    var remainingString = token.remainingString();
                    result.setEntityName(remainingString, token);
                    result.setNeedsEntityField();
                    token.setParseError();
                }
            },

            whereSubquery: function (token) {
                var parentUid = token.getInSubQueryParens() ? token.getLastUid(token.inSubQueryParens - 1) : that.objectUid;
                isSubQueryField = true;
                token.deleteTopLastUid();
                token.countWhere++;
                token.setParent({ fields: eql_fields, functions: eql_functions, uid: parentUid }); // запоминаем поля и функции текущей сущности (для восстановления лексики после закрывающей скобки подзапроса)
                eql_fields = eql_entity_fields;
                eql_functions = eql_entity_functions;
                token.getResult().setNeedsOpenParen(true);
                token.getResult().setNeedsFrom(false);
                token.setInSubQueryParens();

                token.getResult().resetCountExpression();
                token.getResult().resetTerminalClause();
                token.setInParens();
                token.getResult().setNeedsFieldOrOperand(1);

                if (lastFieldType != null) {
                    token.setParenType(1); // 1 = скобки подзапроса
                }
                token.getResult().setNeedsOpenParen(false);
                this.orClause(token);
                this.chewWhitespace(token);
                var remainingString = token.remainingString();
                if (this.startsWithIgnoreCase(")", remainingString)) {
                    token.setOutOfParens();
                    
                    token.setOutOfSubQueryParens();
                    if (token.getInSubQueryParens()) {
                        eql_fields = token.getParent().fields;
                        eql_functions = token.getParent().functions;
                    }
                        // восстанавливаем начальные поля и функции
                    else {
                        eql_fields = eql_fields_initial;
                        eql_functions = eql_functions_initial;
                    }
                    token.deleteTopParent();
                    token.countWhere--;
                }
                else {
                    token.setParseError();
                }
            },

            getEntityFieldAjax: function (token) {
                result = token.getResult();
                var fieldType = result.getLastField().types;
                if (fieldType != null) { // предлагаем сущности в качестве таблицы
                    var uid = fieldType[0];
                    // проверка кэша
                    if (!that.getSavedDataResponse(uid)) {
                        // запрос данных сущности
                        var data = { objectUid: uid, needOperators: false }; // objectUid - Uid типа объекта автокомплита
                        $.ajax({
                            url: serverDataUrl,
                            async: false,
                            data: data,
                            dataType: "json",
                            type: "GET",
                            success: function (response) {
                                if (response != null && response.fields != null) {
                                    eql_entity_fields = response.fields;
                                    eql_entity_functions = response.functions;
                                }
                                else {
                                    eql_entity_fields = [];
                                    eql_entity_functions = [];
                                }
                                that.saveDataResponse(uid, response); // кэширование
                            },
                        });
                    }
                    else { // получение кэшированного запроса
                        var cachedResponse = that.getSavedDataResponse(uid);
                        eql_entity_fields = cachedResponse.fields;
                        eql_entity_functions = cachedResponse.functions;
                    }
                }
            },

            valueWithoutSquareBrackets: function (value) {
                if (value.substring(0, 1) == "[") {
                    value = value.substring(1, value.length);
                }
                if (value.substring(value.length - 1, value.length) == "]") {
                    value = value.substring(0, value.length - 1);
                }
                return value;
            }

        };
    };

    var parser = options.parser ? options.parser : that.MyParser([]);

    // изменение позиции Dropdown с учетом изменения размера текстового поля
    that.fixDropdownPosition = function () {
        this.responseContainer.css({ top: this.field.outerHeight() + "px", width: this.field.innerWidth() + "px" });
    };

    // сохранение элементов HTML-списка
    that.pushSuggestionsOnHtmlStack = function (suggestions, suggestionNodes, htmlParts, mayNeedParenthesis, needHr, typeSug) {
        var length = suggestions.length;
        for (var i = 0; i < length; i++) {
            var actualValueSug;
            var displayNameSug;
            var resultSug;
            // We may have an object with displayName and value OR it may just be a string
            if (suggestions[i].value) {
                resultSug = suggestions[i].value;
                displayNameSug = suggestions[i].displayName;
            }
            else {
                resultSug = suggestions[i];
                displayNameSug = suggestions[i];
            }

            if (typeSug) {
                resultSug = $.inArray(resultSug.toLowerCase(), reserved_word) != -1 ? "[" + resultSug + "]" : resultSug;
            }

            if (result && mayNeedParenthesis && !suggestions[i].isInFunction) {
                // This is a hack that adds an initial ( when the value is the first completed in a list
                // We only do this for suggestions and not moreSuggestions since we know that this is
                // the position that the values will take, moreSuggestions will be function suggestions
                actualValueSug = ((result.getNeedsOpenParen()) ? "(" : "") + resultSug;
            }
            else {
                actualValueSug = resultSug;
            }
            suggestionNodes.push(actualValueSug);

            (suggestions[i].description == "") ?
                htmlParts.push('<li>', displayNameSug, '</li>') :
                htmlParts.push("<li title='", suggestions[i].description, "'>", displayNameSug, "</li>");
            if (i == length - 1 && needHr)
                htmlParts.push('<hr>');
        }
    };

    // сохранение подсказок в виде HTML-списка и добавление навигации/выбора подсказок посредством клавиатуры
    that.renderSuggestions = function (suggestions, moreSuggestions, operatorSuggestions) {
        var suggestionNodes = [];

        if (suggestions instanceof Array || operatorSuggestions instanceof Array) {
            var k = 0; // количество непустых блоков с подсказками
            if (moreSuggestions && moreSuggestions.length > 0)
                k++;
            if (operatorSuggestions && operatorSuggestions.length > 0)
                k++;
            if (suggestions && suggestions.length > 0)
                k++;

            if (k == 0)
                return suggestionNodes;

            var htmlParts = ['<ul>'];
            if (moreSuggestions && moreSuggestions.length > 0) {
                that.pushSuggestionsOnHtmlStack(moreSuggestions, suggestionNodes, htmlParts, true, k - 1);
                k--;
            }
            if (operatorSuggestions && operatorSuggestions.length > 0) {
                that.pushSuggestionsOnHtmlStack(operatorSuggestions, suggestionNodes, htmlParts, true, k - 1, true);
                k--;
            }
            if (suggestions && suggestions.length > 0) {
                that.pushSuggestionsOnHtmlStack(suggestions, suggestionNodes, htmlParts, true, k - 1, true);
            }
            htmlParts.push('</ul>');

            that.responseContainer
            .html(htmlParts.join(''))
            .find('li').each(function (i) {
                suggestionNodes[i] = [jQuery(this), suggestionNodes[i]];
            });

            that.addSuggestionControls(suggestionNodes);
        }

        return suggestionNodes;
    };

    // реакция на выбор подсказки из списка
    that.completeField = function (value) {
        var checkPrefix = REGEXP_PREFIX_NOT_DOT.test(value);
        if (checkPrefix) {
            value += ".";
        }
        var checkCount = REGEXP_COUNT.test(value);
        if (checkCount) {
            value += "(";
        }

        var start = that.getReplacementStartIndex(result, value);
        var end = that.getReplacementEndIndex(result, start);

        that.replaceValue(start, end, value);
        // при использовании функции DateTime вылазит popup
        if ((this.startsWithIgnoreCase('DateTime', value) || this.startsWithIgnoreCase('(DateTime', value)) && that.containsIgnoreCaseNullsMeanAll(",", value)) {
            datetimePopupOpen(options.postfix);
        }
        // при использовании функции WorkTime вылазит popup
        if ((this.startsWithIgnoreCase('WorkTime(', value) || this.startsWithIgnoreCase('(WorkTime(', value))) {
            worktimePopupOpen(options.postfix);
        }

        // Parse the whole thing again with the full string so we can set the parse/not parse indicator correctly, possibly a third parse, this is starting to get crazy
        var newToken = parser.parse(this.field.val());

        that.updateParseIndicator(newToken);

        if (checkPrefix || checkCount || value == ".") {
            that.field.keyup();
        }
    };

    // подготовка подсказок-операндов
    that.prepareOperandSuggestions = function (canAutoComplete, fieldName, functionSuggestions, operatorSuggestions, token, suggestedValue) {
        if (canAutoComplete) {
            var currentSuggestionCount = suggestionCount;
            var fieldValue = (suggestedValue == null) ? ((result.getLastOperand() == null) ? "" : that.stripEscapeCharacters(result.getLastOperand())) : suggestedValue;
            var fieldType = result.getLastFieldType();

            if (result.getLastFieldName() == "Id") {
                fieldType[0] = token.getInSubQueryParens() ? token.getLastUid(token.countSubUid - 2) : objectUid;
                fieldType[2] = entityUid;
                if (!token.getInSubQueryParens()) {
                    operatorSuggestions = [];
                }
            }

            if (fieldType[2] == entityUid) { // предлагаем сущности в качестве операндов
                var entityUidValueKey = fieldType[0] + ":" + fieldValue;
                // проверка кэша
                if (!that.getSavedEntitiesResponse(entityUidValueKey)) {
                    that.dropdownController.dropdown.removeClass("dropdown-ready");
                    $.ajax({
                        url: serverEntitiesUrl,
                        async: true,
                        data: { Uid: fieldType[0], entityValue: fieldValue },
                        dataType: "json",
                        type: "GET",
                        success: function (response) {
                            var results;
                            if (response != null && response.results != null) {
                                results = response.results;
                            }
                            else {
                                results = [];
                            }
                            // кэширование
                            that.saveEntitiesResponse(entityUidValueKey, results);
                            that.renderSuggestionsForOperands(fieldValue, results, functionSuggestions, operatorSuggestions, currentSuggestionCount);
                        },
                        error: function () {
                            that.renderSuggestionsForOperands(fieldValue, [], functionSuggestions, operatorSuggestions, currentSuggestionCount);
                        }
                    });
                }
                else { // получение кэшированного запроса
                    that.renderSuggestionsForOperands(fieldValue, that.getSavedEntitiesResponse(entityUidValueKey), functionSuggestions, operatorSuggestions, currentSuggestionCount);
                }
            }
            else {  // предлагаем значения поля в качестве операндов
                that.renderSuggestionsForOperands(fieldValue, [], functionSuggestions, operatorSuggestions, currentSuggestionCount); // удалить это при раскоментировании запросов значений с сервера выше
            }
        }
        else {
            // We should at least render the function suggestions
            that.renderSuggestionsForOperands(that.stripEscapeCharacters(result.getLastOperand()), [], functionSuggestions, operatorSuggestions, suggestionCount);
        }
    };

    that.dispatcher = function (val) {
        this.fixDropdownPosition();
        var that = this;
        var selectionRange = jQuery(that.field).selectionRange();
        var parseValue = val.substring(0, selectionRange.start);

        var token = parser.parse(parseValue);
        result = token.getResult();
        
        var lastFieldName = result.getLastFieldNameWithoutPrefix();
        var currentEqlFields = token.getParentByLastFieldType();
        var eqlAddPrefix = [];
        var arrayTokens = result.getTokens();
        if (token.inSubQueryParens && result.getNeedsFieldOrOperand() != 2) {
            if (!result.getNeedsChilds()) {
                if ((result.getNeedsField() || result.getNeedsOperand())
                    && (result.countExpression <= 1 || result.getNeedsOpenParen() || arrayTokens[arrayTokens.length - 1] == "(")
                    && result.getNeedsFrom()) {
                    eqlAddPrefix = eqlAddPrefix.concat(eql_predicates_from);
                    if (!result.getCountFunc()) {
                        eqlAddPrefix = eqlAddPrefix.concat(eql_predicates_select);
                    }
                }
                if (token.inSubQueryParens - token.countWhere - (result.getCountFunc() ? 1 : 0) > 0) {
                    eqlAddPrefix = eqlAddPrefix.concat(eql_prefix_root);
                }
            }
            if (token.inSubQueryParens - token.countWhere - (result.getCountFunc() ? 1 : 0) > (result.getNeedsOperand() ? result.getLastOperandCountPrefix() : result.getLastFieldCountPrefix()) && !result.getPrefixRoot()) {
                eqlAddPrefix = eqlAddPrefix.concat(eql_prefix_parent);
            }
        }

        // We will always make a suggestion from here so lets increment the count
        suggestionCount++;
        // In this case we suggest fields, operators, operands, logical operators
        if (result.getNeedsField()) {
            if (result.getNeedsDot()) {
                that.renderSuggestionsFromMap("", eql_dot, [], token);
            }
            else if (result.getNeedsChilds()) {
                that.renderSuggestionsFromMap("", currentEqlFields, eqlAddPrefix, token);
            }
            else {
                if (!result.getCountFunc()) {
                    eqlAddPrefix = eql_count_function.concat(eql_not_logical_operator.concat(eqlAddPrefix));
                }
                that.renderSuggestionsFromMap(that.stripEscapeCharacters(lastFieldName), currentEqlFields, eqlAddPrefix, token);
            }
        }
        else if (result.getCountFunc()) {
            if (result.getIsQuery()) {
                if (result.getNeedsEntity()) {
                    that.renderSuggestionsFromMap(result.getLastFieldName(), eql_entities_initial);
                }
                else if (result.getNeedsWhere()) {
                    that.renderSuggestionsFromMap(result.getLastFieldName(), [], eql_predicates_where);
                }
                else if (result.getNeedsEntityField()) {
                    that.renderSuggestionsFromQuery(result.getLastFieldName(), token);
                }
            }
            else {
                eqlAddPrefix = eqlAddPrefix.concat(eql_predicates_from);
                //var functionSug = (that.isNullOrEmptyOperator(result.getLastOperator())) ? (that.isCollectionField(fieldType2)) ? empty_list : empty_operand : eql_functions;
                that.renderSuggestionsFromMap(that.stripEscapeCharacters(result.getLastOperand()), currentEqlFields, eql_count_function.concat(eqlAddPrefix), token);
            }
        }
        else if (result.getNeedsOperator()) {
            that.renderSuggestionsForOperators(result.getLastOperator(), eql_operators);
        }
        else if (result.getNeedsOperand()) {
            var fieldName = result.getLastFieldName();
            var field = result.getLastField();
            var fieldType2;
            if (field != null) {
                fieldType2 = field.types[1];
            }

            var canAutoComplete = false;
            // If we know that we are only suggesting empty then we do not need to suggest values
            if (!that.isNullOrEmptyOperator(result.getLastOperator()) && field != null) {
                canAutoComplete = field.auto;
            }

            var functionSuggestions = (that.isNullOrEmptyOperator(result.getLastOperator())) ? (that.isCollectionField(fieldType2)) ? empty_list : empty_operand : eql_functions;
            var fieldSuggestions = (that.isNullOrEmptyOperator(result.getLastOperator())) ? [] : eql_fields;

            if (result.getNeedsDot()) {
                that.renderSuggestionsFromMap("", eql_dot);
            }
            else {
                if (result.getNeedsChilds()) {
                    fieldSuggestions = currentEqlFields;
                }
                functionSuggestions = functionSuggestions.concat(eqlAddPrefix);
                that.prepareOperandSuggestions(canAutoComplete, fieldName, functionSuggestions, fieldSuggestions, token);
            }
        }
        else if (result.getNeedsLogicalOperator()) {
            that.renderSuggestionsFromMap(result.getLastLogicalOperator(), [], eql_logical_operators);
        }
        else if (result.getIsQuery()) {
            if (result.getNeedsEntity()) {
                that.renderSuggestionsFromMap(result.getLastFieldName(), eql_entities_initial);
            }
            else if (result.getNeedsSelect()) {
                that.renderSuggestionsFromMap(result.getLastFieldName(), [], eql_predicates_select);
            }
            else if (result.getNeedsWhere()) {
                that.renderSuggestionsFromMap(result.getLastFieldName(), [], eql_predicates_where);
            }
            else if (result.getNeedsEntityField()) {
                that.renderSuggestionsFromQuery(result.getLastFieldName(), token);
            }
        }
        else {
            that.dropdownController.hideDropdown();
        }

        // Need to update the parse/not parse indicator
        that.parse(val);
    };

    // преобразование строки с пропуском "\\"
    that.stripEscapeCharacters = function (val) {

        if (val == null) {
            return val;
        }
        var newVal = "";
        var strArr = val.split("");
        for (var i = 0; i < strArr.length; i++) {
            if (strArr[i] == '\\') {
                // If we are a unicode string then we just consume it like normal
                if (!REGEXP_UNICODE.test(val.substring(i, val.length))) {
                    // Just chew past the escape and use the next char, the parser has already made sure this is cool
                    i++;
                    if (i >= val.length) {
                        break;
                    }
                }
            }
            newVal += strArr[i];
        }
        return newVal;
    };

    // парсинг
    that.parse = function (val) {
        var newToken = parser.parse(val);
        that.updateParseIndicator(newToken);
        return newToken.getResult();
    };

    that.renderSuggestionsFromMap = function (stringVal, list, otherSuggestions, token) {
        if (!otherSuggestions) {
            otherSuggestions = {};
        }

        var suggestions = that.slimListForMapResults(stringVal, list);
        var relevantOtherSuggestions = that.slimListForMapResults(stringVal, otherSuggestions);
        that.convertListForDisplay(relevantOtherSuggestions);
        that.convertListForDisplay(suggestions);

        var arrayTokens = result.getTokens();
        if (result.getNeedsField() && result.getNeedsFieldOrOperand() != 1 && !result.getNeedsLogicalOperator() && token.getInSubQueryParens()
            && (arrayTokens[arrayTokens.length - 2] == "in" || arrayTokens[arrayTokens.length - 3] == "in")) {
            var fieldValue = result.getLastFieldName() == null ? "" : result.getLastFieldName();
            var fieldType = result.getLastField() == null ? null : result.getLastField().types;
            if (fieldType == null) {
                var parentFields = token.parents[token.countSubUid - 1].fields;
                for (var i = 0; i < parentFields.length; i++) {
                    if (parentFields[i].value == arrayTokens[arrayTokens.length - 3]) {
                        fieldType = parentFields[i].types;
                    }
                }
            }

            if (fieldType[2] == entityUid) { // предлагаем сущности в качестве операндов
                var data = { Uid: fieldType[0], entityValue: fieldValue };
                var entityUidValueKey = fieldType[0] + ":" + fieldValue;
                // проверка кэша
                if (!that.getSavedEntitiesResponse(entityUidValueKey)) {
                    that.dropdownController.dropdown.removeClass("dropdown-ready");
                    $.ajax({
                        url: serverEntitiesUrl,
                        async: true,
                        data: data,
                        dataType: "json",
                        type: "GET",
                        success: function (response) {
                            var results;
                            if (response != null && response.results != null) {
                                results = response.results;
                            }
                            else {
                                results = [];
                            }
                            // кэширование
                            that.saveEntitiesResponse(entityUidValueKey, results);
                            that.renderSuggestions(suggestions, relevantOtherSuggestions, results.concat(that.slimListForFunctionResults(stringVal, eql_functions, "in")));
                        },
                        error: function () {
                            that.renderSuggestions(suggestions, relevantOtherSuggestions, that.slimListForFunctionResults(stringVal, eql_functions, "in"));
                        }
                    });
                }
                else { // получение кэшированного запроса
                    that.renderSuggestions(suggestions, relevantOtherSuggestions, that.getSavedEntitiesResponse(entityUidValueKey).concat(that.slimListForFunctionResults(stringVal, eql_functions, "in")));
                }
            }
            else {  // предлагаем значения поля в качестве операндов
                that.renderSuggestions(suggestions, relevantOtherSuggestions, that.slimListForFunctionResults(stringVal, eql_functions, result.getLastOperator()));
            }
        }
        else {
            var eql_func = [];
            if (result.getCountFunc() && !result.getLastFieldHavePrefix() && result.getNeedsField()) {
                eql_func = that.slimListForFunctionResults(stringVal, eql_functions, "in");
            }
            that.renderSuggestions(suggestions, relevantOtherSuggestions, eql_func);
        }
    };

    that.renderSuggestionsFromQuery = function (stringVal, token) {
        if (result.getNeedsEntityField()) {
            var lastField = result.getLastField();
            var fieldValue = result.getEntityName() == null ? "" : result.getEntityName();
            var fieldType = lastField == null ? null : lastField.types;
            var lastFieldValue = lastField == null ? "" : lastField.value;
            if (fieldType != null && lastFieldValue != "Id") { // предлагаем сущности в качестве таблицы
                var uid = fieldType[0];
                // проверка кэша
                if (!that.getSavedDataResponse(uid)) {
                    // запрос данных сущности
                    var data = { objectUid: uid, needOperators: false }; // objectUid - Uid типа объекта автокомплита
                    $.ajax({
                        url: serverDataUrl,
                        async: true,
                        data: data,
                        dataType: "json",
                        type: "GET",
                        success: function (response) {
                            if (response != null && response.fields != null) {
                                eql_entity_fields = response.fields;
                                eql_entity_functions = response.functions;
                            }
                            else {
                                eql_entity_fields = [];
                                eql_entity_functions = [];
                            }
                            that.saveDataResponse(uid, response); // кэширование
                            that.partitionFields(fieldValue, token);
                        },
                    });
                }
                else { // получение кэшированного запроса
                    var cachedResponse = that.getSavedDataResponse(uid);
                    eql_entity_fields = cachedResponse.fields;
                    eql_entity_functions = cachedResponse.functions;
                    that.partitionFields(fieldValue, token);
                }
            }
            else {
                that.dropdownController.hideDropdown();
            }
        }
    };

    that.getSuggestionsForOperators = function (stringVal, list) {
        var suggestions = that.slimListForMapResults(stringVal, list);
        var supportedOperatorsType;
        if (result.getLastField() != null) {
            supportedOperatorsType = result.getLastField().types;
        }

        var supportedOperators = [];
        if (supportedOperatorsType) {
            for (var i = 0; i < eql_fieldoperators.length; i++) {
                for (var j = 0; j < supportedOperatorsType.length; j++) {
                    if (jQuery.inArray(supportedOperatorsType[j], eql_fieldoperators[i].types) > -1) {
                        supportedOperators = $.merge(supportedOperators, eql_fieldoperators[i].operators);
                        break;
                    }
                }
            }
        }
        // Now lets run through the remaining list and if we can identify the field we can see if that field
        // supports which operators
        if (supportedOperators) {
            suggestions = jQuery.grep(suggestions, function (arrValue) {
                return jQuery.inArray(arrValue.value, supportedOperators) > -1;
            });
        }
        else suggestions = []; // если операторы для данного типа не описаны
        return suggestions;
    };

    that.renderSuggestionsForOperators = function (stringVal, list) {
        var suggestions = that.getSuggestionsForOperators(stringVal, list);
        that.convertListForDisplay(suggestions);
        that.renderSuggestions([], suggestions);
        if (suggestions.length == 0) {
            that.dropdownController.hideDropdown();
        }
    };

    that.renderSuggestionsForOperands = function (stringVal, ajaxSuggestions, functions, fields, providedSuggestionCount) {
        // Only render the suggestions if we are the current suggestion
        if (providedSuggestionCount == suggestionCount) {
            // Don't need to slim the ajaxSuggestions since they came from the server slimmed down    
            var functionsSuggestions = that.slimListForFunctionResults(stringVal, functions, result.getLastOperator());
            var fieldsSuggestions = that.slimListForFieldResults(stringVal, fields, result.getLastOperator());

            that.convertListForDisplay(functionsSuggestions);
            that.convertListForDisplay(fieldsSuggestions);
            that.convertListForDisplay(ajaxSuggestions);
            that.renderSuggestions(ajaxSuggestions, functionsSuggestions, fieldsSuggestions);
        }
    };

    // This converts the list to be value/displayName. 
    that.convertListForDisplay = function (list) {
        if (list.length == 0) {
            return;
        }

        for (var i = 0; i < list.length; i++) {
            if (!list[i].displayName) {
                list[i] = { value: list[i], displayName: list[i] };
            }
        }
    };

    // получение индекса начала для замены значения на выбранное
    that.getReplacementStartIndex = function (result, value) {
        var jQueryReference = jQuery(this.field);
        var start;
        if (result.getNeedsField()) {
            var lastFieldLength = result.getLastFieldName() == null ? 0 : result.getLastFieldName().length;
            var lastFieldNameStartIndex = result.getLastFieldNameStartIndex();
            
            if (lastFieldNameStartIndex == null) {
                lastFieldNameStartIndex = jQuery(this.field).selectionRange().end;
            }
            if (result.getNeedsDot() || result.getNeedsChilds()) {
                start = lastFieldNameStartIndex + lastFieldLength;
            }
            else {
                lastFieldLength -= lastFieldLength > 0 ? result.getStringAfterDot(result.getLastFieldName()).length : 0;
                start = lastFieldNameStartIndex + lastFieldLength;
            }
        }
        else if (result.getNeedsEntity() || result.getNeedsSelect() || result.getNeedsWhere()) {
            start = result.getLastFieldNameStartIndex();
        }
        else if (result.getNeedsEntityField()) {
            start = result.getEntityNameStartIndex();
        }
        else if (result.getNeedsOperand()) {
            var lastOperandLength = result.getLastOperand() == null ? 0 : result.getLastOperand().length;
            if (result.getNeedsDot() || result.getNeedsChilds()) {
                start = result.getLastOperandStartIndex() + lastOperandLength;
            }
            else {
                lastOperandLength -= lastOperandLength > 0 ? result.getStringAfterDot(result.getLastOperand()).length : 0;
                start = result.getLastOperandStartIndex() + lastOperandLength;
            }
        }
        else if (result.getNeedsOperator()) {
            start = result.getLastOperatorStartIndex();
        }
        else if (result.getNeedsLogicalOperator()) {
            if (result.getLastLogicalOperatorStartIndex() != null && result.getLastLogicalOperatorStartIndex() != 0) {
                start = result.getLastLogicalOperatorStartIndex();
            }
            else {
                start = jQueryReference.selectionRange().start - 1;
            }
        }
        else {
            start = jQueryReference.selectionRange().start - 1;
        }
        // sanity check
        return start != null ? start : jQueryReference.selectionRange().start;
    };

    // получение индекса конца для замены значения на выбранное
    that.getReplacementEndIndex = function (result, start) {
        var jQueryReference = jQuery(this.field);
        var selectionRange = jQueryReference.selectionRange();
        var end = null;
        // We only need to do a second parse if we have no highlighted selection AND we are not at the end of the input string
        // otherwise we just use the selectionEnd
        if (selectionRange.start == selectionRange.end && selectionRange.end != this.field.val().length) {
            // Lets get the token number from the first parse, this is the token we are currently on
            var currentTokenIdx = result.getTokens().length - 1;

            // Parse it again, but this time the full string so we know what the full token is that we are trying to replace
            // with the selected completion
            var token = parser.parse(this.field.val());
            if (!token.getParseError()) {
                // The user has not highlighted text so lets assume we are completing to the end of the current token
                // Ask the newly parsed result for the complete token we are in the middle of
                var fullTokenValue = token.getResult().getTokens()[currentTokenIdx];
                // This is a special case, we don't want to replace the '(' or ')' instead we want to add inside
                if (fullTokenValue != null && fullTokenValue != '(' && fullTokenValue != ')') {
                    var fullTextVal = this.field.val();
                    // Lets get the start position in the string
                    var remainingString = fullTextVal.substring(start, fullTextVal.length);
                    // We know that we are going to see the fullTokenValue next, but there may be some whitespace between
                    // here and there, lets make sure we ditch the whitespace as well.
                    var remainingStringArr = remainingString.split("");
                    var whitespaceCount = 0;
                    for (var i = 0; i < remainingStringArr.length; i++) {
                        if (REGEXP_WHITESPACE.test(remainingStringArr[i])) {
                            whitespaceCount++;
                        }
                        else {
                            // Stop as soon as we no longer see whitespace
                            break;
                        }
                    }
                    end = start + fullTokenValue.length + whitespaceCount;
                }
            }
        }

        if (end == null) {
            end = selectionRange.end;
        }
        // As the start position could have been incremented to account for spaces in operators
        // e.g. was not in, it is feasible that end may be less than start so a quick check is in order.
        // If start is less than end pad with a space (one is sufficient)
        if (end < start) {
            that.replaceValue(start, end, " ");
            end = start;
        }
        return end;
    };

    // размещение(замена) выбранной подсказки
    that.replaceValue = function (start, end, newValue) {
        var jQueryReference = jQuery(this.field);
        // Lets reset the selection range to include the characters that the user has already typed
        jQueryReference.selectionRange(start, end);
        // Lets replace the value with the autocomplete selected value
        jQueryReference.selection(newValue);
        // Lets stop the replaced bit from being highlighted
        var newEnd = jQueryReference.selectionRange().end;
        jQueryReference.selectionRange(newEnd, newEnd);
    };

    that.slimListForMapResults = function (stringVal, list) {
        var slimedList = jQuery.grep(list, function (arrValue) {
            return that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName.split('<')[0]);
        });

        return slimedList;
    };

    // выбор функций-подсказок для соответствующего типа поля
    that.slimListForFunctionResults = function (stringVal, list, operator) {
        var fieldName = result.getLastFieldName();
        var supportedTypes;
        stringVal = result.getStringAfterDot(stringVal);
        if (result.getLastField() != null) {
            supportedTypes = result.getLastField().types;
        }

        var slimedList = jQuery.grep(list, function (arrValue) {
            if (result.getCountFunc() && arrValue.isInFunction) {
                return that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName);
            }

            if (REGEXP_PREFIX_FIELD.test(arrValue.value)) {
                return that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.value);
            }
            else {
                if (supportedTypes && !(arrValue.isInFunction && (operator != 'in' || !result.getNeedsOpenParen())) && result.getLastFieldCountPrefix() == 0) {
                    // Need to check for Object since this means we always fit
                    var supportsFunction = jQuery.inArray("Object", arrValue.types) > -1 || jQuery.inArray("Object", supportedTypes) > -1;
                    for (var i = 0; i < supportedTypes.length && !supportsFunction; i++) {
                        supportsFunction = jQuery.inArray(supportedTypes[i], arrValue.types) != -1 && arrValue.value != fieldName;
                    }
                    if (!supportsFunction) {
                        return false;
                    }
                }
                else {
                    // Can't find the field so we know that no functions will work with it
                    return false;
                }
            }
            return that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName);
        });

        return slimedList;
    };

    // выбор однотипных полей для соответствующего типа поля
    that.slimListForFieldResults = function (stringVal, list, operator) {
        stringVal = result.getStringAfterDot(stringVal);

        var supportedTypes;
        var isNameId;
        if (result.getLastField() != null) {
            supportedTypes = result.getLastField().types;
            isNameId = this.equalsIgnoreCase(result.getLastField().value, "id");
        }

        var slimedList = jQuery.grep(list, function (arrValue) {
            if (/^(PARENT|ROOT)$/i.test(arrValue.value)) {
                return that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.value);
            }
            else {
                if (that.isListSupportingOperator(operator)) {
                    return false;
                }
                if (supportedTypes) {
                    // выбираем только однотипные поля
                    // кроме самого себя
                    if (result.getLastFieldName() != null && !result.getLastFieldHavePrefix() && arrValue.value.toLowerCase() == result.getLastFieldName().toLowerCase()
                        || supportedTypes.length < arrValue.types.length) {
                        return false;
                    }
                    // проверка на полное совпадение типов
                    for (var i = 0; i < supportedTypes.length; i++) {
                        if (i == 1 && supportedTypes[i] != null && supportedTypes[i] != 0) { continue; } // закоментировать, если не нужно предлагать однотипные поля-неколлекции для коллекций с тем же типом элементов
                        if (i == 1 && isNameId) { continue; }
                        if (supportedTypes[i] != arrValue.types[i]) {
                            return false;
                        }
                    }
                }
                else {
                    // Can't find the field so we know that no field will work with it
                    return false;
                }
            }
            return that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || that.containsIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName.split('<')[0]);
        });

        return slimedList;
    };

    // поддерживает ли оператор список в качестве операнда
    that.isListSupportingOperator = function (operator) {
        return operator == 'in';
    };

    // если оператору нужен только NULL/EMPTY в качестве операнда
    that.isNullOrEmptyOperator = function (operator) {
        return operator == 'is';
    };

    // если тип поля - коллекция элементов какого-либо типа
    that.isCollectionField = function (fieldType2) {
        return fieldType2 && fieldType2 != 0;
    };

    // проверка начал строк на равенство (без учета регистра, NULL значения учитываюся)
    that.containsIgnoreCaseNullsMeanAll = function (startStr, str) {
        // In this case we want all elements of the list included
        if (str == null || startStr == null) {
            return true;
        }
        if (str.length < startStr.length) {
            return false;
        }
        else {
            for (var i = 0; i < str.length - startStr.length + 1; i++) {
                if (startStr.toLowerCase() == str.substr(i, startStr.length).toLowerCase()) {
                    return true;
                }
            }
            return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
        }
    };

    // проверка строк на равенство (без учета регистра)
    that.equalsIgnoreCase = function (str1, str2) {
        if (str1 == null && str2 == null) {
            return true;
        }
        else if (str1 == null || str2 == null || str1.length != str2.length) {
            return false;
        }
        else {
            return str1.toLowerCase() == str2.toLowerCase();
        }
    };

    // проверка начал строк на равенство (без учета регистра)
    that.startsWithIgnoreCase = function (startStr, str) {
        if (str == null || startStr == null || str.length < startStr.length) {
            return false;
        }
        else {
            return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
        }
    };

    // проверка оператора на правильность
    that.isInvalidOperator = function (operator) {
        for (var i = 0; i < eql_operators.length; i++) {
            if (eql_operators[i].value == operator) {
                return false;
            }
        }
        return true;
    };

    // обновление индикатора парсинга
    that.updateParseIndicator = function (token) {
        if (token.getParseError()) {
            parseErrorImg.show();
            parseGoodImg.hide();
            parseErrorMsg.html(token.getResult().getParseErrorMsg());
        }
        else {
            parseErrorImg.hide();
            parseErrorMsg.hide();
            parseGoodImg.show();
        }
    };

    that.partitionFields = function (fieldValue, token) {
        var parentField = [],
            partOne = [],
            partTwo = [];

        if (result.getLastFieldType() != null) {
            var parentFieldType = token.getLastUid(token.countSubUid - 2);

            parentField.push(result.getLastFieldType()[0]);
            parentField.push(result.getLastFieldType()[2]);

            for (var i = 0; i < eql_entity_fields.length; i++) {
                if (eql_entity_fields[i].value == "Id") {
                    if (result.getLastFieldType()[0] == parentFieldType || result.getLastFieldType()[2] == parentFieldType) {
                        partOne.push(eql_entity_fields[i]);
                    }
                    else {
                        partTwo.push(eql_entity_fields[i]);
                    }
                }
                else {
                    if (eql_entity_fields[i].types[0] == parentFieldType) {
                        partOne.push(eql_entity_fields[i]);
                    }
                    else {
                        partTwo.push(eql_entity_fields[i]);
                    }
                }

            }

            that.renderSuggestions(that.slimListForMapResults(fieldValue, partTwo), [], that.slimListForMapResults(fieldValue, partOne));
        }
    };

    that.FieldIsId = function (entity, value) {
        for (var i = 0; i < entity.length; i++) {
            if (entity[i].value == "Id" && value == entity[i].types[0])
                return true;
        }

        return false;
    };

    that.ParseResult = function () {

        var tokens = [];
        var tokenIdx = 0;

        return {
            // получить массив токенов
            getTokens: function () {
                return tokens;
            },

            // добавить токен в массив токенов
            addToken: function (token) {
                tokens[tokenIdx++] = token;
            },

            // последнее поле
            setLastField: function (lastField) {
                this.lastField = lastField;
            },

            getLastField: function () {
                return this.lastField;
            },

            // последнее введенное имя поля
            setLastFieldName: function (lastFieldName, lastFieldType, token) {
                this.fieldNameStartIndex = (lastFieldName == null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastFieldName.length);
                this.lastFieldName = this.getUnquotedString(lastFieldName);
                this.lastFieldType = lastFieldType;
                tokens[tokenIdx++] = lastFieldName;
            },

            getLastFieldName: function () {
                return this.lastFieldName;
            },

            getLastFieldNameWithoutPrefix: function () {
                return this.getStringAfterDot(this.lastFieldName);
            },

            getLastFieldType: function () {
                return this.lastFieldType;
            },

            getLastFieldNameStartIndex: function () {
                return this.fieldNameStartIndex;
            },

            // признак необходимости поля
            setNeedsField: function () {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsField = true;
                this.needsListComma = false;
            },

            getNeedsField: function () {
                return this.needsField;
            },

            // признак необходимости запятой в списке
            setNeedsListComma: function () {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsField = false;
                this.needsListComma = true;
            },

            getNeedsListComma: function () {
                return this.needsListComma;
            },

            // последний введенный оператор
            setLastOperator: function (lastOperator, startIndex) {
                this.lastOperator = lastOperator;
                this.operatorStartIndex = startIndex;
                tokens[tokenIdx++] = lastOperator;
            },

            getLastOperator: function () {
                return this.lastOperator;
            },

            getLastOperatorStartIndex: function () {
                return this.operatorStartIndex;
            },

            // последний введенный операнд
            setLastOperand: function (lastOperand, token) {
                this.operandStartIndex = (lastOperand == null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastOperand.length);
                this.lastOperand = this.getUnquotedString(lastOperand);
                tokens[tokenIdx++] = lastOperand;
            },

            getLastOperand: function () {
                return this.lastOperand;
            },

            // признак необходимости операнда
            setNeedsOperand: function () {
                this.needsField = false;
                this.needsOperator = false;
                this.needsLogicalOperator = false;
                this.needsOperand = true;
                this.needsListComma = false;
            },

            getNeedsOperand: function () {
                return this.needsOperand;
            },

            // индекс последнего введенного операнда
            setLastOperandStartIndex: function (index) {
                this.operandStartIndex = index;
            },

            getLastOperandStartIndex: function () {
                return this.operandStartIndex;
            },

            // последний введенный логический оператор
            setLastLogicalOperator: function (lastLogicalOperator, startIndex) {
                this.lastLogicalOperator = lastLogicalOperator;
                this.logicalOperatorStartIndex = startIndex;
                tokens[tokenIdx++] = lastLogicalOperator;
            },

            getLastLogicalOperator: function () {
                return this.lastLogicalOperator;
            },

            getLastLogicalOperatorStartIndex: function () {
                return this.logicalOperatorStartIndex;
            },

            // признак необходимости оператора           
            setNeedsOperator: function () {
                this.needsField = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOperator = true;
                this.needsListComma = false;
            },

            getNeedsOperator: function () {
                return this.needsOperator;
            },

            // признак необходимости логического оператора 
            setNeedsLogicalOperator: function () {
                this.needsLogicalOperator = true;
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsField = false;
                this.needsListComma = false;
                this.countFunc = false;
            },

            getNeedsLogicalOperator: function () {
                return this.needsLogicalOperator;
            },

            // признак необходимости открывающей скобки
            setNeedsOpenParen: function (value) {
                this.needsOpenParen = value;
            },

            getNeedsOpenParen: function () {
                return this.needsOpenParen;
            },

            // сброс логических операиций
            resetLogicalOperators: function () {
                this.lastLogicalOperator = null;
                this.logicalOperatorStartIndex = null;
                this.needsLogicalOperator = null;
            },

            // получение значения стоки без кавычек
            getUnquotedString: function (value) {
                // We only remove the last quote if it is NOT preceeded by an escape character
                var secondToLastNotEsacape = value != null && value.length >= 3 && value.charAt(value.length - 2) != '\\';

                if (value != null && value.charAt(0) == '"') {
                    value = value.substring(1, value.length);

                    if (value.charAt(value.length - 1) == '"' && secondToLastNotEsacape) {
                        value = value.substring(0, value.length - 1);
                    }
                }
                else if (value != null && (value.charAt(0) == "'" || value.charAt(0) == "’")) {
                    value = value.substring(1, value.length);

                    if ((value.charAt(value.length - 1) == "'" || value.charAt(value.length - 1) == "’") && secondToLastNotEsacape) {
                        value = value.substring(0, value.length - 1);
                    }
                }

                return value;
            },

            // установка ошибки парсинга результата
            setParseError: function (message) {
                this.parseError = true;
                this.parseErrorMsg = message;
            },

            getParseError: function () {
                return this.parseError;
            },

            getParseErrorMsg: function () {
                return this.parseErrorMsg;
            },

            // ничего не требуется
            setNeedsNothing: function () {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsField = false;
                this.needsOpenParen = false;
                this.needsListComma = false;
                this.countFunc = false;
            },

            // признак необходимости поля
            setNeedsDot: function () {
                this.needsDot = true;
            },

            getNeedsDot: function () {
                return this.needsDot;
            },

            //признак необходимости потомка
            setNeedsChilds: function () {
                this.needsChilds = true;
            },

            getNeedsChilds: function () {
                return this.needsChilds;
            },

            // установка признака конца опервнда (для списка)
            setOperandComplete: function () {
                this.operandComplete = true;
            },

            getOperandComplete: function () {
                return this.operandComplete;
            },

            //уровень вложенности parent.
            setLastFieldCountPrefix: function (str) {
                this.lastFieldCountPrefix = str.split(".").length - 1;
            },

            getLastFieldCountPrefix: function () {
                return this.lastFieldCountPrefix;
            },

            getLastOperandCountPrefix: function () {
                return this.lastOperand == null ? 0 : this.lastOperand.split(".").length - 1;
            },

            //имеет ли выражение префикс
            setLastFieldHavePrefix: function () {
                this.lastFieldHavePrefix = true;
            },

            getLastFieldHavePrefix: function () {
                return this.lastFieldHavePrefix;
            },

            //строка без префиксов
            getStringAfterDot: function (str) {
                return str ? str.slice(str.lastIndexOf(".") + 1) : str;
            },

            //строка без префиксов
            getStringAfterCount: function (str) {
                return str ? str.slice(str.lastIndexOf("(") + 1) : str;
            },

            //корневой префикс
            setPrefixRoot: function () {
                this.prefixRoot = true;
            },

            getPrefixRoot: function () {
                return this.prefixRoot;
            },

            //0 - поле или операнд, 1 - поле, 2 - операнд 
            setNeedsFieldOrOperand: function (flag) {
                this.needsFieldOrOperand = flag;
            },

            getNeedsFieldOrOperand: function () {
                return this.needsFieldOrOperand;
            },

            //сбросить поле
            resetLastField: function () {
                this.lastFieldName = null;
                this.lastFieldType = null;
                this.lastField = null;
            },

            //сущность для запроса
            setNeedsEntity: function () {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsField = false;
                this.needsOpenParen = false;
                this.needsListComma = false;
                this.needsEntity = true;
                this.needsSelect = false;
                this.needsEntityField = false;
            },

            getNeedsEntity: function () {
                return this.needsEntity;
            },

            //в запросе
            setIsQuery: function () {
                this.isQuery = true;
            },

            getIsQuery: function () {
                return this.isQuery;
            },

            setEntity: function (entity) {
                this.entity = entity;
                this.entityName = entity.value;
            },

            getEntity: function () {
                return this.entity;
            },

            setEntityName: function (value, token) {
                var valueLength = value == null ? 0 : value.length;
                this.entityNameStartIndex = (this.entity == null) ? (token.getTokenStringIdx() - valueLength) : token.getMaxTokenStringIdx();
                this.entityName = value;
            },

            getEntityNameStartIndex: function () {
                return this.entityNameStartIndex;
            },

            getEntityName: function () {
                return this.entityName;
            },

            setEntityField: function (entityField) {
                this.entityField = entityField;
            },

            getEntityField: function () {
                return this.entityField;
            },

            setNeedsWhere: function () {
                this.needsWhere = true;
                this.needsEntity = false;
                this.needsSelect = false;
                this.needsEntityField = false;
            },

            getNeedsWhere: function () {
                return this.needsWhere;
            },

            setNeedsSelect: function () {
                this.needsEntity = false;
                this.needsSelect = true;
                this.needsEntityField = false;
                this.needsWhere = false;
            },

            getNeedsSelect: function () {
                return this.needsSelect;
            },

            setNeedsEntityField: function () {
                this.needsEntityField = true;
                this.needsEntity = false;
                this.needsSelect = false;
                this.needsWhere = false;
            },

            getNeedsEntityField: function () {
                return this.needsEntityField;
            },

            setCountExpression: function () {
                this.countExpression++;
            },

            setNeedsFrom: function (value) {
                this.needsFrom = value;
            },

            getNeedsFrom: function () {
                return this.needsFrom;
            },

            setReversQuery: function () {
                this.reversQuery = true;
            },

            getReversQuery: function () {
                return this.reversQuery;
            },

            setCountFunc: function (value) {
                this.countFunc = value;
            },

            getCountFunc: function () {
                return this.countFunc;
            },

            resetCountExpression: function () {
                this.countExpression = 0;
            },

            resetTerminalClause: function () {
                this.lastFieldName = null;
                this.lastFieldType = null;
                this.lastFieldHavePrefix = false;
                this.lastFieldCountPrefix = 0;
                this.fieldNameStartIndex = null;
                this.needsField = null;
                this.lastOperator = null;
                this.operatorStartIndex = null;
                this.needsOperator = null;
                this.lastOperand = null;
                this.operandStartIndex = null;
                this.needsOperand = null;
                this.operandComplete = null;
                this.needsListComma = false;
                this.needsDot = false;
                this.needsChilds = false;
                //this.needsOpenParen = null;
                this.prefixRoot = false;
                this.needsFieldOrOperand = 0;
                this.isQuery = false;
                this.entity = null;
                this.needsEntity = false;
                this.needsSelect = false;
                this.needsEntityField = false;
                this.needsWhere = false;
                this.entityField = null;
                this.entityName = null;
                this.entityNameStartIndex = null;
                this.reversQuery = false;
                this.countFunc = false;
            },

            // начальная инициализация
            init: function () {
                this.lastField = null;
                this.lastFieldName = null;
                this.lastFieldType = null;
                this.lastFieldHavePrefix = false;
                this.lastFieldCountPrefix = 0;
                this.fieldNameStartIndex = null;
                this.needsField = null;
                this.lastOperator = null;
                this.operatorStartIndex = null;
                this.needsOperator = null;
                this.lastOperand = null;
                this.operandStartIndex = null;
                this.needsOperand = null;
                this.lastLogicalOperator = null;
                this.logicalOperatorStartIndex = null;
                this.operandComplete = null;
                this.needsOpenParen = null;
                this.needsListComma = null;
                this.needsDot = null;
                this.prefixRoot = false;
                this.needsFieldOrOperand = 0;
                this.isQuery = false;
                this.entity = null;
                this.needsEntity = false;
                this.needsSelect = false;
                this.needsEntityField = false;
                this.needsWhere = false;
                this.entityField = null;
                this.entityName = null;
                this.entityNameStartIndex = null;
                this.countExpression = 0;
                this.needsFrom = false;
                this.reversQuery = false;
                this.countFunc = false;
            }
        };
    };

    that.Token = function () {

        return {

            // начальная инициализация
            init: function (tokenString) {
                this.tokenStringIdx = 0;
                this.tokenString = tokenString;
                this.parseError = false;
                this.parseErrorMsg = null;
                this.result = that.ParseResult();
                this.result.init();
                this.inParens = 0;
                this.inSubQueryParens = 0;
                this.parenTypes = [];
                this.parents = [];
                this.parenIdx = 0;
                this.parentIdx = 0;
                this.lastUid = [];
                this.countSubUid = 0;
                this.countWhere = 0;
            },

            // пропуск 1 символа
            consumeCharacter: function () {
                this.tokenStringIdx++;
            },

            // пропуск символов
            consumeCharacters: function (numChars) {
                this.tokenStringIdx = this.tokenStringIdx + numChars;
            },

            //переход на следующий символ и его получение
            nextCharacter: function () {
                this.tokenStringIdx++;
                return this.currentCharacter();
            },

            // переход назад по индексу backTrackIdx
            backTrackToIdx: function (backTrackIdx) {
                this.tokenStringIdx = backTrackIdx;
                // Lets clear any parse errors that might have occurred as well
                this.parseError = false;
                this.parseErrorMsg = null;
                this.result.parseError = false;
                this.result.parseErrorMsg = null;
            },

            // получение текущего индекса токена
            getTokenStringIdx: function () {
                return this.tokenStringIdx;
            },

            // получение символа с текущей позиции токена
            currentCharacter: function () {
                if (this.tokenStringIdx >= this.tokenString.length) {
                    return null;
                }
                return this.tokenString.charAt(this.tokenStringIdx);
            },

            // получение оставшейся строки за текущим индексом токена
            remainingString: function () {
                if (this.tokenStringIdx >= this.tokenString.length) {
                    return null;
                }
                return this.tokenString.substr(this.tokenStringIdx, this.tokenString.length);
            },

            // получение макс индекса токена
            getMaxTokenStringIdx: function () {
                return this.tokenString.length;
            },

            // признак завершения парсинга
            isComplete: function () {
                if (this.parseError) {
                    return true;
                }
                return this.tokenStringIdx >= this.tokenString.length;
            },

            // увеличиваем признак нахождения в ограничивающих скобках вне подзапроса
            setInParens: function () {
                this.inParens++;
            },

            // уменьшаем признак нахождения в ограничивающих скобках вне подзапроса
            setOutOfParens: function () {
                // Lets never go into negative here
                if (this.inParens > 0) {
                    this.inParens--;
                }
            },

            // проверка на нахождение в ограничивающих скобках вне подзапроса
            getInParens: function () {
                return this.inParens != 0;
            },

            // увеличиваем признак нахождения в скобках подзапроса
            setInSubQueryParens: function () {
                this.inSubQueryParens++;
            },

            // уменьшаем признак нахождения в скобках подзапроса
            setOutOfSubQueryParens: function () {
                // Lets never go into negative here
                if (this.inSubQueryParens != 0) {
                    this.inSubQueryParens--;
                }
            },

            // проверка на нахождение в скобках подзапроса
            getInSubQueryParens: function () {
                return this.inSubQueryParens != 0;
            },

            // установка типа открывающей скобки
            setParenType: function (parenType) {
                this.parenTypes[this.parenIdx++] = parenType;
            },

            // получение типа открывающей скобки с текущим индексом
            getParenType: function () {
                return this.parenTypes[this.parenIdx];
            },

            // установка родителя для полей подзапроса
            setParent: function (parent) {
                this.parents[this.parentIdx++] = parent;
            },

            // получение родителя для полей подзапроса
            getParent: function () {
                return this.parents[this.parentIdx - 1];
            },

            deleteTopParent: function () {
                this.parents.splice(-1, 1);
                this.parentIdx--;
                if (this.countSubUid > 0) {
                    this.deleteTopLastUid();
                    if (this.countSubUid == 1 && this.parentIdx == 0 && !this.result.getCountFunc()) {
                        this.deleteTopLastUid();
                    }
                }
            },

            setLastUid: function (uid) {
                this.lastUid[this.countSubUid++] = uid;
            },

            getLastUid: function (num) {
                return this.lastUid[num];
            },

            deleteTopLastUid: function () {
                this.lastUid.splice(-1, 1);
                if (this.countSubUid > 0)
                    this.countSubUid--;
            },

            getParentByLastFieldType: function () {
                var levelSubQuery = this.result.getPrefixRoot() ? 0 : this.inSubQueryParens - this.countWhere - this.result.getLastFieldCountPrefix()/*this.countSubUid + this.countWhere - this.result.getLastFieldCountPrefix() * 2*/;
                return this.result.getLastFieldHavePrefix() && this.parents.length > levelSubQuery ? this.parents[levelSubQuery].fields : eql_fields;
            },

            // установка ошибки парсинга токена
            setParseError: function () {
                this.parseError = true;
                var preFixIdx = ((this.tokenStringIdx - 64) < 0) ? 0 : this.tokenStringIdx - 64;
                var errorPrefix = this.tokenString.substring(preFixIdx, this.tokenStringIdx);
                var spanbegin = '<span style="color:Red">';
                var spanend = '</span>';
                this.result.setParseError("..." + errorPrefix + spanbegin + this.tokenString.substring(this.tokenStringIdx, this.tokenString.length) + spanend);
            },

            getParseError: function () {
                return this.parseError;
            },

            getResult: function () {
                return this.result;
            },
        };
    };

    // запрос за обновлением данных автокомплита в соответствии с измененным типом объета
    that.UpdateEqlData = function (uid) {
        // проверка кэша
        if (!that.getSavedDataResponse(uid)) {
            // запрос данных для автокомплита
            var data = { objectUid: uid, needOperators: true, needsEntityField: false };
            $.ajax({
                url: serverDataUrl,
                async: true,
                data: data,
                dataType: "json",
                type: "GET",
                success: function (response) {
                    if (response != null && response.fields != null) {
                        eql_fields_initial = response.fields;
                        eql_fields = response.fields;
                        eql_fieldoperators = response.operators;
                        eql_functions_initial = response.functions;
                        eql_functions = response.functions;
                    }
                    else {
                        eql_fields_initial = [];
                        eql_fields = [];
                        eql_fieldoperators = [];
                        eql_functions_initial = [];
                        eql_functions = [];
                    }
                    that.saveDataResponse(uid, response); // кэширование
                },
                error: function () {
                }
            });
        }
        else { // получение кэшированного запроса
            var cachedResponse = that.getSavedDataResponse(uid);
            eql_fields_initial = cachedResponse.fields;
            eql_fields = cachedResponse.fields;
            eql_fieldoperators = cachedResponse.operators;
            eql_functions_initial = cachedResponse.functions;
            eql_functions = cachedResponse.functions;
        }

    };

    that.init(options);

    return that;
};

function _testParse(query) {
    console.log("test query: " + query);

    var parser = ELMA.EQLAutoComplete.MyParser([]);

    var parseResult = parser.parse(query);

    if (parseResult.parseError == true) {
        console.log("Expected parsing to fail");
    } else {
        console.log("Expected parsing to be successful");
    }
}

elma.EQLHelper = function () { };

elma.EQLHelper.Manager = function () {
    var controls = [];
    return {
        create: function (options) {
            var selector = new ELMA.EQLAutoComplete(options);
            return elma.EQLHelper.Manager.register(options.postfix, selector);
        },
        register: function (el, control) {
            controls[el] = control;
            return elma.EQLHelper.Manager.get(el);
        },
        get: function (el) {
            return controls[el] || null;
        },
        getArrayForCheck: function () {
            var funcStatusArray = new Array();
            for (var a in controls) {
                var control = controls[a];
                if (control.Description.fieldQueryNameValue != null && control.Description.fieldTypeNameValue != null) {
                    funcStatusArray.push({
                        postfix: control.Description.postfix,
                        fieldQueryNameValue: control.Description.fieldQueryNameValue.call(),
                        fieldTypeNameValue: control.Description.fieldTypeNameValue.call(),
                        status: false
                    });
                }
            }
            return funcStatusArray;
        },
        updateEqlData: function (uid) {
            if (controls) {
                for (var a in controls) {
                    var typeUid = uid ? uid : (controls[a] && controls[a].Description && controls[a].Description.objectUidFunc ? controls[a].Description.objectUidFunc.call() : null);
                    if (typeUid) {
                        controls[a].UpdateEqlData(typeUid);
                    }
                }
            }
        }
    };
}();


elma.CalcPing = function (singleExecute) {
    if (elma.NeedSkipPing) {
        return;
    }
    $.ajax({
        url: '/SDK.Action/Ping/Ping',
        dataType: "json",
        cache: false,
        success: function (data) {
            for (var i = 0; i < data.length; i++) {
                try {
                    var item = data[i];
                    var func = eval(item.f);
                    func(item.d);
                } catch (e) {
                    // do nothing
                }
            }
            if (!singleExecute) {
                setTimeout(elma.CalcPing, 60000);
            }
        },
        error: function (x, e) {
            // do nothing
            if (!singleExecute) {
                setTimeout(elma.CalcPing, 120000);
            }
        }
    });
};

$(document).ready(function () {
    setTimeout(elma.CalcPing, 60000);
});



ELMA.DropZone = function(options) {
    var that = begetObject(ELMA.DropZone);
    var opts = {};
    var xhrFiles = new Array();
    var dropzone = $(options.name);
    var newVersionsUploaded = new Array();
    var newVersionsUploadedError = false;

    that.versionsUploaded = function () {
        return newVersionsUploaded;
    }

    that.defaults = function() {
        return {
            url: "",
            method: "POST",
            paramname: 'file',
            queryparams: [],
            numConcurrentUploads: 3,
            maxfilesize: 2147480000,
            printLogs: false,
            // update upload speed every second
            uploadRateRefreshTime: 1000,
            useResponseData: false,
        };
    };

    that.log = function(logMsg) {
        if (opts.printLogs) {
            // console && console.log(logMsg);
        }
    };

    // Extend our default options with those provided.
    opts = $.extend({}, that.defaults(), options);
    
    that.log("adding dnd-file-upload functionalities to element with id: " + dropzone.attr('id'));

    that.reset = function () {
        for (var j = 0; j < dropzone.length; j++) {
            dropzone[j].removeEventListener("drop", that.drop, true);
        }
        dropzone.unbind("dragenter", that.dragenter);
        dropzone.unbind("dragover", that.dragover);
    };

    that.getUploadedVersionsUrl = function (prefix) {
        if (!newVersionsUploaded || newVersionsUploaded.length == 0)
            return '';
        var res = '';
        $.each(newVersionsUploaded, function (i, a) {
            if (a.versionId) {
                res += (i > 0 ? '&' : '') + prefix + '[' + i + ']=' + a.versionId;
            }
        });
        return res;
    };

    that.getUploadedDocumentUrl = function (prefix) {
        if (!newVersionsUploaded || newVersionsUploaded.length == 0)
            return '';
        var res = '';
        $.each(newVersionsUploaded, function (i, a) {
            if (a.createdDocument) {
                res += (i > 0 ? '&' : '') + prefix + '[' + i + ']=' + a.createdDocument;
            }
        });
        return res;
    };

    that.isNewVersionsCreated = function () {
        return that.getUploadedVersionsUrl('versions') != '';
    };

    that.isNewDocumentsCreated = function () {
        return that.getUploadedDocumentUrl('documents') != '';
    };

    that.dragenter = function(event) {
        event.stopPropagation();
        event.preventDefault();
        return false;
    };

    that.dragover = function(event) {
        event.stopPropagation();
        event.preventDefault();
        return false;
    };

    that.drop = function(event) {
        var dt = event.dataTransfer;
        var files = dt.files;

        if (files) {
            if ((dt.dropEffect == 'none' || dt.dropEffect == 'move') && files.length > 0) {
                for (var i = 0; i < files.length; i++) {
                    if (files[i].size > opts.maxfilesize) {
                        var tempButton = $.alerts.okButton;
                        $.alerts.okButton = '&nbsp;' + SR.T('Закрыть') + '&nbsp;';
                        jAlert($.validator.format(SR.T('Размер файла {0} превышает максимальный лимит в {1} мб.'), files[i].name, (opts.maxfilesize / 1024 / 1024).toFixed(2)), SR.T('Ошибка'));
                        $.alerts.okButton = tempButton;
                        event.preventDefault();
                        return false;
                    }
                }
                event.preventDefault();
                that.uploadFiles(files);
            } else {
                event.preventDefault();
            }
        }

        return false;
    };

    that.resetUploadState = function(files) {
        this.fileUploadState = [];
        for (var i = 0; i < files.length; i++) {
            this.fileUploadState.push({ file: files[i].name, uploadstate: false });
        }
    };

    that.setUploadStatus = function(filename, status) {
        if (!this.fileUploadState)
            return;
        for (var i = 0; i < this.fileUploadState.length; i++) {
            if (this.fileUploadState[i].file == filename) {
                this.fileUploadState[i].uploadstate = status;
                return;
            }
        }
    };

    that.isUploadFinish = function() {
        if (!this.fileUploadState)
            return true;
        for (var i = 0; i < this.fileUploadState.length; i++) {
            if (!this.fileUploadState[i].uploadstate) {
                return false;
            }
        }
        return true;
    };

    that.sendNexXhr = function() {
        var lastXhr = xhrFiles.pop();

        var upload = lastXhr.xhr.upload;
        upload.fileIndex = lastXhr.i;
        upload.fileObj = lastXhr.file;
        upload.filecount = lastXhr.count;
        upload.downloadStartTime = new Date().getTime();
        upload.currentStart = upload.downloadStartTime;
        upload.currentProgress = 0;
        upload.startData = 0;

        // add listeners
        upload.addEventListener("progress", that.progress, false);
        upload.addEventListener("load", that.load, false);
        lastXhr.xhr.setRequestHeader("__RequestVerificationToken", AntiForgeryToken.Generate());

        lastXhr.xhr.send(lastXhr.file);
        opts.uploadStarted(lastXhr.i, lastXhr.file, lastXhr.count);
    };

    that.uploadFiles = function(files) {
        if (!files)
            return;
        newVersionsUploaded = new Array();
        newVersionsUploadedError = false;
        opts.newFilesDropped(files.length);
        that.resetUploadState(files);
        xhrFiles = new Array();
        var countResponse = 0;
        for (var i = 0; i < files.length; i++) {
            var file = files[i];

            // create a new xhr object
            var xhr = new XMLHttpRequest();
            xhr.open(opts.method, opts.url);
            xhr.setRequestHeader("Cache-Control", "no-cache");
            xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            if (opts.paramname) {
                xhr.setRequestHeader(opts.paramname, encodeURIComponent(file.name));
            }
            xhr.setRequestHeader("X-File-Name", encodeURIComponent(file.name));
            xhr.setRequestHeader("X-File-Size", file.size);
            xhr.setRequestHeader("X-File-Send", 1);
            xhr.setRequestHeader("Content-Disposition", "form-data");
            xhr.setRequestHeader("Content-Type", "application/octet-stream");
            $.each(opts.queryparams, function(j, a) {
                xhr.setRequestHeader(a.name, a.value);
            });

            xhr.onreadystatechange = function() {
                if (opts.useResponseData && this.responseText) {
                    var rd = $.parseJSON(this.responseText);
                    if (rd && rd.error) {
                        jAlert(rd.error, SR.T('Ошибка'));
                    }
                }
                if (this.readyState == 4) {
                    try {
                        var rt = $.parseJSON(this.responseText);
                        if (rt && rt.error) {
                            newVersionsUploadedError = true;
                            jAlert(rt.error, SR.T('Ошибка'));
                        }
                    } catch (e) {
                    }
                    countResponse++;
                    try {
                        if (opts.useResponseData && this.responseText) {
                            var responseData = $.parseJSON(this.responseText);
                            if (responseData && (responseData.versionId || responseData.createdDocument)) {
                                newVersionsUploaded.push(responseData);
                            }
                        }
                    } catch (e) {
                    }
                    if (countResponse == files.length) {
                        opts.uploadAllFinished();
                    }
                    if (xhrFiles.length > 0) {
                        that.sendNexXhr();
                    }
                }
            };

            xhrFiles.push({ xhr: xhr, file: file, i: i, count: files.length });

            //xhr.send(file);

            //$.fn.dropzone.uploadStarted(i, file, files.length);
        }
        xhrFiles.reverse();
        that.sendNexXhr();
    };


    that.load = function(event) {
        var now = new Date().getTime();
        var timeDiff = now - this.downloadStartTime;
        that.setUploadStatus(this.fileObj.name, true);
        opts.uploadFinished(this.fileIndex, this.fileObj, timeDiff);
        that.log("finished loading of file " + this.fileIndex);
    }

    that.progress = function(event) {
        if (event.lengthComputable) {
            var percentage = Math.round((event.loaded * 100) / event.total);
            if (this.currentProgress != percentage) {

                this.currentProgress = percentage;
                opts.fileUploadProgressUpdated(this.fileIndex, this.fileObj, this.currentProgress, this.filecount);

                var elapsed = new Date().getTime();
                var diffTime = elapsed - this.currentStart;
                if (diffTime >= opts.uploadRateRefreshTime) {
                    var diffData = event.loaded - this.startData;
                    var speed = diffData / diffTime; // in KB/sec

                    opts.fileUploadSpeedUpdated(this.fileIndex, this.fileObj, speed);

                    this.startData = event.loaded;
                    this.currentStart = elapsed;
                }
            }
        }
    }

    // invoked when the input field has changed and new files have been dropped
    // or selected
    that.change = function(event) {
        event.preventDefault();

        // get all files ...
        var files = this.files;

        // ... and upload them
        that.uploadFiles(files);
    };

    if (!elma.IsHtml5FileUploadCapable()) {
        return this;
    } else {
        for (var i = 0; i < dropzone.length; i++) {
            dropzone[i].addEventListener("drop", that.drop, true);
        }
        dropzone.bind("dragenter", that.dragenter);
        dropzone.bind("dragover", that.dragover);
    };

    return that;
}

elma.DropZone = function () {
    var controls = [];
    return {
        create: function (options) {
            var dropZone = new ELMA.DropZone(options);
            return elma.DropZone.register(options.name, dropZone);
        },
        register: function (el, control) {
            controls[el] = control;
            return elma.DropZone.get(el);
        },
        get: function (el) {
            return controls[el] || null;
        }
    };
}();




// Copyright 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Known Issues:
//
// * Patterns only support repeat.
// * Radial gradient are not implemented. The VML version of these look very
//   different from the canvas one.
// * Clipping paths are not implemented.
// * Coordsize. The width and height attribute have higher priority than the
//   width and height style values which isn't correct.
// * Painting mode isn't implemented.
// * Canvas width/height should is using content-box by default. IE in
//   Quirks mode will draw the canvas using border-box. Either change your
//   doctype to HTML5
//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype)
//   or use Box Sizing Behavior from WebFX
//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html)
// * Non uniform scaling does not correctly scale strokes.
// * Optimize. There is always room for speed improvements.

// Only add this code if we do not already have a canvas implementation
if (!document.createElement('canvas').getContext) {

(function() {

  // alias some functions to make (compiled) code shorter
  var m = Math;
  var mr = m.round;
  var ms = m.sin;
  var mc = m.cos;
  var abs = m.abs;
  var sqrt = m.sqrt;

  // this is used for sub pixel precision
  var Z = 10;
  var Z2 = Z / 2;

  var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];

  /**
   * This funtion is assigned to the <canvas> elements as element.getContext().
   * @this {HTMLElement}
   * @return {CanvasRenderingContext2D_}
   */
  function getContext() {
    return this.context_ ||
        (this.context_ = new CanvasRenderingContext2D_(this));
  }

  var slice = Array.prototype.slice;

  /**
   * Binds a function to an object. The returned function will always use the
   * passed in {@code obj} as {@code this}.
   *
   * Example:
   *
   *   g = bind(f, obj, a, b)
   *   g(c, d) // will do f.call(obj, a, b, c, d)
   *
   * @param {Function} f The function to bind the object to
   * @param {Object} obj The object that should act as this when the function
   *     is called
   * @param {*} var_args Rest arguments that will be used as the initial
   *     arguments when the function is called
   * @return {Function} A new function that has bound this
   */
  function bind(f, obj, var_args) {
    var a = slice.call(arguments, 2);
    return function() {
      return f.apply(obj, a.concat(slice.call(arguments)));
    };
  }

  function encodeHtmlAttribute(s) {
    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
  }

  function addNamespace(doc, prefix, urn) {
    if (!doc.namespaces[prefix]) {
      doc.namespaces.add(prefix, urn, '#default#VML');
    }
  }

  function addNamespacesAndStylesheet(doc) {
    addNamespace(doc, 'g_vml_', 'urn:schemas-microsoft-com:vml');
    addNamespace(doc, 'g_o_', 'urn:schemas-microsoft-com:office:office');

    // Setup default CSS.  Only add one style sheet per document
    if (!doc.styleSheets['ex_canvas_']) {
      var ss = doc.createStyleSheet();
      ss.owningElement.id = 'ex_canvas_';
      ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +
          // default size is 300x150 in Gecko and Opera
          'text-align:left;width:300px;height:150px}';
    }
  }

  // Add namespaces and stylesheet at startup.
  addNamespacesAndStylesheet(document);

  var G_vmlCanvasManager_ = {
    init: function(opt_doc) {
      var doc = opt_doc || document;
      // Create a dummy element so that IE will allow canvas elements to be
      // recognized.
      doc.createElement('canvas');
      doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
    },

    init_: function(doc) {
      // find all canvas elements
      var els = doc.getElementsByTagName('canvas');
      for (var i = 0; i < els.length; i++) {
        this.initElement(els[i]);
      }
    },

    /**
     * Public initializes a canvas element so that it can be used as canvas
     * element from now on. This is called automatically before the page is
     * loaded but if you are creating elements using createElement you need to
     * make sure this is called on the element.
     * @param {HTMLElement} el The canvas element to initialize.
     * @return {HTMLElement} the element that was created.
     */
    initElement: function(el) {
      if (!el.getContext) {
        el.getContext = getContext;

        // Add namespaces and stylesheet to document of the element.
        addNamespacesAndStylesheet(el.ownerDocument);

        // Remove fallback content. There is no way to hide text nodes so we
        // just remove all childNodes. We could hide all elements and remove
        // text nodes but who really cares about the fallback content.
        el.innerHTML = '';

        // do not use inline function because that will leak memory
        el.attachEvent('onpropertychange', onPropertyChange);
        el.attachEvent('onresize', onResize);

        var attrs = el.attributes;
        if (attrs.width && attrs.width.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setWidth_(attrs.width.nodeValue);
          el.style.width = attrs.width.nodeValue + 'px';
        } else {
          el.width = el.clientWidth;
        }
        if (attrs.height && attrs.height.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setHeight_(attrs.height.nodeValue);
          el.style.height = attrs.height.nodeValue + 'px';
        } else {
          el.height = el.clientHeight;
        }
        //el.getContext().setCoordsize_()
      }
      return el;
    }
  };

  function onPropertyChange(e) {
    var el = e.srcElement;

    switch (e.propertyName) {
      case 'width':
        el.getContext().clearRect();
        el.style.width = el.attributes.width.nodeValue + 'px';
        // In IE8 this does not trigger onresize.
        el.firstChild.style.width =  el.clientWidth + 'px';
        break;
      case 'height':
        el.getContext().clearRect();
        el.style.height = el.attributes.height.nodeValue + 'px';
        el.firstChild.style.height = el.clientHeight + 'px';
        break;
    }
  }

  function onResize(e) {
    var el = e.srcElement;
    if (el.firstChild) {
      el.firstChild.style.width =  el.clientWidth + 'px';
      el.firstChild.style.height = el.clientHeight + 'px';
    }
  }

  G_vmlCanvasManager_.init();

  // precompute "00" to "FF"
  var decToHex = [];
  for (var i = 0; i < 16; i++) {
    for (var j = 0; j < 16; j++) {
      decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
    }
  }

  function createMatrixIdentity() {
    return [
      [1, 0, 0],
      [0, 1, 0],
      [0, 0, 1]
    ];
  }

  function matrixMultiply(m1, m2) {
    var result = createMatrixIdentity();

    for (var x = 0; x < 3; x++) {
      for (var y = 0; y < 3; y++) {
        var sum = 0;

        for (var z = 0; z < 3; z++) {
          sum += m1[x][z] * m2[z][y];
        }

        result[x][y] = sum;
      }
    }
    return result;
  }

  function copyState(o1, o2) {
    o2.fillStyle     = o1.fillStyle;
    o2.lineCap       = o1.lineCap;
    o2.lineJoin      = o1.lineJoin;
    o2.lineWidth     = o1.lineWidth;
    o2.miterLimit    = o1.miterLimit;
    o2.shadowBlur    = o1.shadowBlur;
    o2.shadowColor   = o1.shadowColor;
    o2.shadowOffsetX = o1.shadowOffsetX;
    o2.shadowOffsetY = o1.shadowOffsetY;
    o2.strokeStyle   = o1.strokeStyle;
    o2.globalAlpha   = o1.globalAlpha;
    o2.font          = o1.font;
    o2.textAlign     = o1.textAlign;
    o2.textBaseline  = o1.textBaseline;
    o2.arcScaleX_    = o1.arcScaleX_;
    o2.arcScaleY_    = o1.arcScaleY_;
    o2.lineScale_    = o1.lineScale_;
  }

  var colorData = {
    aliceblue: '#F0F8FF',
    antiquewhite: '#FAEBD7',
    aquamarine: '#7FFFD4',
    azure: '#F0FFFF',
    beige: '#F5F5DC',
    bisque: '#FFE4C4',
    black: '#000000',
    blanchedalmond: '#FFEBCD',
    blueviolet: '#8A2BE2',
    brown: '#A52A2A',
    burlywood: '#DEB887',
    cadetblue: '#5F9EA0',
    chartreuse: '#7FFF00',
    chocolate: '#D2691E',
    coral: '#FF7F50',
    cornflowerblue: '#6495ED',
    cornsilk: '#FFF8DC',
    crimson: '#DC143C',
    cyan: '#00FFFF',
    darkblue: '#00008B',
    darkcyan: '#008B8B',
    darkgoldenrod: '#B8860B',
    darkgray: '#A9A9A9',
    darkgreen: '#006400',
    darkgrey: '#A9A9A9',
    darkkhaki: '#BDB76B',
    darkmagenta: '#8B008B',
    darkolivegreen: '#556B2F',
    darkorange: '#FF8C00',
    darkorchid: '#9932CC',
    darkred: '#8B0000',
    darksalmon: '#E9967A',
    darkseagreen: '#8FBC8F',
    darkslateblue: '#483D8B',
    darkslategray: '#2F4F4F',
    darkslategrey: '#2F4F4F',
    darkturquoise: '#00CED1',
    darkviolet: '#9400D3',
    deeppink: '#FF1493',
    deepskyblue: '#00BFFF',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1E90FF',
    firebrick: '#B22222',
    floralwhite: '#FFFAF0',
    forestgreen: '#228B22',
    gainsboro: '#DCDCDC',
    ghostwhite: '#F8F8FF',
    gold: '#FFD700',
    goldenrod: '#DAA520',
    grey: '#808080',
    greenyellow: '#ADFF2F',
    honeydew: '#F0FFF0',
    hotpink: '#FF69B4',
    indianred: '#CD5C5C',
    indigo: '#4B0082',
    ivory: '#FFFFF0',
    khaki: '#F0E68C',
    lavender: '#E6E6FA',
    lavenderblush: '#FFF0F5',
    lawngreen: '#7CFC00',
    lemonchiffon: '#FFFACD',
    lightblue: '#ADD8E6',
    lightcoral: '#F08080',
    lightcyan: '#E0FFFF',
    lightgoldenrodyellow: '#FAFAD2',
    lightgreen: '#90EE90',
    lightgrey: '#D3D3D3',
    lightpink: '#FFB6C1',
    lightsalmon: '#FFA07A',
    lightseagreen: '#20B2AA',
    lightskyblue: '#87CEFA',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#B0C4DE',
    lightyellow: '#FFFFE0',
    limegreen: '#32CD32',
    linen: '#FAF0E6',
    magenta: '#FF00FF',
    mediumaquamarine: '#66CDAA',
    mediumblue: '#0000CD',
    mediumorchid: '#BA55D3',
    mediumpurple: '#9370DB',
    mediumseagreen: '#3CB371',
    mediumslateblue: '#7B68EE',
    mediumspringgreen: '#00FA9A',
    mediumturquoise: '#48D1CC',
    mediumvioletred: '#C71585',
    midnightblue: '#191970',
    mintcream: '#F5FFFA',
    mistyrose: '#FFE4E1',
    moccasin: '#FFE4B5',
    navajowhite: '#FFDEAD',
    oldlace: '#FDF5E6',
    olivedrab: '#6B8E23',
    orange: '#FFA500',
    orangered: '#FF4500',
    orchid: '#DA70D6',
    palegoldenrod: '#EEE8AA',
    palegreen: '#98FB98',
    paleturquoise: '#AFEEEE',
    palevioletred: '#DB7093',
    papayawhip: '#FFEFD5',
    peachpuff: '#FFDAB9',
    peru: '#CD853F',
    pink: '#FFC0CB',
    plum: '#DDA0DD',
    powderblue: '#B0E0E6',
    rosybrown: '#BC8F8F',
    royalblue: '#4169E1',
    saddlebrown: '#8B4513',
    salmon: '#FA8072',
    sandybrown: '#F4A460',
    seagreen: '#2E8B57',
    seashell: '#FFF5EE',
    sienna: '#A0522D',
    skyblue: '#87CEEB',
    slateblue: '#6A5ACD',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#FFFAFA',
    springgreen: '#00FF7F',
    steelblue: '#4682B4',
    tan: '#D2B48C',
    thistle: '#D8BFD8',
    tomato: '#FF6347',
    turquoise: '#40E0D0',
    violet: '#EE82EE',
    wheat: '#F5DEB3',
    whitesmoke: '#F5F5F5',
    yellowgreen: '#9ACD32'
  };


  function getRgbHslContent(styleString) {
    var start = styleString.indexOf('(', 3);
    var end = styleString.indexOf(')', start + 1);
    var parts = styleString.substring(start + 1, end).split(',');
    // add alpha if needed
    if (parts.length != 4 || styleString.charAt(3) != 'a') {
      parts[3] = 1;
    }
    return parts;
  }

  function percent(s) {
    return parseFloat(s) / 100;
  }

  function clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  }

  function hslToRgb(parts){
    var r, g, b, h, s, l;
    h = parseFloat(parts[0]) / 360 % 360;
    if (h < 0)
      h++;
    s = clamp(percent(parts[1]), 0, 1);
    l = clamp(percent(parts[2]), 0, 1);
    if (s == 0) {
      r = g = b = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hueToRgb(p, q, h + 1 / 3);
      g = hueToRgb(p, q, h);
      b = hueToRgb(p, q, h - 1 / 3);
    }

    return '#' + decToHex[Math.floor(r * 255)] +
        decToHex[Math.floor(g * 255)] +
        decToHex[Math.floor(b * 255)];
  }

  function hueToRgb(m1, m2, h) {
    if (h < 0)
      h++;
    if (h > 1)
      h--;

    if (6 * h < 1)
      return m1 + (m2 - m1) * 6 * h;
    else if (2 * h < 1)
      return m2;
    else if (3 * h < 2)
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    else
      return m1;
  }

  var processStyleCache = {};

  function processStyle(styleString) {
    if (styleString in processStyleCache) {
      return processStyleCache[styleString];
    }

    var str, alpha = 1;

    styleString = String(styleString);
    if (styleString.charAt(0) == '#') {
      str = styleString;
    } else if (/^rgb/.test(styleString)) {
      var parts = getRgbHslContent(styleString);
      var str = '#', n;
      for (var i = 0; i < 3; i++) {
        if (parts[i].indexOf('%') != -1) {
          n = Math.floor(percent(parts[i]) * 255);
        } else {
          n = +parts[i];
        }
        str += decToHex[clamp(n, 0, 255)];
      }
      alpha = +parts[3];
    } else if (/^hsl/.test(styleString)) {
      var parts = getRgbHslContent(styleString);
      str = hslToRgb(parts);
      alpha = parts[3];
    } else {
      str = colorData[styleString] || styleString;
    }
    return processStyleCache[styleString] = {color: str, alpha: alpha};
  }

  var DEFAULT_STYLE = {
    style: 'normal',
    variant: 'normal',
    weight: 'normal',
    size: 10,
    family: 'sans-serif'
  };

  // Internal text style cache
  var fontStyleCache = {};

  function processFontStyle(styleString) {
    if (fontStyleCache[styleString]) {
      return fontStyleCache[styleString];
    }

    var el = document.createElement('div');
    var style = el.style;
    try {
      style.font = styleString;
    } catch (ex) {
      // Ignore failures to set to invalid font.
    }

    return fontStyleCache[styleString] = {
      style: style.fontStyle || DEFAULT_STYLE.style,
      variant: style.fontVariant || DEFAULT_STYLE.variant,
      weight: style.fontWeight || DEFAULT_STYLE.weight,
      size: style.fontSize || DEFAULT_STYLE.size,
      family: style.fontFamily || DEFAULT_STYLE.family
    };
  }

  function getComputedStyle(style, element) {
    var computedStyle = {};

    for (var p in style) {
      computedStyle[p] = style[p];
    }

    // Compute the size
    var canvasFontSize = parseFloat(element.currentStyle.fontSize),
        fontSize = parseFloat(style.size);

    if (typeof style.size == 'number') {
      computedStyle.size = style.size;
    } else if (style.size.indexOf('px') != -1) {
      computedStyle.size = fontSize;
    } else if (style.size.indexOf('em') != -1) {
      computedStyle.size = canvasFontSize * fontSize;
    } else if(style.size.indexOf('%') != -1) {
      computedStyle.size = (canvasFontSize / 100) * fontSize;
    } else if (style.size.indexOf('pt') != -1) {
      computedStyle.size = fontSize / .75;
    } else {
      computedStyle.size = canvasFontSize;
    }

    // Different scaling between normal text and VML text. This was found using
    // trial and error to get the same size as non VML text.
    computedStyle.size *= 0.981;

    return computedStyle;
  }

  function buildStyle(style) {
    return style.style + ' ' + style.variant + ' ' + style.weight + ' ' +
        style.size + 'px ' + style.family;
  }

  var lineCapMap = {
    'butt': 'flat',
    'round': 'round'
  };

  function processLineCap(lineCap) {
    return lineCapMap[lineCap] || 'square';
  }

  /**
   * This class implements CanvasRenderingContext2D interface as described by
   * the WHATWG.
   * @param {HTMLElement} canvasElement The element that the 2D context should
   * be associated with
   */
  function CanvasRenderingContext2D_(canvasElement) {
    this.m_ = createMatrixIdentity();

    this.mStack_ = [];
    this.aStack_ = [];
    this.currentPath_ = [];

    // Canvas context properties
    this.strokeStyle = '#000';
    this.fillStyle = '#000';

    this.lineWidth = 1;
    this.lineJoin = 'miter';
    this.lineCap = 'butt';
    this.miterLimit = Z * 1;
    this.globalAlpha = 1;
    this.font = '10px sans-serif';
    this.textAlign = 'left';
    this.textBaseline = 'alphabetic';
    this.canvas = canvasElement;

    var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' +
        canvasElement.clientHeight + 'px;overflow:hidden;position:absolute';
    var el = canvasElement.ownerDocument.createElement('div');
    el.style.cssText = cssText;
    canvasElement.appendChild(el);

    var overlayEl = el.cloneNode(false);
    // Use a non transparent background.
    overlayEl.style.backgroundColor = 'red';
    overlayEl.style.filter = 'alpha(opacity=0)';
    canvasElement.appendChild(overlayEl);

    this.element_ = el;
    this.arcScaleX_ = 1;
    this.arcScaleY_ = 1;
    this.lineScale_ = 1;
  }

  var contextPrototype = CanvasRenderingContext2D_.prototype;
  contextPrototype.clearRect = function() {
    if (this.textMeasureEl_) {
      this.textMeasureEl_.removeNode(true);
      this.textMeasureEl_ = null;
    }
    this.element_.innerHTML = '';
  };

  contextPrototype.beginPath = function() {
    // TODO: Branch current matrix so that save/restore has no effect
    //       as per safari docs.
    this.currentPath_ = [];
  };

  contextPrototype.moveTo = function(aX, aY) {
    var p = getCoords(this, aX, aY);
    this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});
    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.lineTo = function(aX, aY) {
    var p = getCoords(this, aX, aY);
    this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});

    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                                            aCP2x, aCP2y,
                                            aX, aY) {
    var p = getCoords(this, aX, aY);
    var cp1 = getCoords(this, aCP1x, aCP1y);
    var cp2 = getCoords(this, aCP2x, aCP2y);
    bezierCurveTo(this, cp1, cp2, p);
  };

  // Helper function that takes the already fixed cordinates.
  function bezierCurveTo(self, cp1, cp2, p) {
    self.currentPath_.push({
      type: 'bezierCurveTo',
      cp1x: cp1.x,
      cp1y: cp1.y,
      cp2x: cp2.x,
      cp2y: cp2.y,
      x: p.x,
      y: p.y
    });
    self.currentX_ = p.x;
    self.currentY_ = p.y;
  }

  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
    // the following is lifted almost directly from
    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

    var cp = getCoords(this, aCPx, aCPy);
    var p = getCoords(this, aX, aY);

    var cp1 = {
      x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
      y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
    };
    var cp2 = {
      x: cp1.x + (p.x - this.currentX_) / 3.0,
      y: cp1.y + (p.y - this.currentY_) / 3.0
    };

    bezierCurveTo(this, cp1, cp2, p);
  };

  contextPrototype.arc = function(aX, aY, aRadius,
                                  aStartAngle, aEndAngle, aClockwise) {
    aRadius *= Z;
    var arcType = aClockwise ? 'at' : 'wa';

    var xStart = aX + mc(aStartAngle) * aRadius - Z2;
    var yStart = aY + ms(aStartAngle) * aRadius - Z2;

    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

    // IE won't render arches drawn counter clockwise if xStart == xEnd.
    if (xStart == xEnd && !aClockwise) {
      xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                       // that can be represented in binary
    }

    var p = getCoords(this, aX, aY);
    var pStart = getCoords(this, xStart, yStart);
    var pEnd = getCoords(this, xEnd, yEnd);

    this.currentPath_.push({type: arcType,
                           x: p.x,
                           y: p.y,
                           radius: aRadius,
                           xStart: pStart.x,
                           yStart: pStart.y,
                           xEnd: pEnd.x,
                           yEnd: pEnd.y});

  };

  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
  };

  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.stroke();

    this.currentPath_ = oldPath;
  };

  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.fill();

    this.currentPath_ = oldPath;
  };

  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
    var gradient = new CanvasGradient_('gradient');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    return gradient;
  };

  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                                                   aX1, aY1, aR1) {
    var gradient = new CanvasGradient_('gradientradial');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.r0_ = aR0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    gradient.r1_ = aR1;
    return gradient;
  };

  contextPrototype.drawImage = function(image, var_args) {
    var dx, dy, dw, dh, sx, sy, sw, sh;

    // to find the original width we overide the width and height
    var oldRuntimeWidth = image.runtimeStyle.width;
    var oldRuntimeHeight = image.runtimeStyle.height;
    image.runtimeStyle.width = 'auto';
    image.runtimeStyle.height = 'auto';

    // get the original size
    var w = image.width;
    var h = image.height;

    // and remove overides
    image.runtimeStyle.width = oldRuntimeWidth;
    image.runtimeStyle.height = oldRuntimeHeight;

    if (arguments.length == 3) {
      dx = arguments[1];
      dy = arguments[2];
      sx = sy = 0;
      sw = dw = w;
      sh = dh = h;
    } else if (arguments.length == 5) {
      dx = arguments[1];
      dy = arguments[2];
      dw = arguments[3];
      dh = arguments[4];
      sx = sy = 0;
      sw = w;
      sh = h;
    } else if (arguments.length == 9) {
      sx = arguments[1];
      sy = arguments[2];
      sw = arguments[3];
      sh = arguments[4];
      dx = arguments[5];
      dy = arguments[6];
      dw = arguments[7];
      dh = arguments[8];
    } else {
      throw Error('Invalid number of arguments');
    }

    var d = getCoords(this, dx, dy);

    var w2 = sw / 2;
    var h2 = sh / 2;

    var vmlStr = [];

    var W = 10;
    var H = 10;

    // For some reason that I've now forgotten, using divs didn't work
    vmlStr.push(' <g_vml_:group',
                ' coordsize="', Z * W, ',', Z * H, '"',
                ' coordorigin="0,0"' ,
                ' style="width:', W, 'px;height:', H, 'px;position:absolute;');

    // If filters are necessary (rotation exists), create them
    // filters are bog-slow, so only create them if abbsolutely necessary
    // The following check doesn't account for skews (which don't exist
    // in the canvas spec (yet) anyway.

    if (this.m_[0][0] != 1 || this.m_[0][1] ||
        this.m_[1][1] != 1 || this.m_[1][0]) {
      var filter = [];

      // Note the 12/21 reversal
      filter.push('M11=', this.m_[0][0], ',',
                  'M12=', this.m_[1][0], ',',
                  'M21=', this.m_[0][1], ',',
                  'M22=', this.m_[1][1], ',',
                  'Dx=', mr(d.x / Z), ',',
                  'Dy=', mr(d.y / Z), '');

      // Bounding box calculation (need to minimize displayed area so that
      // filters don't waste time on unused pixels.
      var max = d;
      var c2 = getCoords(this, dx + dw, dy);
      var c3 = getCoords(this, dx, dy + dh);
      var c4 = getCoords(this, dx + dw, dy + dh);

      max.x = m.max(max.x, c2.x, c3.x, c4.x);
      max.y = m.max(max.y, c2.y, c3.y, c4.y);

      vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
                  'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',
                  filter.join(''), ", sizingmethod='clip');");

    } else {
      vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
    }

    vmlStr.push(' ">' ,
                '<g_vml_:image src="', image.src, '"',
                ' style="width:', Z * dw, 'px;',
                ' height:', Z * dh, 'px"',
                ' cropleft="', sx / w, '"',
                ' croptop="', sy / h, '"',
                ' cropright="', (w - sx - sw) / w, '"',
                ' cropbottom="', (h - sy - sh) / h, '"',
                ' />',
                '</g_vml_:group>');

    this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
  };

  contextPrototype.stroke = function(aFill) {
    var lineStr = [];
    var lineOpen = false;

    var W = 10;
    var H = 10;

    lineStr.push('<g_vml_:shape',
                 ' filled="', !!aFill, '"',
                 ' style="position:absolute;width:', W, 'px;height:', H, 'px;"',
                 ' coordorigin="0,0"',
                 ' coordsize="', Z * W, ',', Z * H, '"',
                 ' stroked="', !aFill, '"',
                 ' path="');

    var newSeq = false;
    var min = {x: null, y: null};
    var max = {x: null, y: null};

    for (var i = 0; i < this.currentPath_.length; i++) {
      var p = this.currentPath_[i];
      var c;

      switch (p.type) {
        case 'moveTo':
          c = p;
          lineStr.push(' m ', mr(p.x), ',', mr(p.y));
          break;
        case 'lineTo':
          lineStr.push(' l ', mr(p.x), ',', mr(p.y));
          break;
        case 'close':
          lineStr.push(' x ');
          p = null;
          break;
        case 'bezierCurveTo':
          lineStr.push(' c ',
                       mr(p.cp1x), ',', mr(p.cp1y), ',',
                       mr(p.cp2x), ',', mr(p.cp2y), ',',
                       mr(p.x), ',', mr(p.y));
          break;
        case 'at':
        case 'wa':
          lineStr.push(' ', p.type, ' ',
                       mr(p.x - this.arcScaleX_ * p.radius), ',',
                       mr(p.y - this.arcScaleY_ * p.radius), ' ',
                       mr(p.x + this.arcScaleX_ * p.radius), ',',
                       mr(p.y + this.arcScaleY_ * p.radius), ' ',
                       mr(p.xStart), ',', mr(p.yStart), ' ',
                       mr(p.xEnd), ',', mr(p.yEnd));
          break;
      }


      // TODO: Following is broken for curves due to
      //       move to proper paths.

      // Figure out dimensions so we can do gradient fills
      // properly
      if (p) {
        if (min.x == null || p.x < min.x) {
          min.x = p.x;
        }
        if (max.x == null || p.x > max.x) {
          max.x = p.x;
        }
        if (min.y == null || p.y < min.y) {
          min.y = p.y;
        }
        if (max.y == null || p.y > max.y) {
          max.y = p.y;
        }
      }
    }
    lineStr.push(' ">');

    if (!aFill) {
      appendStroke(this, lineStr);
    } else {
      appendFill(this, lineStr, min, max);
    }

    lineStr.push('</g_vml_:shape>');

    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
  };

  function appendStroke(ctx, lineStr) {
    var a = processStyle(ctx.strokeStyle);
    var color = a.color;
    var opacity = a.alpha * ctx.globalAlpha;
    var lineWidth = ctx.lineScale_ * ctx.lineWidth;

    // VML cannot correctly render a line if the width is less than 1px.
    // In that case, we dilute the color to make the line look thinner.
    if (lineWidth < 1) {
      opacity *= lineWidth;
    }

    lineStr.push(
      '<g_vml_:stroke',
      ' opacity="', opacity, '"',
      ' joinstyle="', ctx.lineJoin, '"',
      ' miterlimit="', ctx.miterLimit, '"',
      ' endcap="', processLineCap(ctx.lineCap), '"',
      ' weight="', lineWidth, 'px"',
      ' color="', color, '" />'
    );
  }

  function appendFill(ctx, lineStr, min, max) {
    var fillStyle = ctx.fillStyle;
    var arcScaleX = ctx.arcScaleX_;
    var arcScaleY = ctx.arcScaleY_;
    var width = max.x - min.x;
    var height = max.y - min.y;
    if (fillStyle instanceof CanvasGradient_) {
      // TODO: Gradients transformed with the transformation matrix.
      var angle = 0;
      var focus = {x: 0, y: 0};

      // additional offset
      var shift = 0;
      // scale factor for offset
      var expansion = 1;

      if (fillStyle.type_ == 'gradient') {
        var x0 = fillStyle.x0_ / arcScaleX;
        var y0 = fillStyle.y0_ / arcScaleY;
        var x1 = fillStyle.x1_ / arcScaleX;
        var y1 = fillStyle.y1_ / arcScaleY;
        var p0 = getCoords(ctx, x0, y0);
        var p1 = getCoords(ctx, x1, y1);
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;
        angle = Math.atan2(dx, dy) * 180 / Math.PI;

        // The angle should be a non-negative number.
        if (angle < 0) {
          angle += 360;
        }

        // Very small angles produce an unexpected result because they are
        // converted to a scientific notation string.
        if (angle < 1e-6) {
          angle = 0;
        }
      } else {
        var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
        focus = {
          x: (p0.x - min.x) / width,
          y: (p0.y - min.y) / height
        };

        width  /= arcScaleX * Z;
        height /= arcScaleY * Z;
        var dimension = m.max(width, height);
        shift = 2 * fillStyle.r0_ / dimension;
        expansion = 2 * fillStyle.r1_ / dimension - shift;
      }

      // We need to sort the color stops in ascending order by offset,
      // otherwise IE won't interpret it correctly.
      var stops = fillStyle.colors_;
      stops.sort(function(cs1, cs2) {
        return cs1.offset - cs2.offset;
      });

      var length = stops.length;
      var color1 = stops[0].color;
      var color2 = stops[length - 1].color;
      var opacity1 = stops[0].alpha * ctx.globalAlpha;
      var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;

      var colors = [];
      for (var i = 0; i < length; i++) {
        var stop = stops[i];
        colors.push(stop.offset * expansion + shift + ' ' + stop.color);
      }

      // When colors attribute is used, the meanings of opacity and o:opacity2
      // are reversed.
      lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"',
                   ' method="none" focus="100%"',
                   ' color="', color1, '"',
                   ' color2="', color2, '"',
                   ' colors="', colors.join(','), '"',
                   ' opacity="', opacity2, '"',
                   ' g_o_:opacity2="', opacity1, '"',
                   ' angle="', angle, '"',
                   ' focusposition="', focus.x, ',', focus.y, '" />');
    } else if (fillStyle instanceof CanvasPattern_) {
      if (width && height) {
        var deltaLeft = -min.x;
        var deltaTop = -min.y;
        lineStr.push('<g_vml_:fill',
                     ' position="',
                     deltaLeft / width * arcScaleX * arcScaleX, ',',
                     deltaTop / height * arcScaleY * arcScaleY, '"',
                     ' type="tile"',
                     // TODO: Figure out the correct size to fit the scale.
                     //' size="', w, 'px ', h, 'px"',
                     ' src="', fillStyle.src_, '" />');
       }
    } else {
      var a = processStyle(ctx.fillStyle);
      var color = a.color;
      var opacity = a.alpha * ctx.globalAlpha;
      lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity,
                   '" />');
    }
  }

  contextPrototype.fill = function() {
    this.stroke(true);
  };

  contextPrototype.closePath = function() {
    this.currentPath_.push({type: 'close'});
  };

  function getCoords(ctx, aX, aY) {
    var m = ctx.m_;
    return {
      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
    };
  };

  contextPrototype.save = function() {
    var o = {};
    copyState(this, o);
    this.aStack_.push(o);
    this.mStack_.push(this.m_);
    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
  };

  contextPrototype.restore = function() {
    if (this.aStack_.length) {
      copyState(this.aStack_.pop(), this);
      this.m_ = this.mStack_.pop();
    }
  };

  function matrixIsFinite(m) {
    return isFinite(m[0][0]) && isFinite(m[0][1]) &&
        isFinite(m[1][0]) && isFinite(m[1][1]) &&
        isFinite(m[2][0]) && isFinite(m[2][1]);
  }

  function setM(ctx, m, updateLineScale) {
    if (!matrixIsFinite(m)) {
      return;
    }
    ctx.m_ = m;

    if (updateLineScale) {
      // Get the line scale.
      // Determinant of this.m_ means how much the area is enlarged by the
      // transformation. So its square root can be used as a scale factor
      // for width.
      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
      ctx.lineScale_ = sqrt(abs(det));
    }
  }

  contextPrototype.translate = function(aX, aY) {
    var m1 = [
      [1,  0,  0],
      [0,  1,  0],
      [aX, aY, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.rotate = function(aRot) {
    var c = mc(aRot);
    var s = ms(aRot);

    var m1 = [
      [c,  s, 0],
      [-s, c, 0],
      [0,  0, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.scale = function(aX, aY) {
    this.arcScaleX_ *= aX;
    this.arcScaleY_ *= aY;
    var m1 = [
      [aX, 0,  0],
      [0,  aY, 0],
      [0,  0,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
    var m1 = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
    var m = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, m, true);
  };

  /**
   * The text drawing function.
   * The maxWidth argument isn't taken in account, since no browser supports
   * it yet.
   */
  contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {
    var m = this.m_,
        delta = 1000,
        left = 0,
        right = delta,
        offset = {x: 0, y: 0},
        lineStr = [];

    var fontStyle = getComputedStyle(processFontStyle(this.font),
                                     this.element_);

    var fontStyleString = buildStyle(fontStyle);

    var elementStyle = this.element_.currentStyle;
    var textAlign = this.textAlign.toLowerCase();
    switch (textAlign) {
      case 'left':
      case 'center':
      case 'right':
        break;
      case 'end':
        textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';
        break;
      case 'start':
        textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';
        break;
      default:
        textAlign = 'left';
    }

    // 1.75 is an arbitrary number, as there is no info about the text baseline
    switch (this.textBaseline) {
      case 'hanging':
      case 'top':
        offset.y = fontStyle.size / 1.75;
        break;
      case 'middle':
        break;
      default:
      case null:
      case 'alphabetic':
      case 'ideographic':
      case 'bottom':
        offset.y = -fontStyle.size / 2.25;
        break;
    }

    switch(textAlign) {
      case 'right':
        left = delta;
        right = 0.05;
        break;
      case 'center':
        left = right = delta / 2;
        break;
    }

    var d = getCoords(this, x + offset.x, y + offset.y);

    lineStr.push('<g_vml_:line from="', -left ,' 0" to="', right ,' 0.05" ',
                 ' coordsize="100 100" coordorigin="0 0"',
                 ' filled="', !stroke, '" stroked="', !!stroke,
                 '" style="position:absolute;width:1px;height:1px;">');

    if (stroke) {
      appendStroke(this, lineStr);
    } else {
      // TODO: Fix the min and max params.
      appendFill(this, lineStr, {x: -left, y: 0},
                 {x: right, y: fontStyle.size});
    }

    var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' +
                m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';

    var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);

    lineStr.push('<g_vml_:skew on="t" matrix="', skewM ,'" ',
                 ' offset="', skewOffset, '" origin="', left ,' 0" />',
                 '<g_vml_:path textpathok="true" />',
                 '<g_vml_:textpath on="true" string="',
                 encodeHtmlAttribute(text),
                 '" style="v-text-align:', textAlign,
                 ';font:', encodeHtmlAttribute(fontStyleString),
                 '" /></g_vml_:line>');

    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
  };

  contextPrototype.fillText = function(text, x, y, maxWidth) {
    this.drawText_(text, x, y, maxWidth, false);
  };

  contextPrototype.strokeText = function(text, x, y, maxWidth) {
    this.drawText_(text, x, y, maxWidth, true);
  };

  contextPrototype.measureText = function(text) {
    if (!this.textMeasureEl_) {
      var s = '<span style="position:absolute;' +
          'top:-20000px;left:0;padding:0;margin:0;border:none;' +
          'white-space:pre;"></span>';
      this.element_.insertAdjacentHTML('beforeEnd', s);
      this.textMeasureEl_ = this.element_.lastChild;
    }
    var doc = this.element_.ownerDocument;
    this.textMeasureEl_.innerHTML = '';
    this.textMeasureEl_.style.font = this.font;
    // Don't use innerHTML or innerText because they allow markup/whitespace.
    this.textMeasureEl_.appendChild(doc.createTextNode(text));
    return {width: this.textMeasureEl_.offsetWidth};
  };

  /******** STUBS ********/
  contextPrototype.clip = function() {
    // TODO: Implement
  };

  contextPrototype.arcTo = function() {
    // TODO: Implement
  };

  contextPrototype.createPattern = function(image, repetition) {
    return new CanvasPattern_(image, repetition);
  };

  // Gradient / Pattern Stubs
  function CanvasGradient_(aType) {
    this.type_ = aType;
    this.x0_ = 0;
    this.y0_ = 0;
    this.r0_ = 0;
    this.x1_ = 0;
    this.y1_ = 0;
    this.r1_ = 0;
    this.colors_ = [];
  }

  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
    aColor = processStyle(aColor);
    this.colors_.push({offset: aOffset,
                       color: aColor.color,
                       alpha: aColor.alpha});
  };

  function CanvasPattern_(image, repetition) {
    assertImageIsValid(image);
    switch (repetition) {
      case 'repeat':
      case null:
      case '':
        this.repetition_ = 'repeat';
        break
      case 'repeat-x':
      case 'repeat-y':
      case 'no-repeat':
        this.repetition_ = repetition;
        break;
      default:
        throwException('SYNTAX_ERR');
    }

    this.src_ = image.src;
    this.width_ = image.width;
    this.height_ = image.height;
  }

  function throwException(s) {
    throw new DOMException_(s);
  }

  function assertImageIsValid(img) {
    if (!img || img.nodeType != 1 || img.tagName != 'IMG') {
      throwException('TYPE_MISMATCH_ERR');
    }
    if (img.readyState != 'complete') {
      throwException('INVALID_STATE_ERR');
    }
  }

  function DOMException_(s) {
    this.code = this[s];
    this.message = s +': DOM Exception ' + this.code;
  }
  var p = DOMException_.prototype = new Error;
  p.INDEX_SIZE_ERR = 1;
  p.DOMSTRING_SIZE_ERR = 2;
  p.HIERARCHY_REQUEST_ERR = 3;
  p.WRONG_DOCUMENT_ERR = 4;
  p.INVALID_CHARACTER_ERR = 5;
  p.NO_DATA_ALLOWED_ERR = 6;
  p.NO_MODIFICATION_ALLOWED_ERR = 7;
  p.NOT_FOUND_ERR = 8;
  p.NOT_SUPPORTED_ERR = 9;
  p.INUSE_ATTRIBUTE_ERR = 10;
  p.INVALID_STATE_ERR = 11;
  p.SYNTAX_ERR = 12;
  p.INVALID_MODIFICATION_ERR = 13;
  p.NAMESPACE_ERR = 14;
  p.INVALID_ACCESS_ERR = 15;
  p.VALIDATION_ERR = 16;
  p.TYPE_MISMATCH_ERR = 17;

  // set up externs
  G_vmlCanvasManager = G_vmlCanvasManager_;
  CanvasRenderingContext2D = CanvasRenderingContext2D_;
  CanvasGradient = CanvasGradient_;
  CanvasPattern = CanvasPattern_;
  DOMException = DOMException_;
})();

} // if



/* Canvas drawing library */

var kpiRed = "rgb(219, 90, 70)",
    kpiYellow = "rgb(246, 206, 66)",
    kpiGreen = "rgb(126, 183, 51)",
    kpiGray = "rgb(189, 205, 226)";

var kpiStrokeRed = "rgb(219, 90, 70)",
    kpiStrokeYellow = "rgb(246, 206, 66)",
    kpiStrokeGreen = "rgb(126, 183, 51)",
    kpiStrokeGray = "rgb(189, 205, 226)";

var kpiDisableRed    = "rgb(255, 241, 237)",
    kpiDisableYellow = "rgb(255, 248, 223)",
    kpiDisableGreen  = "rgb(242, 255, 226)",
    kpiDisableGray   = "rgb(239, 246, 255)";
    kpiDisableBlue  = "#4e80c1";

var kpiStrokeDisableRed     = "rgb(246, 172, 166)",
    kpiStrokeDisableYellow  = "rgb(228, 219, 171)",
    kpiStrokeDisableGreen   = "rgb(211, 234, 180)",
    kpiStrokeDisableBlue   = "rgb(125, 249, 255)",
    kpiStrokeDisableGray    = "rgb(184, 203, 220)";

var kpiColors = [];

/*Стабилизация*/
kpiColors[0] = [kpiRed, kpiYellow, kpiGreen, kpiYellow, kpiRed];
/*Увеличение*/
kpiColors[1] = [kpiRed, kpiYellow, kpiGreen];
/*Уменьшение*/
kpiColors[2] = [kpiGreen, kpiYellow, kpiRed];
/*По плану и выше*/
kpiColors[3] = [kpiRed, kpiGreen];
/*По плану и ниже*/
kpiColors[4] = [kpiGreen, kpiRed];

var maxFontSize = 12;

var kpiDisabledColors = [];

var fontFamily = "Arial";

/*Стабилизация*/
kpiDisabledColors[0] = [kpiDisableRed, kpiDisableYellow, kpiDisableGreen, kpiDisableYellow, kpiDisableRed];
/*Увеличение*/
kpiDisabledColors[1] = [kpiDisableRed, kpiDisableYellow, kpiDisableGreen];
/*Уменьшение*/
kpiDisabledColors[2] = [kpiDisableGreen, kpiDisableYellow, kpiDisableRed];
/*По плану и выше*/
kpiDisabledColors[3] = [kpiDisableRed, kpiDisableGreen];
/*По плану и ниже*/
kpiDisabledColors[4] = [kpiDisableGreen, kpiDisableRed];

var kpiStatusPriority = [-10, 0, 5, 10];
var kpiStatusColors = ["rgb(239, 246, 255)", "rgb(219, 90, 70)", "rgb(246, 209, 66)", "rgb(182, 222, 131)"];
var kpiStatusStrokeColors = [kpiStrokeGray, kpiStrokeRed, kpiStrokeYellow, kpiStrokeGreen];

var countTicks = 5;
var CountYLines = 5;

var sw = screen.width;
var sh = screen.height;
var iw = window.innerWidth;
var ih = window.innerHeight;

var LegendWidth = 100,
    LegendHeight = 25;

var shapeParsCache = [];

function GetShapeParams(uid, x, y, width, height, settings) {

    if (shapeParsCache[uid] != null && shapeParsCache[uid] != undefined) {

        return shapeParsCache[uid];
    }
    else {
        
        var widthWithLegend = settings.LegendAlign === 1 || settings.LegendAlign === 3 ? width - LegendWidth : width;
        var heightWithLegend = settings.LegendAlign === 2 || settings.LegendAlign === 4 ? height - LegendHeight : height;

        var yWidth = (settings.YAxisType === 1 && !settings.Invert) || (settings.XAxisType === 1 && settings.Invert) ? GetYWidth(widthWithLegend) * (settings.Invert ? 2 : 1) : 10;

        var chartX = x + yWidth;
        var titleHeight = settings.TitleAlign === 2 ? GetTitleHeight(heightWithLegend) : 10;

        var xHeight = (settings.XAxisType === 1 && !settings.Invert) || (settings.YAxisType === 1 && settings.Invert) ? GetXHeight(heightWithLegend) : 10;

        var chartHeight = heightWithLegend - titleHeight - xHeight + (settings.LegendAlign === 2 ? LegendHeight : (settings.LegendAlign === 4 && settings.XAxisType === 0 ? -10 : 0));
        var chartWidth = widthWithLegend - yWidth - Math.min(widthWithLegend * 0.05, 10);

        var chartY = y + titleHeight + (settings.LegendAlign === 2 ? LegendHeight : 0);
        
        if (settings.LegendAlign === 3) {
            chartX += LegendWidth;
        }

        shapeParsCache[uid] =
            {
                x: x,
                y: y,
                width: width,
                height: height,
                yWidth: yWidth,
                chartX: chartX,
                chartY: chartY,
                chartWidth: chartWidth,
                chartHeight: chartHeight,
                titleHeight: titleHeight,
                xHeight: xHeight,
                titleAlign: settings.TitleAlign,
                legendAlign: settings.LegendAlign,
                settings: settings,
                invert: settings.Invert
            };
    }
    return shapeParsCache[uid];
}

function GetMaxLegend(legends) {
    var maxLegend = new String();

    for (var i = 0; i < legends.length; i++) {
        if (isset(legends[i]) && legends[i].length > maxLegend.length) {
            maxLegend = legends[i];
        }
    }
    return maxLegend;
}

function GetYWidth(shapeWidth) {
    return Math.min(shapeWidth * 0.15, 75);
}

function GetChartWidth(shapeWidth) {
    return shapeWidth - GetYWidth(shapeWidth) - Math.min(shapeWidth * 0.05, 10);
}

function GetTitleHeight(shapeHeight) {
    return Math.min(shapeHeight * 0.15, 60);
}

function GetXHeight(shapeHeight) {
    return Math.min(shapeHeight * 0.2, 70);
}

function GetChartHeight(shapeHeght) {
    return shapeHeght - GetTitleHeight(shapeHeght) - GetXHeight(shapeHeght);
}

function GetTextWidth(context, text, coef) {
    return context.measureText(text).width * coef;
}

// Разбить число на разряды 10000 => '10 000'
function toRank(strNumber) {
    var str = isset(strNumber) && isNumeric(strNumber) && typeof(strNumber) === "number" ? Round(strNumber, 2) : strNumber;
    return !isset(str) ? "" : str.toString().replace(/(\d)(?=(\d\d\d)+([^\d]|$))/g, "$1 "); // u2002 - короткий пробел
}

function GetStatusColor(status, color) {
    if (status === -15) {
        return color;
    }
    for (var kk = 0; kk < kpiStatusPriority.length; kk++) {
        if (kpiStatusPriority[kk] === status)
            return kpiStatusColors[kk];
    }
    return kpiGray;
}

function GetStatusStrokeColor(status, color) {
    if (status === -15) {
        return color;
    }
    for (var kk = 0; kk < kpiStatusPriority.length; kk++) {
        if (kpiStatusPriority[kk] === status)
            return kpiStatusStrokeColors[kk];
    }
    return kpiGray;
}

function GetTextWidth2(ctx, text, fontSize, fontFamily) {
    ctx.save();
    ctx.font = fontSize + "pt " + fontFamily;
    var width = ctx.measureText(text).width || ctx.measureText(text).width;
    ctx.restore();
    return width;
}

function GetTextOption(ctx, width, height, str, fontSize) {

    if (!isset(fontSize)) {
        fontSize = maxFontSize;
    }

    var vertical = width < height && width < GetTextWidth2(ctx, str.toString(), fontSize, fontFamily);

    var limit = (vertical ? height : width) - 5;

    for (var i = 1; i < 2 && GetTextWidth2(ctx, str.toString(), fontSize, fontFamily) > limit; i++) {
        fontSize = maxFontSize - i * 2;
    }

    return {
        width: width,
        height: height,
        angle: vertical ? -Math.PI / 6 : 0,
        fontSize: fontSize,
        textAlign: vertical ? "right" : "center",
        vertical: vertical,
        foreColor: "black",
        textWidth: GetTextWidth2(ctx, str.toString(), fontSize, fontFamily)
    };
}

function getLines(ctx, phrase, maxPxLength, textStyle) {

    var wa = phrase.split(/\r\n|[' ']/g),
        phraseArray = [],
        lastPhrase = wa[0],
        measure;
    ctx.font = textStyle;
	
    for (var i = 1; i < wa.length; i++) {
        var w = wa[i];
        measure = ctx.measureText(lastPhrase + " " + w).width;
		
        if (measure < maxPxLength) {
            lastPhrase += (" " + w);
        } else {
            phraseArray.push(lastPhrase);
            lastPhrase = w;
        }
        if (i === wa.length - 1) {
            phraseArray.push(lastPhrase);
            break;
        }
    }
    return phraseArray.length === 0 ? [phrase] : phraseArray;
}

//Вывод ТЕКСТ с форматированием
function wrapTextStyle(context, text, x, y, width, height, options) {
    context.save();
    var fontSize = isset(options.fontSize) ? options.fontSize : 9;
    var fontStyle = isset(options.fontStyle) ? options.fontStyle : "";
    context.font = fontStyle + " " + fontSize.toString() + "pt " + fontFamily;
    context.textBaseline = options.baseline || "middle";
    context.textAlign = options.textAlign || "center";
    context.fillStyle = options.fill || "black";
    var w = Math.floor(width * 0.95);
    var h = Math.floor(height * 0.95);
    var lines = getLines(context, isset(text) ? text.toString() : "", w, context.font);
    var lineHeight = Math.ceil(fontSize * 1.5);
    var top = (h - (lines.length * lineHeight)) / 2;
    var cX = x + (context.textAlign === "center" ? w / 2: (context.textAlign === "left" ? 0 : w)) + width * 0.025;
    var cY = y + (context.textBaseline === "middle" ? (top + lineHeight / 2) : (context.textBaseline === "top" ? 0 : top * 2)) + height * 0.025;
    var color = options.stroke || "black";
    for (var i = 0; i < lines.length; i++) {
        var cY1 = cY + lineHeight * (i + 0.5);
        context.fillText(lines[i], cX, cY + lineHeight * i);
        var clx = cX - context.measureText(lines[i]).width / 2;
        if (options.Underline === 1) {
            line(context, clx, cY1, clx + context.measureText(lines[i]).width, cY1, color, fontSize / 10);
        }
        else if (options.LineThrough === 1) {
            line(context, clx , cY + lineHeight * i, clx + context.measureText(lines[i]).width, cY + lineHeight * i, color, fontSize / 10);
        }
    }

    context.restore();
}

function wrapText(context, text, x, y, width, height, fontSize, fill, align, baseline, angle, contra) {

    context.save();
    
    if(typeof (contra) === "undefined")
        contra = false;

    context.textBaseline = baseline || "middle";
    context.textAlign = align || "center";
    context.font = (fontSize || maxFontSize).toString() + "pt " + fontFamily;
    context.fillStyle = fill || "black";

    var w = Math.floor(width * 0.95);
    var h = Math.floor(height * 0.95);
	
    var lines = getLines(context, isset(text) ? text.toString() : "", w, context.font);
	
    // Translate to near the center to rotate about the center
    context.translate(x, y);
    // Rotate ...
    context.rotate(angle);
    // Then translate back to draw in the right place!
    context.translate(-x, -y);

    var lineHeight = Math.ceil(fontSize * 1.5);
    var t = contra ? Math.floor(height / lineHeight) : lines.length;
    if (t > lines.length)
        t = lines.length;
    var top = (h - (t * lineHeight)) / 2;

    var cX = x + (context.textAlign === "center" ? w / 2 : (context.textAlign === "left" ? 0 : w)) + width * 0.025;

    var cY = y + (context.textBaseline === "middle" ? (top + lineHeight / 2) : (context.textBaseline === "top" ? 0 : top * 2)) + height * 0.025;
    var d = context.measureText("йцукенгшщзхъфывапролджэячсмитьбю").width / 32;
	
    for (var i = 0; i < lines.length; i++) {
        var breaking = (contra && (i + 1 < lines.length) && (lineHeight * (i + 1) >= height));       
		var text4 = lines[i];
		
		if (context.measureText(text4).width > w){
			var d2 = (context.measureText(text4).width - w) / d;
			var k = Math.floor(d2);
		    if (Math.abs(k) != 0) {
		        text4 = text4.slice(0, -k);
		    }
		}
        context.fillText(breaking ? text4.slice(0, -2) + "..." : text4, cX, cY + lineHeight * i);
        
        if (breaking)
            break;
    }
    context.restore();
}

function drawRectangle(ctx, x, y, w, h, fill, text) {
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    if (fill.length > 1) {
        ctx.fillStyle = fill;
        ctx.fill();
    }
    ctx.lineWidth = 1;
    ctx.strokeStyle = kpiStrokeGray;

    ctx.closePath();
    ctx.stroke();
    if (text.length > 0) {
        wrapText(ctx, text, x, y, w, h, 9);
    }
}

function isset(obj) {
    return (typeof obj != "undefined" && obj != null);
}

function roundRect(ctx, x, y, width, height, radius, fill, stroke, strokeWidth, angle, options) {
    if (typeof stroke === "undefined") {
        stroke = true;
    }

    ctx.save();

    if (angle != undefined) {
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.translate(-x, -y);
    }
    ctx.translate(0.5, 0.5);
    if (radius !== 0) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();

        if (stroke) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 2;
            if (strokeWidth) {
                ctx.lineWidth = strokeWidth;
            }
            ctx.stroke();
        }
        if (isset(fill)) {
            ctx.fillStyle = fill;
            ctx.fill();
        }

    } else {

        if (isset(fill)) {
            ctx.fillStyle = fill;
            ctx.fillRect(x, y, width, height);
        }
        if (isset(stroke)) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = strokeWidth;
            ctx.strokeRect(x, y, width, height);
        }
    }
    ctx.restore();
    
    if (isset(options) && isset(options.text) && options.text.length > 0) {
        
        if (isset(options.textOptions)) {
            wrapTextStyle(ctx, options.text, x, y, width, height, options.textOptions);
        } else {
            wrapText(ctx, options.text, x, y, width, height, 9);
        }
    }
}

function line(ctx, x1, y1, x2, y2, stroke, strokeWidth) {
    ctx.save();
    ctx.translate(0.5, 0.5);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);

    ctx.strokeStyle = isset(stroke) ? stroke : "black";
    ctx.lineWidth = isset(strokeWidth) ? strokeWidth : 1;
    ctx.stroke();

    ctx.closePath();
    ctx.restore();
}

function linePattern(ctx, x1, y1, x2, y2, stroke, options) {
    ctx.save();

    var strokeWidth = 1;
    var pattern = "";
    if(isset(options)) {
        strokeWidth = options.EmSize || 1;
        pattern = options.Pattern;
    }

    ctx.translate(0.5, 0.5);
    ctx.beginPath();
    
    if (pattern === "Dash") {
        dashLine(ctx, x1, y1, x2, y2, strokeWidth);
    } else if (pattern === "DashDot") {
        DashDotLine(ctx, x1, y1, x2, y2, strokeWidth);
    } else if (pattern === "DashDotDot") {
        DashDotDotLine(ctx, x1, y1, x2, y2, strokeWidth);
    }
    
    else {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
    }
    ctx.strokeStyle = isset(stroke) ? stroke : "black";
    ctx.lineWidth = isset(strokeWidth) ? strokeWidth : 1;
    ctx.stroke();

    ctx.closePath();
    ctx.restore();
}

function DashDotDotLine(context, x, y, x2, y2, dashLen) {

    dashLen = dashLen*2;
    var x1 = x;
    var y1 = y;
    var dX = x2 - x1;
    var dY = y2 - y1;
    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);
    var dashX = dX / dashes;
    var dashY = dY / dashes;
    var step1 = 0.7;
    var step2 = 0.1;
    dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / ((dashX / step1) * 5 + dashX / step2));
    var q = 0;
    context["moveTo"](x1, y1);
    while (q++ < dashes) {

        context["moveTo"](x1, y1);
        x1 += dashX / step2;
        y1 += dashY / step2;
        context["lineTo"](x1, y1);
        x1 += dashX / step1;
        y1 += dashY / step1;
        context["moveTo"](x1, y1);
        x1 += dashX / step1;
        y1 += dashY / step1;
        context["lineTo"](x1, y1);
        x1 += dashX / step1;
        y1 += dashY / step1;
        context["moveTo"](x1, y1);
        x1 += dashX / step1;
        y1 += dashY / step1;
        context["lineTo"](x1, y1);
        x1 += dashX / step1;
        y1 += dashY / step1;
        
    }
    context[q % 2 === 0 ? "moveTo" : "lineTo"](x2, y2);

    context.stroke();
    context.closePath();
};

function DashDotLine(context, x, y, x2, y2, dashLen) {

    dashLen = dashLen*2 ;
    var x1 = x;
    var y1 = y;
    var dX = x2 - x1;
    var dY = y2 - y1;
    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);
    var dashX = dX / dashes ;
    var dashY = dY / dashes ;
    var step1 = 0.6;
    var step2 = 0.2;
    dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / ((dashX / step1) * 3 + dashX / step2));
    var q = 0;
    context["moveTo"](x1, y1);
    while (q++ < dashes) {

        context["moveTo"](x1, y1);
        x1 += dashX / step2;
        y1 += dashY / step2;
        context["lineTo"](x1, y1);
        x1 += dashX / step1;
        y1 += dashY / step1;
        context["moveTo"](x1, y1);
        x1 += dashX / step1;
        y1 += dashY / step1;
        context["lineTo"](x1, y1);
        x1 += dashX / step1;
        y1 += dashY / step1;
     
    }
    context[q % 2 === 0 ? "moveTo" : "lineTo"](x2, y2);

    context.stroke();
    context.closePath();
};

function dashLine(context, x, y, x2, y2, dashLen) {
    dashLen = dashLen * 3;
    var x1 = x;
    var y1 = y;
    var dX = x2 - x1;
    var dY = y2 - y1;
    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);
    var dashX = dX / dashes;
    var dashY = dY / dashes;
    var q = 0;
    context["moveTo"](x1, y1);
    while (q++ < dashes) {
        if (q % 2 !== 0) {
            x1 += dashX * (1.4);
            y1 += dashY * (1.4);
        } else {
            x1 += dashX / (1.8);
            y1 += dashY / (1.8);
        }
        context[q % 2 === 0 ? "moveTo" : "lineTo"](x1, y1);
    }
    context[q % 2 === 0 ? "moveTo" : "lineTo"](x2, y2);
    context.stroke();
    context.closePath();
};

function polygon(ctx, points, fill, stroke, strokeWidth, options) {
    ctx.beginPath();

    var text = isset(options) && isset(options.text) ? options.text : null;

    var minX = points[0];
    var minY = points[1];

    var maxX = points[0];
    var maxY = points[1];

    if (points.length > 2) {
        ctx.moveTo(points[0], points[1]);
        for (var i = 2; i < points.length; i += 2) {
            if(text != null) {
                minX = Math.min(minX, points[i]);
                minY = Math.min(minY, points[i + 1]);
                maxX = Math.max(maxX, points[i]);
                maxY = Math.max(maxY, points[i + 1]);
            }
            ctx.lineTo(points[i], points[i + 1]);
        }
    }
    ctx.closePath();

    if (fill != undefined && fill.length > 0) {
        ctx.fillStyle = fill;
    } else {
        ctx.fillStyle = "white";
    }
    ctx.fill();

    if (stroke) {
        ctx.strokeStyle = stroke;
        if (strokeWidth) {
            ctx.lineWidth = strokeWidth;
        }
        ctx.stroke();
    }
    if(text != null) {
        wrapText(ctx, text, minX, minY, maxX - minX, maxY - minY, 12, "black", "center", "middle");
    }
}

function circle(ctx, x, y, radius, fill, stroke, strokeWidth) {

    ellipse(ctx, x - radius, y - radius, radius * 2, radius * 2, { fill: fill, stroke: stroke, strokeWidth: strokeWidth, text: "" });
}

function bar(ctx, x, y, width, height, fill, stroke, strokeWidth) {
    if (typeof stroke === "undefined") {
        stroke = true;
    }

    ctx.save();
    ctx.beginPath();

    var div = 0;

    var points = [x, y + div, x + width, y, x + width, y + height, x, y + height, x, y + div];

    if (points.length > 2) {
        ctx.moveTo(points[0] + .5, points[1] + .5);
        for (var i = 2; i < points.length; i += 2) {
            ctx.lineTo(points[i] + .5, points[i + 1] + .5);
        }
    }

    ctx.closePath();

    if (stroke) {
        ctx.strokeStyle = stroke;
        if (strokeWidth) {
            ctx.lineWidth = strokeWidth;
        }
        ctx.stroke();
    }
    if (fill !== null && fill !== undefined && fill.length > 1) {
        ctx.fillStyle = fill;
        ctx.fill();
    }
    ctx.restore();
}

function vertBar(ctx, x, y, width, height, radius, fill, stroke, strokeWidth) {
    if (typeof stroke === "undefined") {
        stroke = true;
    }

    ctx.save();
    ctx.beginPath();
    var points = [
        x, y,
        x + width, y,
        x + width, y + height,
        x, y + height,
        x, y];

    if (points.length > 2) {
        ctx.moveTo(points[0], points[1]);
        for (var i = 2; i < points.length; i += 2) {
            ctx.lineTo(points[i], points[i + 1]);
        }
    }

    ctx.closePath();

    if (stroke) {
        ctx.strokeStyle = stroke;
        if (strokeWidth) {
            ctx.lineWidth = strokeWidth;
        }
        ctx.stroke();
    }
    if (fill !== null && fill !== undefined && fill.length > 1) {
        ctx.fillStyle = fill;
        ctx.fill();
    }
    ctx.restore();
}

function connector(ctx, x1, y1, x2, y2) {

    var headlen = 9;
    var dx = x2 - x1;
    var dy = y2 - y1;
    var angle = Math.atan2(dy, dx);
    var anglePlus = angle + Math.PI / 6;
    var angleMinus = angle - Math.PI / 6;

    var points = [
        x1, y1,
        x2 - (headlen - 1) * Math.cos(angle), y2 - (headlen - 1) * Math.sin(angle),
        x2 - headlen * Math.cos(angleMinus), y2 - headlen * Math.sin(angleMinus),
        x2, y2,
        x2 - headlen * Math.cos(anglePlus), y2 - headlen * Math.sin(anglePlus),
        x2 - headlen * Math.cos(angleMinus), y2 - headlen * Math.sin(angleMinus),
        x2, y2
        ];

    polygon(ctx, points, "black", "black", 1);
}

function bezieconnector(ctx, x1, y1, x2, y2) {
    var divX = Math.abs(x2 - x1);
    var divY = Math.abs(y2 - y1);
    
    var cp1 = { x: Math.min(x1, x2) + divX * (x1 > x2 ? 0.75 : 0.10), y: Math.min(y1, y2) + divY * (y1 > y2 ? 0.75 : 0.10) };
    var cp2 = { x: Math.min(x1, x2) + divX * (x1 > x2 ? 0.90 : 0.25), y: Math.min(y1, y2) + divY * (y1 > y2 ? 0.25 : 0.90) };
    
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.bezierCurveTo(cp1.x,cp1.y,cp2.x,cp2.y,x2,y2);
    
    ctx.save();
    ctx.strokeStyle = kpiStrokeDisableGray;
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.restore();
   
}

function ellipse(ctx, x, y, w, h, options) {
    var kappa = .5522848,
            ox = (w / 2) * kappa, // control point offset horizontal
            oy = (h / 2) * kappa, // control point offset vertical
            xe = x + w,           // x-end
            ye = y + h,           // y-end
            xm = x + w / 2,       // x-middle
            ym = y + h / 2;       // y-middle

    ctx.beginPath();
    ctx.moveTo(x, ym);
    ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
    ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

    ctx.fillStyle = isset(options.fill) ? options.fill : kpiGray;
    ctx.fill();

    ctx.strokeStyle = isset(options.stroke) ? options.stroke : kpiStrokeGray;
    ctx.lineWidth = isset(options.strokeWidth) ? options.strokeWidth : 1;

    ctx.closePath();
    ctx.stroke();

    if (isset(options.text) && options.text.length > 0) {

        var textOptions = GetTextOption(ctx, w, h, options.text);

        wrapText(ctx, options.text, x, y, w, h, textOptions.fontSize, "black", "center", "middle", 0);
    }
}

// зоны спидометра
function Wedge(ctx, x, y, radius, color, dx, dy) {
    ctx.beginPath();
    ctx.arc(x, y, radius, dx * Math.PI, dy * Math.PI, false);
    ctx.lineWidth = Math.ceil(radius / 10);
    ctx.strokeStyle = color;
    ctx.stroke();
}

// стрелка
function Needle(ctx, x, y, radius, dataangle) {
    if (isNumber(dataangle) &&
    dataangle !== Number.NEGATIVE_INFINITY &&
    dataangle !== Number.POSITIVE_INFINITY
    ) {

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - (radius * 0.9) * Math.cos(dataangle), y - (radius * 0.9) * Math.sin(dataangle));
        ctx.lineCap = "round";
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = Math.ceil(radius / 25);

        ctx.stroke();
        ctx.restore();
        circle(ctx, x, y, radius * 0.08, "#000000", "#000000", 1);
    }
}

// засечки на шкале и подписи к ним
function TickLegend(ctx, x, y, radius, angle, value, textOption) {

    var textX = x - radius * 1.08 * Math.cos(angle);
    var textY = y - radius * 1.15 * Math.sin(angle)- radius * 0.1;

    var align = textX > x ? "left" : "right";
    textX = textX > x ? textX : textX - textOption.width;

    var strValue = toRank(Round(value, 2));

    var realLength = textOption.width / (textOption.textWidth / strValue.toString().length);

    var dif = Math.floor(strValue.toString().length - realLength);
    var diff = dif >= 5 ? 6 : (dif >= 2 ? 3 : 0);
    var krat = Math.pow(10, diff);
    var legend = diff === 6 ? "млн." : (diff === 3 ? "тыс." : "");
    var t = toRank(Round(value / krat, 2));

    if (textY <= y) {
        textY -= diff > 0 ? textOption.fontSize : 0;
    }
	//debugRect(ctx, textX, textY, textOption.width, textOption.height);
    wrapText(ctx, toRank(t), textX, textY, textOption.width, textOption.height, textOption.fontSize, textOption.foreColor, align);
    wrapText(ctx, legend, textX, textY + textOption.fontSize * 0.7, textOption.width, textOption.height, textOption.fontSize, textOption.foreColor, align);
}

// Сконвертировать минуты в дни часы минуты
function ConvertUnitsShape(valueGraph, units, MinutesWorkDay) {
    var day = SR.T("д.");
    var hour = SR.T("ч.");
    var min = SR.T("м.");
    var minDay = MinutesWorkDay||1440;
    var minHour = 60;

    if (units != undefined && valueGraph > 0) {
        switch (units) {
            case 'Min':
                valueGraph = Math.round(valueGraph) + "" + min;
                break;
            case 'Hour':
                var hourKol = Math.floor(valueGraph / minHour);
                var minKol = Math.round(valueGraph % minHour);
                hourKol = hourKol > 0 ? hourKol + "" + hour + "" : "";
                minKol = minKol > 0 ? minKol + "" + min:"";
                valueGraph = hourKol + minKol ;
                break;
            case 'Day':
                var dayKol = Math.floor(valueGraph / minDay);
                var dayMinKol = Math.floor(valueGraph % minDay);
                var hourKol = Math.floor(dayMinKol / minHour);
                var minKol = Math.round(dayMinKol % minHour);
                dayKol = dayKol > 0 ? dayKol + "" + day + "" : "";
                hourKol = hourKol > 0 ? hourKol + "" + hour + "" : "";
                minKol = minKol > 0 ? minKol + "" + min:"";
                valueGraph = dayKol + hourKol + minKol;
                break;
        }
    }
    return valueGraph;
}

// засечки на шкале и подписи к ним
function Tick(ctx, x, y, radius, angle, value, textOption, units, MinutesWorkDay) {

    var textX = x - radius * 1.08 * Math.cos(angle);
    var textY = y - radius * 1.15 * Math.sin(angle) - radius * 0.05;

    var align = textX > x ? "left" : "right";
    textX = textX > x ? textX : textX - textOption.width;

    var strValue = toRank(Round(value, 2));
    
    var realLength = textOption.width / (textOption.textWidth / strValue.toString().length);

    var dif = Math.floor(strValue.toString().length - realLength);
    var diff = dif >= 5 ? 6 : (dif >= 2 ? 3 : 0);
    var krat = Math.pow(10, diff);
    var legend = diff === 6 ? SR.T("млн.") : (diff === 3 ? SR.T("тыс.") : "");
    var t = toRank(Round(value / krat, 2));

    if (textY <= y) {
        textY -= diff > 0 ? textOption.fontSize : 0;
    }
    var valueGraph = toRank(t);
    if (units != undefined && units != 'Default') {
        legend = "";
        t = value;
        valueGraph = ConvertUnitsShape(t, units, MinutesWorkDay);
    }
    
    wrapText(ctx, valueGraph, textX, textY, textOption.width, textOption.height, textOption.fontSize, null, align);
    wrapText(ctx, legend, textX, textY + textOption.fontSize * 0.7, textOption.width, textOption.height, textOption.fontSize, null, align);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x - radius * 0.9 * Math.cos(angle), y - radius * 0.9 * Math.sin(angle));
    ctx.lineTo(x - radius * 1.04 * Math.cos(angle), y - radius * 1.04 * Math.sin(angle));
    ctx.lineCap = "round";
    ctx.strokeStyle = "#858881";
    ctx.lineWidth = radius * 0.02;

    ctx.stroke();
    ctx.restore();
}

function NormalizeInvertvals(intervals, scale, datapoint) {
    if (Number.isNaN(intervals[0]) || intervals[0] === Number.NEGATIVE_INFINITY) {
        intervals[0] = 0;
    }
    var il = intervals.length - 1;
    if (Number.isNaN(intervals[il]) || intervals[il] === Number.POSITIVE_INFINITY) {
        intervals[il] = intervals[il - 1] * il;
    }

    if (intervals.length === 2) {
        var dif = Math.abs(datapoint - intervals[1]);

        if (scale === 1 || scale === 2) {
            intervals[2] = intervals[1] * 2;
            intervals[3] = intervals[1] * 3;
        }
        if (scale === 3 || scale === 4) {
            intervals[2] = intervals[1] + (30 * dif);
        }
    }
    return intervals;
}

function pieCharts(ctx, some, uid, x, y, width, height, options) {

    var settings = options.Settings;

    var shapePars = GetShapeParams(uid, x, y, width, height, settings);
    // Рамка
    roundRect(ctx, x, y, width - 1, height - 1, 0, options.showBackground ? kpiGray : "white", kpiStrokeGray, 1);

    var intervals = [];
	var dataspan = 0;
    var i;
    for (i = 0; i < options.data[0].Values.length; i++){
		intervals.push(options.data[0].Values[i]);
		dataspan += options.data[0].Values[i];
	}
	var colors = options.data[0].Colors;
    // Текущее значение
    var lMax = arrayMax(intervals, 0);

    var strLMax = toRank(Round(lMax, 2));

    // сколько процентов от круга отрезаем
    var pie = 0;
    var lMin = arrayMin(intervals, lMax);
	
    var length = 2 - (2 * pie / 100);
    var span = length * 360 / 2;
    var startAngle = (90 + (360 - span) / 2) * Math.PI / 180;

    if (dataspan > 0) {

        var startPoint = 1.5;
        var endPoint;
		var il = intervals.length;
		
        var countValues = isset(options.data[0].Values) ? options.data[0].Values.length : 0;

        var valWidth = shapePars.chartWidth / (countValues + 1);

        var legendOption = GetTextOption(ctx, valWidth, shapePars.xHeight, GetMaxLegend(options.legends), 9);
        
        var legendWidth = settings.LegendAlign === 1 || settings.LegendAlign === 3 ? LegendWidth : shapePars.chartWidth / il;
        
        var lHeight = legendOption.fontSize * 3;
        var legendHeight = settings.LegendAlign === 2 || settings.LegendAlign === 4 ? LegendHeight : (il * lHeight > shapePars.chartHeight ? shapePars.chartHeight / il : lHeight);

		legendHeight = Math.max(legendHeight, 30);
		
		var cvf = Math.min(Math.floor(shapePars.chartHeight / legendHeight), il);

        cvf = il - cvf <= 2 ? il : cvf;

		var radius = Math.min(width - legendWidth, height - legendHeight) / 2 * 0.8;
		
		var ge = GetTextOption(ctx, legendWidth, radius * 0.23, strLMax);
		
		var wx = x + (settings.LegendAlign === 2 || settings.LegendAlign === 4 || settings.LegendAlign === 0 ? width * 0.5 : shapePars.chartWidth * 0.6) 
			+ (settings.LegendAlign === 3 ? legendWidth : 0);
		var wy = y + height * 0.5 + (settings.LegendAlign === 2 ? legendHeight : 0);
		startPoint = -1.575;
		var dd = 0;
		
        for (i = 0; i < cvf; i++) {
            endPoint = startPoint + Math.PI*2*(intervals[i]/dataspan);
			
			Pie(ctx, wx, wy, radius, startPoint, endPoint, colors[i], il <= 1 || (il === 2 && lMax*lMin===0)? colors[i] : "white");
			
			startPoint = endPoint;
			
			dd += intervals[i];
            ge.foreColor = colors[i];
            TickLegend(ctx, wx, wy, radius, (dd - (intervals[i]/2))/ dataspan * span * Math.PI / 180 + startAngle, intervals[i], ge);
			
            var isuser = isset(options.data[0].Responsibles) && options.data[0].Responsibles.length > 0 && isset(options.data[0].Responsibles[i]);
            var user = isuser ? options.data[0].Responsibles[i] : null;
            var chartClick = options.data[0].Click || options.data[0].Clicks[i];
            
            if (isset(chartClick)) {
                if (isset(user))
                    chartClick = elma.repString(chartClick, "userId", isset(user.Id) ? user.Id : -1);
                else {
                    chartClick = elma.repString(chartClick, "userId", -1);
                }
            } 
			
			var chart = {Click: chartClick, Name: options.legends[i], Color: colors[i]};
			
			DrawChartLegend(ctx, some, uid, chart, legendOption.fontSize, legendWidth, legendHeight, i, lMin, lMax);
        }
		
		if (cvf < il){
			var othersValue = 0;
			for(i = cvf; i < il; i++){
				othersValue += intervals[i];
			}
			/***/
			
            endPoint = startPoint + Math.PI*2*(othersValue/dataspan);
			
			Pie(ctx, wx, wy, radius, startPoint, endPoint, kpiStrokeDisableGray, il <= 1 || (il === 2 && lMax*lMin===0)? kpiStrokeDisableGray : "white");
			
			startPoint = endPoint;
			
			dd += othersValue;
            ge.foreColor = kpiStrokeDisableGray;
            TickLegend(ctx, wx, wy, radius, (dd - (othersValue/2))/ dataspan * span * Math.PI / 180 + startAngle, othersValue, ge);
			
			chart = {Name: SR.T("Другое ({0})", il-cvf), Color: kpiStrokeDisableGray};
			
			DrawChartLegend(ctx, some, uid, chart, legendOption.fontSize, legendWidth, legendHeight, cvf, lMin, lMax);			
			
			/***/
		}
		
		
    } else {
		wrapText(ctx, SR.T("Нет данных за период"), x, y, width, height, 18, kpiRed, "center", "middle", 0);
	}
	
	DrawChartTitle(ctx, uid, options.text, 14);
}

function Pie(ctx, x, y, radius, startPoint, endPoint, color, borderColor){
	if (startPoint !== endPoint){
		ctx.fillStyle = color;
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.arc(x,y,radius,startPoint,endPoint,false);
		ctx.lineTo(x,y);
		ctx.fill();
		ctx.strokeStyle = borderColor;
		ctx.lineWidth = 2;
		ctx.stroke();
	}
}

function Speedometer(ctx, x, y, w, h, text, datapoint, intervals, status, scale, units, MinutesWorkDay) {
    var rectFill = status === 10 ? "#f2ffe2" : (status === 5 ? "#fff8df" : (status === 0 ? "#fff1ed" : "#eff6ff"));
    var rectStroke = status === 10 ? "#d3eab4" : (status === 5 ? "#e4dbab" : (status === 0 ? "#f6aca6" : "#b8cbdc"));
    // золотое сечение :)
    var radius = Math.min(w, h) / 2 * 0.62;
    var wx = x + w / 2;
    var wy = y + h * 0.62;
    var fontSize = Math.min(Math.ceil(radius / 7) + 2, 18);
    
    roundRect(ctx, x, y, w, h, 10, rectFill, rectStroke, 2);
    wrapText(ctx, text, x, y, w, h * 0.2, fontSize, "black", "center", "middle", 0, !0);

    intervals = NormalizeInvertvals(intervals, scale, datapoint);

    // Текущее значение
    var lMax = arrayMax(intervals, datapoint);

    var strLMax = toRank(Round(lMax, 2));
    var legendWidth = (w - radius * 2) * 0.4;
    var ge = GetTextOption(ctx, legendWidth, radius * 0.23, strLMax);

    
    var factText = "";
    if (Number.isNaN(datapoint)) {
        factText =   SR.T("Нет значения") 
    } else {
        factText = toRank(datapoint).toString();
        if (units != undefined && units != 'Default') {
            factText = ConvertUnitsShape(datapoint, units, MinutesWorkDay);
        }
    }


     
	
	var ctextWidth = GetTextWidth2(ctx, factText, ge.fontSize, fontFamily) * 1.1;
    roundRect(ctx, wx - ctextWidth * 0.5 - 5, wy + radius * 0.43 - 5, ctextWidth + 10, ge.fontSize * 1.2 + 10, 5, rectStroke, rectStroke, 1);
	
    wrapText(ctx, factText, wx - ctextWidth * 0.5, wy + radius * 0.43, ctextWidth, ge.fontSize * 1.2, ge.fontSize);
    
    if (intervals.length > 0) {
        // сколько процентов от круга отрезаем
        var pie = 20;
        var lMin = arrayMin(intervals, lMax);

        /* Стрелка - указатель */

        var dataspan = lMax - lMin;
        
        var length = 2 - (2 * pie / 100);
        var span = length * 360 / 2;
        var startAngle = (270 + (360 - span) / 2) * Math.PI / 180;
        if (dataspan > 0) {

            var coef = length / dataspan,
                startPoint = 0.5 + pie / 100,
                endPoint;
            var i;
            for (i = 0; i < intervals.length - 1; i++) {
                endPoint = startPoint + (intervals[i + 1] - intervals[i]) * coef;
                Wedge(ctx, wx, wy, radius, kpiColors[scale][i], startPoint, endPoint);
                startPoint = endPoint;
            }
            
            var dataang = (datapoint - lMin) / dataspan * span * Math.PI / 180 + startAngle;

            Needle(ctx, wx, wy, radius, dataang);
            
            var step = Round((lMax - lMin) / countTicks, 2);
            for (i = 0; i <= countTicks; i++) {
                var textAngle = step * i / dataspan * span * Math.PI / 180 + startAngle;
                
                Tick(ctx, wx, wy, radius, textAngle, lMin + step * i, ge, units, MinutesWorkDay);
            }
        } else {

            wrapText(ctx, SR.T("Неверно указаны границы зон"), x, y, w, h, 18, "black", "center", "middle", 0);
        }
    }
}

function DrawChartArea(ctx, uid, fill) {
    var shapeParams = GetShapeParams(uid);
    roundRect(ctx, shapeParams.chartX, shapeParams.chartY, shapeParams.chartWidth, shapeParams.chartHeight, 0, fill, kpiStrokeGray, 1);
}

function DrawGrid(ctx, uid, countX, countY) {

    var shapeParams = GetShapeParams(uid);

    if(shapeParams.invert) {
        var swaper = countX;
        countX = countY;
        countY = swaper;
    }
    var step;
    
    if (countX > 0) {
        for (var x = 0; x <= countX; x++) {
            step = Math.round(x * shapeParams.chartWidth / countX);
            line(ctx,
                shapeParams.chartX + step,
                shapeParams.chartY + shapeParams.chartHeight,
                shapeParams.chartX + step,
                shapeParams.chartY,
                kpiStrokeGray, 1);
        }
    }
    
    if (countY > 0) {
        for (var y = 0; y <= countY; y++) {
            step = Math.round(shapeParams.chartHeight * (1 - y / countY));
            line(ctx,
                shapeParams.chartX,
                shapeParams.chartY + step,
                shapeParams.chartX + shapeParams.chartWidth,
                shapeParams.chartY + step,
                kpiStrokeGray, 1);
        }
    }
    
}

function Round(value, round) {
    return isNumeric(value) ? Number(value.toFixed(round)) : value;
}

function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function GetStep(min, max) {
    var minmax = Math.max(5, max === 5 ? 6 : max) - min;
    var step = Round(minmax * 1.1 / CountYLines, 5);

    var cStep = step.toString().length;
    var coefs = [];
    coefs.push(1);
    for (var pow = 1; pow < cStep; pow++) {
        coefs.push(Math.pow(2, pow));
        coefs.push(Math.pow(3, pow));
        coefs.push(Math.pow(5, pow));
        coefs.push(Math.pow(10, pow));
        coefs.push(Math.pow(25, pow));
        coefs.push(Math.pow(50, pow));
        coefs.push(Math.pow(100, pow));
    }

    var check = Round(step * (1 + 1 / CountYLines), 2);
    var realStep = step;
    var minstep = Math.abs(check - realStep);

    for (var i = 0; i < coefs.length; i++) {
        var coef = coefs[i];
        var checkStep = Round(step + (coef - (step % coef)) % coef, 2);
        if (checkStep !== realStep) {
            var dif = Math.abs(checkStep - check);
            if (dif < minstep) {
                minstep = dif;
                realStep = checkStep;
            }
        }
    }
    
    return Math.ceil(realStep);
}

function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1);
};

function guid() {
    return s4() + s4() + "-" + s4() + "-" + s4() + "-" +
         s4() + "-" + s4() + s4() + s4();
}

function buildAnchor(ctx, parentShape, x, y, radius, color, text, planText, borderColor, user, click) {
    
    var uid = guid();
    var shapeText = "";
    
    if((isset(planText) && planText.length > 0) || isset(user)) {
        shapeText = text + (isset(planText) && planText.length > 0 ? "\u2002/\u2002" + planText : "") + (isset(user) ? "\r\n" + user.Name : "");
    }
    
    var shape = new Shape(uid, x, y, radius, radius, "circle",
                {
                    text: shapeText,
                    fill: color,
                    radius: radius,
                    stroke: borderColor != undefined ? borderColor : kpiStrokeGray,
                    strokeWidth: 1
                });
    
    if (isset(parentShape))
    {
        shape.mouseover = function() { pointMouseOver(this); };
        shape.mouseout = function() { pointMouseOut(this); };
        shape.click = click;
        shape.parentShape = parentShape;
        parentShape.canvasState.addShape(shape);
    }
    shape.draw(ctx);
	
    wrapText(ctx, text, x, y - 18, ctx.measureText(text).width * 1.1, 8, 8, null, "center", "middle", 0);
}

function contextMenuItem(canvasState, x, y, text, click, img) {

    var uid = guid();
    var context = canvasState.ctx;
    h=30;
    var menuText = "         " + text;
    if (text === "---") {
        h=1;
        menuText = "";
    }
   
    var shape = new Shape(uid, x, y, 180, h, "contextMenuItem",
                {
                    text: menuText,
                    fill: "#FFFFFF",
                    stroke: kpiStrokeGray,
                    strokeWidth: 0,
                    radius: 0,
                    textOptions: { textAlign: "left", fill: "black" },
                    img: img
                });
    if (text !== "---") {
        shape.mouseover = function () { contextMenuMouseOver(this, shape); };
        shape.mouseout = function () { contextMenuMouseOut(this, shape); };
        shape.click = click;
        shape.text = text;
    }
    canvasState.addShape(shape);
    shape.draw(context);
}

function contextMenuMouseOver(e, anchor) {
    defaultMouseOver(anchor);
    roundRect(anchor.canvasState.ctx, anchor.x, anchor.y, 180, 30, 0, "#F1F1F1", kpiStrokeGray, 1, null,
        { text: "         " + anchor.text, textOptions: { textAlign: "left", fill: "black" } }
    );
    if (isset(anchor.options.img)) {
        DrawImage(anchor.canvasState.ctx, anchor.x + 7, anchor.y + 7, 16, 16, { src: anchor.options.img });
    }
}

function contextMenuMouseOut(e, anchor) {
    defaultMouseOut(anchor);
    var needDraw = false;
    for (var i = 0; i < anchor.canvasState.shapes.length; i++) {
        if (anchor.canvasState.shapes[i].uid == anchor.uid) {
            needDraw = true;
            break;
        }
    }
    if (needDraw) {
        roundRect(anchor.canvasState.ctx, anchor.x, anchor.y, 180, 30, 0, "#FFFFFF", kpiStrokeGray, 1, null,
            { text: "         " + anchor.text, textOptions: { textAlign: "left", fill: "black" } }
        );
        if (isset(anchor.options.img)) {
            DrawImage(anchor.canvasState.ctx, anchor.x + 7, anchor.y + 7, 16, 16, { src: anchor.options.img });
        }
    }
}

function addLegend(ctx, cX, cY, cW, cH, cText, option, baseline) {

    var coef = GetTextWidth2(ctx, "m", option.fontSize, fontFamily) * .4;
    var subLength = option.vertical ? Math.ceil(cW / 2) : Math.ceil(cW / coef);

	if (!isset(cText))
		return;
	
    var subtext = subLength > cText.length ? cText : cText.substr(0, subLength - 2) + "...";

    var textX = cX,
        textY = cY;
    if (option.vertical) {
        textX -= cW * Math.cos(option.angle) * 0.5;
        textY -= cH * Math.sin(option.angle) * 0.9;
    }

    wrapText(ctx, subtext, textX, textY, cW, cH, option.fontSize, "black", option.textAlign, baseline, option.angle);
}

function debugRect(ctx, x, y, w, h, a) {
    ctx.save();

    if (a != undefined) {
        ctx.translate(x, y);
        ctx.rotate(a);
        ctx.translate(-x, -y);
    }

    circle(ctx, x, y, 3, "red", "red", 1);
    line(ctx, x, y, x + w, y, "orange", 1);
    circle(ctx, x + w, y, 3, "lime", "lime", 1);
    line(ctx, x + w, y, x + w, y + h, "lime", 1);
    circle(ctx, x + w, y + h, 3, "blue", "blue", 1);
    line(ctx, x + w, y + h, x, y + h, "blue", 1);
    circle(ctx, x, y + h, 3, "yellow", "yellow", 1);
    line(ctx, x, y + h, x, y, "yellow", 1);
    ctx.restore();
}

function colorRect(ctx, x, y, w, h, color) {
    ctx.save();
    line(ctx, x, y, x + w, y, color, 1);
    line(ctx, x + w, y, x + w, y + h, color, 1);
    line(ctx, x + w, y + h, x, y + h, color, 1);
    line(ctx, x, y + h, x, y, color, 1);
    ctx.restore();
}

function DrawPlanYValues(ctx, x, y, width, height, position, valueWidth, planValue, prevPlanValue, isFirst, isLast) {
    var yWidth = GetYWidth(width);
    var chartWidth = GetChartWidth(width);
    var bottomShift = height - GetXHeight(height);

    if (isFirst) {
        line(ctx, yWidth + x, bottomShift - prevPlanValue + y, position - valueWidth, bottomShift - prevPlanValue + y, "#437500", 1);
    }

    if (prevPlanValue !== planValue) {
        line(ctx, position - valueWidth, bottomShift - prevPlanValue + y, position - valueWidth, bottomShift - prevPlanValue + y, "#437500", 1);
        line(ctx, position - valueWidth, bottomShift - prevPlanValue + y, position - valueWidth, bottomShift - planValue + y, "#437500", 1);
        line(ctx, position - valueWidth, bottomShift - planValue + y, position + valueWidth, bottomShift - planValue + y, "#437500", 1);
    }
    else {
        line(ctx, position - valueWidth, bottomShift - prevPlanValue + y, position + valueWidth, bottomShift - planValue + y, "#437500", 1);
    }

    if (isLast) {
        line(ctx, position + valueWidth, bottomShift - planValue + y, yWidth + chartWidth + x, bottomShift - planValue + y, "#437500", 1);
    }
}

function createText(ctx, cX, cY, cW, cH, cText, color, jsonConfig) {
    var config = {};

    if (jsonConfig != null) {
        config = jsonConfig;
    }
    else {
        config.align = "center";
        config.verticalAlign = "middle";
    }

    var fontSize = 18;
    for (var i = 1; i < 5 && GetTextWidth2(ctx, cText, fontSize, fontFamily) > cW - 5; i++) {
        fontSize = 18 - i;
    }
    wrapText(ctx, cText, cX - cW / 2, cY - cH / 2, cW, cH, fontSize, color != undefined && color.length > 1 ? color : "black", config.align);
}

function DrawYAxisValues(ctx, uid, min, max, textOption) {

    var sp = GetShapeParams(uid);

    var step = GetStep(min, max);

    var legendHeight = sp.chartHeight / CountYLines;
    var textVerticalAlign = "middle";
    var yStep;
    for (var i = 0; i <= CountYLines; i++) {
        yStep = sp.chartY + Math.round(sp.chartHeight * (1 - i / CountYLines));
        line(ctx, sp.chartX, yStep, sp.chartX - 5, yStep, kpiStrokeGray, 1);
        var value = min + i * step;
        var y = yStep - legendHeight / 2;
        wrapText(ctx, toRank(value), sp.chartX - sp.yWidth, y, sp.yWidth - 5, legendHeight, textOption.fontSize, "black", "right", textVerticalAlign, textOption.angle);
    }

    line(ctx,
        sp.chartX, sp.chartY,
        sp.chartX, sp.chartY + sp.chartHeight,
        kpiStrokeGray, 1);

}

function DrawXAxisLegends(ctx, uid, legends) {

    if (legends.length === 0) {
        return 0;
    }
    
    var sp = GetShapeParams(uid);
    
    var bottomShift = sp.chartY + sp.chartHeight;

    var objLength = (sp.invert ? sp.chartHeight : sp.chartWidth) / legends.length;
    var lmaxWidth = sp.invert ? sp.yWidth : sp.xHeight;
    var lmax = GetMaxLegend(legends);
    
    var legendOption = sp.invert ? GetTextOption(ctx, lmaxWidth, objLength, lmax, 9) : GetTextOption(ctx, objLength, lmaxWidth, lmax, 9);
    legendOption.fontSize = 9;
    if (sp.invert) {
        legendOption.textAlign = "right";
    }

    var lineStep;
    var countLines = legends.length;
    for (var i = 0; i <= countLines; i++) {

        if (sp.invert) {
            lineStep = sp.chartY + Math.round(i * sp.chartHeight / countLines);
            line(ctx, sp.chartX - 5, lineStep, sp.chartX, lineStep, kpiStrokeGray, 1);

            if (i < countLines) {
                addLegend(ctx, 5, lineStep, sp.yWidth - 3, objLength, legends[i], legendOption, "middle");
            }

        } else {
            lineStep = sp.chartX + Math.round(i * sp.chartWidth / countLines);
            line(ctx, lineStep, bottomShift, lineStep, bottomShift + 5, kpiStrokeGray, 1);

            if (i < countLines) {
                addLegend(ctx, lineStep, bottomShift + 3, objLength, sp.xHeight - 3, legends[i], legendOption, "top");
            }
        }
    }
    
    line(ctx,
        sp.chartX, sp.chartY + sp.chartHeight,
        sp.chartX + sp.chartWidth, sp.chartY + sp.chartHeight,
        kpiStrokeGray, 1);
    return 1;
}

function isNumber(element, index, array) {
    return !isNaN(element);
}

function arrayMax(array, max) {
    var maxArr = Math.max.apply(null, array);
    return Math.max(customIsNaN(max) ? maxArr: max, maxArr);
}

function arrayMin(array, min) {
    var minArr = Math.min.apply(null, array);
    return Math.min(customIsNaN(min) ? minArr : min, minArr);
}

function customIsNaN(o) {
    return typeof(o) === 'number' && isNaN(o);
}

function IndicatorChart(ctx, some, uid, x, y, width, height, options) {
    IndicatorGroup(ctx, some, uid, x, y, width, height, options, "chart");
}

function IndicatorCharts(ctx, some, uid, x, y, width, height, options) {
    IndicatorGroup(ctx, some, uid, x, y, width, height, options, "chart");
}

function IndicatorGroup(ctx, some, uid, x, y, width, height, options, type) {
    var settings = options.Settings;

    var shapePars = GetShapeParams(uid, x, y, width, height, settings);
    // Рамка
    roundRect(ctx, x, y, width - 1, height - 1, 0, options.showBackground ? kpiGray : "white", kpiStrokeGray, 1);

    // Сетка
    DrawGrid(ctx, uid, settings.VertGrid ? options.legends.length : 0, settings.HorzGrid ? CountYLines : 0);

    var legendOption = {};
    
    if (options.data != undefined && options.data.length > 0) {

        var max = 0;
        var min = 0;

        var pmax = 0;
        var pmin = 0;

        var countValues = isset(options.data[0].Values) ? options.data[0].Values.length : 0;

        var valWidth = shapePars.chartWidth / (countValues + 1);

        legendOption = GetTextOption(ctx, valWidth, shapePars.xHeight, GetMaxLegend(options.legends), 9);
        
        var legendWidth = settings.LegendAlign === 1 || settings.LegendAlign === 3 ? LegendWidth : shapePars.chartWidth / options.data.length;
        var lHeight = legendOption.fontSize * 3;
        var legendHeight = settings.LegendAlign === 2 || settings.LegendAlign === 4 ? LegendHeight : (options.data.length * lHeight > shapePars.chartHeight ? shapePars.chartHeight / options.data.length : lHeight);
        
        if (countValues > 0) {
            var i;
            for (i = 0; i < options.data.length; i++) {
                max = arrayMax(options.data[i].Values, max);
                min = arrayMin(options.data[i].Values, min);
                
                pmax = arrayMax(options.data[i].PlanValues, pmax);
                pmin = arrayMin(options.data[i].PlanValues, pmin);
            }
            min = Math.min(min, pmin);
            max = Math.max(max, pmax);
            if (isNaN(max)) max = 0;
            if (isNaN(min)) min = 0;

            var barWidth = shapePars.chartWidth / (countValues * (options.data.length + 1));
            var dataWidth = barWidth * (options.data.length + 1);
            var limit = 0;
            for (i = 0; i < options.data.length; i++) {

                var chart = options.data[i];

                if (i === 0) {
                    limit = chart.Values.length;
                } else {
                    chart.Values = chart.Values.slice(0, limit);
                }

                if (type === "bar") {
                    DrawBar(ctx, some, uid, i, barWidth, dataWidth, min, max, chart, false, null, options.data.length == 1);
                } else if (type === "chart") {
                    DrawChart(ctx, some, uid, min, max, chart, 0, null);
                }
                
                if (isset(chart.Responsibles) && chart.Responsibles.length === 0) {
                    if (isset(chart.Click)) {
                        chart.Click = elma.repString(chart.Click, "userId", -1);
                    }
                    for (var z = 0; z < chart.Clicks.length; z++) {
                        chart.Clicks[z] = elma.repString(chart.Clicks[z], "userId", -1);
                    }
                }
                DrawChartLegend(ctx, some, uid, chart, legendOption.fontSize, legendWidth, legendHeight, i, min, max);
            }
        }

        // Подписи оси Y - Значения
        if (settings.YAxisType === 1) {
            var valueTextOption = GetTextOption(ctx, shapePars.yWidth, shapePars.xHeight, toRank(max), legendOption.fontSize);
            DrawYAxisValues(ctx, uid, min, max, valueTextOption);
        }

        // Подписи оси X - Метки
        if (settings.XAxisType === 1) {
            DrawXAxisLegends(ctx, uid, options.legends);
        }
    }

    DrawChartTitle(ctx, uid, options.text, 14);
}

function IndicatorBars(ctx, some, uid, x, y, width, height, options) {
    IndicatorGroup(ctx, some, uid, x, y, width, height, options, "bar");
}

function DrawChartTitle(ctx, uid, title, fontSize) {
    var shapePars = GetShapeParams(uid);
    if (shapePars.titleAlign === 0) {
        return 0;
    }

    var titleOption = GetTextOption(ctx, shapePars.width * 0.9, shapePars.titleHeight, title, fontSize);

    var titleHeight = shapePars.titleAlign === 2 ? shapePars.titleHeight : GetTitleHeight(shapePars.height);

    wrapText(ctx, title, shapePars.x, shapePars.y, shapePars.width, titleHeight, titleOption.fontSize);
    return 1;
}

function DrawChartLegend(ctx, parentShape, uid, chart, fontSize, legendWidth, legendHeight, index, min, max) {
    
    var sp = GetShapeParams(uid);
    if (sp.legendAlign === 0) {
        return;
    }
    
    var x1 = sp.x,
        y1 = sp.y;
    if (sp.legendAlign === 1 || sp.legendAlign === 3) {
        x1 += sp.legendAlign === 1 ? sp.yWidth + sp.chartWidth + 6 : 6;
        y1 += sp.titleHeight + index * legendHeight;
    } else {
        x1 += sp.yWidth + index * legendWidth;
        y1 += sp.legendAlign === 4 ? sp.height - sp.titleHeight - (sp.YAxisType === 1 ? fontSize * 0.5 : -fontSize ) : sp.titleHeight;
    }

    var textWidth = GetTextWidth2(ctx, chart.Name, fontSize + 3, fontFamily) + GetTextWidth2(ctx, "w", fontSize + 3, fontFamily) * 2;
    var lWidth = Math.min(textWidth * 1.1, legendWidth);
    
    var shape = new Shape(uid, x1, y1 - fontSize, lWidth, legendHeight, "chartLegend",
                {
                    text: chart.Name,
                    fill: chart.Color,
                    stroke: chart.Color,
                    fontSize: fontSize,
                    mouseover: function () { legendMouseOver(this); },
                    mouseout: function () { legendMouseOut(this); },
                    click: chart.Click,
                    chart: chart,
                    maxValue: max,
                    index : index,
                    parentShape: parentShape
                });

    parentShape.canvasState.addShape(shape);
    shape.draw(ctx);
}

function chartLegend(ctx, uid, x, y, width, height, color, text, fontSize) {
    line(ctx, x, y + height / 2, x + 6, y + height / 2, color, 6);
    
    wrapText(ctx, text, x + 9, y, width - 20, height, fontSize, "black", "left", "middle", 0, true);
}

function DrawChart(ctx, parentShape, uid, min, max, chart, lineWidth, forecast) {
    var sp = GetShapeParams(uid);
    var bottomShift = sp.chartY + sp.chartHeight;

    var countValues = isset(chart.Values) ? chart.Values.length : 0;
    if (countValues === 0)
        return;

    var step = GetStep(min, max);
    
    var coef = max > 0 ? sp.chartHeight / (step * CountYLines) : 1;
    var valWidth = sp.chartWidth / countValues;
    var radius = Math.floor(Math.min(sp.height, sp.width) / 70) + lineWidth;
    var lineColor = isset(chart.Color) ? chart.Color : kpiDisableBlue;
    var position;
    var value;
    var planValue;
    var v;
    for (v = 0; v < countValues; v++) {
        if(isset(chart.PlanValues[v])) {
            planValue = (chart.PlanValues[v] - min) * coef;
            if (v > 0 && isset(chart.PlanValues[v - 1])) {
                var prevPlanValue = (chart.PlanValues[v - 1] - min) * coef;
                position = v * valWidth + sp.chartX + valWidth / 2;

                line(ctx, position, bottomShift - planValue, position - valWidth, bottomShift - prevPlanValue, kpiGray, radius / 1.5);
            }
        }
    }
    for (v = 0; v < countValues; v++) {
        if(isset(chart.Values[v])) {
            value = (chart.Values[v] - min) * coef;
            if (v > 0 && isset(chart.Values[v - 1])) {
                var prevValue = (chart.Values[v - 1] - min) * coef;
                position = v * valWidth + sp.chartX + valWidth / 2;

                line(ctx, position, bottomShift - value, position - valWidth, bottomShift - prevValue, lineColor, radius / 1.5);
            }
        }
    }

    for (var i = 0; i < countValues; i++) {
        position = i * valWidth + sp.chartX;

        if (isset(chart.PlanValues[i]) && !isNaN(chart.PlanValues[i])) {

            buildAnchor(ctx,
                    null,
                    position + valWidth / 2,
                    bottomShift - (chart.PlanValues[i] - min) * coef,
                    radius,
                    kpiGray,
                    "",
                    "",
                    kpiGray
                );
        }

        if (isset(chart.Values[i]) && !isNaN(chart.Values[i])) {

            var anchorValue = chart.Values[i];
            var anchorPlanValue = isset(chart.PlanValues) ? chart.PlanValues[i] : undefined;
            var anchorColor = GetStatusColor(chart.Statuses[i], kpiGray);

            if (forecast != null && forecast != undefined && forecast.index === i) {
                anchorValue = forecast.value;
                anchorColor = "orange";
            }
            
            var isgroup = isset(chart.Clicks) && chart.Clicks.length > 0 && isset(chart.Clicks[i]);
            var isuser = isset(chart.Responsibles) && chart.Responsibles.length > 0;
            var user = isuser ? chart.Responsibles[i] : (isgroup ? "" : null);
            var chartClick = isgroup && !isuser ? chart.Clicks[i] : chart.Click;
            
            if(isset(chartClick) && isset(user)) {
                chartClick = elma.repString(chartClick, "userId", isset(user.Id) ? user.Id : -1);
            }

            buildAnchor(ctx,
                    parentShape,
                    position + valWidth / 2,
                    bottomShift - (anchorValue - min) * coef,
                    radius,
                    anchorColor,
                    toRank(anchorValue),
                    toRank(anchorPlanValue),
                    lineColor,
                    user,
                    chartClick
                );
        }

        
    }

}

function DrawBar(ctx, parentShape, uid, index, valWidth, dataWidth, min, max, chart, highlight, forecast, statusColor) {
    
    var chartColor = isset(chart.Color) ? chart.Color : kpiStrokeGray;
    if(highlight) {
        chartColor = GetLightColor(chartColor);
    }
    
    var sp = GetShapeParams(uid);

    var bottomShift = sp.chartY + sp.chartHeight;

    var step = GetStep(min, max);
    var coef = max > 0 ? sp.chartHeight / (step * CountYLines) : 1;
    var position;

    for (var i = 0; i < chart.Values.length; i++) {
        position = i * dataWidth + index * valWidth + sp.chartX + valWidth / 2;

        if (chart.Values[i] != null && !isNaN(chart.Values[i])) {

            var anchorValue = chart.Values[i];

            var anchorColor = GetStatusStrokeColor(chart.Statuses[i], "black");

            if (forecast != null && forecast.index === i) {
                anchorValue = forecast.value;
                anchorColor = "orange";
            }

            var isgroup = isset(chart.Clicks) && chart.Clicks.length > 0 && isset(chart.Clicks[i]);
            var isuser = isset(chart.Responsibles) && chart.Responsibles.length > 0;
            var user = isuser ? chart.Responsibles[i] : (isgroup ? "" : null);
            var chartClick = isgroup && !isuser ? chart.Clicks[i] : chart.Click;
            
            var fillColor = statusColor ? anchorColor : (isset(chart.Colors) && chart.Colors.length > 0 && isset(chart.Colors[i]) ? chart.Colors[i] : chartColor);
            
            buildRectAnchor(ctx, 
                parentShape, 
                position, 
                bottomShift - (anchorValue - min) * coef, 
                valWidth - 1, 
                anchorValue * coef, 
                fillColor,
                toRank(anchorValue), 
                chartColor, 
                1, 
                false, 
                sp.settings.DataSignature, 
                anchorColor,
                user,
                chartClick
            );
        }
    }
}

function DrawInvertBar(ctx, uid, index, valWidth, dataWidth, min, max, values, statuses, lineColor, forecast) {

    var sp = GetShapeParams(uid);
    
    var step = GetStep(min, max);
    var coef = max > 0 ? sp.chartWidth / (step * countTicks) : 1;
    var position;

    for (var i = 0; i < values.length; i++) {
        position = i * dataWidth + index * valWidth + sp.chartY + valWidth / 2;

        if (values[i] != null && !isNaN(values[i])) {

            var anchorValue = values[i];

            var anchorColor = GetStatusStrokeColor(statuses[i], kpiStrokeDisableGray);

            if (forecast != null && forecast.index === i) {
                anchorValue = forecast.value;
                anchorColor = "orange";
            }
            buildRectAnchor(ctx, 
                null, 
                sp.chartX + 1, position, 
                (anchorValue - min) * coef, 
                valWidth - 1, 
                anchorColor,
                toRank(anchorValue), 
                lineColor, 
                1, 
                true, 
                sp.settings.DataSignature, 
                anchorColor === kpiStrokeDisableGray ? "black" : anchorColor);
                
        }
    }
}

function DrawInvertChartLegend(ctx, uid, chart, fontSize, legendWidth, i) {

    var sp = GetShapeParams(uid);
    if (sp.legendAlign === 0) {
        return;
    }

    var x1 = sp.x,
        y1 = sp.y;
    if (sp.legendAlign === 1 || sp.legendAlign === 3) {
        x1 += sp.legendAlign === 1 ? sp.yWidth + sp.chartWidth + 3 : 3;
        y1 += sp.titleHeight + sp.chartHeight * 0.3 + i * fontSize * 3;
    } else {
        x1 += sp.yWidth + i * legendWidth;
        y1 += sp.legendAlign === 4 ? sp.height - fontSize * 2 : sp.titleHeight + fontSize * .5;
    }
    var x2 = x1 + 6;
    line(ctx, x1, y1, x2, y1, chart.Color, 6);
    wrapText(ctx, chart.Name,
        x2 + 3, y1 - fontSize,
        legendWidth - 20, fontSize * 2,
        fontSize, "black", "left", "middle", 0);
}

function DrawPlanXValues(ctx, x, y, width, height, position, valueHeight, planValue, prevPlanValue, isFirst, isLast) {
    var yWidth = GetYWidth(width);
    var titleHeight = GetTitleHeight(height);
    var bottomShift = height - GetXHeight(height);

    if (isFirst) {
        line(ctx, yWidth + prevPlanValue + x, titleHeight + y, yWidth + prevPlanValue + x, position - valueHeight, "#437500", 1);
    }
    if (prevPlanValue !== planValue) {
        line(ctx, yWidth + prevPlanValue + x, position - valueHeight, yWidth + prevPlanValue + x, position - valueHeight * 0.5, "#437500", 1);
        line(ctx, yWidth + prevPlanValue + x, position - valueHeight * 0.5, yWidth + planValue + x, position - valueHeight * 0.5, "#437500", 1);
        line(ctx, yWidth + planValue + x, position - valueHeight * 0.5, yWidth + planValue + x, position + valueHeight * 1.5, "#437500", 1);
    }
    else {
        line(ctx, yWidth + prevPlanValue + x, position - valueHeight, yWidth + planValue + x, position + valueHeight, "#437500", 1);
    }

    if (isLast) {
        line(ctx, yWidth + planValue + x, position + valueHeight, yWidth + planValue + x, bottomShift + y, "#437500", 1);
    }
}

function DrawXValues(ctx, mx, my, width, height, step) {
    var xHeight = GetXHeight(height);
    var chartWidth = GetChartWidth(width);
    var bottomShift = height - xHeight;

    var valueWidth = chartWidth / CountYLines;
    for (var i = 0; i <= CountYLines; i++) {
        var value = i * step;
        var x = mx + i * valueWidth;
        //roundRect(ctx, x - valueWidth / 2 + 10, bottomShift + my, valueWidth - 20, xHeight - 20, 0, null, 'blue', 1, 0);
        wrapText(ctx, toRank(value), x - valueWidth / 2, bottomShift + my, valueWidth, xHeight, 9, "black", "center", "top", 0);
    }
}

function IndicatorChartInvert(ctx, x, y, width, height, title, legends, values, statuses, planValues) {
    var yWidth = GetYWidth(width);
    var chartWidth = GetChartWidth(width);
    var titleHeight = GetTitleHeight(height);
    var chartHeight = GetChartHeight(height);

    roundRect(ctx, x, y, width, height, 0, kpiGray, kpiStrokeGray, 2);
    var chartX = yWidth + x;
    var chartY = titleHeight + y;
    roundRect(ctx, chartX, chartY, chartWidth, chartHeight, 0, "white", kpiStrokeGray, 2);

    var max = arrayMax(values, null);
    var min = arrayMin(values, 0);
    
    if (planValues.length > 0) {
        var planMax = arrayMax(planValues, null);
        var planMin = arrayMin(planValues, 0);
        if (!isNaN(planMax)) {
            max = Math.max(max, planMax);
        }
        if (!isNaN(planMin)) {
            min = Math.max(min, planMin);
        }
    }

    var countValues = values.length;

    DrawGrid(ctx, chartX, chartY, width, height, CountYLines, legends.length + 1);

    var coef = max > 0 ? chartWidth / (GetStep(min, max) * CountYLines) : 1;
    var rectHeight = (chartHeight / (countValues + 1));
    var radius = Math.floor(Math.min(height, width) / 50);

    var legendOption = GetTextOption(ctx, yWidth, rectHeight, GetMaxLegend(legends));
    var position;
    var value;
    var i;
    for (i = 0; i < countValues; i++) {
        position = (i + 1) * rectHeight + titleHeight;
        value = values[i] * coef;
        if (i > 0) {
            var prevValue = values[i - 1] * coef;
            line(ctx, yWidth + prevValue + x, position - rectHeight + y, yWidth + value + x, position + y, kpiStrokeGray, (radius / 2));
        }
    }

    for (i = 0; i < countValues; i++) {
        position = (i + 1) * rectHeight + titleHeight + y;
        value = values[i] * coef;
        if (values[i] != null) {
            buildAnchor(ctx,
                yWidth + value + x,
                position,
                radius,
                radius,
                GetStatusColor(statuses[i]),
                values[i].toString()
            );
        }

        addLegend(ctx, x, position - rectHeight / 2, yWidth, rectHeight, legends[i], legendOption, "middle");

        if (planValues.length && i > 0) {
            var planValue = planValues[i] * coef;
            var prevPlanValue = planValues[i - 1] * coef;

            DrawPlanXValues(ctx, x, y, width, height, position, rectHeight * 0.5, planValue, prevPlanValue, i === 1, i === countValues - 1);
        }

    }

    // Подписи оси Y - значения
    DrawXValues(ctx, chartX, y, width, height, max);

    var titleOption = GetTextOption(ctx, width * 0.9, titleHeight, title);

    wrapText(ctx, title, x, y, width, titleHeight, titleOption.fontSize);
}

function buildRectAnchor(ctx, parentShape, x, y, width, height, color, text, stroke, strokeWidth, isVertical, dataSignatureAlign, textFill, user, clickTemplate) {
    var fs = 8;
    if (isVertical) {
        vertBar(ctx, x, y, width, height, 0, color, stroke, strokeWidth);

        if (dataSignatureAlign === 1) {
            // Center
            wrapText(ctx, text, x, y, width, height, fs, "black", "center");
        } else if (dataSignatureAlign === 2) {
            // Top Inside
            wrapText(ctx, text, x, y, width, height, fs, "black", "right");
        } else if (dataSignatureAlign === 3) {
            // Bottom Inside
            wrapText(ctx, text, x, y, width, height, fs, "black", "left");
        } else if (dataSignatureAlign === 4) {
            // Top Outside
            wrapText(ctx, text, x + width, y, width, height, fs, textFill, "left");
        }

    } else {

        var uid = guid();
        var bar = new Shape(uid, x, y, width, height, "bar",
                {
                    text: text,
                    fill: color,
                    stroke: stroke,
                    strokeWidth: strokeWidth
                });
        
        if (isset(parentShape))
        {
            bar.mouseover = function(e) { barMouseOver(e, this); };
            bar.mouseout = function(e) { barMouseOut(e, this); };
            if (isset(clickTemplate) && isset(user)) {
                bar.click = elma.repString(clickTemplate, "userId", isset(user.Id) ? user.Id : -1);
            }
            bar.parentShape = parentShape;
            parentShape.canvasState.addShape(bar);
        }
        bar.draw(ctx);

        if (dataSignatureAlign === 1) {
            // Center
            wrapText(ctx, text, x, y, width, height, fs, textFill);
        } else if (dataSignatureAlign === 2) {
            // TopInside
            var tY = fs * 2 < height ? y + fs : y + height - fs * 1.5;
            wrapText(ctx, text, x, tY, width, fs, fs, textFill);
        } else if (dataSignatureAlign === 3) {
            // Bottom Inside
            wrapText(ctx, text, x, y + height - fs * 1.5, width, fs, fs, textFill);
        } else if (dataSignatureAlign === 4) {
            // Top Outside
            wrapText(ctx, text, x, y - fs * 1.5, width, fs, fs, textFill);
        }
    }
}

function anchorMouseOver() {
    $(document.body).css("cursor", "pointer");
}

function anchorMouseOut() {
    $(document.body).css("cursor", "default");
}

function pointMouseOver(anchor) {
    $(document.body).css("cursor", "pointer");
    circle(anchor.canvasState.ctx, anchor.x, anchor.y, anchor.radius + 3, GetLightColor(anchor.stroke), GetLightColor(anchor.stroke), anchor.strokeWidth);
    circle(anchor.canvasState.ctx, anchor.x, anchor.y, anchor.radius, anchor.fill, anchor.stroke, anchor.strokeWidth);
    
    if (isset(anchor.parentShape) && isset(anchor.text) && anchor.text.length > 0) {
        showTooltip(anchor.canvasState.ctx, anchor.x, anchor.y, anchor.text, anchor.parentShape);
    }
}
function pointMouseOut(anchor) {
    defaultMouseOut(anchor);
}

function defaultMouseOver(anchor) {
    $(document.body).css("cursor", "pointer");
    $("canvas").css("cursor", "pointer");
}

function defaultMouseOut(anchor) {
    $(document.body).css("cursor", "default");
    $("canvas").css("cursor", "default");
    $("canvas.ui-draggable").css("cursor", "move");
    if(isset(anchor) && isset(anchor.parentShape)) {
        anchor.parentShape.draw(anchor.canvasState.ctx);
    }
}

function barMouseOver(e, anchor) {
    defaultMouseOver(anchor);
    bar(anchor.canvasState.ctx, anchor.x, anchor.y, anchor.w, anchor.h - 1, GetLightColor(anchor.fill), anchor.stroke, anchor.strokeWidth + 1);
}

function barMouseOut(e, anchor) {
    defaultMouseOut(anchor);
}

function mindMapMouseOver(e, anchor) {
    $(document.body).css("cursor", "pointer");
    $("canvas").css("cursor", "pointer");
}

function mindMapMouseOut(e, anchor) {
    $(document.body).css("cursor", "default");
    $("canvas").css("cursor", "default");
    $("canvas.ui-draggable").css("cursor", "move");
    if(isset(anchor)) {
        anchor.draw(anchor.canvasState.ctx);
    }
}

function GetLightColor(rgbaColor) {
    var match = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(rgbaColor);
    if(!isset(match)) {
        return rgbaColor;
    }
    var r = match[1] * 1 + 40;
    var g = match[2] * 1 + 40;
    var b = match[3] * 1 + 40;
    return "rgb(" + r + "," + g + ", " + b + ")";
}

function GetDarkColor(rgbaColor) {
    var match = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(rgbaColor);
    if(!isset(match)) {
        return rgbaColor;
    }
    var r = match[1] * 1 - 32;
    var g = match[2] * 1 - 32;
    var b = match[3] * 1 - 32;
    return "rgb(" + r + "," + g + ", " + b + ")";
}

function legendMouseOver(anchor) {
    $(document.body).css("cursor", "pointer");
    $("canvas").css("cursor", "pointer");
    
    if (anchor.parentShape.type === "indicatorBars" || anchor.parentShape.type === "bar") {
        var countValues = anchor.chart.Values.length;
        var countCharts = anchor.parentShape.options.data.length;
        var shapePars = GetShapeParams(anchor.parentShape.uid);
        var barWidth = shapePars.chartWidth / (countValues * (countCharts + 1));
        var dataWidth = barWidth * (countCharts + 1);
        
        DrawBar(anchor.canvasState.ctx, null, anchor.parentShape.uid, anchor.index, barWidth, dataWidth, anchor.minValue, anchor.maxValue, anchor.chart, true, null);
    } else {
        DrawChart(anchor.canvasState.ctx, null, anchor.parentShape.uid, anchor.minValue, anchor.maxValue, anchor.chart, 1, null);
    }
    
    wrapText(anchor.canvasState.ctx, anchor.text,
        anchor.x + 9, anchor.y,
        anchor.w - 20, anchor.h,
        anchor.fontSize, "#3366CC", "left", "middle", 0, true);
}
function legendMouseOut(anchor) {
    defaultMouseOut(anchor);
}

function showTooltip(ctx, x, y, value, parentShape) {
    var fontSize = 10;
    var h = fontSize * 2;
    var words = value.split(/\r\n/g);
    var maxWordWidth = 0;
    for(var i=0;i <= words.length;i++) {
        maxWordWidth = Math.max(maxWordWidth, GetTextWidth2(ctx, words[i], fontSize, fontFamily));
    }
    maxWordWidth *= 1.1;
    var th = words.length > 1 ? h * 2 : h;
    var tx = x + 16;
    if (isset(parentShape) && tx + maxWordWidth > parentShape.x + parentShape.w) {
        tx -= maxWordWidth + 32;
    }

    var ty = y + 10;
    if (isset(parentShape) && ty + th > parentShape.y + parentShape.h) {
        ty -= th + 20;
    }

    roundRect(ctx, tx, ty, maxWordWidth, th, 1, "rgb(216, 216, 216)", "rgb(186, 186, 186)", 1, 0);
    
    wrapText(ctx, value, tx, ty, maxWordWidth, th, fontSize, "rgb(109, 109, 109)", "left");
}

function IndicatorBar(ctx, some, uid, x, y, width, height, options) {
    IndicatorGroup(ctx, some, uid, x, y, width, height, options, "bar");
}

function IndicatorInvertBars(ctx, uid, x, y, width, height, options) {

    var settings = options.Settings;

    var shapePars = GetShapeParams(uid, x, y, width, height, settings);
    // Рамка
    roundRect(ctx, x, y, width - 1, height - 1, 0, options.showBackground ? kpiGray : "white", kpiStrokeGray, 1);

    // Сетка
    DrawGrid(ctx, uid, settings.VertGrid ? options.legends.length : 0, settings.HorzGrid ? CountYLines : 0);
    
    var legendOption = {};

    if (options.data != undefined && options.data.length > 0) {

        var max = 0;
        var min = 0;

        var countValues = options.data[0].Values.length;

        var valWidth = shapePars.chartWidth / (countValues + 1);

        legendOption = GetTextOption(ctx, valWidth, shapePars.xHeight, GetMaxLegend(options.legends), 9);

        var legendWidth = settings.LegendAlign === 1 || settings.LegendAlign === 3 ? LegendWidth : shapePars.chartWidth / options.data.length;
        var i;
        for (i = 0; i < options.data.length; i++) {
            max = arrayMax(options.data[i].Values, max);
            min = arrayMin(options.data[i].Values, min);
        }

        if (countValues > 0) {
            var barHeight = shapePars.chartHeight / (countValues * (options.data.length + 1));
            var dataHeight = barHeight * (options.data.length + 1);
            for (i = 0; i < options.data.length; i++) {

                var chart = options.data[i];
                var chartColor = isset(chart.Color) ? chart.Color : kpiStrokeGray;

                DrawInvertBar(ctx, uid, i, barHeight, dataHeight, min, max, chart.Values, chart.Statuses, chartColor, null);

                DrawInvertChartLegend(ctx, uid, chart, legendOption.fontSize, legendWidth, i);
            }
        }
        
        /*
        // Подписи оси Y - Значения
        if (settings.YAxisType === 1) {
            var valueTextOption = GetTextOption(ctx, shapePars.yWidth, shapePars.xHeight, toRank(max), legendOption.fontSize);
            DrawYAxisValues(ctx, uid, step, valueTextOption);
        }*/
        
        // Подписи оси X - Метки
        if (settings.XAxisType === 1) {
            DrawXAxisLegends(ctx, uid, options.legends);
        }
    }
    
    DrawChartTitle(ctx, uid, options.text, 18);
}

// Светофор
function TrafficLight(ctx, x, y, width, height, active) {

    roundRect(ctx, x, y, width, height, 15, kpiDisableGray, kpiGray, 4, 0);

    var countRanges = 3;

    var m = Math.max(width, height) / 3;

    var diametr = Math.round(m * 0.8);

    var vertical = width < height;

    var osn = vertical ? height : width;
    var dop = (vertical ? width : height) / 2;

    var stateShiftStep = (osn - diametr * countRanges) / (countRanges + 1);
    var radius = diametr / 2;

    var start = stateShiftStep + radius;

    var circleX = x + (vertical ? dop : start);

    var circleY = y + (vertical ? start : dop);
    for (var i = 1; i <= countRanges; i++) {

        circle(ctx, circleX, circleY, radius,
            kpiStatusPriority[i] === active ? kpiStatusColors[i] : kpiGray,
            kpiStatusPriority[i] === active ? kpiStatusColors[i] : kpiStrokeGray,
            2
        );

        if (vertical) {
            circleY += stateShiftStep + diametr;
        } else {
            circleX += stateShiftStep + diametr;
        }
    }

}

// Линейка
function IndicatorScale(ctx, x, y, width, height, text, datapoint, intervals, status, scale) {

    var border = Math.floor(Math.min(width, height) / 10) + 2;
    var rangeHeight = height * 0.48;
    var rangeWidth = width * 0.89;
    var leftShift = (width - rangeWidth) / 2;
    var topShift = height - rangeHeight - leftShift;
    var startPoint = x + leftShift;
    var rectWidth = 0;

    intervals = NormalizeInvertvals(intervals, scale, datapoint);
    var i;
    if (intervals.length > 1 && datapoint.toString() !== "NaN") {

        roundRect(ctx, x, y, width, height, border, kpiGray, kpiStrokeGray, 2);

        var lMax = arrayMax(intervals, null);
        var lMin = arrayMin(intervals, null);
        var coef = lMax !== lMin ? rangeWidth / (lMax - lMin) : 1;

        for (i = 0; i < intervals.length - 1; i++) {

            rectWidth = (intervals[i + 1] - intervals[i]) * coef;

            roundRect(ctx,
                startPoint,
                y + topShift,
                rectWidth,
                rangeHeight,
                0,
                kpiColors[scale][i],
                kpiColors[scale][i],
                1
            );
            startPoint += rectWidth;
        }

        var markerWidth = height * 0.18;
        var markerHeight = height * 0.25;
        var markerX = x + (datapoint - lMin) * coef + leftShift;
        var markerY = y + topShift;

        polygon(ctx,
            [
                markerX - markerWidth / 2, markerY - markerHeight / 1.5,
                markerX + markerWidth / 2, markerY - markerHeight / 1.5,
                markerX, markerY + markerHeight / 1.5
            ],
            "black",
            "black",
            1
        );

    } else {

        rectWidth = rangeWidth / 3;
        for (i = 0; i < 3; i++) {
            roundRect(ctx,
                startPoint,
                y + topShift,
                rectWidth,
                rangeHeight,
                0,
                kpiDisabledColors[1][i],
                kpiDisabledColors[1][i],
                1
            );

            startPoint += rectWidth;
        }
    }
}

/* VAD objects */

function OrganizationItemShape(ctx, x, y, w, h, options) {

    ellipse(ctx, x, y, w, h, { fill: options.fill, text: "" });

    var xd = w * 0.15;
    var yd1 = h * 0.15;
    var yd2 = h * (1 - 1 / 6.66);

    line(ctx, x + xd, y + yd1, x + xd, y + yd2, "black", 1);

    if (options.text.length > 0) {

        var textOptions = GetTextOption(ctx, w - xd, h, options.text);

        wrapText(ctx, options.text, x + xd, y, w - xd, h, textOptions.fontSize, "black", "center", "middle", 0);
    }

}

function mindMapShape(ctx, x, y, width, height, radius, fill, stroke, strokeWidth, angle, options) {
    
    mindMapRect(ctx, x, y, width, height, radius, fill, stroke, strokeWidth, angle, options);

    DrawImage(ctx, x, y, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/mindmap.png" });
}

function mindMapRect(ctx, x, y, width, height, radius, fill, stroke, strokeWidth, angle, options) {

    roundRect(ctx, x, y, width, height, radius, fill, stroke, 10, angle, options);

    if(isset(options.totalSmarts) && options.totalSmarts > 0){
        var smartInfo = SR.T("{0} из {1}", isset(options.completeSmarts) ? options.completeSmarts : 0, options.totalSmarts);
        var smartIndoWidth = GetTextWidth2(ctx, smartInfo, 9, fontFamily) + 24;
        roundRect(ctx, x + width - smartIndoWidth, y + height - 6, smartIndoWidth, 15, 1, kpiStrokeDisableGreen, kpiStrokeDisableGreen, 0, angle, { text: "    " + smartInfo });
        DrawImage(ctx, x + width - smartIndoWidth, y + height - 6, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/smart.png" });
    }


    if (isset(options.totalActions) && options.totalActions > 0) {
        var actionInfo = SR.T("{0} из {1}", isset(options.completeActions) ? options.completeActions : 0, options.totalActions);
        var actionIndoWidth = GetTextWidth2(ctx, actionInfo, 9, fontFamily) + 24;
        roundRect(ctx, x, y + height - 6, actionIndoWidth, 15, 1, kpiStrokeDisableGreen, kpiStrokeDisableGreen, 0, angle, { text: "    " + actionInfo });
        DrawImage(ctx, x, y + height - 6, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/action.png" });
    }
    
    if(isset(options.isScheduled) && options.isScheduled === "True") {
        DrawImage(ctx, x + width - 16, y, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/planned.png" });
    }
    if(isset(options.priority) && options.priority === 1) {
        DrawImage(ctx, x, y, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/high_priority.png" });
    }
    
    if(isset(options.scaleStatus)) {
        DrawScaleStatus(ctx, x + width - 8, y-4, options.scaleStatus);
    }
}

function DrawScaleStatus(ctx, x, y, status) {
    if(status === 10) {
        DrawImage(ctx, x, y, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/ScaleStatus/green_indicator.gif" });
    }
    else if(status === 5) {
        DrawImage(ctx, x, y, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/ScaleStatus/yellow_indicator.gif" });
    }
    else if(status === 0) {
        DrawImage(ctx, x, y, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/ScaleStatus/red_indicator.gif" });
    }
    else if(status === -10) {
        DrawImage(ctx, x, y, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/ScaleStatus/na_indicator.gif" });
    }
}

function processArrow(ctx, x, y, w, h, options) {

    var points = [
        x, y,
        x + w - (h / 2), y,
        x + w, y + h / 2,
        x + w - (h / 2), y + h,
        x, y + h,
        x + h / 2, y + h / 2
    ];

    var fill = isset(options.fill) && options.fill.length > 0 ? options.fill : kpiDisableGray;

    polygon(ctx, points, fill, "black", 1);

    wrapText(ctx, options.text, x + h / 2, y, w - h, h, 9);
}

/***************/

function DrawImage(ctx, x, y, w, h, options) {

    var imageObj = new Image(w, h);
    /*
    imageObj.onload = function () {
        ctx.drawImage(imageObj, x, y, w, h);
    };*/
    imageObj.src = options.src;

    ctx.drawImage(imageObj, x, y, w, h);
}

function DrawProspect(ctx, uid, x, y, w, h, options) {

    roundRect(ctx, x, y, w, h, 0, options.fill, "black", 1, 0);

    var hwidth = options.header.size;
    roundRect(ctx, x, y, hwidth, h, 0, options.header.fill, "black", 1, 0);

    if (isset(options.text)) {

        var to = GetTextOption(ctx, hwidth, h, options.text);

        wrapText(ctx, options.text, x, y + h / 2, hwidth, h, to.fontSize, "black", "right", "top", -Math.PI / 2);
    }
}

// Constructor for Shape objects to hold data for all drawn objects.
// For now they will just be defined as rectangles.
function Shape(uid, x, y, w, h, type, options,units) {
    // This is a very simple and unsafe constructor. All we're doing is checking if the values exist.
    // "x || 0" just means "if there is a value for x, use that. Otherwise use 0."
    // But we aren't checking anything else! We could put "Lalala" for the value of x
    this.uid = uid || "";
    this.x = x || 0;
    this.y = y || 0;
    this.w = w || 1;
    this.h = h || 1;
    this.type = type || "rect";
    if (options != undefined) {
        this.options = options;
        this.fill = options.fill || "";
        this.text = options.text || "";
        this.click = options.click;
        this.mouseover = options.mouseover;
        this.mouseout = options.mouseout;
        this.datapoint = options.datapoint;
        this.intervals = options.intervals;
        this.legends = options.legends;
        this.values = options.values;
        this.statuses = options.statuses;
        this.planValues = options.planValues;
        this.radius = options.radius;
        this.stroke = options.stroke || "black";
        this.strokeWidth = options.strokeWidth || 1;
        this.parentShape = options.parentShape;
        this.status = options.status === 0 ? 0 : options.status || -10;
        this.scale = options.scale === 0 ? 0 : options.scale || 3;
        this.forecast = options.forecast;
        this.showBackground = options.showBackground;
        this.showGrid = options.showGrid;
        this.vertical = options.vertical;
        this.points = options.points;
        this.fontSize = options.fontSize;
        this.chart = options.chart;
        this.minValue = options.minValue || 0;
        this.maxValue = options.maxValue;
        this.index = options.index;
        this.plan = options.plan;
        this.fact = options.fact;
        this.units = options.units;
        this.MinutesWorkDay = options.MinutesWorkDay;
    }
    else {
        this.fill = "";
        this.text = "";
    }
}


// Draws this shape to a given context
Shape.prototype.draw = function (ctx) {
    ctx.ImageSmoothingEnabled = true;
    if (this.type === "rect") {
        drawRectangle(ctx, this.x, this.y, this.w, this.h, this.fill, this.text);
    }
    else if (this.type === "rounded_rect") {
        roundRect(ctx, this.x, this.y, this.w, this.h, 10, this.fill, this.stroke, this.strokeWidth, null, this.options);
    }
    else if (this.type === "contextMenuItem") {
        roundRect(ctx, this.x, this.y, this.w, this.h, this.radius, this.fill, this.stroke, this.strokeWidth, null, this.options);
        if (isset(this.options.img)) {
            DrawImage(ctx, this.x + 7, this.y + 7, 16, 16, { src: this.options.img });
        }
    }
    else if (this.type === "prospect") {
        DrawProspect(ctx, this.uid, this.x, this.y, this.w, this.h, this.options);
    }
    else if (this.type === "ellipse") {
        ellipse(ctx, this.x, this.y, this.w, this.h, this.options);
    }
    else if (this.type === "polygon") {
        polygon(ctx, this.points, this.fill, this.stroke, this.strokeWidth, this.options);
    }
    else if (this.type === "arrow") {

        var headlen = 9;
        var dx = this.w - this.x;
        var dy = this.h - this.y;
        var angle = Math.atan2(dy, dx);
        var anglePlus = angle + Math.PI / 6;
        var angleMinus = angle - Math.PI / 6;

        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.w - (headlen - 1) * Math.cos(angle), this.h - (headlen - 1) * Math.sin(angle));
        ctx.moveTo(this.w - headlen * Math.cos(angleMinus), this.h - headlen * Math.sin(angleMinus));
        ctx.lineTo(this.w, this.h);
        ctx.lineTo(this.w - headlen * Math.cos(anglePlus), this.h - headlen * Math.sin(anglePlus));
        ctx.lineTo(this.w - headlen * Math.cos(angleMinus), this.h - headlen * Math.sin(angleMinus));
        ctx.stroke();
    }
    else if (this.type === "line") {
        linePattern(ctx, this.x, this.y, this.w, this.h, "black", this.options);
    }
    else if (this.type === "text") {
        wrapTextStyle(ctx, this.text, this.x, this.y, this.w, this.h, this.options);
    }
    else if (this.type === "v-text") {
        ctx.save();

        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.font = "9pt " + fontFamily;
        ctx.fillStyle = "black";

        var tx = this.x + 2;
        var ty = this.y;

        ctx.translate(tx, ty);
        ctx.rotate(-Math.PI / 2);
        ctx.translate(-tx, -ty);

        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }
    else if (this.type === "circle") {
        circle(ctx, this.x, this.y, this.radius, this.fill, this.stroke, this.strokeWidth);
    }
    else if (this.type === "chartLegend") {
        chartLegend(ctx, this.uid, this.x, this.y, this.w, this.h, this.fill, this.text, this.fontSize);
    }
    else if (this.type === "speedometer") {
        Speedometer(ctx, this.x, this.y, this.w, this.h, this.text, this.datapoint, this.intervals, this.status, this.scale, this.units, this.MinutesWorkDay);
    }
    else if (this.type === "multipiechart") {
        pieCharts(ctx, this, this.uid, this.x, this.y, this.w, this.h, this.options);
    }
    else if (this.type === "indicatorChart") {
        IndicatorChart(ctx, this, this.canvasState, this.uid, this.x, this.y, this.w, this.h, this.options);
    }
    else if (this.type === "indicatorCharts") {
        IndicatorGroup(ctx, this, this.uid, this.x, this.y, this.w, this.h, this.options, "chart");
    }
    else if (this.type === "indicatorChartInvert") {
        IndicatorChartInvert(ctx, this.x, this.y, this.w, this.h, this.text, this.legends, this.values, this.statuses, this.planValues);
    }
    else if (this.type === "bar") {
        bar(ctx, this.x, this.y, this.w, this.h, this.options.fill, this.options.stroke, this.options.strokeWidth);
    }
    else if (this.type === "indicatorBar") {
        IndicatorBar(ctx, this, this.uid, this.x, this.y, this.w, this.h, this.options);
    }
    else if (this.type === "indicatorBars") {
        IndicatorGroup(ctx, this, this.uid, this.x, this.y, this.w, this.h, this.options, "bar");
    }
    else if (this.type === "indicatorInvertBars") {
        IndicatorInvertBars(ctx, this.uid, this.x, this.y, this.w, this.h, this.options);
    }
    else if (this.type === "rectAnchor") {
        buildRectAnchor(ctx, this.x, this.y, this.w, this.h, this.fill, this.text, this.stroke, this.strokeWidth, this.vertical);
    }
    else if (this.type === "trafficLight") {
        TrafficLight(ctx, this.x, this.y, this.w, this.h, this.status);
    }
    else if (this.type === "scale") {
        IndicatorScale(ctx, this.x, this.y, this.w, this.h, this.text, this.datapoint, this.intervals, this.status, this.scale);
    }
    else if (this.type === "connector") {
        connector(ctx, this.x, this.y, this.w, this.h);
    }
    else if (this.type === "bezieconnector") {
        bezieconnector(ctx, this.x, this.y, this.w, this.h);
        /*connector(ctx, this.x, this.y, this.w, this.h);*/
    }
    else if (this.type === "image") {
        DrawImage(ctx, this.x, this.y, this.w, this.h, this.options);
    }
    //VAD objects
    else if (this.type === "organizationItem") {
        OrganizationItemShape(ctx, this.x, this.y, this.w, this.h, this.options);
    }
    else if (this.type === "mindMap") {
        mindMapShape(ctx, this.x, this.y, this.w, this.h, 10, this.fill, this.stroke, this.strokeWidth, null, this.options);
    }
    else if (this.type === "mindMapRect") {
        mindMapRect(ctx, this.x, this.y, this.w, this.h, 10, this.fill, this.stroke, this.strokeWidth, null, this.options);
    }
    else if (this.type === "processArrow") {
        if (isset(this.click) && this.click.length > 0) {
            this.mouseover = "anchorMouseOver()";
            this.mouseout = "anchorMouseOut()";
        }
        processArrow(ctx, this.x, this.y, this.w, this.h, this.options);
    }
};

// Determine if a point is inside the shape's bounds
Shape.prototype.contains = function (mx, my) {
    // All we have to do is make sure the Mouse X,Y fall in the area between
    // the shape's X and (X + Height) and its Y and (Y + Height)
    var isContains;

    if (this.type === "connector" || this.type === "bezieconnector" ) {
        isContains = false;
    } else if (this.type === "ellipse") {
        var rx = this.w / 2;
        var ry = this.h / 2;
        var x0 = this.x + rx;
        var y0 = this.y + ry;
        isContains = Math.pow(mx - x0, 2) / Math.pow(rx, 2) + Math.pow(my - y0, 2) / Math.pow(ry, 2) <= 1;
    }
    else if (this.type === "circle") {
        isContains = ((this.x - (this.radius + 5)) <= mx) && (this.x + this.radius + 5 >= mx) && ((this.y - (this.radius + 5)) <= my) && (this.y + this.radius + 5 >= my);
    }
    else {
        isContains = (this.x <= mx) && (this.x + this.w >= mx) && (this.y <= my) && (this.y + this.h >= my);
    }

    return isContains;
};

function mousedown_handler(e, myState) {
    
    var mouse = myState.getMouse(e);
    var mx, my;
    
    if (isNaN(mouse.x) && isNaN(mouse.y)) {
        mx = (isset(e.pageX) ? e.pageX : e.clientX) - canvas.offsetLeft;
        my = (isset(e.pageY) ? e.pageY : e.clientY) - canvas.offsetTop;
    }
    else {
        mx = mouse.x;
        my = mouse.y;
    }
    myState.mdown = true;
    myState.mDownCoords = { x: (isset(e.pageX) ? e.pageX : e.clientX), y: (isset(e.pageY) ? e.pageY : e.clientY) };

    if(myState.selection != null) {
        myState.prevSelection = myState.selection;
    }
   
    var shapes = myState.shapes;
    var l = shapes.length;
    var deleted;
    for (var i = l - 1; i >= 0; i--) {
        if (shapes[i].contains(mx, my)) {
            var mySel = shapes[i];
            // Keep track of where in the object we clicked
            // so we can move it smoothly (see mousemove)
            myState.dragoffx = mx - mySel.x;
            myState.dragoffy = my - mySel.y;
            if(myState.interactive){
                myState.dragging = true;
                $("canvas").draggable({ disabled: true }).removeClass("ui-draggable ui-draggable-disabled ui-state-disabled");
            }
            myState.selection = mySel;
            myState.valid = false;
            
            if (myState.selection.type !== "contextMenuItem") {
                clearContextMenu(myState);
                myState.draw();
            }
            return;
        }
    }
    
    clearContextMenu(myState);
    myState.valid = false;
    myState.draw();
    
    // havent returned means we have failed to select anything.
    // If there was an object selected, we deselect it
    if (myState.selection) {
        myState.selection = null;
        myState.valid = false; // Need to clear the old selection border
    }
}

function mouseup_handler(e, myState) {
    var mySel = myState.selection;

    if (!isset(mySel)) {
        closeInfoPanel();
    }

    clearContextMenu(myState);
    
    if (myState.interactive && (e.which === 3 || e.button === 2)) {
        var mouse = myState.getMouse(e);

        var dy = 0;

		var startX = mouse.x;
		var startY = mouse.y;
		
		if (startX + 180 > (myState.width / 2) - 10){
			startX -= 180;
		}
		var startY = mouse.y;
		if (startY + 60 > (myState.height / 2) - 10){
			startY -= myState.interactive ? (isset(mySel) ? 120 : 60) : 30;
		}
		
        var mindMapId = $("#MindMapId").val();
        var targetId = isset(mySel) ? mySel.options.id : "-1";

        var parameters = elma.repString("?targetId={targetId}&mindMapId=" + mindMapId+"&mX="+mouse.x+"&mY="+mouse.y, "targetId", targetId);

        var add_group = in_array("group", myState.interactiveElements);
        var add_goal = in_array("goal", myState.interactiveElements);
        var del_goal = in_array("delgoal", myState.interactiveElements);

        if (myState.interactive && (add_goal || add_group)) {
            if (add_group) {
                var targetGroupCreate = "refreshPopup('TargetCreatePopup','/KPI/Target/Create" + parameters + "&isFolder=true');";
                contextMenuItem(myState, startX, startY + dy, SR.T("Создать группу целей"), targetGroupCreate, "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/folder.png");
            }
            if (add_goal) {
                dy += 30;
                var targetCreate = "refreshPopup('TargetCreatePopup','/KPI/Target/Create" + parameters + "');";
                contextMenuItem(myState, startX, startY + dy, SR.T("Создать цель"), targetCreate, "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/target.png");
            }
        } else {
            //dy = 0;
        }
        if (isset(mySel)) {
            if (myState.interactive) {
                if (in_array("action", myState.interactiveElements)) {
                    dy += 30;
                    contextMenuItem(myState, startX, startY + dy, "---");
                    var actionCreate = "refreshPopup('ActionCreatePopup','/KPI/Action/Create" + parameters + "');";
                    contextMenuItem(myState, startX, startY + dy + 1, SR.T("Создать мероприятие"), actionCreate, "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/action.png");
                }
            } else {
                dy = -90;
            }
            if (in_array("smart", myState.interactiveElements)) {
                dy += 30;
                var smartCreate = "refreshPopup('SmartTaskCreatePopup_','/KPI/SmartTask/CreatePopup" + parameters + "','', '', '');";
                contextMenuItem(myState, startX, startY + dy, SR.T("Создать SMART-задачу"), smartCreate, "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/smart.png");
            }
            if (in_array("del_goal", myState.interactiveElements)) {
                dy += 30;
                contextMenuItem(myState, startX, startY + dy, "---");
                var targetDelete = "jConfirm('"+SR.T("Удалить цель?")+"', '"+SR.T("Удаление")+"', function (r) {if (r == true) {elma.openPleaseWait(true); window.location = '/KPI/Target/Remove/"+parameters+"';} else {}})";
                contextMenuItem(myState, startX, startY + dy + 1, SR.T("Удалить"), targetDelete, "/Content/Images/x16/delete.png");
            }
        }
    }
    else {
        clearContextMenu(myState);
        myState.valid = false;
        myState.draw();
    }
        
    if (myState.prevSelection != null && mySel != null) {
            if (typeof (myState.prevSelection) !== "undefined" && myState.prevSelection != null) {
                if (myState.prevSelection.type !== "connector" && myState.prevSelection.type !== "bezieconnector") {
                    myState.ctx.clearRect(myState.prevSelection.x, myState.prevSelection.y, myState.prevSelection.w, myState.prevSelection.h);
                    myState.prevSelection.draw(myState.ctx);
                }
            }
    }

    if ((e.which === 1 || e.button === 1) && !myState.moving) {
        if (mySel !== null && mySel.click !== null && mySel.click !== undefined && mySel.click !== "") {
                if (mySel.type === "contextMenuItem") {
                    clearContextMenu(myState);
                }
                if (typeof (mySel.click) === "string") {
                    eval(elma.repString(mySel.click, "userId", -1));
                } else {
                    mySel.click();
                }

                if (mySel.type === "contextMenuItem") {
                    clearContextMenu(myState);
                    mySel = null;
                    myState.selection = null;
                    myState.valid = false;
                    myState.draw();
                }

                if (isset(mySel) && mySel.type !== "connector" && mySel.type !== "bezieconnector") {
                    var opts;
                    if (mySel.type === "ellipse") {
                        opts = JSON.parse(JSON.stringify(mySel.options));
                        opts.stroke = kpiStrokeRed;
                        opts.strokeWidth = 2;
                        ellipse(myState.ctx, mySel.x, mySel.y, mySel.w, mySel.h, opts);
                    } else if (mySel.type === "rounded_rect" || mySel.type === "mindMapRect" || mySel.type === "mindMap") {
                        opts = JSON.parse(JSON.stringify(mySel.options));
                        opts.text = "";
                        
                        var addHeight = (isset(opts.totalSmarts) && opts.totalSmarts > 0) || (isset(opts.totalActions) && opts.totalActions > 0)
                            ? 13 : 4;
						var seldx = 2;
							
                        roundRect(myState.ctx, mySel.x-seldx, mySel.y-seldx, mySel.w+seldx*2, mySel.h+seldx*2, 10, null, kpiStrokeDisableRed, 6, null, opts);
						
						
						if(isset(opts.totalSmarts) && opts.totalSmarts > 0){
							var smartInfo = SR.T("{0} из {1}", isset(opts.completeSmarts) ? opts.completeSmarts : 0, opts.totalSmarts);
							var smartIndoWidth = GetTextWidth2(myState.ctx, smartInfo, 9, fontFamily) + 24;
							roundRect(myState.ctx, mySel.x + mySel.w - smartIndoWidth, mySel.y + mySel.h - 6, smartIndoWidth, 15, 1, kpiStrokeDisableGreen, kpiStrokeDisableGreen, 0, null, { text: "    " + smartInfo });
							DrawImage(myState.ctx, mySel.x + mySel.w - smartIndoWidth, mySel.y + mySel.h - 6, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/smart.png" });
						}
						if (isset(opts.totalActions) && opts.totalActions > 0) {
							var actionInfo = SR.T("{0} из {1}", isset(opts.completeActions) ? opts.completeActions : 0, opts.totalActions);
							var actionIndoWidth = GetTextWidth2(myState.ctx, actionInfo, 9, fontFamily) + 24;
							roundRect(myState.ctx, mySel.x, mySel.y + mySel.h - 6, actionIndoWidth, 15, 1, kpiStrokeDisableGreen, kpiStrokeDisableGreen, 0, null, { text: "    " + actionInfo });
							DrawImage(myState.ctx, mySel.x, mySel.y + mySel.h - 6, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/action.png" });
						}
						
						if(isset(opts.isScheduled) && opts.isScheduled === "True") {
							DrawImage(myState.ctx, mySel.x + mySel.w - 16, mySel.y, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/planned.png" });
						}
						if(isset(opts.priority) && opts.priority === 1) {
							DrawImage(myState.ctx, mySel.x, mySel.y, 16, 16, { src: "/Modules/EleWise.ELMA.KPI.Web/Content/Images/high_priority.png" });
						}
						
						if(isset(opts.scaleStatus)) {
							DrawScaleStatus(myState.ctx, mySel.x + mySel.w - 8, mySel.y-4, opts.scaleStatus);
						}						
						
                    } else {
                        colorRect(myState.ctx, mySel.x, mySel.y, mySel.w, mySel.h, kpiStrokeDisableRed);
                    }
                }
            }
        }
    
    myState.mDownCoords = { x: 0, y: 0 };
    myState.mdown = false;

    if (myState.moving && isset(mySel) && typeof (updateEntityCoord) !== "undefined") {
        updateEntityCoord(mySel.uid, mySel.x, mySel.y);
    }
    myState.dragging = false;
    myState.moving = false;

    $("canvas").draggable("enable");
}

function clearContextMenu(canvasState) {
    var deleted = [];
    for (var s = 0; s < canvasState.shapes.length; s++) {
        if (canvasState.shapes[s].type === "contextMenuItem") {
            deleted.push(s);
        }
    }
    for (var s = 0; s < deleted.reverse().length; s++) {
        var index = deleted[s];
        var shape = canvasState.shapes[index];
        canvasState.shapes.splice(index, 1);
    }
}

function call_mouseover(element) {
    if (element.mouseover != null && element.mouseover != undefined && element.mouseover !== "") {
        if (typeof (element.mouseover) === "string") {
            eval(element.mouseover);
        }
        else {
            element.mouseover();
        }
    }
}

function call_mouseout(element) {
    if (element.mouseout != null && element.mouseout != undefined && element.mouseout !== "") {
        if (typeof (element.mouseout) === "string") {
            eval(element.mouseout);
        }
        else {
            element.mouseout();
        }
    }
}

function mousemove_handler(e, myState) {
    var mouse = myState.getMouse(e);
    var mx, my;
    
    if (isNaN(mouse.x) && isNaN(mouse.y)) {
        mx = (isset(e.pageX) ? e.pageX : e.clientX) - canvas.offsetLeft;
        my = (isset(e.pageY) ? e.pageY : e.clientY) - canvas.offsetTop;
    }
    else {
        mx = mouse.x;
        my = mouse.y;
    }
    
    if (myState.interactive && myState.dragging) {
        // we don't want to drag the object by its top-left corner, we want to drag it
        // from where we clicked. thats why we saved the offset and use it here
        myState.selection.x = mouse.x - myState.dragoffx;
        myState.selection.y = mouse.y - myState.dragoffy;
        myState.valid = false; // something's dragging so we must redraw

        var shapes = myState.shapes;
        var l = shapes.length;
        for (var i = 0; i < l; i++) {
            if (shapes[i].type === "bezieconnector") {
                if (shapes[i].options.from === myState.selection.uid) {
                    shapes[i].x = myState.selection.x + myState.selection.w / 2;
                    shapes[i].y = myState.selection.y + myState.selection.h / 2;
                }
                if (shapes[i].options.to === myState.selection.uid) {
                    shapes[i].w = myState.selection.x + myState.selection.w / 2;
                    shapes[i].h = myState.selection.y + myState.selection.h / 2;
                }
            }
        }

    }

    if(myState.mdown) {
        var difX = Math.abs(myState.mDownCoords.x - (isset(e.pageX) ? e.pageX : e.clientX));
        var difY = Math.abs(myState.mDownCoords.y - (isset(e.pageY) ? e.pageY : e.clientY));
        
        myState.moving = difX > 2 || difY > 2;
    }

    var shapes = myState.shapes;
    var l = shapes.length;
    var overshape;
    for (var i = l - 1; i >= 0; i--) {
        if (shapes[i].contains(mx, my)) {
            overshape = shapes[i];
            // TODO if mouseover event present
            break;
        }
    }

    if (overshape != undefined) {
        if (myState.overelement !== overshape) {
            if (myState.overelement != undefined) {
                call_mouseout(myState.overelement);
            }
            myState.overelement = overshape;
            call_mouseover(myState.overelement);
        }
    }
    else {
        if (myState.overelement != undefined) {
            call_mouseout(myState.overelement);
            myState.overelement = undefined;
        }
    }
}

function CanvasState(canvas) {
    // **** First some setup! ****
    this.canvas = canvas;
    this.width = canvas.width;
    this.height = canvas.height;
    this.ctx = canvas.getContext("2d");
    // This complicates things a little but but fixes mouse co-ordinate problems
    // when there's a border or padding. See getMouse for more detail
    if (document.defaultView && document.defaultView.getComputedStyle) {
        this.stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)["paddingLeft"], 10) || 0;
        this.stylePaddingTop = parseInt(document.defaultView.getComputedStyle(canvas, null)["paddingTop"], 10) || 0;
        this.styleBorderLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)["borderLeftWidth"], 10) || 0;
        this.styleBorderTop = parseInt(document.defaultView.getComputedStyle(canvas, null)["borderTopWidth"], 10) || 0;
    }
    // Some pages have fixed-position bars (like the stumbleupon bar) at the top or left of the page
    // They will mess up mouse coordinates and this fixes that
    var html = document.body.parentNode;
    this.htmlTop = html.offsetTop;
    this.htmlLeft = html.offsetLeft;

    // **** Keep track of state! ****

    this.valid = false; // when set to false, the canvas will redraw everything
    this.shapes = [];  // the collection of things to be drawn
    this.dragging = false; // Keep track of when we are dragging
    // the current selected object. In the future we could turn this into an array for multiple selection
    this.selection = null;
    this.prevSelection = null;
    this.dragoffx = 0; // See mousedown and mousemove events for explanation
    this.dragoffy = 0;

    this.moving = false;
    this.mdown = false;
    this.mDownCoords = { x: 0, y: 0 };

    this.interactive = false;
    this.interactiveElements = [];

    // **** Then events! ****

    // This is an example of a closure!
    // Right here "this" means the CanvasState. But we are making events on the Canvas itself,
    // and when the events are fired on the canvas the variable "this" is going to mean the canvas!
    // Since we still want to use this particular CanvasState in the events we have to save a reference to it.
    // This is our reference!
    var myState = this;

    if (canvas.addEventListener) {
        //fixes a problem where double clicking causes text to get selected on the canvas
        canvas.addEventListener("selectstart", function (e) { e.preventDefault(); return false; }, false);
        // Up, down, and move are for dragging

        canvas.addEventListener("mousedown", function (e) { mousedown_handler(e, myState); }, true);
        canvas.addEventListener("mouseup", function (e) { mouseup_handler(e, myState); }, true);
        canvas.addEventListener("mousemove", function (e) { mousemove_handler(e, myState); }, true);

        canvas.addEventListener("touchstart", function (e) { mousedown_handler(e, myState); }, true);
        canvas.addEventListener("touchend", function (e) { mouseup_handler(e, myState); }, true);
        canvas.addEventListener("touchmove", function (e) { mousemove_handler(e, myState); }, true);

    } else if (canvas.attachEvent) { // IE
        canvas.attachEvent("onmousedown", function (e) { mousedown_handler(e, myState); }, true);
        canvas.attachEvent("onmouseup", function (e) { mouseup_handler(e, myState); }, true);
        canvas.attachEvent("onmousemove", function (e) { mousemove_handler(e, myState); }, true);
    }

    // double click for making new shapes
    //    canvas.addEventListener('dblclick', function (e) {
    //        var mouse = myState.getMouse(e);
    //        myState.addShape(new Shape(mouse.x - 10, mouse.y - 10, 20, 20, 'rgba(0,255,0,.6)'));
    //    }, true);

    // **** Options! ****

    this.selectionColor = "#CC0000";
    this.selectionWidth = 2;
    this.interval = 100;
    setInterval(function () { myState.draw(); }, myState.interval);
}

CanvasState.prototype.addShape = function (shape) {
    shape.canvasState = this;
    this.shapes.push(shape);

    this.shapes.sort(sortShapes);
    
    this.valid = false;
};

CanvasState.prototype.clear = function () {
    this.ctx.clearRect(0, 0, this.width, this.height);
};
// While draw is called as often as the INTERVAL variable demands,
// It only ever does something if the canvas gets invalidated by our code
CanvasState.prototype.draw = function () {
    // if our state is invalid, redraw and validate!
    if (!this.valid) {
        var ctx = this.ctx;
        var shapes = this.shapes.sort(sortShapes);
        this.clear();
        
        // ** Add stuff you want drawn in the background all the time here **

        // draw all shapes
        var l = shapes.length;
        
        for (var i = 0; i < l; i++) {
            var shape = shapes[i];
            
            if (!isset(shape)) {
                continue;
            }
            // We can skip the drawing of elements that have moved off the screen:
            if (shape.x > this.width ||
                    shape.y > this.height ||
                    shape.x + shape.w < 0 ||
                    shape.y + shape.h < 0
            ) {
                continue;
            }
            shape.draw(ctx);
        }

        // draw selection
        // right now this is just a stroke along the edge of the selected Shape
        if (this.selection != null) {
            ctx.strokeStyle = this.selectionColor;
            ctx.lineWidth = this.selectionWidth;
            var mySel = this.selection;
            if (mySel.type === "rect") {
                ctx.strokeRect(mySel.x, mySel.y, mySel.w, mySel.h);
            }
        }

        // ** Add stuff you want drawn on top all the time here **

        this.valid = true;
    }
};


function sortShapes(a, b) {
    if (a.type === b.type)
        return 0;
    if (a.type === "contextMenuItem")
        return 1;
    if (a.type === "connector" || a.type === "bezieconnector")
        return -1;
    return 0;
}

// Creates an object with x and y defined, set to the mouse position relative to the state's canvas
// If you wanna be super-correct this can be tricky, we have to worry about padding and borders
CanvasState.prototype.getMouse = function (e) {
    var element = this.canvas, 
        offsetX = 0, 
        offsetY = 0, 
        mx, 
        my;

    // Compute the total offset
    if (typeof element.offsetParent !== "undefined") {
        do {
            offsetX += element.offsetLeft;
            offsetY += element.offsetTop;
        } while ((element = element.offsetParent));
    }

    // Add padding and border style widths to offset
    // Also add the <html> offsets in case there's a position:fixed bar
    offsetX += this.stylePaddingLeft || 0 + this.styleBorderLeft || 0 + this.htmlLeft || 0;
    offsetY += this.stylePaddingTop || 0 + this.styleBorderTop || 0 + this.htmlTop || 0;

    if (isset(e) && isset(e.pageX) && isset(e.pageY)) {
        mx = e.pageX;
        my = e.pageY;
    }
    else {
        mx = e.clientX + document.body.scrollLeft +
        document.documentElement.scrollLeft;
        my = e.clientY + document.body.scrollTop +
        document.documentElement.scrollTop;
    }
    mx -= offsetX;
    my -= offsetY;

    var ttx = this.width / (this.canvas.clientWidth * 1);
    var tty = this.height / (this.canvas.clientHeight * 1);
    
    mx *= ttx;
    my *= tty;

    return { x: mx, y: my };
};

function in_array(needle, haystack, strict) {   // Checks if a value exists in an array
    var found = false, key, strict = !!strict;
    for (key in haystack) {
        if ((strict && haystack[key] === needle) || (!strict && haystack[key] == needle)) {
            found = true;
            break;
        }
    }
    return found;
}

function imagesInit()
{
    var kpiImages = [
        "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/mindmap.png",
        "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/smart.png",
        "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/action.png",
        "/Modules/EleWise.ELMA.KPI.Web/Content/Images/x16/planned.png",
        "/Modules/EleWise.ELMA.KPI.Web/Content/Images/high_priority.png",
        "/Modules/EleWise.ELMA.KPI.Web/Content/Images/ScaleStatus/green_indicator.gif",
        "/Modules/EleWise.ELMA.KPI.Web/Content/Images/ScaleStatus/yellow_indicator.gif",
        "/Modules/EleWise.ELMA.KPI.Web/Content/Images/ScaleStatus/red_indicator.gif",
        "/Modules/EleWise.ELMA.KPI.Web/Content/Images/ScaleStatus/na_indicator.gif"
    ];
    for (var i = 0; i < kpiImages.length;i++){
        var imageObj = new Image(16, 16);
        imageObj.src= kpiImages[i];
    }
}

imagesInit();


/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */
(function(d){function e(a){var b=a||window.event,c=[].slice.call(arguments,1),f=0,e=0,g=0,a=d.event.fix(b);a.type="mousewheel";b.wheelDelta&&(f=b.wheelDelta/120);b.detail&&(f=-b.detail/3);g=f;b.axis!==void 0&&b.axis===b.HORIZONTAL_AXIS&&(g=0,e=-1*f);b.wheelDeltaY!==void 0&&(g=b.wheelDeltaY/120);b.wheelDeltaX!==void 0&&(e=-1*b.wheelDeltaX/120);c.unshift(a,f,e,g);return(d.event.dispatch||d.event.handle).apply(this,c)}var c=["DOMMouseScroll","mousewheel"];if(d.event.fixHooks)for(var h=c.length;h;)d.event.fixHooks[c[--h]]=
d.event.mouseHooks;d.event.special.mousewheel={setup:function(){if(this.addEventListener)for(var a=c.length;a;)this.addEventListener(c[--a],e,false);else this.onmousewheel=e},teardown:function(){if(this.removeEventListener)for(var a=c.length;a;)this.removeEventListener(c[--a],e,false);else this.onmousewheel=null}};d.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})})(jQuery);


/*
 * iviewer Widget for jQuery UI
 * https://github.com/can3p/iviewer
 *
 * Copyright (c) 2009 - 2013 Dmitry Petrov
 * Dual licensed under the MIT license.
 *  - http://www.opensource.org/licenses/mit-license.php
 *
 * Author: Dmitry Petrov
 * Version: 0.7.9
 */

( function( $, undefined ) {

//this code was taken from the https://github.com/furf/jquery-ui-touch-punch
var mouseEvents = {
        touchstart: 'mousedown',
        touchmove: 'mousemove',
        touchend: 'mouseup'
    },
    gesturesSupport = 'ongesturestart' in document.createElement('div');


/**
 * Convert a touch event to a mouse-like
 */
function makeMouseEvent (event) {
    var touch = event.originalEvent.changedTouches[0];

    return $.extend(event, {
        type:    mouseEvents[event.type],
        which:   1,
        pageX:   touch.pageX,
        pageY:   touch.pageY,
        screenX: touch.screenX,
        screenY: touch.screenY,
        clientX: touch.clientX,
        clientY: touch.clientY,
        isTouchEvent: true
    });
}

var mouseProto = $.ui.mouse.prototype,
    _mouseInit = $.ui.mouse.prototype._mouseInit;

mouseProto._mouseInit = function() {
    var self = this;
    self._touchActive = false;

    this.element.bind( 'touchstart.' + this.widgetName, function(event) {
        if (gesturesSupport && event.originalEvent.touches.length > 1) { return; }
        self._touchActive = true;
        return self._mouseDown(makeMouseEvent(event));
    });

    // these delegates are required to keep context
    this._mouseMoveDelegate = function(event) {
        if (gesturesSupport && event.originalEvent.touches && event.originalEvent.touches.length > 1) { return; }
        if (self._touchActive) {
            return self._mouseMove(makeMouseEvent(event));
        }
    };
    this._mouseUpDelegate = function(event) {
        if (self._touchActive) {
            self._touchActive = false;
            return self._mouseUp(makeMouseEvent(event));
        }
    };

    $(document)
        .bind('touchmove.'+ this.widgetName, this._mouseMoveDelegate)
        .bind('touchend.' + this.widgetName, this._mouseUpDelegate);

    _mouseInit.apply(this);
};

/**
 * Simple implementation of jQuery like getters/setters
 * var val = something();
 * something(val);
 */
var setter = function(setter, getter) {
    return function(val) {
        if (arguments.length === 0) {
            return getter.apply(this);
        } else {
            setter.apply(this, arguments);
        }
    }
};

/**
 * Internet explorer rotates image relative left top corner, so we should
 * shift image when it's rotated.
 */
var ieTransforms = {
        '0': {
            marginLeft: 0,
            marginTop: 0,
            filter: 'progid:DXImageTransform.Microsoft.Matrix(M11=1, M12=0, M21=0, M22=1, SizingMethod="auto expand")'
        },

        '90': {
            marginLeft: -1,
            marginTop: 1,
            filter: 'progid:DXImageTransform.Microsoft.Matrix(M11=0, M12=-1, M21=1, M22=0, SizingMethod="auto expand")'
        },

        '180': {
            marginLeft: 0,
            marginTop: 0,
            filter: 'progid:DXImageTransform.Microsoft.Matrix(M11=-1, M12=0, M21=0, M22=-1, SizingMethod="auto expand")'
        },

        '270': {
            marginLeft: -1,
            marginTop: 1,
            filter: 'progid:DXImageTransform.Microsoft.Matrix(M11=0, M12=1, M21=-1, M22=0, SizingMethod="auto expand")'
        }
    },
    // this test is the inversion of the css filters test from the modernizr project
    useIeTransforms = function() {
        var modElem = document.createElement('modernizr'),
            mStyle = modElem.style,
            omPrefixes = 'Webkit Moz O ms',
            domPrefixes = omPrefixes.toLowerCase().split(' '),
            props = ("transform" + ' ' + domPrefixes.join("Transform ") + "Transform").split(' ');

        for ( var i in props ) {
            var prop = props[i];
            if ( prop.indexOf("-") == -1 && mStyle[prop] !== undefined ) {
                return false;
            }
        }
        return true;
    }();

$.widget( "ui.iviewer", $.ui.mouse, {
    widgetEventPrefix: "iviewer",
    options : {
        /**
        * start zoom value for image, not used now
        * may be equal to "fit" to fit image into container or scale in %
        **/
        zoom: "fit",
        /**
        * base value to scale image
        **/
        zoom_base: 100,
        /**
        * maximum zoom
        **/
        zoom_max: 800,
        /**
        * minimum zoom
        **/
        zoom_min: 25,
        /**
        * base of rate multiplier.
        * zoom is calculated by formula: zoom_base * zoom_delta^rate
        **/
        zoom_delta: 1.4,
        /**
        * whether the zoom should be animated.
        */
        zoom_animation: true,
        /**
        * if true plugin doesn't add its own controls
        **/
        ui_disabled: false,
        /**
         * If false mousewheel will be disabled
         */
        mousewheel: true,
        /**
        * if false, plugin doesn't bind resize event on window and this must
        * be handled manually
        **/
        update_on_resize: true,
        /**
        * whether to provide zoom on doubleclick functionality
        */
        zoom_on_dblclick: true,
        /**
        * if true the image will fill the container and the image will be distorted
        */
        fill_container: false,
        /**
        * event is triggered when zoom value is changed
        * @param int new zoom value
        * @return boolean if false zoom action is aborted
        **/
        onZoom: jQuery.noop,
        /**
        * event is triggered when zoom value is changed after image is set to the new dimensions
        * @param int new zoom value
        * @return boolean if false zoom action is aborted
        **/
        onAfterZoom: jQuery.noop,
        /**
        * event is fired on drag begin
        * @param object coords mouse coordinates on the image
        * @return boolean if false is returned, drag action is aborted
        **/
        onStartDrag: jQuery.noop,
        /**
        * event is fired on drag action
        * @param object coords mouse coordinates on the image
        **/
        onDrag: jQuery.noop,
        /**
        * event is fired on drag stop
        * @param object coords mouse coordinates on the image
        **/
        onStopDrag: jQuery.noop,
        /**
        * event is fired when mouse moves over image
        * @param object coords mouse coordinates on the image
        **/
        onMouseMove: jQuery.noop,
        /**
        * mouse click event
        * @param object coords mouse coordinates on the image
        **/
        onClick: jQuery.noop,
        /**
        * mouse double click event. If used will delay each click event.
        * If double click event was fired, clicks will not.
        *
        * @param object coords mouse coordinates on the image
        **/
        onDblClick: null,
        /**
        * event is fired when image starts to load
        */
        onStartLoad: null,
        /**
        * event is fired, when image is loaded and initially positioned
        */
        onFinishLoad: null,
        /**
        * event is fired when image load error occurs
        */
        onErrorLoad: null
    },

    _create: function() {
        var me = this;

        //drag variables
        this.dx = 0;
        this.dy = 0;

        /* object containing actual information about image
        *   @img_object.object - jquery img object
        *   @img_object.orig_{width|height} - original dimensions
        *   @img_object.display_{width|height} - actual dimensions
        */
        this.img_object = {};

        this.zoom_object = {}; //object to show zoom status

        this._angle = 0;

        this.current_zoom = this.options.zoom;

        if(this.options.src === null){
            return;
        }

        this.container = this.element;

        this._updateContainerInfo();

        //init container
        this.container.css("overflow","hidden");

        if (this.options.update_on_resize == true) {
            $(window).resize(function() {
                me.update();
            });
        }

        this.img_object = new $.ui.iviewer.ImageObject(this.options.zoom_animation);

        if (this.options.mousewheel) {
            this.container.bind('mousewheel.iviewer', function(ev, delta)
                {
                    //this event is there instead of containing div, because
                    //at opera it triggers many times on div
                    var zoom = (delta > 0)?1:-1,
                        container_offset = me.container.offset(),
                        mouse_pos = {
                            //jquery.mousewheel 3.1.0 uses strange MozMousePixelScroll event
                            //which is not being fixed by jQuery.Event
                            x: (ev.pageX || ev.originalEvent.pageX) - container_offset.left,
                            y: (ev.pageY || ev.originalEvent.pageX) - container_offset.top
                        };

                    me.zoom_by(zoom, mouse_pos);
                    return false;
                });

            if (gesturesSupport) {
                var gestureThrottle = +new Date();
                var originalScale, originalCenter;
                this.img_object.object()
                    // .bind('gesturestart', function(ev) {
                    .bind('touchstart', function(ev) {
                        originalScale = me.current_zoom;
                        var touches = ev.originalEvent.touches,
                            container_offset;
                        if (touches.length == 2) {
                            container_offset = me.container.offset();
                            originalCenter = {
                                x: (touches[0].pageX + touches[1].pageX) / 2  - container_offset.left,
                                y: (touches[0].pageY + touches[1].pageY) / 2 - container_offset.top
                            };
                        } else {
                            originalCenter = null;
                        }
                    }).bind('gesturechange.iviewer', function(ev) {
                        //do not want to import throttle function from underscore
                        var d = +new Date();
                        if ((d - gestureThrottle) < 50) { return; }
                        gestureThrottle = d;
                        var zoom = originalScale * ev.originalEvent.scale;
                        me.set_zoom(zoom, originalCenter);
                        ev.preventDefault();
                }).bind('gestureend.iviewer', function(ev) {
                        originalCenter = null;
                    });
            }
        }

        //bind doubleclick only if callback is not falsy
        var useDblClick = !!this.options.onDblClick || this.options.zoom_on_dblclick,
            dblClickTimer = null,
            clicksNumber = 0;

        //init object
        this.img_object.object()
            .prependTo(this.container);

        //all these tricks are needed to fire either click
        //or doubleclick events at the same time
        if (useDblClick) {
            this.img_object.object()
                //bind mouse events
                .click(function(e){
                    clicksNumber++;
                    clearTimeout(dblClickTimer);

                    dblClickTimer = setTimeout(function() {
                        clicksNumber = 0;
                        me._click(e);
                    }, 300);
                })
                .dblclick(function(e){
                    if (clicksNumber !== 2) return;

                    clearTimeout(dblClickTimer);
                    clicksNumber = 0;
                    me._dblclick(e);
                });
        } else {
            this.img_object.object()
                .click(function(e){ me._click(e); });
        }

        this.container.bind('mousemove.iviewer', function(ev) { me._handleMouseMove(ev); });

        this.loadImage(this.options.src);

        if(!this.options.ui_disabled)
        {
            this.createui();
        }

        this._mouseInit();
    },

    destroy: function() {
        $.Widget.prototype.destroy.call( this );
        this._mouseDestroy();
        this.img_object.object().remove();
        try {
            this.container.off('.iviewer');
            this.container.css('overflow', ''); //cleanup styles on destroy
        } catch (err) {
        }
    },

    _updateContainerInfo: function()
    {
        this.options.height = this.container.height();
        this.options.width = this.container.width();
    },

    update: function()
    {
        this._updateContainerInfo();
        this.setCoords(this.img_object.x(), this.img_object.y());
    },

    loadImage: function( src )
    {
        this.current_zoom = this.options.zoom;
        var me = this;

        this._trigger('onStartLoad', 0, src);

        this.container.addClass("iviewer_loading");
        this.img_object.load(src, function() {
            me._fill_orig_dimensions = { width: me.img_object.orig_width(), height: me.img_object.orig_height() };
            me._imageLoaded(src);
        }, function() {
            me._trigger("onErrorLoad", 0, src);
        });
    },

    _imageLoaded: function(src) {
        this.container.removeClass("iviewer_loading");
        this.container.addClass("iviewer_cursor");

        if(this.options.zoom == "fit"){
            this.fit(true);
        }
        else {
            this.set_zoom(this.options.zoom, true);
        }

        this._trigger('onFinishLoad', 0, src);

        if(this.options.fill_container)
        {
          this.fill_container(true);
        }
    },

    /**
    * fits image in the container
    *
    * @param {boolean} skip_animation
    **/
    fit: function(skip_animation)
    {
        var aspect_ratio = this.img_object.orig_width() / this.img_object.orig_height();
        var window_ratio = this.options.width /  this.options.height;
        var choose_left = (aspect_ratio > window_ratio);
        var new_zoom = 0;

        if(choose_left){
            new_zoom = this.options.width / this.img_object.orig_width() * 100;
        }
        else {
            new_zoom = this.options.height / this.img_object.orig_height() * 100;
        }

      this.set_zoom(new_zoom, skip_animation);
    },

    /**
    * center image in container
    **/
    center: function()
    {
        this.setCoords(-Math.round((this.img_object.display_width() - this.options.width)/2),
                -Math.round((this.img_object.display_height() - this.options.height)/2));
    },

    /**
    *   move a point in container to the center of display area
    *   @param x a point in container
    *   @param y a point in container
    **/
    moveTo: function(x, y)
    {
        var dx = x-Math.round(this.options.width/2);
        var dy = y-Math.round(this.options.height/2);

        var new_x = this.img_object.x() - dx;
        var new_y = this.img_object.y() - dy;

        this.setCoords(new_x, new_y);
    },

    /**
     * Get container offset object.
     */
    getContainerOffset: function() {
        return jQuery.extend({}, this.container.offset());
    },

    /**
    * set coordinates of upper left corner of image object
    **/
    setCoords: function(x,y)
    {
        //do nothing while image is being loaded
        if(!this.img_object.loaded()) { return; }

        var coords = this._correctCoords(x,y);
        this.img_object.x(coords.x);
        this.img_object.y(coords.y);
    },

    _correctCoords: function( x, y )
    {
        x = parseInt(x, 10);
        y = parseInt(y, 10);

        //check new coordinates to be correct (to be in rect)
        if(y > 0){
            y = 0;
        }
        if(x > 0){
            x = 0;
        }
        if(y + this.img_object.display_height() < this.options.height){
            y = this.options.height - this.img_object.display_height();
        }
        if(x + this.img_object.display_width() < this.options.width){
            x = this.options.width - this.img_object.display_width();
        }
        if(this.img_object.display_width() <= this.options.width){
            x = -(this.img_object.display_width() - this.options.width)/2;
        }
        if(this.img_object.display_height() <= this.options.height){
            y = -(this.img_object.display_height() - this.options.height)/2;
        }

        return { x: x, y:y };
    },


    /**
    * convert coordinates on the container to the coordinates on the image (in original size)
    *
    * @return object with fields x,y according to coordinates or false
    * if initial coords are not inside image
    **/
    containerToImage : function (x,y)
    {
        var coords = { x : x - this.img_object.x(),
                 y :  y - this.img_object.y()
        };

        coords = this.img_object.toOriginalCoords(coords);

        return { x :  util.descaleValue(coords.x, this.current_zoom),
                 y :  util.descaleValue(coords.y, this.current_zoom)
        };
    },

    /**
    * convert coordinates on the image (in original size, and zero angle) to the coordinates on the container
    *
    * @return object with fields x,y according to coordinates
    **/
    imageToContainer : function (x,y)
    {
        var coords = {
                x : util.scaleValue(x, this.current_zoom),
                y : util.scaleValue(y, this.current_zoom)
            };

        return this.img_object.toRealCoords(coords);
    },

    /**
    * get mouse coordinates on the image
    * @param e - object containing pageX and pageY fields, e.g. mouse event object
    *
    * @return object with fields x,y according to coordinates or false
    * if initial coords are not inside image
    **/
    _getMouseCoords : function(e)
    {
        var containerOffset = this.container.offset(),
            coords = this.containerToImage(e.pageX - containerOffset.left, e.pageY - containerOffset.top);

        return coords;
    },

    /**
    * fills container entirely by distorting image
    *
    * @param {boolean} fill wether to fill the container entirely or not.
    **/
    fill_container: function(fill)
    {
        this.options.fill_container = fill;
        if(fill)
        {
            var ratio = this.options.width / this.options.height;
            if (ratio > 1)
                this.img_object.orig_width(this.img_object.orig_height() * ratio);
            else
                this.img_object.orig_height(this.img_object.orig_width() * ratio);
        }
        else
        {
            this.img_object.orig_width(this._fill_orig_dimensions.width);
            this.img_object.orig_height(this._fill_orig_dimensions.height);
        }
        this.set_zoom(this.current_zoom);
    },

    /**
    * set image scale to the new_zoom
    *
    * @param {number} new_zoom image scale in %
    * @param {boolean} skip_animation
    * @param {x: number, y: number} Coordinates of point the should not be moved on zoom. The default is the center of image.
    **/
    set_zoom: function(new_zoom, skip_animation, zoom_center)
    {
        if (this._trigger('onZoom', 0, new_zoom) == false) {
            return;
        }

        //do nothing while image is being loaded
        if(!this.img_object.loaded()) { return; }

        zoom_center = zoom_center || {
            x: Math.round(this.options.width/2),
            y: Math.round(this.options.height/2)
        };

        if(new_zoom <  this.options.zoom_min)
        {
            new_zoom = this.options.zoom_min;
        }
        else if(new_zoom > this.options.zoom_max)
        {
            new_zoom = this.options.zoom_max;
        }

        /* we fake these values to make fit zoom properly work */
        var old_x, old_y;
        if(this.current_zoom == "fit")
        {
            old_x = zoom_center.x + Math.round(this.img_object.orig_width()/2);
            old_y = zoom_center.y + Math.round(this.img_object.orig_height()/2);
            this.current_zoom = 100;
        }
        else {
            old_x = -this.img_object.x() + zoom_center.x;
            old_y = -this.img_object.y() + zoom_center.y;
        }

        var new_width = util.scaleValue(this.img_object.orig_width(), new_zoom);
        var new_height = util.scaleValue(this.img_object.orig_height(), new_zoom);
        var new_x = util.scaleValue( util.descaleValue(old_x, this.current_zoom), new_zoom);
        var new_y = util.scaleValue( util.descaleValue(old_y, this.current_zoom), new_zoom);

        new_x = zoom_center.x - new_x;
        new_y = zoom_center.y - new_y;

        new_width = Math.floor(new_width);
        new_height = Math.floor(new_height);
        new_x = Math.floor(new_x);
        new_y = Math.floor(new_y);

        this.img_object.display_width(new_width);
        this.img_object.display_height(new_height);

        var coords = this._correctCoords( new_x, new_y ),
            self = this;

        this.img_object.setImageProps(new_width, new_height, coords.x, coords.y,
                                        skip_animation, function() {
            self._trigger('onAfterZoom', 0, new_zoom );
        });
        this.current_zoom = new_zoom;

        this.update_status();
    },

    /**
    * changes zoom scale by delta
    * zoom is calculated by formula: zoom_base * zoom_delta^rate
    * @param Integer delta number to add to the current multiplier rate number
    * @param {x: number, y: number=} Coordinates of point the should not be moved on zoom.
    **/
    zoom_by: function(delta, zoom_center)
    {
        var closest_rate = this.find_closest_zoom_rate(this.current_zoom);

        var next_rate = closest_rate + delta;
        var next_zoom = this.options.zoom_base * Math.pow(this.options.zoom_delta, next_rate);
        if(delta > 0 && next_zoom < this.current_zoom)
        {
            next_zoom *= this.options.zoom_delta;
        }

        if(delta < 0 && next_zoom > this.current_zoom)
        {
            next_zoom /= this.options.zoom_delta;
        }

        this.set_zoom(next_zoom, undefined, zoom_center);
    },

    /**
    * Rotate image
    * @param {num} deg Degrees amount to rotate. Positive values rotate image clockwise.
    *     Currently 0, 90, 180, 270 and -90, -180, -270 values are supported
    *
    * @param {boolean} abs If the flag is true if, the deg parameter will be considered as
    *     a absolute value and relative otherwise.
    * @return {num|null} Method will return current image angle if called without any arguments.
    **/
    angle: function(deg, abs) {
        if (arguments.length === 0) { return this.img_object.angle(); }

        if (deg < -270 || deg > 270 || deg % 90 !== 0) { return; }
        if (!abs) { deg += this.img_object.angle(); }
        if (deg < 0) { deg += 360; }
        if (deg >= 360) { deg -= 360; }

        if (deg === this.img_object.angle()) { return; }

        this.img_object.angle(deg);
        //the rotate behavior is different in all editors. For now we  just center the
        //image. However, it will be better to try to keep the position.
        this.center();
        this._trigger('angle', 0, { angle: this.img_object.angle() });
    },

    /**
    * finds closest multiplier rate for value
    * basing on zoom_base and zoom_delta values from settings
    * @param Number value zoom value to examine
    **/
    find_closest_zoom_rate: function(value)
    {
        if(value == this.options.zoom_base)
        {
            return 0;
        }

        function div(val1,val2) { return val1 / val2; };
        function mul(val1,val2) { return val1 * val2; };

        var func = (value > this.options.zoom_base)?mul:div;
        var sgn = (value > this.options.zoom_base)?1:-1;

        var mltplr = this.options.zoom_delta;
        var rate = 1;

        while(Math.abs(func(this.options.zoom_base, Math.pow(mltplr,rate)) - value) >
              Math.abs(func(this.options.zoom_base, Math.pow(mltplr,rate+1)) - value))
        {
            rate++;
        }

        return sgn * rate;
    },

    /* update scale info in the container */
    update_status: function()
    {
        if(!this.options.ui_disabled)
        {
            var percent = Math.round(100*this.img_object.display_height()/this.img_object.orig_height());
            if(percent)
            {
                this.zoom_object.html(percent + "%");
            }
        }
    },

    /**
     * Get some information about the image.
     *     Currently orig_(width|height), display_(width|height), angle, zoom and src params are supported.
     *
     *  @param {string} parameter to check
     *  @param {boolean} withoutRotation if param is orig_width or orig_height and this flag is set to true,
     *      method will return original image width without considering rotation.
     *
     */
    info: function(param, withoutRotation) {
        if (!param) { return; }

        switch (param) {
            case 'orig_width':
            case 'orig_height':
                if (withoutRotation) {
                    return (this.img_object.angle() % 180 === 0 ? this.img_object[param]() :
                            param === 'orig_width' ? this.img_object.orig_height() :
                                                        this.img_object.orig_width());
                } else {
                    return this.img_object[param]();
                }
            case 'display_width':
            case 'display_height':
            case 'angle':
                return this.img_object[param]();
            case 'zoom':
                return this.current_zoom;
            case 'options':
                return this.options;
            case 'src':
                return this.img_object.object().attr('src');
            case 'coords':
                return {
                    x: this.img_object.x(),
                    y: this.img_object.y()
                };
        }
    },

    /**
    *   callback for handling mousdown event to start dragging image
    **/
    _mouseStart: function( e )
    {
        $.ui.mouse.prototype._mouseStart.call(this, e);
        if (this._trigger('onStartDrag', 0, this._getMouseCoords(e)) === false) {
            return false;
        }

        /* start drag event*/
        this.container.addClass("iviewer_drag_cursor");

        //#10: fix movement quirks for ipad
        this._dragInitialized = !(e.originalEvent.changedTouches && e.originalEvent.changedTouches.length==1);

        this.dx = e.pageX - this.img_object.x();
        this.dy = e.pageY - this.img_object.y();
        return true;
    },

    _mouseCapture: function( e ) {
        return true;
    },

    /**
     * Handle mouse move if needed. User can avoid using this callback, because
     *    he can get the same information through public methods.
     *  @param {jQuery.Event} e
     */
    _handleMouseMove: function(e) {
        this._trigger('onMouseMove', e, this._getMouseCoords(e));
    },

    /**
    *   callback for handling mousemove event to drag image
    **/
    _mouseDrag: function(e)
    {
        $.ui.mouse.prototype._mouseDrag.call(this, e);

        //#10: imitate mouseStart, because we can get here without it on iPad for some reason
        if (!this._dragInitialized) {
            this.dx = e.pageX - this.img_object.x();
            this.dy = e.pageY - this.img_object.y();
            this._dragInitialized = true;
        }

        var ltop =  e.pageY - this.dy;
        var lleft = e.pageX - this.dx;

        this.setCoords(lleft, ltop);
        this._trigger('onDrag', e, this._getMouseCoords(e));
        return false;
    },

    /**
    *   callback for handling stop drag
    **/
    _mouseStop: function(e)
    {
        $.ui.mouse.prototype._mouseStop.call(this, e);
        this.container.removeClass("iviewer_drag_cursor");
        this._trigger('onStopDrag', 0, this._getMouseCoords(e));
    },

    _click: function(e)
    {
        this._trigger('onClick', 0, this._getMouseCoords(e));
    },

    _dblclick: function(ev)
    {
      if (this.options.onDblClick) {
        this._trigger('onDblClick', 0, this._getMouseCoords(ev));
      }

      if (this.options.zoom_on_dblclick) {
        var container_offset = this.container.offset()
          , mouse_pos = {
            x: ev.pageX - container_offset.left,
            y: ev.pageY - container_offset.top
          };

        this.zoom_by(1, mouse_pos);
      }
    },

    /**
    *   create zoom buttons info box
    **/
    createui: function()
    {
        var me=this;

        $("<div>", { 'class': "iviewer_zoom_in iviewer_common iviewer_button"})
                    .bind('mousedown touchstart',function(){me.zoom_by(1); return false;})
                    .appendTo(this.container);

        $("<div>", { 'class': "iviewer_zoom_out iviewer_common iviewer_button"})
                    .bind('mousedown touchstart',function(){me.zoom_by(- 1); return false;})
                    .appendTo(this.container);

        $("<div>", { 'class': "iviewer_zoom_zero iviewer_common iviewer_button"})
                    .bind('mousedown touchstart',function(){me.set_zoom(100); return false;})
                    .appendTo(this.container);

        $("<div>", { 'class': "iviewer_zoom_fit iviewer_common iviewer_button"})
                    .bind('mousedown touchstart',function(){me.fit(this); return false;})
                    .appendTo(this.container);

        this.zoom_object = $("<div>").addClass("iviewer_zoom_status iviewer_common")
                                    .appendTo(this.container);

        $("<div>", { 'class': "iviewer_rotate_left iviewer_common iviewer_button"})
                    .bind('mousedown touchstart',function(){me.angle(-90); return false;})
                    .appendTo(this.container);

        $("<div>", { 'class': "iviewer_rotate_right iviewer_common iviewer_button" })
                    .bind('mousedown touchstart',function(){me.angle(90); return false;})
                    .appendTo(this.container);

        this.update_status(); //initial status update
    }

} );

/**
 * @class $.ui.iviewer.ImageObject Class represents image and provides public api without
 *     extending image prototype.
 * @constructor
 * @param {boolean} do_anim Do we want to animate image on dimension changes?
 */
$.ui.iviewer.ImageObject = function(do_anim) {
    this._img = $("<img>")
            //this is needed, because chromium sets them auto otherwise
            .css({ position: "absolute", top :"0px", left: "0px"});

    this._loaded = false;
    this._swapDimensions = false;
    this._do_anim = do_anim || false;
    this.x(0, true);
    this.y(0, true);
    this.angle(0);
};


/** @lends $.ui.iviewer.ImageObject.prototype */
(function() {
    /**
     * Restore initial object state.
     *
     * @param {number} w Image width.
     * @param {number} h Image height.
     */
    this._reset = function(w, h) {
        this._angle = 0;
        this._swapDimensions = false;
        this.x(0);
        this.y(0);

        this.orig_width(w);
        this.orig_height(h);
        this.display_width(w);
        this.display_height(h);
    };

    /**
     * Check if image is loaded.
     *
     * @return {boolean}
     */
    this.loaded = function() { return this._loaded; };

    /**
     * Load image.
     *
     * @param {string} src Image url.
     * @param {Function=} loaded Function will be called on image load.
     */
    this.load = function(src, loaded, error) {
        var self = this;

        loaded = loaded || jQuery.noop;
        this._loaded = false;

        //If we assign new image url to the this._img IE9 fires onload event and image width and
        //height are set to zero. So, we create another image object and load image through it.
        var img = new Image();
        img.onload = function() {
            self._loaded = true;
            self._reset(this.width, this.height);

            self._img
                .removeAttr("width")
                .removeAttr("height")
                .removeAttr("style")
                //max-width is reset, because plugin breaks in the twitter bootstrap otherwise
                .css({ position: "absolute", top :"0px", left: "0px", maxWidth: "none"});

            self._img[0].src = src;
            loaded();
        };

        img.onerror = error;

        //we need this because sometimes internet explorer 8 fires onload event
        //right after assignment (synchronously)
        setTimeout(function() {
            img.src = src;
        }, 0);

        this.angle(0);
    };

    this._dimension = function(prefix, name) {
        var horiz = '_' + prefix + '_' + name,
            vert = '_' + prefix + '_' + (name === 'height' ? 'width' : 'height');
        return setter(function(val) {
                this[this._swapDimensions ? horiz: vert] = val;
            },
            function() {
                return this[this._swapDimensions ? horiz: vert];
            });
    };

    /**
     * Getters and setter for common image dimensions.
     *    display_ means real image tag dimensions
     *    orig_ means physical image dimensions.
     *  Note, that dimensions are swapped if image is rotated. It necessary,
     *  because as little as possible code should know about rotation.
     */
    this.display_width = this._dimension('display', 'width'),
    this.display_height = this._dimension('display', 'height'),
    this.display_diff = function() { return Math.floor( this.display_width() - this.display_height() ); };
    this.orig_width = this._dimension('orig', 'width'),
    this.orig_height = this._dimension('orig', 'height'),

    /**
     * Setter for  X coordinate. If image is rotated we need to additionaly shift an
     *     image to map image coordinate to the visual position.
     *
     * @param {number} val Coordinate value.
     * @param {boolean} skipCss If true, we only set the value and do not touch the dom.
     */
    this.x = setter(function(val, skipCss) {
            this._x = val;
            if (!skipCss) {
                this._finishAnimation();
                this._img.css("left",this._x + (this._swapDimensions ? this.display_diff() / 2 : 0) + "px");
            }
        },
        function() {
            return this._x;
        });

    /**
     * Setter for  Y coordinate. If image is rotated we need to additionaly shift an
     *     image to map image coordinate to the visual position.
     *
     * @param {number} val Coordinate value.
     * @param {boolean} skipCss If true, we only set the value and do not touch the dom.
     */
    this.y = setter(function(val, skipCss) {
            this._y = val;
            if (!skipCss) {
                this._finishAnimation();
                this._img.css("top",this._y - (this._swapDimensions ? this.display_diff() / 2 : 0) + "px");
            }
        },
       function() {
            return this._y;
       });

    /**
     * Perform image rotation.
     *
     * @param {number} deg Absolute image angle. The method will work with values 0, 90, 180, 270 degrees.
     */
    this.angle = setter(function(deg) {
            var prevSwap = this._swapDimensions;

            this._angle = deg;
            this._swapDimensions = deg % 180 !== 0;

            if (prevSwap !== this._swapDimensions) {
                var verticalMod = this._swapDimensions ? -1 : 1;
                this.x(this.x() - verticalMod * this.display_diff() / 2, true);
                this.y(this.y() + verticalMod * this.display_diff() / 2, true);
            };

            var cssVal = 'rotate(' + deg + 'deg)',
                img = this._img;

            jQuery.each(['', '-webkit-', '-moz-', '-o-', '-ms-'], function(i, prefix) {
                img.css(prefix + 'transform', cssVal);
            });

            if (useIeTransforms) {
                jQuery.each(['-ms-', ''], function(i, prefix) {
                    img.css(prefix + 'filter', ieTransforms[deg].filter);
                });

                img.css({
                    marginLeft: ieTransforms[deg].marginLeft * this.display_diff() / 2,
                    marginTop: ieTransforms[deg].marginTop * this.display_diff() / 2
                });
            }
        },
       function() { return this._angle; });

    /**
     * Map point in the container coordinates to the point in image coordinates.
     *     You will get coordinates of point on image with respect to rotation,
     *     but will be set as if image was not rotated.
     *     So, if image was rotated 90 degrees, it's (0,0) point will be on the
     *     top right corner.
     *
     * @param {{x: number, y: number}} point Point in container coordinates.
     * @return  {{x: number, y: number}}
     */
    this.toOriginalCoords = function(point) {
        switch (this.angle()) {
            case 0: return { x: point.x, y: point.y };
            case 90: return { x: point.y, y: this.display_width() - point.x };
            case 180: return { x: this.display_width() - point.x, y: this.display_height() - point.y };
            case 270: return { x: this.display_height() - point.y, y: point.x };
        }
    };

    /**
     * Map point in the image coordinates to the point in container coordinates.
     *     You will get coordinates of point on container with respect to rotation.
     *     Note, if image was rotated 90 degrees, it's (0,0) point will be on the
     *     top right corner.
     *
     * @param {{x: number, y: number}} point Point in container coordinates.
     * @return  {{x: number, y: number}}
     */
    this.toRealCoords = function(point) {
        switch (this.angle()) {
            case 0: return { x: this.x() + point.x, y: this.y() + point.y };
            case 90: return { x: this.x() + this.display_width() - point.y, y: this.y() + point.x};
            case 180: return { x: this.x() + this.display_width() - point.x, y: this.y() + this.display_height() - point.y};
            case 270: return { x: this.x() + point.y, y: this.y() + this.display_height() - point.x};
        }
    };

    /**
     * @return {jQuery} Return image node. this is needed to add event handlers.
     */
    this.object = setter(jQuery.noop,
                           function() { return this._img; });

    /**
     * Change image properties.
     *
     * @param {number} disp_w Display width;
     * @param {number} disp_h Display height;
     * @param {number} x
     * @param {number} y
     * @param {boolean} skip_animation If true, the animation will be skiped despite the
     *     value set in constructor.
     * @param {Function=} complete Call back will be fired when zoom will be complete.
     */
    this.setImageProps = function(disp_w, disp_h, x, y, skip_animation, complete) {
        complete = complete || jQuery.noop;

        this.display_width(disp_w);
        this.display_height(disp_h);
        this.x(x, true);
        this.y(y, true);

        var w = this._swapDimensions ? disp_h : disp_w;
        var h = this._swapDimensions ? disp_w : disp_h;

        var params = {
            width: w,
            height: h,
            top: y - (this._swapDimensions ? this.display_diff() / 2 : 0) + "px",
            left: x + (this._swapDimensions ? this.display_diff() / 2 : 0) + "px"
        };

        if (useIeTransforms) {
            jQuery.extend(params, {
                marginLeft: ieTransforms[this.angle()].marginLeft * this.display_diff() / 2,
                marginTop: ieTransforms[this.angle()].marginTop * this.display_diff() / 2
            });
        }

        var swapDims = this._swapDimensions,
            img = this._img;

        //here we come: another IE oddness. If image is rotated 90 degrees with a filter, than
        //width and height getters return real width and height of rotated image. The bad news
        //is that to set height you need to set a width and vice versa. Fuck IE.
        //So, in this case we have to animate width and height manually.
        if(useIeTransforms && swapDims) {
            var ieh = this._img.width(),
                iew = this._img.height(),
                iedh = params.height - ieh;
                iedw = params.width - iew;

            delete params.width;
            delete params.height;
        }

        if (this._do_anim && !skip_animation) {
            this._img.stop(true)
                .animate(params, {
                    duration: 200,
                    complete: complete,
                    step: function(now, fx) {
                        if(useIeTransforms && swapDims && (fx.prop === 'top')) {
                            var percent = (now - fx.start) / (fx.end - fx.start);

                            img.height(ieh + iedh * percent);
                            img.width(iew + iedw * percent);
                            img.css('top', now);
                        }
                    }
                });
        } else {
            this._img.css(params);
            setTimeout(complete, 0); //both if branches should behave equally.
        }
    };

    //if we set image coordinates we need to be sure that no animation is active atm
    this._finishAnimation = function() {
      this._img.stop(true, true);
    };

}).apply($.ui.iviewer.ImageObject.prototype);



var util = {
    scaleValue: function(value, toZoom)
    {
        return value * toZoom / 100;
    },

    descaleValue: function(value, fromZoom)
    {
        return value * 100 / fromZoom;
    }
};

 } )( jQuery, undefined );




ELMA.PrintManager = function (options) {
    var that = begetObject(ELMA.PrintManager);
    var windowObj = options.window ? options.window : window;
    var print = windowObj.print;
    var frameSelector = options.frame;
    var frame;
    var frames;
    var progress;
    that.CtrlPPrevent = function (event) {
        if (event.ctrlKey && event.keyCode == 80) {
            event.keyCode = 0;
            windowObj.print();            
            return false;
        }
    };
    that.RewritePrint = function (win) {
        win.print = function () {
            windowObj.focus();
            windowObj.print();
        }
        if (win.document.attachEvent) {
            win.document.attachEvent("onkeydown", that.CtrlPPrevent);
        }
        else {
            $(win).keydown(that.CtrlPPrevent);
        }        
    };
	
    that.InitPrintFunc = function () {
        frame = $(windowObj.document).find(frameSelector);
        frames = $(windowObj.document).find('frame');
        if (frames.length > 0) {
            frames.each(function(i, a) {
                that.RewritePrint(a.contentWindow);
            });
            frame.bind("load", function() {
                that.RewritePrint(frame[0].contentWindow);
            });
        } else {
            that.RewritePrint($(windowObj.document)[0]);
        }
        
        windowObj.print = function () {
            if (progress) {
                console.warn('Ignored window.print() because of a pending print job.');
                return;
            }
            try {
                that.dispatchEvent('beforeprint');
            } finally {
                progress = true;
                var printebleObject = frames.length > 0 ? frame[0].contentWindow.document : $(windowObj.document)[0];
                var result = printebleObject.execCommand('print', false, null);
                if (!result)
                    print.call(printebleObject.contentWindow);
                setTimeout(that.abort, 20);
            }
        };
        windowObj.print.asynch = true;
    };

    that.dispatchEvent = function(eventType) {
        var event = windowObj.document.createEvent('CustomEvent');
        event.initCustomEvent(eventType, false, false, 'custom');
        windowObj.dispatchEvent(event);
    };

    that.abort = function() {
        if (progress) {
            progress = false;
            that.dispatchEvent('afterprint');
        }
    };

    return that;
}

elma.PrintManager = function () { }

elma.PrintManager.Manager = function () {
    var controls = [];
    return {
        create: function (options) {
            var printManager = new ELMA.PrintManager(options);
            printManager.InitPrintFunc();
            return elma.PrintManager.Manager.register(options.postfix, printManager);
        },
        register: function (el, control) {
            controls[el] = control;
            return elma.PrintManager.Manager.get(el);
        },
        get: function (el) {
            return controls[el] || null;
        }
    };
}();


elma.InitTranslationAttribute = function (containerId, name) {
    var regexp = new RegExp('\\|SRString\\|((.|\n|\r)*?)\\|/SRString\\|', 'g');
    var regExpStart = new RegExp('\\|SRString\\|', 'g');
    var regExpClose = new RegExp('\\|/SRString\\|', 'g');
    var selector = containerId ? $('#' + containerId).find('*[' + name + ']') :
        $('*[' + name + ']');
    var text = 'Translate';
    var isTootipHeader = name.toUpperCase().indexOf('TOOLTIPHEADER') >= 0;
    var isTooltip = isTootipHeader || name.toUpperCase().indexOf('TOOLTIPTEXT') >= 0 || name.toUpperCase().indexOf('TITLE') >= 0 || name.toUpperCase().indexOf('ALT') >= 0;
    if (isTootipHeader) {
        text = 'Translate tooltip header';
    }
    else if (isTooltip) {
        text = 'Translate tooltip';
    } else if (name.toUpperCase().indexOf('VALUE') >= 0)
        text = 'Translate input';
    selector.each(function (i, a) {
        var attrVal = $(a).attr(name);
        var key = '';
        var current = '';
        var target = '';
        var formatcurrent = '';
        var formattarget = '';
        var literals = attrVal.match(regexp);
        if (literals == null)
            return;
        var resources = new Array();
        $.each(literals, function(j, l) {
            var val = l;
            if (val.match(regExpStart) || $(a).attr('localizationkey-' + name)) {
                if (val.match(regExpStart)) {
                    val = val.replace(regExpStart, '');
                    val = val.replace(regExpClose, '');
                    var arr = val.split('_____');
                    key = elma.processEncodeTranslateAttribute(arr[0]);
                    current = elma.processEncodeTranslateAttribute(arr[1]);
                    target = elma.processEncodeTranslateAttribute(arr[2]);
                    formatcurrent = elma.processEncodeTranslateAttribute(arr[3] ? arr[3] : '');
                    formattarget = elma.processEncodeTranslateAttribute(arr[4] ? arr[4] : '');
                    $(a).attr(name, (arr[2] ? arr[2] : (arr[1] ? arr[1] : arr[0])));
                    $(a).attr('localizationkey-' + name + (j>0 ?'-' + j : ''), key);
                    $(a).attr('localizationcurrent-' + name + (j > 0 ? '-' + j : ''), current);
                    $(a).attr('localizationtarget-' + name + (j > 0 ? '-' + j : ''), target);
                    $(a).attr('localizationformatcurrent-' + name + (j > 0 ? '-' + j : ''), formatcurrent);
                    $(a).attr('localizationformattarget-' + name + (j > 0 ? '-' + j : ''), formattarget);
                } else if ($(a).attr('localizationkey-' + name + (j > 0 ? '-' + j : ''))) {
                    key = $(a).attr('localizationkey-' + name + (j > 0 ? '-' + j : ''));
                    current = $(a).attr('localizationcurrent-' + name + (j > 0 ? '-' + j : ''));
                    target = $(a).attr('localizationtarget-' + name + (j > 0 ? '-' + j : ''));
                    formatcurrent = $(a).attr('localizationformatcurrent-' + name + (j > 0 ? '-' + j : ''));
                    formattarget = $(a).attr('localizationformattarget-' + name + (j > 0 ? '-' + j : ''));
                }
                if (key) {
                    var addContent = isTooltip || isTootipHeader ? '<div style="display:block;margin-bottom:5px;" class="' + (target ? "translated" : "needtranslate") + '">' + elma.processDecodeTranslateAttribute(target ? target : (current ? current : key)) + '</div>' : '';
                    key = elma.processEncodeForJavascript(key);
                    current = elma.processEncodeForJavascript(current);
                    target = elma.processEncodeForJavascript(target);
                    formatcurrent = elma.processEncodeForJavascript(formatcurrent);
                    formattarget = elma.processEncodeForJavascript(formattarget);
                    /*if (current && current.indexOf('javascript') >= 0) {
                        debugger;
                    }*/
                    var postContent = '';
                    if (isTootipHeader) {
                        var keytooltip = $(a).attr('localizationkey-tooltiptext');
                        var currenttooltip = $(a).attr('localizationcurrent-tooltiptext');
                        var targettooltip = $(a).attr('localizationtarget-tooltiptext');
                        var formatcurrenttooltip = $(a).attr('localizationformatcurrent-tooltiptext');
                        var formattargettooltip = $(a).attr('localizationformattarget-tooltiptext');
                        addContent = '<b>' + addContent + '</b>' + '<div style="display:block;margin-bottom:5px;" class="' + (targettooltip ? "translated" : "needtranslate") + '">' + elma.processDecodeTranslateAttribute(targettooltip ? targettooltip : (currenttooltip ? currenttooltip : keytooltip)) + '</div>';
                        postContent = '<input class=\"confirm t-button\" type=\"button\" onclick=\"elma.refreshTranslatePopup(\'' + keytooltip + '\',\'' + currenttooltip + '\',\'' + targettooltip + '\',\'' + formatcurrenttooltip + '\',\'' + formattargettooltip + '\');\" value=\"Translate tooltip\" />';
                    }
                    resources.push(addContent + '<span style=\"padding-right:5px;\"><input class=\"confirm t-button\" type=\"button\" onclick=\"elma.refreshTranslatePopup(\'' + key + '\',\'' + current + '\',\'' + target + '\',\'' + formatcurrent + '\',\'' + formattarget + '\');\" value=\"' + text + ' \" /></span>' + postContent);
                }
            }
        });
        if (resources.length == 0)
            return;
        var content = '';
        $.each(resources, function(k, r) {
            content += '<div style=\"height:10px;\"></div>' + r;
        });
        if (content) {
            $(a).qtip({
                content: {
                    text: content,
                    button: true
                },
                hide: {
                    fixed: true,
                    delay: 300
                },
                position: {
                    my: 'bottom left',
                    at: 'center right'
                }
            });
        }
    });
}

elma.processEncodeForJavascript = function (text) {
    if (text) {
        text = text.replace('\\', '\\\\').replace(/\"/g, '&quot;').replace(/\n/g, '\\n').replace(/\t/g, '\\t').replace(/\r/g, '\\r');
    }
    return text;
}

elma.processEncodeTranslateAttribute = function (text) {
    if (text) {
        text = elma.htmlEncode(text).replace(/\"/g, '&quot;').replace(/\'/g, '\\\'').replace(/\t/g, '\\t').replace(/&nbsp;/, ' ');
    }
    return text;
}

elma.processDecodeTranslateAttribute = function (text) {
    if (text) {
        text = elma.htmlDecode(text);
    }
    return text;
}

elma.ExtractTargetString = function (text) {
    var regexp = new RegExp('\\|SRString\\|((.|\n|\r)*?)\\|/SRString\\|', 'g');
    var regexpdelstart = new RegExp('\\|SRString\\|', 'g');
    var regexpdelclose = new RegExp('\\|/SRString\\|', 'g');
    var res = text.replace(regexp, function (str) {
        str = str.replace(regexpdelstart, '');
        str = str.replace(regexpdelclose, '');
        var arr = str.split('_____');
        return arr[2] ? arr[2] : (arr[1] ? arr[1] : arr[0]);
    });
    return res;
}

elma.ProcessTranslationHtmlElement = function (a, text, valToDisplay) {
    var regexp = new RegExp('\\|SRString\\|((.|\n|\r)*?)\\|/SRString\\|', 'g');
    var regexpdelstart = new RegExp('\\|SRString\\|', 'g');
    var regexpdelclose = new RegExp('\\|/SRString\\|', 'g');
    var content = text ? text : $(a).html();
        //$(a)[0].childNodes[0].nodeValue; //$(a).html();
    var newContent = content.replace(regexp, function (str) {
        str = str.replace(regexpdelstart, '');
        str = str.replace(regexpdelclose, '');
        var arr = str.split('_____');
        return '<span class="' + (arr[2] ? "translated" : "needtranslate") + '" localizationkey="' + elma.processEncodeTranslateAttribute(arr[0]) + '" localizationcurrent="' + elma.processEncodeTranslateAttribute(arr[1]) + '" localizationtarget="' + elma.processEncodeTranslateAttribute(arr[2]) + '" localizationformatcurrent="' + elma.processEncodeTranslateAttribute(arr[3] ? arr[3] : '') + '" localizationformattarget="' + elma.processEncodeTranslateAttribute(arr[4] ? arr[4] : '') + '">' + (valToDisplay ? valToDisplay : (arr[2] ? arr[2] : (arr[1] ? arr[1] : arr[0]))) + '</span>';
    });
    if (!text) {
        $(a).html(newContent);
        //$(a)[0].childNodes[0].nodeValue = newContent;
    }
    return newContent;
}

elma.processContainerElement = function (containerId, tag) {
    var tagSelector = containerId ? $('#' + containerId).find(tag).contents().filter(function () { return this.textContent.indexOf('|SRString|') >= 0 && this.nodeType == 3; }) :
        $(tag).contents().filter(function () { return this.textContent.indexOf('|SRString|') >= 0 && this.nodeType == 3; });
    tagSelector.each(function (i, a) {
        if (a.textContent) {
            var onlystart = a.textContent.indexOf('|SRString|') >= 0 && this.textContent.indexOf('|/SRString|') < 0;
            if (onlystart) {
                var parentElem = $(a.parentElement);
                var content = parentElem.html();
                var newContent = $(elma.ProcessTranslationHtmlElement(null, content));
                parentElem.empty();
                parentElem.append(newContent);
            } else {
                var newElem = $(elma.ProcessTranslationHtmlElement(null, a.textContent));
                a.textContent = '';
                if (a.nextSibling) {
                    $(a.nextSibling).before(newElem);
                } else if (a.previousSibling) {
                    $(a.previousSibling).after(newElem);
                } else {
                    $(a.parentElement).prepend(newElem);
                }
            }
        }
    });
}

elma.InitTranslationContainer = function (containerId) {
    if (typeof JsLocalizator.TranslateEnabled != 'function' || !JsLocalizator.TranslateEnabled())
        return;
    elma.InitTranslationAttribute(containerId, 'alt');
    elma.InitTranslationAttribute(containerId, 'title');
    elma.InitTranslationAttribute(containerId, 'text');
    elma.InitTranslationAttribute(containerId, 'oldtitle');
    elma.InitTranslationAttribute(containerId, 'tooltiptext');
    elma.InitTranslationAttribute(containerId, 'tooltipheader');
    elma.InitTranslationAttribute(containerId, 'left-menu-tooltip');
    elma.InitTranslationAttribute(containerId, 'value');
    elma.InitTranslationAttribute(containerId, 'oldvalue');
    elma.InitTranslationAttribute(containerId, 'placeholder');
    var bSelector = containerId ? $('#' + containerId).find("b:contains('SRString')") : $("b:contains('SRString')");
    bSelector.each(function (i, a) {
        elma.ProcessTranslationHtmlElement(a);
    });
    var aSelector = containerId ? $('#' + containerId).find("a:contains('SRString'), i:contains('SRString')") : $("a:contains('SRString'), i:contains('SRString')");
    aSelector.each(function (i, a) {
        elma.ProcessTranslationHtmlElement(a);
    });
    var hSelector = containerId ? $('#' + containerId).find("h1:contains('SRString'),h2:contains('SRString'),h3:contains('SRString'),h4:contains('SRString')") : $("h1:contains('SRString'),h2:contains('SRString'),h3:contains('SRString'),h4:contains('SRString')");
    hSelector.each(function (i, a) {
        elma.ProcessTranslationHtmlElement(a);
    });
    elma.processContainerElement(containerId, 'label');
    elma.processContainerElement(containerId, 'span');
    elma.processContainerElement(containerId, 'div');
    elma.processContainerElement(containerId, 'td');
    elma.processContainerElement(containerId, 'th');
    elma.processContainerElement(containerId, 'li');
    elma.processContainerElement(containerId, 'p');
    $("title").text($('.page_header_title').text());
    var locSpans = containerId ? $('#' + containerId).find('span[localizationkey]') : $("span[localizationkey]");
    locSpans.each(function (i, a) {
        var key = $(a).attr('localizationkey');
        var current = $(a).attr('localizationcurrent');
        var target = $(a).attr('localizationtarget');
        var formatcurrent = $(a).attr('localizationformatcurrent');
        var formattarget = $(a).attr('localizationformattarget');
        key = elma.processEncodeForJavascript(key);
        current = elma.processEncodeForJavascript(current);
        target = elma.processEncodeForJavascript(target);
        formatcurrent = elma.processEncodeForJavascript(formatcurrent);
        formattarget = elma.processEncodeForJavascript(formattarget);
        $(a).qtip({
            content: {
                text: '<input class=\"confirm t-button\" type=\"button\" onclick=\"elma.refreshTranslatePopup(\'' + key + '\',\'' + current + '\',\'' + target + '\',\'' + formatcurrent + '\',\'' + formattarget + '\');\" value=\"Translate\" />',
                button: true
            },
            hide: {
                fixed: true,
                delay: 300
            }
        });
    });
}

elma.refreshTranslatePopup = function (key, current, target, formatcurrent, formattarget) {
    var postData = {
        key: key,
        current: current,
        target: target,
        formatcurrent: formatcurrent,
        formattarget: formattarget
    };
    refreshPopup('TranslateEditPopup', '/SDK.Action/Translate/EnterTranslation', postData);
}

elma.FormatResource = function (originformattext, formattext, templatetext) {
    var regExp = new RegExp('({)(\\d*?)(})', 'g');
    var arrStr = originformattext.replace(regExp, '&&&&');
    var arr = arrStr.split('&&&&');
    var newText = templatetext;
    for (var i = 0; i < arr.length; i++) {
        if (!arr[i] || arr[i] == '')
            continue;
        newText = newText.replace(arr[i], '&&&&');
    }
    newText = newText.replace('&&&&', '');
    var paramArr = newText.split('&&&&');
    return $.validator.format(formattext, paramArr);
}

elma.InitTranslation = function (containerId) {
    setTimeout(function () {
        elma.InitTranslationContainer(containerId ? containerId : null);
    }, 300);
}

$(document).ready(function () {
    if (typeof JsLocalizator.TranslateEnabled == 'function' && JsLocalizator.TranslateEnabled()) {
        $('#PanelPageTitle').html($('title').html());
    }
    elma.InitTranslation();
});


/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 1.0.2
 *
 * Copyright 2015 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */
(function(){"use strict";var t=this,i=t.Chart,e=function(t){this.canvas=t.canvas,this.ctx=t;var i=function(t,i){return t["offset"+i]?t["offset"+i]:document.defaultView.getComputedStyle(t).getPropertyValue(i)},e=this.width=i(t.canvas,"Width"),n=this.height=i(t.canvas,"Height");t.canvas.width=e,t.canvas.height=n;var e=this.width=t.canvas.width,n=this.height=t.canvas.height;return this.aspectRatio=this.width/this.height,s.retinaScale(this),this};e.defaults={global:{animation:!0,animationSteps:60,animationEasing:"easeOutQuart",showScale:!0,scaleOverride:!1,scaleSteps:null,scaleStepWidth:null,scaleStartValue:null,scaleLineColor:"rgba(0,0,0,.1)",scaleLineWidth:1,scaleShowLabels:!0,scaleLabel:"<%=value%>",scaleIntegersOnly:!0,scaleBeginAtZero:!1,scaleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",scaleFontSize:12,scaleFontStyle:"normal",scaleFontColor:"#666",responsive:!1,maintainAspectRatio:!0,showTooltips:!0,customTooltips:!1,tooltipEvents:["mousemove","touchstart","touchmove","mouseout"],tooltipFillColor:"rgba(0,0,0,0.8)",tooltipFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipFontSize:14,tooltipFontStyle:"normal",tooltipFontColor:"#fff",tooltipTitleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipTitleFontSize:14,tooltipTitleFontStyle:"bold",tooltipTitleFontColor:"#fff",tooltipYPadding:6,tooltipXPadding:6,tooltipCaretSize:8,tooltipCornerRadius:6,tooltipXOffset:10,tooltipTemplate:"<%if (label){%><%=label%>: <%}%><%= value %>",multiTooltipTemplate:"<%= value %>",multiTooltipKeyBackground:"#fff",onAnimationProgress:function(){},onAnimationComplete:function(){}}},e.types={};var s=e.helpers={},n=s.each=function(t,i,e){var s=Array.prototype.slice.call(arguments,3);if(t)if(t.length===+t.length){var n;for(n=0;n<t.length;n++)i.apply(e,[t[n],n].concat(s))}else for(var o in t)i.apply(e,[t[o],o].concat(s))},o=s.clone=function(t){var i={};return n(t,function(e,s){t.hasOwnProperty(s)&&(i[s]=e)}),i},a=s.extend=function(t){return n(Array.prototype.slice.call(arguments,1),function(i){n(i,function(e,s){i.hasOwnProperty(s)&&(t[s]=e)})}),t},h=s.merge=function(){var t=Array.prototype.slice.call(arguments,0);return t.unshift({}),a.apply(null,t)},l=s.indexOf=function(t,i){if(Array.prototype.indexOf)return t.indexOf(i);for(var e=0;e<t.length;e++)if(t[e]===i)return e;return-1},r=(s.where=function(t,i){var e=[];return s.each(t,function(t){i(t)&&e.push(t)}),e},s.findNextWhere=function(t,i,e){e||(e=-1);for(var s=e+1;s<t.length;s++){var n=t[s];if(i(n))return n}},s.findPreviousWhere=function(t,i,e){e||(e=t.length);for(var s=e-1;s>=0;s--){var n=t[s];if(i(n))return n}},s.inherits=function(t){var i=this,e=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return i.apply(this,arguments)},s=function(){this.constructor=e};return s.prototype=i.prototype,e.prototype=new s,e.extend=r,t&&a(e.prototype,t),e.__super__=i.prototype,e}),c=s.noop=function(){},u=s.uid=function(){var t=0;return function(){return"chart-"+t++}}(),d=s.warn=function(t){window.console&&"function"==typeof window.console.warn&&console.warn(t)},p=s.amd="function"==typeof define&&define.amd,f=s.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},g=s.max=function(t){return Math.max.apply(Math,t)},m=s.min=function(t){return Math.min.apply(Math,t)},v=(s.cap=function(t,i,e){if(f(i)){if(t>i)return i}else if(f(e)&&e>t)return e;return t},s.getDecimalPlaces=function(t){return t%1!==0&&f(t)?t.toString().split(".")[1].length:0}),S=s.radians=function(t){return t*(Math.PI/180)},x=(s.getAngleFromPoint=function(t,i){var e=i.x-t.x,s=i.y-t.y,n=Math.sqrt(e*e+s*s),o=2*Math.PI+Math.atan2(s,e);return 0>e&&0>s&&(o+=2*Math.PI),{angle:o,distance:n}},s.aliasPixel=function(t){return t%2===0?0:.5}),y=(s.splineCurve=function(t,i,e,s){var n=Math.sqrt(Math.pow(i.x-t.x,2)+Math.pow(i.y-t.y,2)),o=Math.sqrt(Math.pow(e.x-i.x,2)+Math.pow(e.y-i.y,2)),a=s*n/(n+o),h=s*o/(n+o);return{inner:{x:i.x-a*(e.x-t.x),y:i.y-a*(e.y-t.y)},outer:{x:i.x+h*(e.x-t.x),y:i.y+h*(e.y-t.y)}}},s.calculateOrderOfMagnitude=function(t){return Math.floor(Math.log(t)/Math.LN10)}),C=(s.calculateScaleRange=function(t,i,e,s,n){var o=2,a=Math.floor(i/(1.5*e)),h=o>=a,l=g(t),r=m(t);l===r&&(l+=.5,r>=.5&&!s?r-=.5:l+=.5);for(var c=Math.abs(l-r),u=y(c),d=Math.ceil(l/(1*Math.pow(10,u)))*Math.pow(10,u),p=s?0:Math.floor(r/(1*Math.pow(10,u)))*Math.pow(10,u),f=d-p,v=Math.pow(10,u),S=Math.round(f/v);(S>a||a>2*S)&&!h;)if(S>a)v*=2,S=Math.round(f/v),S%1!==0&&(h=!0);else if(n&&u>=0){if(v/2%1!==0)break;v/=2,S=Math.round(f/v)}else v/=2,S=Math.round(f/v);return h&&(S=o,v=f/S),{steps:S,stepValue:v,min:p,max:p+S*v}},s.template=function(t,i){function e(t,i){var e=/\W/.test(t)?new Function("obj","var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('"+t.replace(/[\r\t\n]/g," ").split("<%").join("	").replace(/((^|%>)[^\t]*)'/g,"$1\r").replace(/\t=(.*?)%>/g,"',$1,'").split("	").join("');").split("%>").join("p.push('").split("\r").join("\\'")+"');}return p.join('');"):s[t]=s[t];return i?e(i):e}if(t instanceof Function)return t(i);var s={};return e(t,i)}),w=(s.generateLabels=function(t,i,e,s){var o=new Array(i);return labelTemplateString&&n(o,function(i,n){o[n]=C(t,{value:e+s*(n+1)})}),o},s.easingEffects={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-1*t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-0.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return 1*((t=t/1-1)*t*t+1)},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-1*((t=t/1-1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-0.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return 1*(t/=1)*t*t*t*t},easeOutQuint:function(t){return 1*((t=t/1-1)*t*t*t*t+1)},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return-1*Math.cos(t/1*(Math.PI/2))+1},easeOutSine:function(t){return 1*Math.sin(t/1*(Math.PI/2))},easeInOutSine:function(t){return-0.5*(Math.cos(Math.PI*t/1)-1)},easeInExpo:function(t){return 0===t?1:1*Math.pow(2,10*(t/1-1))},easeOutExpo:function(t){return 1===t?1:1*(-Math.pow(2,-10*t/1)+1)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return t>=1?t:-1*(Math.sqrt(1-(t/=1)*t)-1)},easeOutCirc:function(t){return 1*Math.sqrt(1-(t=t/1-1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-0.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),-(s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)))},easeOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),s*Math.pow(2,-10*t)*Math.sin(2*(1*t-i)*Math.PI/e)+1)},easeInOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:2==(t/=.5)?1:(e||(e=.3*1.5),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),1>t?-.5*s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e):s*Math.pow(2,-10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)*.5+1)},easeInBack:function(t){var i=1.70158;return 1*(t/=1)*t*((i+1)*t-i)},easeOutBack:function(t){var i=1.70158;return 1*((t=t/1-1)*t*((i+1)*t+i)+1)},easeInOutBack:function(t){var i=1.70158;return(t/=.5)<1?.5*t*t*(((i*=1.525)+1)*t-i):.5*((t-=2)*t*(((i*=1.525)+1)*t+i)+2)},easeInBounce:function(t){return 1-w.easeOutBounce(1-t)},easeOutBounce:function(t){return(t/=1)<1/2.75?7.5625*t*t:2/2.75>t?1*(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?1*(7.5625*(t-=2.25/2.75)*t+.9375):1*(7.5625*(t-=2.625/2.75)*t+.984375)},easeInOutBounce:function(t){return.5>t?.5*w.easeInBounce(2*t):.5*w.easeOutBounce(2*t-1)+.5}}),b=s.requestAnimFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)}}(),P=s.cancelAnimFrame=function(){return window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame||function(t){return window.clearTimeout(t,1e3/60)}}(),L=(s.animationLoop=function(t,i,e,s,n,o){var a=0,h=w[e]||w.linear,l=function(){a++;var e=a/i,r=h(e);t.call(o,r,e,a),s.call(o,r,e),i>a?o.animationFrame=b(l):n.apply(o)};b(l)},s.getRelativePosition=function(t){var i,e,s=t.originalEvent||t,n=t.currentTarget||t.srcElement,o=n.getBoundingClientRect();return s.touches?(i=s.touches[0].clientX-o.left,e=s.touches[0].clientY-o.top):(i=s.clientX-o.left,e=s.clientY-o.top),{x:i,y:e}},s.addEvent=function(t,i,e){t.addEventListener?t.addEventListener(i,e):t.attachEvent?t.attachEvent("on"+i,e):t["on"+i]=e}),k=s.removeEvent=function(t,i,e){t.removeEventListener?t.removeEventListener(i,e,!1):t.detachEvent?t.detachEvent("on"+i,e):t["on"+i]=c},F=(s.bindEvents=function(t,i,e){t.events||(t.events={}),n(i,function(i){t.events[i]=function(){e.apply(t,arguments)},L(t.chart.canvas,i,t.events[i])})},s.unbindEvents=function(t,i){n(i,function(i,e){k(t.chart.canvas,e,i)})}),R=s.getMaximumWidth=function(t){var i=t.parentNode;return i.clientWidth},T=s.getMaximumHeight=function(t){var i=t.parentNode;return i.clientHeight},A=(s.getMaximumSize=s.getMaximumWidth,s.retinaScale=function(t){var i=t.ctx,e=t.canvas.width,s=t.canvas.height;window.devicePixelRatio&&(i.canvas.style.width=e+"px",i.canvas.style.height=s+"px",i.canvas.height=s*window.devicePixelRatio,i.canvas.width=e*window.devicePixelRatio,i.scale(window.devicePixelRatio,window.devicePixelRatio))}),M=s.clear=function(t){t.ctx.clearRect(0,0,t.width,t.height)},W=s.fontString=function(t,i,e){return i+" "+t+"px "+e},z=s.longestText=function(t,i,e){t.font=i;var s=0;return n(e,function(i){var e=t.measureText(i).width;s=e>s?e:s}),s},B=s.drawRoundedRectangle=function(t,i,e,s,n,o){t.beginPath(),t.moveTo(i+o,e),t.lineTo(i+s-o,e),t.quadraticCurveTo(i+s,e,i+s,e+o),t.lineTo(i+s,e+n-o),t.quadraticCurveTo(i+s,e+n,i+s-o,e+n),t.lineTo(i+o,e+n),t.quadraticCurveTo(i,e+n,i,e+n-o),t.lineTo(i,e+o),t.quadraticCurveTo(i,e,i+o,e),t.closePath()};e.instances={},e.Type=function(t,i,s){this.options=i,this.chart=s,this.id=u(),e.instances[this.id]=this,i.responsive&&this.resize(),this.initialize.call(this,t)},a(e.Type.prototype,{initialize:function(){return this},clear:function(){return M(this.chart),this},stop:function(){return P(this.animationFrame),this},resize:function(t){this.stop();var i=this.chart.canvas,e=R(this.chart.canvas),s=this.options.maintainAspectRatio?e/this.chart.aspectRatio:T(this.chart.canvas);return i.width=this.chart.width=e,i.height=this.chart.height=s,A(this.chart),"function"==typeof t&&t.apply(this,Array.prototype.slice.call(arguments,1)),this},reflow:c,render:function(t){return t&&this.reflow(),this.options.animation&&!t?s.animationLoop(this.draw,this.options.animationSteps,this.options.animationEasing,this.options.onAnimationProgress,this.options.onAnimationComplete,this):(this.draw(),this.options.onAnimationComplete.call(this)),this},generateLegend:function(){return C(this.options.legendTemplate,this)},destroy:function(){this.clear(),F(this,this.events);var t=this.chart.canvas;t.width=this.chart.width,t.height=this.chart.height,t.style.removeProperty?(t.style.removeProperty("width"),t.style.removeProperty("height")):(t.style.removeAttribute("width"),t.style.removeAttribute("height")),delete e.instances[this.id]},showTooltip:function(t,i){"undefined"==typeof this.activeElements&&(this.activeElements=[]);var o=function(t){var i=!1;return t.length!==this.activeElements.length?i=!0:(n(t,function(t,e){t!==this.activeElements[e]&&(i=!0)},this),i)}.call(this,t);if(o||i){if(this.activeElements=t,this.draw(),this.options.customTooltips&&this.options.customTooltips(!1),t.length>0)if(this.datasets&&this.datasets.length>1){for(var a,h,r=this.datasets.length-1;r>=0&&(a=this.datasets[r].points||this.datasets[r].bars||this.datasets[r].segments,h=l(a,t[0]),-1===h);r--);var c=[],u=[],d=function(){var t,i,e,n,o,a=[],l=[],r=[];return s.each(this.datasets,function(i){t=i.points||i.bars||i.segments,t[h]&&t[h].hasValue()&&a.push(t[h])}),s.each(a,function(t){l.push(t.x),r.push(t.y),c.push(s.template(this.options.multiTooltipTemplate,t)),u.push({fill:t._saved.fillColor||t.fillColor,stroke:t._saved.strokeColor||t.strokeColor})},this),o=m(r),e=g(r),n=m(l),i=g(l),{x:n>this.chart.width/2?n:i,y:(o+e)/2}}.call(this,h);new e.MultiTooltip({x:d.x,y:d.y,xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,xOffset:this.options.tooltipXOffset,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,titleTextColor:this.options.tooltipTitleFontColor,titleFontFamily:this.options.tooltipTitleFontFamily,titleFontStyle:this.options.tooltipTitleFontStyle,titleFontSize:this.options.tooltipTitleFontSize,cornerRadius:this.options.tooltipCornerRadius,labels:c,legendColors:u,legendColorBackground:this.options.multiTooltipKeyBackground,title:t[0].label,chart:this.chart,ctx:this.chart.ctx,custom:this.options.customTooltips}).draw()}else n(t,function(t){var i=t.tooltipPosition();new e.Tooltip({x:Math.round(i.x),y:Math.round(i.y),xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,caretHeight:this.options.tooltipCaretSize,cornerRadius:this.options.tooltipCornerRadius,text:C(this.options.tooltipTemplate,t),chart:this.chart,custom:this.options.customTooltips}).draw()},this);return this}},toBase64Image:function(){return this.chart.canvas.toDataURL.apply(this.chart.canvas,arguments)}}),e.Type.extend=function(t){var i=this,s=function(){return i.apply(this,arguments)};if(s.prototype=o(i.prototype),a(s.prototype,t),s.extend=e.Type.extend,t.name||i.prototype.name){var n=t.name||i.prototype.name,l=e.defaults[i.prototype.name]?o(e.defaults[i.prototype.name]):{};e.defaults[n]=a(l,t.defaults),e.types[n]=s,e.prototype[n]=function(t,i){var o=h(e.defaults.global,e.defaults[n],i||{});return new s(t,o,this)}}else d("Name not provided for this chart, so it hasn't been registered");return i},e.Element=function(t){a(this,t),this.initialize.apply(this,arguments),this.save()},a(e.Element.prototype,{initialize:function(){},restore:function(t){return t?n(t,function(t){this[t]=this._saved[t]},this):a(this,this._saved),this},save:function(){return this._saved=o(this),delete this._saved._saved,this},update:function(t){return n(t,function(t,i){this._saved[i]=this[i],this[i]=t},this),this},transition:function(t,i){return n(t,function(t,e){this[e]=(t-this._saved[e])*i+this._saved[e]},this),this},tooltipPosition:function(){return{x:this.x,y:this.y}},hasValue:function(){return f(this.value)}}),e.Element.extend=r,e.Point=e.Element.extend({display:!0,inRange:function(t,i){var e=this.hitDetectionRadius+this.radius;return Math.pow(t-this.x,2)+Math.pow(i-this.y,2)<Math.pow(e,2)},draw:function(){if(this.display){var t=this.ctx;t.beginPath(),t.arc(this.x,this.y,this.radius,0,2*Math.PI),t.closePath(),t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.fillStyle=this.fillColor,t.fill(),t.stroke()}}}),e.Arc=e.Element.extend({inRange:function(t,i){var e=s.getAngleFromPoint(this,{x:t,y:i}),n=e.angle>=this.startAngle&&e.angle<=this.endAngle,o=e.distance>=this.innerRadius&&e.distance<=this.outerRadius;return n&&o},tooltipPosition:function(){var t=this.startAngle+(this.endAngle-this.startAngle)/2,i=(this.outerRadius-this.innerRadius)/2+this.innerRadius;return{x:this.x+Math.cos(t)*i,y:this.y+Math.sin(t)*i}},draw:function(t){var i=this.ctx;i.beginPath(),i.arc(this.x,this.y,this.outerRadius,this.startAngle,this.endAngle),i.arc(this.x,this.y,this.innerRadius,this.endAngle,this.startAngle,!0),i.closePath(),i.strokeStyle=this.strokeColor,i.lineWidth=this.strokeWidth,i.fillStyle=this.fillColor,i.fill(),i.lineJoin="bevel",this.showStroke&&i.stroke()}}),e.Rectangle=e.Element.extend({draw:function(){var t=this.ctx,i=this.width/2,e=this.x-i,s=this.x+i,n=this.base-(this.base-this.y),o=this.strokeWidth/2;this.showStroke&&(e+=o,s-=o,n+=o),t.beginPath(),t.fillStyle=this.fillColor,t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.moveTo(e,this.base),t.lineTo(e,n),t.lineTo(s,n),t.lineTo(s,this.base),t.fill(),this.showStroke&&t.stroke()},height:function(){return this.base-this.y},inRange:function(t,i){return t>=this.x-this.width/2&&t<=this.x+this.width/2&&i>=this.y&&i<=this.base}}),e.Tooltip=e.Element.extend({draw:function(){var t=this.chart.ctx;t.font=W(this.fontSize,this.fontStyle,this.fontFamily),this.xAlign="center",this.yAlign="above";var i=this.caretPadding=2,e=t.measureText(this.text).width+2*this.xPadding,s=this.fontSize+2*this.yPadding,n=s+this.caretHeight+i;this.x+e/2>this.chart.width?this.xAlign="left":this.x-e/2<0&&(this.xAlign="right"),this.y-n<0&&(this.yAlign="below");var o=this.x-e/2,a=this.y-n;if(t.fillStyle=this.fillColor,this.custom)this.custom(this);else{switch(this.yAlign){case"above":t.beginPath(),t.moveTo(this.x,this.y-i),t.lineTo(this.x+this.caretHeight,this.y-(i+this.caretHeight)),t.lineTo(this.x-this.caretHeight,this.y-(i+this.caretHeight)),t.closePath(),t.fill();break;case"below":a=this.y+i+this.caretHeight,t.beginPath(),t.moveTo(this.x,this.y+i),t.lineTo(this.x+this.caretHeight,this.y+i+this.caretHeight),t.lineTo(this.x-this.caretHeight,this.y+i+this.caretHeight),t.closePath(),t.fill()}switch(this.xAlign){case"left":o=this.x-e+(this.cornerRadius+this.caretHeight);break;case"right":o=this.x-(this.cornerRadius+this.caretHeight)}B(t,o,a,e,s,this.cornerRadius),t.fill(),t.fillStyle=this.textColor,t.textAlign="center",t.textBaseline="middle",t.fillText(this.text,o+e/2,a+s/2)}}}),e.MultiTooltip=e.Element.extend({initialize:function(){this.font=W(this.fontSize,this.fontStyle,this.fontFamily),this.titleFont=W(this.titleFontSize,this.titleFontStyle,this.titleFontFamily),this.height=this.labels.length*this.fontSize+(this.labels.length-1)*(this.fontSize/2)+2*this.yPadding+1.5*this.titleFontSize,this.ctx.font=this.titleFont;var t=this.ctx.measureText(this.title).width,i=z(this.ctx,this.font,this.labels)+this.fontSize+3,e=g([i,t]);this.width=e+2*this.xPadding;var s=this.height/2;this.y-s<0?this.y=s:this.y+s>this.chart.height&&(this.y=this.chart.height-s),this.x>this.chart.width/2?this.x-=this.xOffset+this.width:this.x+=this.xOffset},getLineHeight:function(t){var i=this.y-this.height/2+this.yPadding,e=t-1;return 0===t?i+this.titleFontSize/2:i+(1.5*this.fontSize*e+this.fontSize/2)+1.5*this.titleFontSize},draw:function(){if(this.custom)this.custom(this);else{B(this.ctx,this.x,this.y-this.height/2,this.width,this.height,this.cornerRadius);var t=this.ctx;t.fillStyle=this.fillColor,t.fill(),t.closePath(),t.textAlign="left",t.textBaseline="middle",t.fillStyle=this.titleTextColor,t.font=this.titleFont,t.fillText(this.title,this.x+this.xPadding,this.getLineHeight(0)),t.font=this.font,s.each(this.labels,function(i,e){t.fillStyle=this.textColor,t.fillText(i,this.x+this.xPadding+this.fontSize+3,this.getLineHeight(e+1)),t.fillStyle=this.legendColorBackground,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize),t.fillStyle=this.legendColors[e].fill,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize)},this)}}}),e.Scale=e.Element.extend({initialize:function(){this.fit()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}));this.yLabelWidth=this.display&&this.showLabels?z(this.ctx,this.font,this.yLabels):0},addXLabel:function(t){this.xLabels.push(t),this.valuesCount++,this.fit()},removeXLabel:function(){this.xLabels.shift(),this.valuesCount--,this.fit()},fit:function(){this.startPoint=this.display?this.fontSize:0,this.endPoint=this.display?this.height-1.5*this.fontSize-5:this.height,this.startPoint+=this.padding,this.endPoint-=this.padding;var t,i=this.endPoint-this.startPoint;for(this.calculateYRange(i),this.buildYLabels(),this.calculateXLabelRotation();i>this.endPoint-this.startPoint;)i=this.endPoint-this.startPoint,t=this.yLabelWidth,this.calculateYRange(i),this.buildYLabels(),t<this.yLabelWidth&&this.calculateXLabelRotation()},calculateXLabelRotation:function(){this.ctx.font=this.font;var t,i,e=this.ctx.measureText(this.xLabels[0]).width,s=this.ctx.measureText(this.xLabels[this.xLabels.length-1]).width;if(this.xScalePaddingRight=s/2+3,this.xScalePaddingLeft=e/2>this.yLabelWidth+10?e/2:this.yLabelWidth+10,this.xLabelRotation=0,this.display){var n,o=z(this.ctx,this.font,this.xLabels);this.xLabelWidth=o;for(var a=Math.floor(this.calculateX(1)-this.calculateX(0))-6;this.xLabelWidth>a&&0===this.xLabelRotation||this.xLabelWidth>a&&this.xLabelRotation<=90&&this.xLabelRotation>0;)n=Math.cos(S(this.xLabelRotation)),t=n*e,i=n*s,t+this.fontSize/2>this.yLabelWidth+8&&(this.xScalePaddingLeft=t+this.fontSize/2),this.xScalePaddingRight=this.fontSize/2,this.xLabelRotation++,this.xLabelWidth=n*o;this.xLabelRotation>0&&(this.endPoint-=Math.sin(S(this.xLabelRotation))*o+3)}else this.xLabelWidth=0,this.xScalePaddingRight=this.padding,this.xScalePaddingLeft=this.padding},calculateYRange:c,drawingArea:function(){return this.startPoint-this.endPoint},calculateY:function(t){var i=this.drawingArea()/(this.min-this.max);return this.endPoint-i*(t-this.min)},calculateX:function(t){var i=(this.xLabelRotation>0,this.width-(this.xScalePaddingLeft+this.xScalePaddingRight)),e=i/Math.max(this.valuesCount-(this.offsetGridLines?0:1),1),s=e*t+this.xScalePaddingLeft;return this.offsetGridLines&&(s+=e/2),Math.round(s)},update:function(t){s.extend(this,t),this.fit()},draw:function(){var t=this.ctx,i=(this.endPoint-this.startPoint)/this.steps,e=Math.round(this.xScalePaddingLeft);this.display&&(t.fillStyle=this.textColor,t.font=this.font,n(this.yLabels,function(n,o){var a=this.endPoint-i*o,h=Math.round(a),l=this.showHorizontalLines;t.textAlign="right",t.textBaseline="middle",this.showLabels&&t.fillText(n,e-10,a),0!==o||l||(l=!0),l&&t.beginPath(),o>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),h+=s.aliasPixel(t.lineWidth),l&&(t.moveTo(e,h),t.lineTo(this.width,h),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(e-5,h),t.lineTo(e,h),t.stroke(),t.closePath()},this),n(this.xLabels,function(i,e){var s=this.calculateX(e)+x(this.lineWidth),n=this.calculateX(e-(this.offsetGridLines?.5:0))+x(this.lineWidth),o=this.xLabelRotation>0,a=this.showVerticalLines;0!==e||a||(a=!0),a&&t.beginPath(),e>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),a&&(t.moveTo(n,this.endPoint),t.lineTo(n,this.startPoint-3),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(n,this.endPoint),t.lineTo(n,this.endPoint+5),t.stroke(),t.closePath(),t.save(),t.translate(s,o?this.endPoint+12:this.endPoint+8),t.rotate(-1*S(this.xLabelRotation)),t.font=this.font,t.textAlign=o?"right":"center",t.textBaseline=o?"middle":"top",t.fillText(i,0,0),t.restore()},this))}}),e.RadialScale=e.Element.extend({initialize:function(){this.size=m([this.height,this.width]),this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2},calculateCenterOffset:function(t){var i=this.drawingArea/(this.max-this.min);return(t-this.min)*i},update:function(){this.lineArc?this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2:this.setScaleSize(),this.buildYLabels()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}))},getCircumference:function(){return 2*Math.PI/this.valuesCount},setScaleSize:function(){var t,i,e,s,n,o,a,h,l,r,c,u,d=m([this.height/2-this.pointLabelFontSize-5,this.width/2]),p=this.width,g=0;for(this.ctx.font=W(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),i=0;i<this.valuesCount;i++)t=this.getPointPosition(i,d),e=this.ctx.measureText(C(this.templateString,{value:this.labels[i]})).width+5,0===i||i===this.valuesCount/2?(s=e/2,t.x+s>p&&(p=t.x+s,n=i),t.x-s<g&&(g=t.x-s,a=i)):i<this.valuesCount/2?t.x+e>p&&(p=t.x+e,n=i):i>this.valuesCount/2&&t.x-e<g&&(g=t.x-e,a=i);l=g,r=Math.ceil(p-this.width),o=this.getIndexAngle(n),h=this.getIndexAngle(a),c=r/Math.sin(o+Math.PI/2),u=l/Math.sin(h+Math.PI/2),c=f(c)?c:0,u=f(u)?u:0,this.drawingArea=d-(u+c)/2,this.setCenterPoint(u,c)},setCenterPoint:function(t,i){var e=this.width-i-this.drawingArea,s=t+this.drawingArea;this.xCenter=(s+e)/2,this.yCenter=this.height/2},getIndexAngle:function(t){var i=2*Math.PI/this.valuesCount;return t*i-Math.PI/2},getPointPosition:function(t,i){var e=this.getIndexAngle(t);return{x:Math.cos(e)*i+this.xCenter,y:Math.sin(e)*i+this.yCenter}},draw:function(){if(this.display){var t=this.ctx;if(n(this.yLabels,function(i,e){if(e>0){var s,n=e*(this.drawingArea/this.steps),o=this.yCenter-n;if(this.lineWidth>0)if(t.strokeStyle=this.lineColor,t.lineWidth=this.lineWidth,this.lineArc)t.beginPath(),t.arc(this.xCenter,this.yCenter,n,0,2*Math.PI),t.closePath(),t.stroke();else{t.beginPath();for(var a=0;a<this.valuesCount;a++)s=this.getPointPosition(a,this.calculateCenterOffset(this.min+e*this.stepValue)),0===a?t.moveTo(s.x,s.y):t.lineTo(s.x,s.y);t.closePath(),t.stroke()}if(this.showLabels){if(t.font=W(this.fontSize,this.fontStyle,this.fontFamily),this.showLabelBackdrop){var h=t.measureText(i).width;t.fillStyle=this.backdropColor,t.fillRect(this.xCenter-h/2-this.backdropPaddingX,o-this.fontSize/2-this.backdropPaddingY,h+2*this.backdropPaddingX,this.fontSize+2*this.backdropPaddingY)}t.textAlign="center",t.textBaseline="middle",t.fillStyle=this.fontColor,t.fillText(i,this.xCenter,o)}}},this),!this.lineArc){t.lineWidth=this.angleLineWidth,t.strokeStyle=this.angleLineColor;for(var i=this.valuesCount-1;i>=0;i--){if(this.angleLineWidth>0){var e=this.getPointPosition(i,this.calculateCenterOffset(this.max));t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(e.x,e.y),t.stroke(),t.closePath()}var s=this.getPointPosition(i,this.calculateCenterOffset(this.max)+5);t.font=W(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),t.fillStyle=this.pointLabelFontColor;var o=this.labels.length,a=this.labels.length/2,h=a/2,l=h>i||i>o-h,r=i===h||i===o-h;t.textAlign=0===i?"center":i===a?"center":a>i?"left":"right",t.textBaseline=r?"middle":l?"bottom":"top",t.fillText(this.labels[i],s.x,s.y)}}}}}),s.addEvent(window,"resize",function(){var t;return function(){clearTimeout(t),t=setTimeout(function(){n(e.instances,function(t){t.options.responsive&&t.resize(t.render,!0)})},50)}}()),p?define(function(){return e}):"object"==typeof module&&module.exports&&(module.exports=e),t.Chart=e,e.noConflict=function(){return t.Chart=i,e}}).call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleBeginAtZero:!0,scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,barShowStroke:!0,barStrokeWidth:2,barValueSpacing:5,barDatasetSpacing:1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].fillColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Bar",defaults:s,initialize:function(t){var s=this.options;this.ScaleClass=i.Scale.extend({offsetGridLines:!0,calculateBarX:function(t,i,e){var n=this.calculateBaseWidth(),o=this.calculateX(e)-n/2,a=this.calculateBarWidth(t);return o+a*i+i*s.barDatasetSpacing+a/2},calculateBaseWidth:function(){return this.calculateX(1)-this.calculateX(0)-2*s.barValueSpacing},calculateBarWidth:function(t){var i=this.calculateBaseWidth()-(t-1)*s.barDatasetSpacing;return i/t}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getBarsAtEvent(t):[];this.eachBars(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),this.BarClass=i.Rectangle.extend({strokeWidth:this.options.barStrokeWidth,showStroke:this.options.barShowStroke,ctx:this.chart.ctx}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,bars:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.bars.push(new this.BarClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.strokeColor,fillColor:i.fillColor,highlightFill:i.highlightFill||i.fillColor,highlightStroke:i.highlightStroke||i.strokeColor}))},this)},this),this.buildScale(t.labels),this.BarClass.prototype.base=this.scale.endPoint,this.eachBars(function(t,i,s){e.extend(t,{width:this.scale.calculateBarWidth(this.datasets.length),x:this.scale.calculateBarX(this.datasets.length,s,i),y:this.scale.endPoint}),t.save()},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachBars(function(t){t.save()}),this.render()},eachBars:function(t){e.each(this.datasets,function(i,s){e.each(i.bars,t,this,s)},this)},getBarsAtEvent:function(t){for(var i,s=[],n=e.getRelativePosition(t),o=function(t){s.push(t.bars[i])},a=0;a<this.datasets.length;a++)for(i=0;i<this.datasets[a].bars.length;i++)if(this.datasets[a].bars[i].inRange(n.x,n.y))return e.each(this.datasets,o),s;return s},buildScale:function(t){var i=this,s=function(){var t=[];return i.eachBars(function(i){t.push(i.value)}),t},n={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(s(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.barShowStroke?this.options.barStrokeWidth:0,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(n,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new this.ScaleClass(n)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].bars.push(new this.BarClass({value:t,label:i,x:this.scale.calculateBarX(this.datasets.length,e,this.scale.valuesCount+1),y:this.scale.endPoint,width:this.scale.calculateBarWidth(this.datasets.length),base:this.scale.endPoint,strokeColor:this.datasets[e].strokeColor,fillColor:this.datasets[e].fillColor}))
},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.bars.shift()},this),this.update()},reflow:function(){e.extend(this.BarClass.prototype,{y:this.scale.endPoint,base:this.scale.endPoint});var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();this.chart.ctx;this.scale.draw(i),e.each(this.datasets,function(t,s){e.each(t.bars,function(t,e){t.hasValue()&&(t.base=this.scale.endPoint,t.transition({x:this.scale.calculateBarX(this.datasets.length,s,e),y:this.scale.calculateY(t.value),width:this.scale.calculateBarWidth(this.datasets.length)},i).draw())},this)},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,percentageInnerCutout:50,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Doughnut",defaults:s,initialize:function(t){this.segments=[],this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,this.SegmentArc=i.Arc.extend({ctx:this.chart.ctx,x:this.chart.width/2,y:this.chart.height/2}),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.calculateTotal(t),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({value:t.value,outerRadius:this.options.animateScale?0:this.outerRadius,innerRadius:this.options.animateScale?0:this.outerRadius/100*this.options.percentageInnerCutout,fillColor:t.color,highlightColor:t.highlight||t.color,showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,startAngle:1.5*Math.PI,circumference:this.options.animateRotate?0:this.calculateCircumference(t.value),label:t.label})),e||(this.reflow(),this.update())},calculateCircumference:function(t){return 2*Math.PI*(Math.abs(t)/this.total)},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=Math.abs(t.value)},this)},update:function(){this.calculateTotal(this.segments),e.each(this.activeElements,function(t){t.restore(["fillColor"])}),e.each(this.segments,function(t){t.save()}),this.render()},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,e.each(this.segments,function(t){t.update({outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout})},this)},draw:function(t){var i=t?t:1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.calculateCircumference(t.value),outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout},i),t.endAngle=t.startAngle+t.circumference,t.draw(),0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle)},this)}}),i.types.Doughnut.extend({name:"Pie",defaults:e.merge(s,{percentageInnerCutout:0})})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,bezierCurve:!0,bezierCurveTension:.4,pointDot:!0,pointDotRadius:4,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Line",defaults:s,initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx,inRange:function(t){return Math.pow(t-this.x,2)<Math.pow(this.radius+this.hitDetectionRadius,2)}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this),this.buildScale(t.labels),this.eachPoints(function(t,i){e.extend(t,{x:this.scale.calculateX(i),y:this.scale.endPoint}),t.save()},this)},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachPoints(function(t){t.save()}),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.datasets,function(t){e.each(t.points,function(t){t.inRange(s.x,s.y)&&i.push(t)})},this),i},buildScale:function(t){var s=this,n=function(){var t=[];return s.eachPoints(function(i){t.push(i.value)}),t},o={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(n(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.pointDotRadius+this.options.pointDotStrokeWidth,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(o,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new i.Scale(o)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:this.scale.calculateX(this.scale.valuesCount+1),y:this.scale.endPoint,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.points.shift()},this),this.update()},reflow:function(){var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();var s=this.chart.ctx,n=function(t){return null!==t.value},o=function(t,i,s){return e.findNextWhere(i,n,s)||t},a=function(t,i,s){return e.findPreviousWhere(i,n,s)||t};this.scale.draw(i),e.each(this.datasets,function(t){var h=e.where(t.points,n);e.each(t.points,function(t,e){t.hasValue()&&t.transition({y:this.scale.calculateY(t.value),x:this.scale.calculateX(e)},i)},this),this.options.bezierCurve&&e.each(h,function(t,i){var s=i>0&&i<h.length-1?this.options.bezierCurveTension:0;t.controlPoints=e.splineCurve(a(t,h,i),t,o(t,h,i),s),t.controlPoints.outer.y>this.scale.endPoint?t.controlPoints.outer.y=this.scale.endPoint:t.controlPoints.outer.y<this.scale.startPoint&&(t.controlPoints.outer.y=this.scale.startPoint),t.controlPoints.inner.y>this.scale.endPoint?t.controlPoints.inner.y=this.scale.endPoint:t.controlPoints.inner.y<this.scale.startPoint&&(t.controlPoints.inner.y=this.scale.startPoint)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(h,function(t,i){if(0===i)s.moveTo(t.x,t.y);else if(this.options.bezierCurve){var e=a(t,h,i);s.bezierCurveTo(e.controlPoints.outer.x,e.controlPoints.outer.y,t.controlPoints.inner.x,t.controlPoints.inner.y,t.x,t.y)}else s.lineTo(t.x,t.y)},this),s.stroke(),this.options.datasetFill&&h.length>0&&(s.lineTo(h[h.length-1].x,this.scale.endPoint),s.lineTo(h[0].x,this.scale.endPoint),s.fillStyle=t.fillColor,s.closePath(),s.fill()),e.each(h,function(t){t.draw()})},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowLabelBackdrop:!0,scaleBackdropColor:"rgba(255,255,255,0.75)",scaleBeginAtZero:!0,scaleBackdropPaddingY:2,scaleBackdropPaddingX:2,scaleShowLine:!0,segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"PolarArea",defaults:s,initialize:function(t){this.segments=[],this.SegmentArc=i.Arc.extend({showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,ctx:this.chart.ctx,innerRadius:0,x:this.chart.width/2,y:this.chart.height/2}),this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,lineArc:!0,width:this.chart.width,height:this.chart.height,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,valuesCount:t.length}),this.updateScaleRange(t),this.scale.update(),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({fillColor:t.color,highlightColor:t.highlight||t.color,label:t.label,value:t.value,outerRadius:this.options.animateScale?0:this.scale.calculateCenterOffset(t.value),circumference:this.options.animateRotate?0:this.scale.getCircumference(),startAngle:1.5*Math.PI})),e||(this.reflow(),this.update())},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this),this.scale.valuesCount=this.segments.length},updateScaleRange:function(t){var i=[];e.each(t,function(t){i.push(t.value)});var s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s,{size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2})},update:function(){this.calculateTotal(this.segments),e.each(this.segments,function(t){t.save()}),this.reflow(),this.render()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.updateScaleRange(this.segments),this.scale.update(),e.extend(this.scale,{xCenter:this.chart.width/2,yCenter:this.chart.height/2}),e.each(this.segments,function(t){t.update({outerRadius:this.scale.calculateCenterOffset(t.value)})},this)},draw:function(t){var i=t||1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.scale.getCircumference(),outerRadius:this.scale.calculateCenterOffset(t.value)},i),t.endAngle=t.startAngle+t.circumference,0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle),t.draw()},this),this.scale.draw()}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers;i.Type.extend({name:"Radar",defaults:{scaleShowLine:!0,angleShowLineOut:!0,scaleShowLabels:!1,scaleBeginAtZero:!0,angleLineColor:"rgba(0,0,0,.1)",angleLineWidth:1,pointLabelFontFamily:"'Arial'",pointLabelFontStyle:"normal",pointLabelFontSize:10,pointLabelFontColor:"#666",pointDot:!0,pointDotRadius:3,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'},initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx}),this.datasets=[],this.buildScale(t),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){var o;this.scale.animation||(o=this.scale.getPointPosition(n,this.scale.calculateCenterOffset(e))),s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,x:this.options.animation?this.scale.xCenter:o.x,y:this.options.animation?this.scale.yCenter:o.y,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this)},this),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=e.getRelativePosition(t),s=e.getAngleFromPoint({x:this.scale.xCenter,y:this.scale.yCenter},i),n=2*Math.PI/this.scale.valuesCount,o=Math.round((s.angle-1.5*Math.PI)/n),a=[];return(o>=this.scale.valuesCount||0>o)&&(o=0),s.distance<=this.scale.drawingArea&&e.each(this.datasets,function(t){a.push(t.points[o])}),a},buildScale:function(t){this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,angleLineColor:this.options.angleLineColor,angleLineWidth:this.options.angleShowLineOut?this.options.angleLineWidth:0,pointLabelFontColor:this.options.pointLabelFontColor,pointLabelFontSize:this.options.pointLabelFontSize,pointLabelFontFamily:this.options.pointLabelFontFamily,pointLabelFontStyle:this.options.pointLabelFontStyle,height:this.chart.height,width:this.chart.width,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,labels:t.labels,valuesCount:t.datasets[0].data.length}),this.scale.setScaleSize(),this.updateScaleRange(t.datasets),this.scale.buildYLabels()},updateScaleRange:function(t){var i=function(){var i=[];return e.each(t,function(t){t.data?i=i.concat(t.data):e.each(t.points,function(t){i.push(t.value)})}),i}(),s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s)},addData:function(t,i){this.scale.valuesCount++,e.each(t,function(t,e){var s=this.scale.getPointPosition(this.scale.valuesCount,this.scale.calculateCenterOffset(t));this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:s.x,y:s.y,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.labels.push(i),this.reflow(),this.update()},removeData:function(){this.scale.valuesCount--,this.scale.labels.shift(),e.each(this.datasets,function(t){t.points.shift()},this),this.reflow(),this.update()},update:function(){this.eachPoints(function(t){t.save()}),this.reflow(),this.render()},reflow:function(){e.extend(this.scale,{width:this.chart.width,height:this.chart.height,size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2}),this.updateScaleRange(this.datasets),this.scale.setScaleSize(),this.scale.buildYLabels()},draw:function(t){var i=t||1,s=this.chart.ctx;this.clear(),this.scale.draw(),e.each(this.datasets,function(t){e.each(t.points,function(t,e){t.hasValue()&&t.transition(this.scale.getPointPosition(e,this.scale.calculateCenterOffset(t.value)),i)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(t.points,function(t,i){0===i?s.moveTo(t.x,t.y):s.lineTo(t.x,t.y)},this),s.closePath(),s.stroke(),s.fillStyle=t.fillColor,s.fill(),e.each(t.points,function(t){t.hasValue()&&t.draw()})},this)}})}.call(this);


/*!
 * Chart.js
 * http://chartjs.org/
 * Version: {{ version }}
 *
 * Copyright 2015 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */


(function(){

	"use strict";

	//Declare root variable - window in the browser, global on the server
	var root = this,
		previous = root.Chart;

	//Occupy the global variable of Chart, and create a simple base class
	var Chart = function(context){
		var chart = this;
		this.canvas = context.canvas;

		this.ctx = context;

		//Variables global to the chart
		var computeDimension = function(element,dimension)
		{
			if (element['offset'+dimension])
			{
				return element['offset'+dimension];
			}
			else
			{
				return document.defaultView.getComputedStyle(element).getPropertyValue(dimension);
			}
		};

		var width = this.width = computeDimension(context.canvas,'Width') || context.canvas.width;
		var height = this.height = computeDimension(context.canvas,'Height') || context.canvas.height;

		// Firefox requires this to work correctly
		context.canvas.width  = width;
		context.canvas.height = height;

		width = this.width = context.canvas.width;
		height = this.height = context.canvas.height;
		this.aspectRatio = this.width / this.height;
		//High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.
		helpers.retinaScale(this);

		return this;
	};
	//Globally expose the defaults to allow for user updating/changing
	Chart.defaults = {
		global: {
			// Boolean - Whether to animate the chart
			animation: true,

			// Number - Number of animation steps
			animationSteps: 60,

			// String - Animation easing effect
			animationEasing: "easeOutQuart",

			// Boolean - If we should show the scale at all
			showScale: true,

			// Boolean - If we want to override with a hard coded scale
			scaleOverride: false,

			// ** Required if scaleOverride is true **
			// Number - The number of steps in a hard coded scale
			scaleSteps: null,
			// Number - The value jump in the hard coded scale
			scaleStepWidth: null,
			// Number - The scale starting value
			scaleStartValue: null,

			// String - Colour of the scale line
			scaleLineColor: "rgba(0,0,0,.1)",

			// Number - Pixel width of the scale line
			scaleLineWidth: 1,

			// Boolean - Whether to show labels on the scale
			scaleShowLabels: true,

			// Interpolated JS string - can access value
			scaleLabel: "<%=value%>",

			// Boolean - Whether the scale should stick to integers, and not show any floats even if drawing space is there
			scaleIntegersOnly: true,

			// Boolean - Whether the scale should start at zero, or an order of magnitude down from the lowest value
			scaleBeginAtZero: false,

			// String - Scale label font declaration for the scale label
			scaleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

			// Number - Scale label font size in pixels
			scaleFontSize: 12,

			// String - Scale label font weight style
			scaleFontStyle: "normal",

			// String - Scale label font colour
			scaleFontColor: "#666",

			// Boolean - whether or not the chart should be responsive and resize when the browser does.
			responsive: false,

			// Boolean - whether to maintain the starting aspect ratio or not when responsive, if set to false, will take up entire container
			maintainAspectRatio: true,

			// Boolean - Determines whether to draw tooltips on the canvas or not - attaches events to touchmove & mousemove
			showTooltips: true,

			// Boolean - Determines whether to draw built-in tooltip or call custom tooltip function
			customTooltips: false,

			// Array - Array of string names to attach tooltip events
			tooltipEvents: ["mousemove", "touchstart", "touchmove", "mouseout"],

			// String - Tooltip background colour
			tooltipFillColor: "rgba(0,0,0,0.8)",

			// String - Tooltip label font declaration for the scale label
			tooltipFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

			// Number - Tooltip label font size in pixels
			tooltipFontSize: 14,

			// String - Tooltip font weight style
			tooltipFontStyle: "normal",

			// String - Tooltip label font colour
			tooltipFontColor: "#fff",

			// String - Tooltip title font declaration for the scale label
			tooltipTitleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

			// Number - Tooltip title font size in pixels
			tooltipTitleFontSize: 14,

			// String - Tooltip title font weight style
			tooltipTitleFontStyle: "bold",

			// String - Tooltip title font colour
			tooltipTitleFontColor: "#fff",

			// Number - pixel width of padding around tooltip text
			tooltipYPadding: 6,

			// Number - pixel width of padding around tooltip text
			tooltipXPadding: 6,

			// Number - Size of the caret on the tooltip
			tooltipCaretSize: 8,

			// Number - Pixel radius of the tooltip border
			tooltipCornerRadius: 6,



			// Number - Pixel offset from point x to tooltip edge
			tooltipXOffset: 10,

			// String - Template string for single tooltips
			tooltipTemplate: "<%if (label){%><%=label%>: <%}%><%= value %>",

			// String - Template string for single tooltips
			multiTooltipTemplate: "<%= value %>",

			// String - Colour behind the legend colour block
			multiTooltipKeyBackground: '#fff',

			// Function - Will fire on animation progression.
			onAnimationProgress: function(){},

			// Function - Will fire on animation completion.
			onAnimationComplete: function(){}

		}
	};

	//Create a dictionary of chart types, to allow for extension of existing types
	Chart.types = {};

	//Global Chart helpers object for utility methods and classes
	var helpers = Chart.helpers = {};

		//-- Basic js utility methods
	var each = helpers.each = function(loopable,callback,self){
			var additionalArgs = Array.prototype.slice.call(arguments, 3);
			// Check to see if null or undefined firstly.
			if (loopable){
				if (loopable.length === +loopable.length){
					var i;
					for (i=0; i<loopable.length; i++){
						callback.apply(self,[loopable[i], i].concat(additionalArgs));
					}
				}
				else{
					for (var item in loopable){
						callback.apply(self,[loopable[item],item].concat(additionalArgs));
					}
				}
			}
		},
		clone = helpers.clone = function(obj){
			var objClone = {};
			each(obj,function(value,key){
				if (obj.hasOwnProperty(key)){
					objClone[key] = value;
				}
			});
			return objClone;
		},
		extend = helpers.extend = function(base){
			each(Array.prototype.slice.call(arguments,1), function(extensionObject) {
				each(extensionObject,function(value,key){
					if (extensionObject.hasOwnProperty(key)){
						base[key] = value;
					}
				});
			});
			return base;
		},
		merge = helpers.merge = function(base,master){
			//Merge properties in left object over to a shallow clone of object right.
			var args = Array.prototype.slice.call(arguments,0);
			args.unshift({});
			return extend.apply(null, args);
		},
		indexOf = helpers.indexOf = function(arrayToSearch, item){
			if (Array.prototype.indexOf) {
				return arrayToSearch.indexOf(item);
			}
			else{
				for (var i = 0; i < arrayToSearch.length; i++) {
					if (arrayToSearch[i] === item) return i;
				}
				return -1;
			}
		},
		where = helpers.where = function(collection, filterCallback){
			var filtered = [];

			helpers.each(collection, function(item){
				if (filterCallback(item)){
					filtered.push(item);
				}
			});

			return filtered;
		},
		findNextWhere = helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex){
			// Default to start of the array
			if (!startIndex){
				startIndex = -1;
			}
			for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)){
					return currentItem;
				}
			}
		},
		findPreviousWhere = helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex){
			// Default to end of the array
			if (!startIndex){
				startIndex = arrayToSearch.length;
			}
			for (var i = startIndex - 1; i >= 0; i--) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)){
					return currentItem;
				}
			}
		},
		inherits = helpers.inherits = function(extensions){
			//Basic javascript inheritance based on the model created in Backbone.js
			var parent = this;
			var ChartElement = (extensions && extensions.hasOwnProperty("constructor")) ? extensions.constructor : function(){ return parent.apply(this, arguments); };

			var Surrogate = function(){ this.constructor = ChartElement;};
			Surrogate.prototype = parent.prototype;
			ChartElement.prototype = new Surrogate();

			ChartElement.extend = inherits;

			if (extensions) extend(ChartElement.prototype, extensions);

			ChartElement.__super__ = parent.prototype;

			return ChartElement;
		},
		noop = helpers.noop = function(){},
		uid = helpers.uid = (function(){
			var id=0;
			return function(){
				return "chart-" + id++;
			};
		})(),
		warn = helpers.warn = function(str){
			//Method for warning of errors
			if (window.console && typeof window.console.warn === "function") console.warn(str);
		},
		amd = helpers.amd = (typeof define === 'function' && define.amd),
		//-- Math methods
		isNumber = helpers.isNumber = function(n){
			return !isNaN(parseFloat(n)) && isFinite(n);
		},
		max = helpers.max = function(array){
			return Math.max.apply( Math, array );
		},
		min = helpers.min = function(array){
			return Math.min.apply( Math, array );
		},
		cap = helpers.cap = function(valueToCap,maxValue,minValue){
			if(isNumber(maxValue)) {
				if( valueToCap > maxValue ) {
					return maxValue;
				}
			}
			else if(isNumber(minValue)){
				if ( valueToCap < minValue ){
					return minValue;
				}
			}
			return valueToCap;
		},
		getDecimalPlaces = helpers.getDecimalPlaces = function(num){
			if (num%1!==0 && isNumber(num)){
				var s = num.toString();
				if(s.indexOf("e-") < 0){
					// no exponent, e.g. 0.01
					return s.split(".")[1].length;
				}
				else if(s.indexOf(".") < 0) {
					// no decimal point, e.g. 1e-9
					return parseInt(s.split("e-")[1]);
				}
				else {
					// exponent and decimal point, e.g. 1.23e-9
					var parts = s.split(".")[1].split("e-");
					return parts[0].length + parseInt(parts[1]);
				}
			}
			else {
				return 0;
			}
		},
		toRadians = helpers.radians = function(degrees){
			return degrees * (Math.PI/180);
		},
		// Gets the angle from vertical upright to the point about a centre.
		getAngleFromPoint = helpers.getAngleFromPoint = function(centrePoint, anglePoint){
			var distanceFromXCenter = anglePoint.x - centrePoint.x,
				distanceFromYCenter = anglePoint.y - centrePoint.y,
				radialDistanceFromCenter = Math.sqrt( distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);


			var angle = Math.PI * 2 + Math.atan2(distanceFromYCenter, distanceFromXCenter);

			//If the segment is in the top left quadrant, we need to add another rotation to the angle
			if (distanceFromXCenter < 0 && distanceFromYCenter < 0){
				angle += Math.PI*2;
			}

			return {
				angle: angle,
				distance: radialDistanceFromCenter
			};
		},
		aliasPixel = helpers.aliasPixel = function(pixelWidth){
			return (pixelWidth % 2 === 0) ? 0 : 0.5;
		},
		splineCurve = helpers.splineCurve = function(FirstPoint,MiddlePoint,AfterPoint,t){
			//Props to Rob Spencer at scaled innovation for his post on splining between points
			//http://scaledinnovation.com/analytics/splines/aboutSplines.html
			var d01=Math.sqrt(Math.pow(MiddlePoint.x-FirstPoint.x,2)+Math.pow(MiddlePoint.y-FirstPoint.y,2)),
				d12=Math.sqrt(Math.pow(AfterPoint.x-MiddlePoint.x,2)+Math.pow(AfterPoint.y-MiddlePoint.y,2)),
				fa=t*d01/(d01+d12),// scaling factor for triangle Ta
				fb=t*d12/(d01+d12);
			return {
				inner : {
					x : MiddlePoint.x-fa*(AfterPoint.x-FirstPoint.x),
					y : MiddlePoint.y-fa*(AfterPoint.y-FirstPoint.y)
				},
				outer : {
					x: MiddlePoint.x+fb*(AfterPoint.x-FirstPoint.x),
					y : MiddlePoint.y+fb*(AfterPoint.y-FirstPoint.y)
				}
			};
		},
		calculateOrderOfMagnitude = helpers.calculateOrderOfMagnitude = function(val){
			return Math.floor(Math.log(val) / Math.LN10);
		},
		calculateScaleRange = helpers.calculateScaleRange = function(valuesArray, drawingSize, textSize, startFromZero, integersOnly){

			//Set a minimum step of two - a point at the top of the graph, and a point at the base
			var minSteps = 2,
				maxSteps = Math.floor(drawingSize/(textSize * 1.5)),
				skipFitting = (minSteps >= maxSteps);

			var maxValue = max(valuesArray),
				minValue = min(valuesArray);

			// We need some degree of seperation here to calculate the scales if all the values are the same
			// Adding/minusing 0.5 will give us a range of 1.
			if (maxValue === minValue){
				maxValue += 0.5;
				// So we don't end up with a graph with a negative start value if we've said always start from zero
				if (minValue >= 0.5 && !startFromZero){
					minValue -= 0.5;
				}
				else{
					// Make up a whole number above the values
					maxValue += 0.5;
				}
			}

			var	valueRange = Math.abs(maxValue - minValue),
				rangeOrderOfMagnitude = calculateOrderOfMagnitude(valueRange),
				graphMax = Math.ceil(maxValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude),
				graphMin = (startFromZero) ? 0 : Math.floor(minValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude),
				graphRange = graphMax - graphMin,
				stepValue = Math.pow(10, rangeOrderOfMagnitude),
				numberOfSteps = Math.round(graphRange / stepValue);

			//If we have more space on the graph we'll use it to give more definition to the data
			while((numberOfSteps > maxSteps || (numberOfSteps * 2) < maxSteps) && !skipFitting) {
				if(numberOfSteps > maxSteps){
					stepValue *=2;
					numberOfSteps = Math.round(graphRange/stepValue);
					// Don't ever deal with a decimal number of steps - cancel fitting and just use the minimum number of steps.
					if (numberOfSteps % 1 !== 0){
						skipFitting = true;
					}
				}
				//We can fit in double the amount of scale points on the scale
				else{
					//If user has declared ints only, and the step value isn't a decimal
					if (integersOnly && rangeOrderOfMagnitude >= 0){
						//If the user has said integers only, we need to check that making the scale more granular wouldn't make it a float
						if(stepValue/2 % 1 === 0){
							stepValue /=2;
							numberOfSteps = Math.round(graphRange/stepValue);
						}
						//If it would make it a float break out of the loop
						else{
							break;
						}
					}
					//If the scale doesn't have to be an int, make the scale more granular anyway.
					else{
						stepValue /=2;
						numberOfSteps = Math.round(graphRange/stepValue);
					}

				}
			}

			if (skipFitting){
				numberOfSteps = minSteps;
				stepValue = graphRange / numberOfSteps;
			}

			return {
				steps : numberOfSteps,
				stepValue : stepValue,
				min : graphMin,
				max	: graphMin + (numberOfSteps * stepValue)
			};

		},
		/* jshint ignore:start */
		// Blows up jshint errors based on the new Function constructor
		//Templating methods
		//Javascript micro templating by John Resig - source at http://ejohn.org/blog/javascript-micro-templating/
		template = helpers.template = function(templateString, valuesObject,xLabelTypeCustom,xLabelConvertCustom,xMinutesWorkDay){
			// If templateString is function rather than string-template - call the function for valuesObject

			if(templateString instanceof Function){
			 	return templateString(valuesObject);
		 	}

			var cache = {};
			function tmpl(str, data,xLabelTypeCustom,xLabelConvertCustom,xMinutesWorkDay){
				// Figure out if we're getting a template, or if we need to
				// load the template - and be sure to cache the result.
				var fn = !/\W/.test(str) ?
				cache[str] = cache[str] :

				// Generate a reusable function that will serve as a template
				// generator (and which will be cached).
				new Function("obj",
					"var p=[],print=function(){p.push.apply(p,arguments);};" +

					// Introduce the data as local variables using with(){}
					"with(obj){p.push('" +

					// Convert the template into pure JavaScript
					str
						.replace(/[\r\t\n]/g, " ")
						.split("<%").join("\t")
						.replace(/((^|%>)[^\t]*)'/g, "$1\r")
						.replace(/\t=(.*?)%>/g, "',$1,'")
						.split("\t").join("');")
						.split("%>").join("p.push('")
						.split("\r").join("\\'") +
					"');}return p.join('');"
				);

				// Provide some basic currying to the user
				data.valueOld=data.value;
				if(xLabelConvertCustom!=undefined && xLabelTypeCustom!=undefined)
					{
					data.value=xLabelConvertCustom(data.value,xLabelTypeCustom,xMinutesWorkDay);
					}
				var d = data ? fn( data ) : fn;
				data.value=data.valueOld;
				return d;
			}
			return tmpl(templateString,valuesObject,xLabelTypeCustom,xLabelConvertCustom,xMinutesWorkDay);
		},
		/* jshint ignore:end */
		generateLabels = helpers.generateLabels = function(templateString,numberOfSteps,graphMin,stepValue){
			var labelsArray = new Array(numberOfSteps);
			if (templateString){
				each(labelsArray,function(val,index){
					labelsArray[index] = template(templateString,{value: (graphMin + (stepValue*(index+1)))});
				});
			}
			return labelsArray;
		},
		//--Animation methods
		//Easing functions adapted from Robert Penner's easing equations
		//http://www.robertpenner.com/easing/
		easingEffects = helpers.easingEffects = {
			linear: function (t) {
				return t;
			},
			easeInQuad: function (t) {
				return t * t;
			},
			easeOutQuad: function (t) {
				return -1 * t * (t - 2);
			},
			easeInOutQuad: function (t) {
				if ((t /= 1 / 2) < 1){
					return 1 / 2 * t * t;
				}
				return -1 / 2 * ((--t) * (t - 2) - 1);
			},
			easeInCubic: function (t) {
				return t * t * t;
			},
			easeOutCubic: function (t) {
				return 1 * ((t = t / 1 - 1) * t * t + 1);
			},
			easeInOutCubic: function (t) {
				if ((t /= 1 / 2) < 1){
					return 1 / 2 * t * t * t;
				}
				return 1 / 2 * ((t -= 2) * t * t + 2);
			},
			easeInQuart: function (t) {
				return t * t * t * t;
			},
			easeOutQuart: function (t) {
				return -1 * ((t = t / 1 - 1) * t * t * t - 1);
			},
			easeInOutQuart: function (t) {
				if ((t /= 1 / 2) < 1){
					return 1 / 2 * t * t * t * t;
				}
				return -1 / 2 * ((t -= 2) * t * t * t - 2);
			},
			easeInQuint: function (t) {
				return 1 * (t /= 1) * t * t * t * t;
			},
			easeOutQuint: function (t) {
				return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);
			},
			easeInOutQuint: function (t) {
				if ((t /= 1 / 2) < 1){
					return 1 / 2 * t * t * t * t * t;
				}
				return 1 / 2 * ((t -= 2) * t * t * t * t + 2);
			},
			easeInSine: function (t) {
				return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;
			},
			easeOutSine: function (t) {
				return 1 * Math.sin(t / 1 * (Math.PI / 2));
			},
			easeInOutSine: function (t) {
				return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);
			},
			easeInExpo: function (t) {
				return (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));
			},
			easeOutExpo: function (t) {
				return (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);
			},
			easeInOutExpo: function (t) {
				if (t === 0){
					return 0;
				}
				if (t === 1){
					return 1;
				}
				if ((t /= 1 / 2) < 1){
					return 1 / 2 * Math.pow(2, 10 * (t - 1));
				}
				return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);
			},
			easeInCirc: function (t) {
				if (t >= 1){
					return t;
				}
				return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);
			},
			easeOutCirc: function (t) {
				return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);
			},
			easeInOutCirc: function (t) {
				if ((t /= 1 / 2) < 1){
					return -1 / 2 * (Math.sqrt(1 - t * t) - 1);
				}
				return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);
			},
			easeInElastic: function (t) {
				var s = 1.70158;
				var p = 0;
				var a = 1;
				if (t === 0){
					return 0;
				}
				if ((t /= 1) == 1){
					return 1;
				}
				if (!p){
					p = 1 * 0.3;
				}
				if (a < Math.abs(1)) {
					a = 1;
					s = p / 4;
				} else{
					s = p / (2 * Math.PI) * Math.asin(1 / a);
				}
				return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
			},
			easeOutElastic: function (t) {
				var s = 1.70158;
				var p = 0;
				var a = 1;
				if (t === 0){
					return 0;
				}
				if ((t /= 1) == 1){
					return 1;
				}
				if (!p){
					p = 1 * 0.3;
				}
				if (a < Math.abs(1)) {
					a = 1;
					s = p / 4;
				} else{
					s = p / (2 * Math.PI) * Math.asin(1 / a);
				}
				return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;
			},
			easeInOutElastic: function (t) {
				var s = 1.70158;
				var p = 0;
				var a = 1;
				if (t === 0){
					return 0;
				}
				if ((t /= 1 / 2) == 2){
					return 1;
				}
				if (!p){
					p = 1 * (0.3 * 1.5);
				}
				if (a < Math.abs(1)) {
					a = 1;
					s = p / 4;
				} else {
					s = p / (2 * Math.PI) * Math.asin(1 / a);
				}
				if (t < 1){
					return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));}
				return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
			},
			easeInBack: function (t) {
				var s = 1.70158;
				return 1 * (t /= 1) * t * ((s + 1) * t - s);
			},
			easeOutBack: function (t) {
				var s = 1.70158;
				return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);
			},
			easeInOutBack: function (t) {
				var s = 1.70158;
				if ((t /= 1 / 2) < 1){
					return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));
				}
				return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
			},
			easeInBounce: function (t) {
				return 1 - easingEffects.easeOutBounce(1 - t);
			},
			easeOutBounce: function (t) {
				if ((t /= 1) < (1 / 2.75)) {
					return 1 * (7.5625 * t * t);
				} else if (t < (2 / 2.75)) {
					return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);
				} else if (t < (2.5 / 2.75)) {
					return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);
				} else {
					return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);
				}
			},
			easeInOutBounce: function (t) {
				if (t < 1 / 2){
					return easingEffects.easeInBounce(t * 2) * 0.5;
				}
				return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;
			}
		},
		//Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
		requestAnimFrame = helpers.requestAnimFrame = (function(){
			return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					return window.setTimeout(callback, 1000 / 60);
				};
		})(),
		cancelAnimFrame = helpers.cancelAnimFrame = (function(){
			return window.cancelAnimationFrame ||
				window.webkitCancelAnimationFrame ||
				window.mozCancelAnimationFrame ||
				window.oCancelAnimationFrame ||
				window.msCancelAnimationFrame ||
				function(callback) {
					return window.clearTimeout(callback, 1000 / 60);
				};
		})(),
		animationLoop = helpers.animationLoop = function(callback,totalSteps,easingString,onProgress,onComplete,chartInstance){

			var currentStep = 0,
				easingFunction = easingEffects[easingString] || easingEffects.linear;

			var animationFrame = function(){
				currentStep++;
				var stepDecimal = currentStep/totalSteps;
				var easeDecimal = easingFunction(stepDecimal);

				callback.call(chartInstance,easeDecimal,stepDecimal, currentStep);
				onProgress.call(chartInstance,easeDecimal,stepDecimal);
				if (currentStep < totalSteps){
					chartInstance.animationFrame = requestAnimFrame(animationFrame);
				} else{
					onComplete.apply(chartInstance);
				}
			};
			requestAnimFrame(animationFrame);
		},
		//-- DOM methods
		getRelativePosition = helpers.getRelativePosition = function(evt){
			var mouseX, mouseY;
			var e = evt.originalEvent || evt,
				canvas = evt.currentTarget || evt.srcElement,
				boundingRect = canvas.getBoundingClientRect();

			if (e.touches){
				mouseX = e.touches[0].clientX - boundingRect.left;
				mouseY = e.touches[0].clientY - boundingRect.top;

			}
			else{
				mouseX = e.clientX - boundingRect.left;
				mouseY = e.clientY - boundingRect.top;
			}

			return {
				x : mouseX,
				y : mouseY
			};

		},
		addEvent = helpers.addEvent = function(node,eventType,method){
			if (node.addEventListener){
				node.addEventListener(eventType,method);
			} else if (node.attachEvent){
				node.attachEvent("on"+eventType, method);
			} else {
				node["on"+eventType] = method;
			}
		},
		removeEvent = helpers.removeEvent = function(node, eventType, handler){
			if (node.removeEventListener){
				node.removeEventListener(eventType, handler, false);
			} else if (node.detachEvent){
				node.detachEvent("on"+eventType,handler);
			} else{
				node["on" + eventType] = noop;
			}
		},
		bindEvents = helpers.bindEvents = function(chartInstance, arrayOfEvents, handler){
			// Create the events object if it's not already present
			if (!chartInstance.events) chartInstance.events = {};

			each(arrayOfEvents,function(eventName){
				chartInstance.events[eventName] = function(){
					handler.apply(chartInstance, arguments);
				};
				addEvent(chartInstance.chart.canvas,eventName,chartInstance.events[eventName]);
			});
		},
		unbindEvents = helpers.unbindEvents = function (chartInstance, arrayOfEvents) {
			each(arrayOfEvents, function(handler,eventName){
				removeEvent(chartInstance.chart.canvas, eventName, handler);
			});
		},
		getMaximumWidth = helpers.getMaximumWidth = function(domNode){
			var container = domNode.parentNode,
			    padding = parseInt(getStyle(container, 'padding-left')) + parseInt(getStyle(container, 'padding-right'));
			// TODO = check cross browser stuff with this.
			return container.clientWidth - padding;
		},
		getMaximumHeight = helpers.getMaximumHeight = function(domNode){
			var container = domNode.parentNode,
			    padding = parseInt(getStyle(container, 'padding-bottom')) + parseInt(getStyle(container, 'padding-top'));
			// TODO = check cross browser stuff with this.
			return container.clientHeight - padding;
		},
		getStyle = helpers.getStyle = function (el, property) {
			return el.currentStyle ?
				el.currentStyle[property] :
				document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
		},
		getMaximumSize = helpers.getMaximumSize = helpers.getMaximumWidth, // legacy support
		retinaScale = helpers.retinaScale = function(chart){
			var ctx = chart.ctx,
				width = chart.canvas.width,
				height = chart.canvas.height;

			if (window.devicePixelRatio) {
				ctx.canvas.style.width = width + "px";
				ctx.canvas.style.height = height + "px";
				ctx.canvas.height = height * window.devicePixelRatio;
				ctx.canvas.width = width * window.devicePixelRatio;
				ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
			}
		},
		//-- Canvas methods
		clear = helpers.clear = function(chart){
			chart.ctx.clearRect(0,0,chart.width,chart.height);
		},
		fontString = helpers.fontString = function(pixelSize,fontStyle,fontFamily){
			return fontStyle + " " + pixelSize+"px " + fontFamily;
		},
		longestText = helpers.longestText = function(ctx,font,arrayOfStrings){
			ctx.font = font;
			var longest = 0;
			each(arrayOfStrings,function(string){
				var textWidth = ctx.measureText(string).width;
				longest = (textWidth > longest) ? textWidth : longest;
			});
			return longest;
		},
		drawRoundedRectangle = helpers.drawRoundedRectangle = function(ctx,x,y,width,height,radius){
			ctx.beginPath();
			ctx.moveTo(x + radius, y);
			ctx.lineTo(x + width - radius, y);
			ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
			ctx.lineTo(x + width, y + height - radius);
			ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
			ctx.lineTo(x + radius, y + height);
			ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
			ctx.lineTo(x, y + radius);
			ctx.quadraticCurveTo(x, y, x + radius, y);
			ctx.closePath();
		},
		// Helper method to draw dashed lines
		// Adapted from code by Rod MacDougall - http://stackoverflow.com/a/4663129
		drawDashedLine = helpers.drawDashedLine = function(ctx,x,y,x2,y2,da) {
			ctx.save();
			var dx = (x2-x), dy = (y2-y);
			var len = Math.sqrt(dx*dx + dy*dy);
			var rot = Math.atan2(dy, dx);
			ctx.translate(x, y);
			ctx.moveTo(0, 0);
			ctx.rotate(rot);
			var dc = da.length;
			var di = 0, draw = true;
			x = 0;
			while (len > x) {
				x += da[di++ % dc];
				if (x > len) x = len;
				draw ? ctx.lineTo(x?x:1, 0) : ctx.moveTo(x, 0);
				draw = !draw;
			}
			ctx.restore();
		};


	//Store a reference to each instance - allowing us to globally resize chart instances on window resize.
	//Destroy method on the chart will remove the instance of the chart from this reference.
	Chart.instances = {};

	Chart.Type = function(data,options,chart){
		this.options = options;
		this.chart = chart;
		this.id = uid();
		//Add the chart instance to the global namespace
		Chart.instances[this.id] = this;

		// Initialize is always called when a chart type is created
		// By default it is a no op, but it should be extended
		if (options.responsive){
			this.resize();
		}
		this.initialize.call(this,data);
	};

	//Core methods that'll be a part of every chart type
	extend(Chart.Type.prototype,{
		initialize : function(){return this;},
		clear : function(){
			clear(this.chart);
			return this;
		},
		stop : function(){
			// Stops any current animation loop occuring
			Chart.animationService.cancelAnimation(this);
			return this;
		},
		resize : function(callback){
			this.stop();
			var canvas = this.chart.canvas,
				newWidth = getMaximumWidth(this.chart.canvas),
				newHeight = this.options.maintainAspectRatio ? newWidth / this.chart.aspectRatio : getMaximumHeight(this.chart.canvas);

			canvas.width = this.chart.width = newWidth;
			canvas.height = this.chart.height = newHeight;

			retinaScale(this.chart);

			if (typeof callback === "function"){
				callback.apply(this, Array.prototype.slice.call(arguments, 1));
			}
			return this;
		},
		reflow : noop,
		render : function(reflow){
			if (reflow){
				this.reflow();
			}
			
			if (this.options.animation && !reflow){
				var animation = new Chart.Animation();
				animation.numSteps = this.options.animationSteps;
				animation.easing = this.options.animationEasing;
				
				// render function
				animation.render = function(chartInstance, animationObject) {
					var easingFunction = helpers.easingEffects[animationObject.easing];
					var stepDecimal = animationObject.currentStep / animationObject.numSteps;
					var easeDecimal = easingFunction(stepDecimal);
					
					chartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);
				};
				
				// user events
				animation.onAnimationProgress = this.options.onAnimationProgress;
				animation.onAnimationComplete = this.options.onAnimationComplete;
				
				Chart.animationService.addAnimation(this, animation);
			}
			else{
				this.draw();
				this.options.onAnimationComplete.call(this);
			}
			return this;
		},
		generateLegend : function(){
			return template(this.options.legendTemplate,this);
		},
		destroy : function(){
			this.clear();
			unbindEvents(this, this.events);
			var canvas = this.chart.canvas;

			// Reset canvas height/width attributes starts a fresh with the canvas context
			canvas.width = this.chart.width;
			canvas.height = this.chart.height;

			// < IE9 doesn't support removeProperty
			if (canvas.style.removeProperty) {
				canvas.style.removeProperty('width');
				canvas.style.removeProperty('height');
			} else {
				canvas.style.removeAttribute('width');
				canvas.style.removeAttribute('height');
			}

			delete Chart.instances[this.id];
		},
		showTooltip : function(ChartElements, forceRedraw){
			// Only redraw the chart if we've actually changed what we're hovering on.
			if (typeof this.activeElements === 'undefined') this.activeElements = [];

			var isChanged = (function(Elements){
				var changed = false;

				if (Elements.length !== this.activeElements.length){
					changed = true;
					return changed;
				}

				each(Elements, function(element, index){
					if (element !== this.activeElements[index]){
						changed = true;
					}
				}, this);
				return changed;
			}).call(this, ChartElements);

			if (!isChanged && !forceRedraw){
				return;
			}
			else{
				this.activeElements = ChartElements;
			}
			this.draw();
			if(this.options.customTooltips){
				this.options.customTooltips(false);
			}
			if (ChartElements.length > 0){
				// If we have multiple datasets, show a MultiTooltip for all of the data points at that index
				if (this.datasets && this.datasets.length > 1) {
					var dataArray,
						dataIndex;

					for (var i = this.datasets.length - 1; i >= 0; i--) {
						dataArray = this.datasets[i].points || this.datasets[i].bars || this.datasets[i].segments;
						dataIndex = indexOf(dataArray, ChartElements[0]);
						if (dataIndex !== -1){
							break;
						}
					}
					var tooltipLabels = [],
						tooltipColors = [],
						medianPosition = (function(index) {

							// Get all the points at that particular index
							var Elements = [],
								dataCollection,
								xPositions = [],
								yPositions = [],
								xMax,
								yMax,
								xMin,
								yMin;
							helpers.each(this.datasets, function(dataset){
								dataCollection = dataset.points || dataset.bars || dataset.segments;
								if (dataCollection[dataIndex] && dataCollection[dataIndex].hasValue()){
									Elements.push(dataCollection[dataIndex]);
								}
							});

							helpers.each(Elements, function(element) {
								xPositions.push(element.x);
								yPositions.push(element.y);


								//Include any colour information about the element
								tooltipLabels.push(helpers.template(this.options.multiTooltipTemplate, element));
								tooltipColors.push({
									fill: element._saved.fillColor || element.fillColor,
									stroke: element._saved.strokeColor || element.strokeColor
								});

							}, this);

							yMin = min(yPositions);
							yMax = max(yPositions);

							xMin = min(xPositions);
							xMax = max(xPositions);

							return {
								x: (xMin > this.chart.width/2) ? xMin : xMax,
								y: (yMin + yMax)/2
							};
						}).call(this, dataIndex);

					new Chart.MultiTooltip({
						x: medianPosition.x,
						y: medianPosition.y,
						xPadding: this.options.tooltipXPadding,
						yPadding: this.options.tooltipYPadding,
						xOffset: this.options.tooltipXOffset,

						fillColor: this.options.tooltipFillColor,
						textColor: this.options.tooltipFontColor,
						fontFamily: this.options.tooltipFontFamily,
						fontStyle: this.options.tooltipFontStyle,
						fontSize: this.options.tooltipFontSize,
						titleTextColor: this.options.tooltipTitleFontColor,
						titleFontFamily: this.options.tooltipTitleFontFamily,
						titleFontStyle: this.options.tooltipTitleFontStyle,
						titleFontSize: this.options.tooltipTitleFontSize,
						cornerRadius: this.options.tooltipCornerRadius,
						labels: tooltipLabels,
						legendColors: tooltipColors,
						legendColorBackground : this.options.multiTooltipKeyBackground,
						title: ChartElements[0].label,
						chart: this.chart,
						ctx: this.chart.ctx,
						custom: this.options.customTooltips
					}).draw();

				} else {
					each(ChartElements, function(Element) {
						var tooltipPosition = Element.tooltipPosition();
						new Chart.Tooltip({
							x: Math.round(tooltipPosition.x),
							y: Math.round(tooltipPosition.y),
							xPadding: this.options.tooltipXPadding,
							yPadding: this.options.tooltipYPadding,

							fillColor: this.options.tooltipFillColor,
							textColor: this.options.tooltipFontColor,
							fontFamily: this.options.tooltipFontFamily,
							fontStyle: this.options.tooltipFontStyle,
							fontSize: this.options.tooltipFontSize,
							caretHeight: this.options.tooltipCaretSize,
							cornerRadius: this.options.tooltipCornerRadius,
							text: template(this.options.tooltipTemplate, Element,this.options.xLabelTypeCustom,this.options.xLabelConvertCustom,this.options.xMinutesWorkDay),
							chart: this.chart,
							custom: this.options.customTooltips
						}).draw();
					}, this);
				}
			}
			return this;
		},
		toBase64Image : function(){
			return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);
		}
	});

	Chart.Type.extend = function(extensions){

		var parent = this;

		var ChartType = function(){
			return parent.apply(this,arguments);
		};

		//Copy the prototype object of the this class
		ChartType.prototype = clone(parent.prototype);
		//Now overwrite some of the properties in the base class with the new extensions
		extend(ChartType.prototype, extensions);

		ChartType.extend = Chart.Type.extend;

		if (extensions.name || parent.prototype.name){

			var chartName = extensions.name || parent.prototype.name;
			//Assign any potential default values of the new chart type

			//If none are defined, we'll use a clone of the chart type this is being extended from.
			//I.e. if we extend a line chart, we'll use the defaults from the line chart if our new chart
			//doesn't define some defaults of their own.

			var baseDefaults = (Chart.defaults[parent.prototype.name]) ? clone(Chart.defaults[parent.prototype.name]) : {};

			Chart.defaults[chartName] = extend(baseDefaults,extensions.defaults);

			Chart.types[chartName] = ChartType;

			//Register this new chart type in the Chart prototype
			Chart.prototype[chartName] = function(data,options){
				var config = merge(Chart.defaults.global, Chart.defaults[chartName], options || {});
				return new ChartType(data,config,this);
			};
		} else{
			warn("Name not provided for this chart, so it hasn't been registered");
		}
		return parent;
	};

	Chart.Element = function(configuration){
		extend(this,configuration);
		this.initialize.apply(this,arguments);
		this.save();
	};
	extend(Chart.Element.prototype,{
		initialize : function(){},
		restore : function(props){
			if (!props){
				extend(this,this._saved);
			} else {
				each(props,function(key){
					this[key] = this._saved[key];
				},this);
			}
			return this;
		},
		save : function(){
			this._saved = clone(this);
			delete this._saved._saved;
			return this;
		},
		update : function(newProps){
			each(newProps,function(value,key){
				this._saved[key] = this[key];
				this[key] = value;
			},this);
			return this;
		},
		transition : function(props,ease){
			each(props,function(value,key){
				this[key] = ((value - this._saved[key]) * ease) + this._saved[key];
			},this);
			return this;
		},
		tooltipPosition : function(){
			return {
				x : this.x,
				y : this.y
			};
		},
		hasValue: function(){
			return isNumber(this.value);
		}
	});

	Chart.Element.extend = inherits;


	Chart.Point = Chart.Element.extend({
		display: true,
		inRange: function(chartX,chartY){
			var hitDetectionRange = this.hitDetectionRadius + this.radius;
			return ((Math.pow(chartX-this.x, 2)+Math.pow(chartY-this.y, 2)) < Math.pow(hitDetectionRange,2));
		},
		draw : function(){
			if (this.display){
				var ctx = this.ctx;
				ctx.beginPath();

				if (this.square) {
					ctx.rect(this.x - this.radius, this.y - this.radius, this.radius*2, this.radius*2);
				} else {
					ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
				}

				ctx.closePath();
				ctx.strokeStyle = this.strokeColor;
				ctx.lineWidth = this.strokeWidth;

				ctx.fillStyle = this.fillColor;

				ctx.fill();
				ctx.stroke();
			}


			//Quick debug for bezier curve splining
			//Highlights control points and the line between them.
			//Handy for dev - stripped in the min version.

			// ctx.save();
			// ctx.fillStyle = "black";
			// ctx.strokeStyle = "black"
			// ctx.beginPath();
			// ctx.arc(this.controlPoints.inner.x,this.controlPoints.inner.y, 2, 0, Math.PI*2);
			// ctx.fill();

			// ctx.beginPath();
			// ctx.arc(this.controlPoints.outer.x,this.controlPoints.outer.y, 2, 0, Math.PI*2);
			// ctx.fill();

			// ctx.moveTo(this.controlPoints.inner.x,this.controlPoints.inner.y);
			// ctx.lineTo(this.x, this.y);
			// ctx.lineTo(this.controlPoints.outer.x,this.controlPoints.outer.y);
			// ctx.stroke();

			// ctx.restore();



		}
	});

	Chart.Arc = Chart.Element.extend({
		inRange : function(chartX,chartY){

			var pointRelativePosition = helpers.getAngleFromPoint(this, {
				x: chartX,
				y: chartY
			});

			//Check if within the range of the open/close angle
			var betweenAngles = (pointRelativePosition.angle >= this.startAngle && pointRelativePosition.angle <= this.endAngle),
				withinRadius = (pointRelativePosition.distance >= this.innerRadius && pointRelativePosition.distance <= this.outerRadius);

			return (betweenAngles && withinRadius);
			//Ensure within the outside of the arc centre, but inside arc outer
		},
		tooltipPosition : function(){
			var centreAngle = this.startAngle + ((this.endAngle - this.startAngle) / 2),
				rangeFromCentre = (this.outerRadius - this.innerRadius) / 2 + this.innerRadius;
			return {
				x : this.x + (Math.cos(centreAngle) * rangeFromCentre),
				y : this.y + (Math.sin(centreAngle) * rangeFromCentre)
			};
		},
		draw : function(animationPercent){

			var easingDecimal = animationPercent || 1;

			var ctx = this.ctx;

			ctx.beginPath();

			ctx.arc(this.x, this.y, this.outerRadius, this.startAngle, this.endAngle);

			ctx.arc(this.x, this.y, this.innerRadius, this.endAngle, this.startAngle, true);

			ctx.closePath();
			ctx.strokeStyle = this.strokeColor;
			ctx.lineWidth = this.strokeWidth;

			ctx.fillStyle = this.fillColor;

			ctx.fill();
			ctx.lineJoin = 'bevel';

			if (this.showStroke){
				ctx.stroke();
			}
		}
	});

	Chart.Rectangle = Chart.Element.extend({
		draw : function(){
			var ctx = this.ctx,
				halfWidth = this.width/2,
				leftX = this.x - halfWidth,
				rightX = this.x + halfWidth,
				top = this.base - (this.base - this.y),
				halfStroke = this.strokeWidth / 2;

			// Canvas doesn't allow us to stroke inside the width so we can
			// adjust the sizes to fit if we're setting a stroke on the line
			if (this.showStroke){
				leftX += halfStroke;
				rightX -= halfStroke;
				top += halfStroke;
			}

			ctx.beginPath();

			ctx.fillStyle = this.fillColor;
			ctx.strokeStyle = this.strokeColor;
			ctx.lineWidth = this.strokeWidth;

			// It'd be nice to keep this class totally generic to any rectangle
			// and simply specify which border to miss out.
			ctx.moveTo(leftX, this.base);
			ctx.lineTo(leftX, top);
			ctx.lineTo(rightX, top);
			ctx.lineTo(rightX, this.base);
			ctx.fill();
			if (this.showStroke){
				ctx.stroke();
			}
		},
		height : function(){
			return this.base - this.y;
		},
		inRange : function(chartX,chartY){
			return (chartX >= this.x - this.width/2 && chartX <= this.x + this.width/2) && (chartY >= this.y && chartY <= this.base);
		}
	});

	Chart.Animation = Chart.Element.extend({
		currentStep: null, // the current animation step
		numSteps: 60, // default number of steps
		easing: "", // the easing to use for this animation
		render: null, // render function used by the animation service
		
		onAnimationProgress: null, // user specified callback to fire on each step of the animation 
		onAnimationComplete: null, // user specified callback to fire when the animation finishes
	});
	
	Chart.Tooltip = Chart.Element.extend({
		draw : function(){

			var ctx = this.chart.ctx;

			ctx.font = fontString(this.fontSize,this.fontStyle,this.fontFamily);

			this.xAlign = "center";
			this.yAlign = "above";


			//Distance between the actual element.y position and the start of the tooltip caret
			var caretPadding = this.caretPadding = 2;

			var tooltipWidth = ctx.measureText(this.text).width + 2*this.xPadding,
				tooltipRectHeight = this.fontSize + 2*this.yPadding,
				tooltipHeight = tooltipRectHeight + this.caretHeight + caretPadding;

			if (this.x + tooltipWidth/2 >this.chart.width){
				this.xAlign = "left";
			} else if (this.x - tooltipWidth/2 < 0){
				this.xAlign = "right";
			}

			if (this.y - tooltipHeight < 0){
				this.yAlign = "below";

			}


			var tooltipX = this.x - tooltipWidth/2,
				tooltipY = this.y - tooltipHeight;

			ctx.fillStyle = this.fillColor;

			// Custom Tooltips
			if(this.custom){
				this.custom(this);
			}
			else{
				switch(this.yAlign)
				{
				case "above":
					//Draw a caret above the x/y
					ctx.beginPath();
					ctx.moveTo(this.x,this.y - caretPadding);
					ctx.lineTo(this.x + this.caretHeight, this.y - (caretPadding + this.caretHeight));
					ctx.lineTo(this.x - this.caretHeight, this.y - (caretPadding + this.caretHeight));
					ctx.closePath();
					ctx.fill();
					break;
				case "below":
					tooltipY = this.y + caretPadding + this.caretHeight;
					//Draw a caret below the x/y
					ctx.beginPath();
					ctx.moveTo(this.x, this.y + caretPadding);
					ctx.lineTo(this.x + this.caretHeight, this.y + caretPadding + this.caretHeight);
					ctx.lineTo(this.x - this.caretHeight, this.y + caretPadding + this.caretHeight);
					ctx.closePath();
					ctx.fill();
					break;
				}

				switch(this.xAlign)
				{
				case "left":
					tooltipX = this.x - tooltipWidth + (this.cornerRadius + this.caretHeight);
					break;
				case "right":
					tooltipX = this.x - (this.cornerRadius + this.caretHeight);
					break;
				}

				drawRoundedRectangle(ctx,tooltipX,tooltipY,tooltipWidth,tooltipRectHeight,this.cornerRadius);

				ctx.fill();

				ctx.fillStyle = this.textColor;
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				ctx.fillText(this.text, tooltipX + tooltipWidth/2, tooltipY + tooltipRectHeight/2);
			}
		}
	});

	Chart.MultiTooltip = Chart.Element.extend({
		initialize : function(){
			this.font = fontString(this.fontSize,this.fontStyle,this.fontFamily);

			this.titleFont = fontString(this.titleFontSize,this.titleFontStyle,this.titleFontFamily);

			this.height = (this.labels.length * this.fontSize) + ((this.labels.length-1) * (this.fontSize/2)) + (this.yPadding*2) + this.titleFontSize *1.5;

			this.ctx.font = this.titleFont;

			var titleWidth = this.ctx.measureText(this.title).width,
				//Label has a legend square as well so account for this.
				labelWidth = longestText(this.ctx,this.font,this.labels) + this.fontSize + 3,
				longestTextWidth = max([labelWidth,titleWidth]);

			this.width = longestTextWidth + (this.xPadding*2);


			var halfHeight = this.height/2;

			//Check to ensure the height will fit on the canvas
			this.OriginalY = this.Y;
			if (this.y - halfHeight < 0 ){
				this.y = halfHeight;
			} else if (this.y + halfHeight > this.chart.height){
				this.y = this.chart.height - halfHeight;
			}

			//Decide whether to align left or right based on position on canvas
			this.OriginalX = this.x;
			if (this.x > this.chart.width/2){
				this.x -= this.xOffset + this.width;
			} else {
				this.x += this.xOffset;
			}


		},
		getLineHeight : function(index){
			var baseLineHeight = this.y - (this.height/2) + this.yPadding,
				afterTitleIndex = index-1;

			//If the index is zero, we're getting the title
			if (index === 0){
				return baseLineHeight + this.titleFontSize/2;
			} else{
				return baseLineHeight + ((this.fontSize*1.5*afterTitleIndex) + this.fontSize/2) + this.titleFontSize * 1.5;
			}

		},
		draw : function(){
			// Custom Tooltips
			if(this.custom){
				this.custom(this);
			}
			else{
				drawRoundedRectangle(this.ctx,this.x,this.y - this.height/2,this.width,this.height,this.cornerRadius);
				var ctx = this.ctx;
				ctx.fillStyle = this.fillColor;
				ctx.fill();
				ctx.closePath();

				ctx.textAlign = "left";
				ctx.textBaseline = "middle";
				ctx.fillStyle = this.titleTextColor;
				ctx.font = this.titleFont;

				ctx.fillText(this.title,this.x + this.xPadding, this.getLineHeight(0));

				ctx.font = this.font;
				helpers.each(this.labels,function(label,index){
					ctx.fillStyle = this.textColor;
					ctx.fillText(label,this.x + this.xPadding + this.fontSize + 3, this.getLineHeight(index + 1));

					//A bit gnarly, but clearing this rectangle breaks when using explorercanvas (clears whole canvas)
					//ctx.clearRect(this.x + this.xPadding, this.getLineHeight(index + 1) - this.fontSize/2, this.fontSize, this.fontSize);
					//Instead we'll make a white filled block to put the legendColour palette over.

					ctx.fillStyle = this.legendColorBackground;
					ctx.fillRect(this.x + this.xPadding, this.getLineHeight(index + 1) - this.fontSize/2, this.fontSize, this.fontSize);

					ctx.fillStyle = this.legendColors[index].fill;
					ctx.fillRect(this.x + this.xPadding, this.getLineHeight(index + 1) - this.fontSize/2, this.fontSize, this.fontSize);


				},this);
			}
		}
	});

	Chart.Scale = Chart.Element.extend({
		initialize : function(){
			this.fit();
		},
		buildYLabels : function(){
			this.yLabels = [];
			/*0*/
			var stepDecimalPlaces = getDecimalPlaces(this.stepValue);

			for (var i=0; i<=this.steps; i++){

	var label=template(this.templateString,{value:(this.min + (i * this.stepValue)).toFixed(stepDecimalPlaces)});
				if(this.ctx.xLabelConvertCustom!=undefined && this.ctx.xLabelTypeCustom!=undefined)
					{
					label=this.ctx.xLabelConvertCustom(label,this.ctx.xLabelTypeCustom,this.ctx.xMinutesWorkDay);
					}
				this.yLabels.push(label);			
			}
			this.yLabelWidth = (this.display && this.showLabels) ? longestText(this.ctx,this.font,this.yLabels) + 10 : 0;
		},
		addXLabel : function(label){
			this.xLabels.push(label);
			this.valuesCount++;
			this.fit();
		},
		removeXLabel : function(){
			this.xLabels.shift();
			this.valuesCount--;
			this.fit();
		},
		// Fitting loop to rotate x Labels and figure out what fits there, and also calculate how many Y steps to use
		fit: function(){
			// First we need the width of the yLabels, assuming the xLabels aren't rotated

			// To do that we need the base line at the top and base of the chart, assuming there is no x label rotation
			this.startPoint = (this.display) ? this.fontSize : 0;
			this.endPoint = (this.display) ? this.height - (this.fontSize * 1.5) - 5 : this.height; // -5 to pad labels

			// Apply padding settings to the start and end point.
			this.startPoint += this.padding;
			this.endPoint -= this.padding;

			// Cache the starting endpoint, excluding the space for x labels
			var cachedEndPoint = this.endPoint;

			// Cache the starting height, so can determine if we need to recalculate the scale yAxis
			var cachedHeight = this.endPoint - this.startPoint,
				cachedYLabelWidth;

			// Build the current yLabels so we have an idea of what size they'll be to start
			/*
			 *	This sets what is returned from calculateScaleRange as static properties of this class:
			 *
				this.steps;
				this.stepValue;
				this.min;
				this.max;
			 *
			 */
			this.calculateYRange(cachedHeight);

			// With these properties set we can now build the array of yLabels
			// and also the width of the largest yLabel
			this.buildYLabels();

			this.calculateXLabelRotation();

			while((cachedHeight > this.endPoint - this.startPoint)){
				cachedHeight = this.endPoint - this.startPoint;
				cachedYLabelWidth = this.yLabelWidth;

				this.calculateYRange(cachedHeight);
				this.buildYLabels();

				// Only go through the xLabel loop again if the yLabel width has changed
				if (cachedYLabelWidth < this.yLabelWidth){
					this.endPoint = cachedEndPoint;
					this.calculateXLabelRotation();
				}
			}

		},
		calculateXLabelRotation : function(){
			//Get the width of each grid by calculating the difference
			//between x offsets between 0 and 1.

			this.ctx.font = this.font;

			var firstWidth = this.ctx.measureText(this.xLabels[0]).width,
				lastWidth = this.ctx.measureText(this.xLabels[this.xLabels.length - 1]).width,
				firstRotated,
				lastRotated;


			this.xScalePaddingRight = lastWidth/2 + 3;
			this.xScalePaddingLeft = (firstWidth/2 > this.yLabelWidth) ? firstWidth/2 : this.yLabelWidth;

			this.xLabelRotation = 0;
			if (this.display){
				var originalLabelWidth = longestText(this.ctx,this.font,this.xLabels),
					cosRotation,
					firstRotatedWidth;
				this.xLabelWidth = originalLabelWidth;
				//Allow 3 pixels x2 padding either side for label readability
				var xGridWidth = Math.floor(this.calculateX(1) - this.calculateX(0)) - 6;

				//Max label rotate should be 90 - also act as a loop counter
				while ((this.xLabelWidth > xGridWidth && this.xLabelRotation === 0) || (this.xLabelWidth > xGridWidth && this.xLabelRotation <= 90 && this.xLabelRotation > 0)){
					cosRotation = Math.cos(toRadians(this.xLabelRotation));

					firstRotated = cosRotation * firstWidth;
					lastRotated = cosRotation * lastWidth;

					// We're right aligning the text now.
					if (firstRotated + this.fontSize / 2 > this.yLabelWidth){
						this.xScalePaddingLeft = firstRotated + this.fontSize / 2;
					}
					this.xScalePaddingRight = this.fontSize/2;


					this.xLabelRotation++;
					this.xLabelWidth = cosRotation * originalLabelWidth;

				}
				if (this.xLabelRotation > 0){
					this.endPoint -= Math.sin(toRadians(this.xLabelRotation))*originalLabelWidth + 3;
				}
			}
			else{
				this.xLabelWidth = 0;
				this.xScalePaddingRight = this.padding;
				this.xScalePaddingLeft = this.padding;
			}

		},
		// Needs to be overidden in each Chart type
		// Otherwise we need to pass all the data into the scale class
		calculateYRange: noop,
		drawingArea: function(){
			return this.startPoint - this.endPoint;
		},
		calculateY : function(value){
			var scalingFactor = this.drawingArea() / (this.min - this.max);
			return this.endPoint - (scalingFactor * (value - this.min));
		},
		calculateX : function(index){
			var isRotated = (this.xLabelRotation > 0),
				// innerWidth = (this.offsetGridLines) ? this.width - offsetLeft - this.padding : this.width - (offsetLeft + halfLabelWidth * 2) - this.padding,
				innerWidth = this.width - (this.xScalePaddingLeft + this.xScalePaddingRight),
				valueWidth = innerWidth/Math.max((this.valuesCount - ((this.offsetGridLines) ? 0 : 1)), 1),
				valueOffset = (valueWidth * index) + this.xScalePaddingLeft;

			if (this.offsetGridLines){
				valueOffset += (valueWidth/2);
			}

			return Math.round(valueOffset);
		},
		update : function(newProps){
			helpers.extend(this, newProps);
			this.fit();
		},
		draw : function(){
			var ctx = this.ctx,
				yLabelGap = (this.endPoint - this.startPoint) / this.steps,
				xStart = Math.round(this.xScalePaddingLeft);
			if (this.display){
				ctx.fillStyle = this.textColor;
				ctx.font = this.font;
				each(this.yLabels,function(labelString,index){
					var yLabelCenter = this.endPoint - (yLabelGap * index),
						linePositionY = Math.round(yLabelCenter),
						drawHorizontalLine = this.showHorizontalLines;

					ctx.textAlign = "right";
					ctx.textBaseline = "middle";
					if (this.showLabels){
						ctx.fillText(labelString,xStart - 10,yLabelCenter);
					}

					// This is X axis, so draw it
					if (index === 0 && !drawHorizontalLine){
						drawHorizontalLine = true;
					}

					if (drawHorizontalLine){
						ctx.beginPath();
					}

					if (index > 0){
						// This is a grid line in the centre, so drop that
						ctx.lineWidth = this.gridLineWidth;
						ctx.strokeStyle = this.gridLineColor;
					} else {
						// This is the first line on the scale
						ctx.lineWidth = this.lineWidth;
						ctx.strokeStyle = this.lineColor;
					}

					linePositionY += helpers.aliasPixel(ctx.lineWidth);

					if(drawHorizontalLine){
						ctx.moveTo(xStart, linePositionY);
						ctx.lineTo(this.width, linePositionY);
						ctx.stroke();
						ctx.closePath();
					}

					ctx.lineWidth = this.lineWidth;
					ctx.strokeStyle = this.lineColor;
					ctx.beginPath();
					ctx.moveTo(xStart - 5, linePositionY);
					ctx.lineTo(xStart, linePositionY);
					ctx.stroke();
					ctx.closePath();

				},this);

				each(this.xLabels,function(label,index){
					var xPos = this.calculateX(index) + aliasPixel(this.lineWidth),
						// Check to see if line/bar here and decide where to place the line
						linePos = this.calculateX(index - (this.offsetGridLines ? 0.5 : 0)) + aliasPixel(this.lineWidth),
						isRotated = (this.xLabelRotation > 0),
						drawVerticalLine = this.showVerticalLines;


					// This is Y axis, so draw it
					if (index === 0 && !drawVerticalLine){
						drawVerticalLine = true;
					}

					if (drawVerticalLine){
						ctx.beginPath();
					}

					if (index > 0){
						// This is a grid line in the centre, so drop that
						ctx.lineWidth = this.gridLineWidth;
						ctx.strokeStyle = this.gridLineColor;
					} else {
						// This is the first line on the scale
						ctx.lineWidth = this.lineWidth;
						ctx.strokeStyle = this.lineColor;
					}

					if (drawVerticalLine){
						ctx.moveTo(linePos,this.endPoint);
						ctx.lineTo(linePos,this.startPoint - 3);
						ctx.stroke();
						ctx.closePath();
					}






					ctx.lineWidth = this.lineWidth;
					ctx.strokeStyle = this.lineColor;


					// Small lines at the bottom of the base grid line
					ctx.beginPath();
					ctx.moveTo(linePos,this.endPoint);
					ctx.lineTo(linePos,this.endPoint + 5);
					ctx.stroke();
					ctx.closePath();

					ctx.save();
					ctx.translate(xPos,(isRotated) ? this.endPoint + 12 : this.endPoint + 8);
					ctx.rotate(toRadians(this.xLabelRotation)*-1);
					ctx.font = this.font;
					ctx.textAlign = (isRotated) ? "right" : "center";
					ctx.textBaseline = (isRotated) ? "middle" : "top";
					ctx.fillText(label, 0, 0);
					ctx.restore();
				},this);

			}
		}

	});

	Chart.RadialScale = Chart.Element.extend({
		initialize: function(){
			this.size = min([this.height, this.width]);
			this.drawingArea = (this.display) ? (this.size/2) - (this.fontSize/2 + this.backdropPaddingY) : (this.size/2);
		},
		calculateCenterOffset: function(value){
			// Take into account half font size + the yPadding of the top value
			var scalingFactor = this.drawingArea / (this.max - this.min);

			return (value - this.min) * scalingFactor;
		},
		update : function(){
			if (!this.lineArc){
				this.setScaleSize();
			} else {
				this.drawingArea = (this.display) ? (this.size/2) - (this.fontSize/2 + this.backdropPaddingY) : (this.size/2);
			}
			this.buildYLabels();
		},
		buildYLabels: function(){
			this.yLabels = [];

			var stepDecimalPlaces = getDecimalPlaces(this.stepValue);

			for (var i=0; i<=this.steps; i++){
				this.yLabels.push(template(this.templateString,{value:(this.min + (i * this.stepValue)).toFixed(stepDecimalPlaces)}));
			}
		},
		getCircumference : function(){
			return ((Math.PI*2) / this.valuesCount);
		},
		setScaleSize: function(){
			/*
			 * Right, this is really confusing and there is a lot of maths going on here
			 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
			 *
			 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
			 *
			 * Solution:
			 *
			 * We assume the radius of the polygon is half the size of the canvas at first
			 * at each index we check if the text overlaps.
			 *
			 * Where it does, we store that angle and that index.
			 *
			 * After finding the largest index and angle we calculate how much we need to remove
			 * from the shape radius to move the point inwards by that x.
			 *
			 * We average the left and right distances to get the maximum shape radius that can fit in the box
			 * along with labels.
			 *
			 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
			 * on each side, removing that from the size, halving it and adding the left x protrusion width.
			 *
			 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
			 * and position it in the most space efficient manner
			 *
			 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
			 */


			// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
			// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
			var largestPossibleRadius = min([(this.height/2 - this.pointLabelFontSize - 5), this.width/2]),
				pointPosition,
				i,
				textWidth,
				halfTextWidth,
				furthestRight = this.width,
				furthestRightIndex,
				furthestRightAngle,
				furthestLeft = 0,
				furthestLeftIndex,
				furthestLeftAngle,
				xProtrusionLeft,
				xProtrusionRight,
				radiusReductionRight,
				radiusReductionLeft,
				maxWidthRadius;
			this.ctx.font = fontString(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily);
			for (i=0;i<this.valuesCount;i++){
				// 5px to space the text slightly out - similar to what we do in the draw function.
				pointPosition = this.getPointPosition(i, largestPossibleRadius);
				textWidth = this.ctx.measureText(template(this.templateString, { value: this.labels[i] })).width + 5;
				if (i === 0 || i === this.valuesCount/2){
					// If we're at index zero, or exactly the middle, we're at exactly the top/bottom
					// of the radar chart, so text will be aligned centrally, so we'll half it and compare
					// w/left and right text sizes
					halfTextWidth = textWidth/2;
					if (pointPosition.x + halfTextWidth > furthestRight) {
						furthestRight = pointPosition.x + halfTextWidth;
						furthestRightIndex = i;
					}
					if (pointPosition.x - halfTextWidth < furthestLeft) {
						furthestLeft = pointPosition.x - halfTextWidth;
						furthestLeftIndex = i;
					}
				}
				else if (i < this.valuesCount/2) {
					// Less than half the values means we'll left align the text
					if (pointPosition.x + textWidth > furthestRight) {
						furthestRight = pointPosition.x + textWidth;
						furthestRightIndex = i;
					}
				}
				else if (i > this.valuesCount/2){
					// More than half the values means we'll right align the text
					if (pointPosition.x - textWidth < furthestLeft) {
						furthestLeft = pointPosition.x - textWidth;
						furthestLeftIndex = i;
					}
				}
			}

			xProtrusionLeft = furthestLeft;

			xProtrusionRight = Math.ceil(furthestRight - this.width);

			furthestRightAngle = this.getIndexAngle(furthestRightIndex);

			furthestLeftAngle = this.getIndexAngle(furthestLeftIndex);

			radiusReductionRight = xProtrusionRight / Math.sin(furthestRightAngle + Math.PI/2);

			radiusReductionLeft = xProtrusionLeft / Math.sin(furthestLeftAngle + Math.PI/2);

			// Ensure we actually need to reduce the size of the chart
			radiusReductionRight = (isNumber(radiusReductionRight)) ? radiusReductionRight : 0;
			radiusReductionLeft = (isNumber(radiusReductionLeft)) ? radiusReductionLeft : 0;

			this.drawingArea = largestPossibleRadius - (radiusReductionLeft + radiusReductionRight)/2;

			//this.drawingArea = min([maxWidthRadius, (this.height - (2 * (this.pointLabelFontSize + 5)))/2])
			this.setCenterPoint(radiusReductionLeft, radiusReductionRight);

		},
		setCenterPoint: function(leftMovement, rightMovement){

			var maxRight = this.width - rightMovement - this.drawingArea,
				maxLeft = leftMovement + this.drawingArea;

			this.xCenter = (maxLeft + maxRight)/2;
			// Always vertically in the centre as the text height doesn't change
			this.yCenter = (this.height/2);
		},

		getIndexAngle : function(index){
			var angleMultiplier = (Math.PI * 2) / this.valuesCount;
			// Start from the top instead of right, so remove a quarter of the circle

			return index * angleMultiplier - (Math.PI/2);
		},
		getPointPosition : function(index, distanceFromCenter){
			var thisAngle = this.getIndexAngle(index);
			return {
				x : (Math.cos(thisAngle) * distanceFromCenter) + this.xCenter,
				y : (Math.sin(thisAngle) * distanceFromCenter) + this.yCenter
			};
		},
		draw: function(){
			if (this.display){
				var ctx = this.ctx;
				each(this.yLabels, function(label, index){
					// Don't draw a centre value
					if (index > 0){
						var yCenterOffset = index * (this.drawingArea/this.steps),
							yHeight = this.yCenter - yCenterOffset,
							pointPosition;

						// Draw circular lines around the scale
						if (this.lineWidth > 0){
							ctx.strokeStyle = this.lineColor;
							ctx.lineWidth = this.lineWidth;

							if(this.lineArc){
								ctx.beginPath();
								ctx.arc(this.xCenter, this.yCenter, yCenterOffset, 0, Math.PI*2);
								ctx.closePath();
								ctx.stroke();
							} else{
								ctx.beginPath();
								for (var i=0;i<this.valuesCount;i++)
								{
									pointPosition = this.getPointPosition(i, this.calculateCenterOffset(this.min + (index * this.stepValue)));
									if (i === 0){
										ctx.moveTo(pointPosition.x, pointPosition.y);
									} else {
										ctx.lineTo(pointPosition.x, pointPosition.y);
									}
								}
								ctx.closePath();
								ctx.stroke();
							}
						}
						if(this.showLabels){
							ctx.font = fontString(this.fontSize,this.fontStyle,this.fontFamily);
							if (this.showLabelBackdrop){
								var labelWidth = ctx.measureText(label).width;
								ctx.fillStyle = this.backdropColor;
								ctx.fillRect(
									this.xCenter - labelWidth/2 - this.backdropPaddingX,
									yHeight - this.fontSize/2 - this.backdropPaddingY,
									labelWidth + this.backdropPaddingX*2,
									this.fontSize + this.backdropPaddingY*2
								);
							}
							ctx.textAlign = 'center';
							ctx.textBaseline = "middle";
							ctx.fillStyle = this.fontColor;
							ctx.fillText(label, this.xCenter, yHeight);
						}
					}
				}, this);

				if (!this.lineArc){
					ctx.lineWidth = this.angleLineWidth;
					ctx.strokeStyle = this.angleLineColor;
					for (var i = this.valuesCount - 1; i >= 0; i--) {
						if (this.angleLineWidth > 0){
							var outerPosition = this.getPointPosition(i, this.calculateCenterOffset(this.max));
							ctx.beginPath();
							ctx.moveTo(this.xCenter, this.yCenter);
							ctx.lineTo(outerPosition.x, outerPosition.y);
							ctx.stroke();
							ctx.closePath();
						}
						// Extra 3px out for some label spacing
						var pointLabelPosition = this.getPointPosition(i, this.calculateCenterOffset(this.max) + 5);
						ctx.font = fontString(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily);
						ctx.fillStyle = this.pointLabelFontColor;

						var labelsCount = this.labels.length,
							halfLabelsCount = this.labels.length/2,
							quarterLabelsCount = halfLabelsCount/2,
							upperHalf = (i < quarterLabelsCount || i > labelsCount - quarterLabelsCount),
							exactQuarter = (i === quarterLabelsCount || i === labelsCount - quarterLabelsCount);
						if (i === 0){
							ctx.textAlign = 'center';
						} else if(i === halfLabelsCount){
							ctx.textAlign = 'center';
						} else if (i < halfLabelsCount){
							ctx.textAlign = 'left';
						} else {
							ctx.textAlign = 'right';
						}

						// Set the correct text baseline based on outer positioning
						if (exactQuarter){
							ctx.textBaseline = 'middle';
						} else if (upperHalf){
							ctx.textBaseline = 'bottom';
						} else {
							ctx.textBaseline = 'top';
						}

						ctx.fillText(this.labels[i], pointLabelPosition.x, pointLabelPosition.y);
					}
				}
			}
		}
	});

	Chart.animationService = {
		frameDuration: 17,
		animations: [],
		dropFrames: 0,
		addAnimation: function(chartInstance, animationObject) {
			for (var index = 0; index < this.animations.length; ++ index){
				if (this.animations[index].chartInstance === chartInstance){
					// replacing an in progress animation
					this.animations[index].animationObject = animationObject;
					return;
				}
			}
			
			this.animations.push({
				chartInstance: chartInstance,
				animationObject: animationObject
			});

			// If there are no animations queued, manually kickstart a digest, for lack of a better word
			if (this.animations.length == 1) {
				helpers.requestAnimFrame.call(window, this.digestWrapper);
			}
		},
		// Cancel the animation for a given chart instance
		cancelAnimation: function(chartInstance) {
			var index = helpers.findNextWhere(this.animations, function(animationWrapper) {
				return animationWrapper.chartInstance === chartInstance;
			});
			
			if (index)
			{
				this.animations.splice(index, 1);
			}
		},
		// calls startDigest with the proper context
		digestWrapper: function() {
			Chart.animationService.startDigest.call(Chart.animationService);
		},
		startDigest: function() {

			var startTime = Date.now();
			var framesToDrop = 0;

			if(this.dropFrames > 1){
				framesToDrop = Math.floor(this.dropFrames);
				this.dropFrames -= framesToDrop;
			}

			for (var i = 0; i < this.animations.length; i++) {

				if (this.animations[i].animationObject.currentStep === null){
					this.animations[i].animationObject.currentStep = 0;
				}

				this.animations[i].animationObject.currentStep += 1 + framesToDrop;
				if(this.animations[i].animationObject.currentStep > this.animations[i].animationObject.numSteps){
					this.animations[i].animationObject.currentStep = this.animations[i].animationObject.numSteps;
				}
				
				this.animations[i].animationObject.render(this.animations[i].chartInstance, this.animations[i].animationObject);
				
				if (this.animations[i].animationObject.currentStep == this.animations[i].animationObject.numSteps){
					// executed the last frame. Remove the animation.
					this.animations.splice(i, 1);
					// Keep the index in place to offset the splice
					i--;
				}
			}

			var endTime = Date.now();
			var delay = endTime - startTime - this.frameDuration;
			var frameDelay = delay / this.frameDuration;

			if(frameDelay > 1){
				this.dropFrames += frameDelay;
			}

			// Do we have more stuff to animate?
			if (this.animations.length > 0){
				helpers.requestAnimFrame.call(window, this.digestWrapper);
			}
		}
	};

	// Attach global event to resize each chart instance when the browser resizes
	helpers.addEvent(window, "resize", (function(){
		// Basic debounce of resize function so it doesn't hurt performance when resizing browser.
		var timeout;
		return function(){
			clearTimeout(timeout);
			timeout = setTimeout(function(){
				each(Chart.instances,function(instance){
					// If the responsive flag is set in the chart instance config
					// Cascade the resize event down to the chart.
					if (instance.options.responsive){
						instance.resize(instance.render, true);
					}
				});
			}, 50);
		};
	})());


	if (amd) {
		define(function(){
			return Chart;
		});
	} else if (typeof module === 'object' && module.exports) {
		module.exports = Chart;
	}

	root.Chart = Chart;

	Chart.noConflict = function(){
		root.Chart = previous;
		return Chart;
	};

}).call(this);



(function(){
	"use strict";

	var root = this,
		Chart = root.Chart,
		helpers = Chart.helpers;

	var defaultConfig = {

		///Boolean - Whether grid lines are shown across the chart
		scaleShowGridLines : true,

		//String - Colour of the grid lines
		scaleGridLineColor : "rgba(0,0,0,.05)",

		//Number - Width of the grid lines
		scaleGridLineWidth : 1,

		//Boolean - Whether to show horizontal lines (except X axis)
		scaleShowHorizontalLines: true,

		//Boolean - Whether to show vertical lines (except Y axis)
		scaleShowVerticalLines: true,

		//Boolean - Whether the line is curved between points
		bezierCurve : true,

		//Number - Tension of the bezier curve between points
		bezierCurveTension : 0.4,

		//Boolean - Whether to show a dot for each point
		pointDot : true,
		//Boolean - Whether to show each dot as a square
		pointSquare : false,

		//Number - Radius of each point dot in pixels
		pointDotRadius : 4,

		//Number - Pixel width of point dot stroke
		pointDotStrokeWidth : 1,

		//Number - amount extra to add to the radius to cater for hit detection outside the drawn point
		pointHitDetectionRadius : 20,

		//Boolean - Whether to show a stroke for datasets
		datasetStroke : true,

		//Number - Pixel width of dataset stroke
		datasetStrokeWidth : 2,

		//Boolean - Whether to fill the dataset with a colour
		datasetFill : true,
		//Boolean - Whether to show candles for each point
		candles : false,
		//Number - Pixel width of candle stroke
		candleStrokeWidth : 3,

		//String - A legend template
		legendTemplate : "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<datasets.length; i++){%><li><span style=\"background-color:<%=datasets[i].strokeColor%>\"><%if(datasets[i].label){%><%=datasets[i].label%><%}%></span></li><%}%></ul>",

		//Boolean - Whether to horizontally center the label and point dot inside the grid
		offsetGridLines : false

	};


	Chart.Type.extend({
		name: "Line",
		defaults : defaultConfig,
		initialize:  function(data){
			//Declare the extension of the default point, to cater for the options passed in to the constructor
			this.PointClass = Chart.Point.extend({
				offsetGridLines : this.options.offsetGridLines,
				strokeWidth : this.options.pointDotStrokeWidth,
				radius : this.options.pointDotRadius,
				display: this.options.pointDot,
				square : this.options.pointSquare,
				hitDetectionRadius : this.options.pointHitDetectionRadius,
				ctx : this.chart.ctx,
				inRange : function(mouseX){
					return (Math.pow(mouseX-this.x, 2) < Math.pow(this.radius + this.hitDetectionRadius,2));
				}
			});

			this.datasets = [];

			//Set up tooltip events on the chart
			if (this.options.showTooltips){
				helpers.bindEvents(this, this.options.tooltipEvents, function(evt){
					var activePoints = (evt.type !== 'mouseout') ? this.getPointsAtEvent(evt) : [];
					this.eachPoints(function(point){
						point.restore(['fillColor', 'strokeColor']);
					});
					helpers.each(activePoints, function(activePoint){
						activePoint.fillColor = activePoint.highlightFill;
						activePoint.strokeColor = activePoint.highlightStroke;
					});
					this.showTooltip(activePoints);
				});
			}

			//Iterate through each of the datasets, and build this into a property of the chart
			helpers.each(data.datasets,function(dataset){

				var datasetObject = {
					label : dataset.label || null,
					fillColor : dataset.fillColor,
					strokeColor : dataset.strokeColor,
					candleStrokeColor : dataset.candleStrokeColor,
					pointColor : dataset.pointColor,
					pointStrokeColor : dataset.pointStrokeColor,
					dashStyle : dataset.dashStyle,
					points : []
				};

				this.datasets.push(datasetObject);


				helpers.each(dataset.data,function(dataPoint,index){
					//Best way to do this? or in draw sequence...?
					if (helpers.isNumber(dataPoint)){
					//Add a new point for each piece of data, passing any required data to draw.
					datasetObject.points.push(new this.PointClass({
						value : dataPoint,
						label : data.labels[index],
						datasetLabel: dataset.label,
						strokeColor : dataset.pointStrokeColor,
						fillColor : dataset.pointColor,
						highlightFill : dataset.pointHighlightFill || dataset.pointColor,
						highlightStroke : dataset.pointHighlightStroke || dataset.pointStrokeColor
					}));
					}
				},this);

				this.buildScale(data.labels);


				this.eachPoints(function(point, index){
					helpers.extend(point, {
						x: this.scale.calculateX(index),
						y: this.scale.endPoint
					});
					point.save();
				}, this);

			},this);


			this.render();
		},
		update : function(){
			this.scale.update();
			// Reset any highlight colours before updating.
			helpers.each(this.activeElements, function(activeElement){
				activeElement.restore(['fillColor', 'strokeColor']);
			});
			this.eachPoints(function(point){
				point.save();
			});
			this.render();
		},
		eachPoints : function(callback){
			helpers.each(this.datasets,function(dataset){
				helpers.each(dataset.points,callback,this);
			},this);
		},
		getPointsAtEvent : function(e){
			var pointsArray = [],
				eventPosition = helpers.getRelativePosition(e);
			helpers.each(this.datasets,function(dataset){
				helpers.each(dataset.points,function(point){
					if (point.inRange(eventPosition.x,eventPosition.y)) pointsArray.push(point);
				});
			},this);
			return pointsArray;
		},
		buildScale : function(labels){
			var self = this;

			var dataTotal = function(){
				var values = [];
				self.eachPoints(function(point){
					values.push(point.value);
				});

				return values;
			};

			var scaleOptions = {
				templateString : this.options.scaleLabel,
				height : this.chart.height,
				width : this.chart.width,
				ctx : this.chart.ctx,
				textColor : this.options.scaleFontColor,
				offsetGridLines : this.options.offsetGridLines,
				fontSize : this.options.scaleFontSize,
				fontStyle : this.options.scaleFontStyle,
				fontFamily : this.options.scaleFontFamily,
				valuesCount : labels.length,
				beginAtZero : this.options.scaleBeginAtZero,
				integersOnly : this.options.scaleIntegersOnly,
				calculateYRange : function(currentHeight){
					var updatedRanges = helpers.calculateScaleRange(
						dataTotal(),
						currentHeight,
						this.fontSize,
						this.beginAtZero,
						this.integersOnly
					);
					helpers.extend(this, updatedRanges);
				},
				xLabels : labels,
				font : helpers.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
				lineWidth : this.options.scaleLineWidth,
				lineColor : this.options.scaleLineColor,
				showHorizontalLines : this.options.scaleShowHorizontalLines,
				showVerticalLines : this.options.scaleShowVerticalLines,
				gridLineWidth : (this.options.scaleShowGridLines) ? this.options.scaleGridLineWidth : 0,
				gridLineColor : (this.options.scaleShowGridLines) ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
				padding: (this.options.showScale) ? 0 : this.options.pointDotRadius + this.options.pointDotStrokeWidth,
				showLabels : this.options.scaleShowLabels,
				display : this.options.showScale
			};

			if (this.options.scaleOverride){
				helpers.extend(scaleOptions, {
					calculateYRange: helpers.noop,
					steps: this.options.scaleSteps,
					stepValue: this.options.scaleStepWidth,
					min: this.options.scaleStartValue,
					max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
				});
			}


			this.scale = new Chart.Scale(scaleOptions);
		},
		addData : function(valuesArray,label){
			//Map the values array for each of the datasets

			helpers.each(valuesArray,function(value,datasetIndex){
					if (helpers.isNumber(value)){
					//Add a new point for each piece of data, passing any required data to draw.
						this.datasets[datasetIndex].points.push(new this.PointClass({
							value : value,
							label : label,
							x: this.scale.calculateX(this.scale.valuesCount+1),
							y: this.scale.endPoint,
							strokeColor : this.datasets[datasetIndex].pointStrokeColor,
							fillColor : this.datasets[datasetIndex].pointColor
						}));
					}
			},this);

			this.scale.addXLabel(label);
			//Then re-render the chart.
			this.update();
		},
		removeData : function(){
			this.scale.removeXLabel();
			//Then re-render the chart.
			helpers.each(this.datasets,function(dataset){
				dataset.points.shift();
			},this);
			this.update();
		},
		reflow : function(){
			var newScaleProps = helpers.extend({
				height : this.chart.height,
				width : this.chart.width
			});
			this.scale.update(newScaleProps);
		},
		draw : function(ease){
			var easingDecimal = ease || 1;
			this.clear();

			var ctx = this.chart.ctx;

			// Some helper methods for getting the next/prev points
			var hasValue = function(item){
				return item.value !== null;
			},
			nextPoint = function(point, collection, index){
				return helpers.findNextWhere(collection, hasValue, index) || point;
			},
			previousPoint = function(point, collection, index){
				return helpers.findPreviousWhere(collection, hasValue, index) || point;
			};

            if (this.scale != null)
			    this.scale.draw(easingDecimal);


			helpers.each(this.datasets,function(dataset){
				var pointsWithValues = helpers.where(dataset.points, hasValue);

				//Transition each point first so that the line and point drawing isn't out of sync
				//We can use this extra loop to calculate the control points of this dataset also in this loop

				helpers.each(dataset.points, function(point, index){
					if (point.hasValue()){
						point.transition({
							y : this.scale.calculateY(point.value),
							x : this.scale.calculateX(index)
						}, easingDecimal);
					}
				},this);


				// Control points need to be calculated in a seperate loop, because we need to know the current x/y of the point
				// This would cause issues when there is no animation, because the y of the next point would be 0, so beziers would be skewed
				if (this.options.bezierCurve){
					helpers.each(pointsWithValues, function(point, index){
						var tension = (index > 0 && index < pointsWithValues.length - 1) ? this.options.bezierCurveTension : 0;
						point.controlPoints = helpers.splineCurve(
							previousPoint(point, pointsWithValues, index),
							point,
							nextPoint(point, pointsWithValues, index),
							tension
						);

						// Prevent the bezier going outside of the bounds of the graph

						// Cap puter bezier handles to the upper/lower scale bounds
						if (point.controlPoints.outer.y > this.scale.endPoint){
							point.controlPoints.outer.y = this.scale.endPoint;
						}
						else if (point.controlPoints.outer.y < this.scale.startPoint){
							point.controlPoints.outer.y = this.scale.startPoint;
						}

						// Cap inner bezier handles to the upper/lower scale bounds
						if (point.controlPoints.inner.y > this.scale.endPoint){
							point.controlPoints.inner.y = this.scale.endPoint;
						}
						else if (point.controlPoints.inner.y < this.scale.startPoint){
							point.controlPoints.inner.y = this.scale.startPoint;
						}
					},this);
				}


				//Draw the line between all the points
				ctx.lineWidth = this.options.datasetStrokeWidth;
				ctx.strokeStyle = dataset.strokeColor;
				ctx.beginPath();

				helpers.each(pointsWithValues, function(point, index){
					if (index === 0){
						ctx.moveTo(point.x, point.y);
					}
					else{
						if(this.options.bezierCurve){
							var previous = previousPoint(point, pointsWithValues, index);

							ctx.bezierCurveTo(
								previous.controlPoints.outer.x,
								previous.controlPoints.outer.y,
								point.controlPoints.inner.x,
								point.controlPoints.inner.y,
								point.x,
								point.y
							);
						}
						else if (dataset.dashStyle instanceof Array){
							helpers.drawDashedLine(ctx, dataset.points[index-1].x, dataset.points[index-1].y, point.x, point.y, dataset.dashStyle);
						} else{
							ctx.lineTo(point.x,point.y);
						}
					}
				},this);

				ctx.stroke();

				if (this.options.datasetFill && pointsWithValues.length > 0){
					if (!this.options.bezierCurve && dataset.dashStyle) {
						//Outline path created by lines
						ctx.closePath();
						ctx.beginPath();
						helpers.each(dataset.points,function(point,index){
							if (index>0){
								ctx.lineTo(point.x,point.y);
							}
							else{
								ctx.moveTo(point.x,point.y);
							}
						});
					}
					//Round off the line by going to the base of the chart, back to the start, then fill.
					ctx.lineTo(pointsWithValues[pointsWithValues.length - 1].x, this.scale.endPoint);
					ctx.lineTo(pointsWithValues[0].x, this.scale.endPoint);
					ctx.fillStyle = dataset.fillColor;
					ctx.closePath();
					ctx.fill();
				}

				//Draw the candles from the base to the point
				if (this.options.candles) {
					ctx.lineWidth = this.options.candleStrokeWidth;
					ctx.strokeStyle = dataset.candleStrokeColor;
					helpers.each(dataset.points,function(point,index){
						ctx.beginPath();
						ctx.moveTo(point.x, this.scale.endPoint);
						ctx.lineTo(point.x, point.y);
						ctx.stroke();
					},this)
				}
				//Now draw the points over the line
				//A little inefficient double looping, but better than the line
				//lagging behind the point positions
				helpers.each(pointsWithValues,function(point){
					point.draw();
				});
			},this);
		}
	});


}).call(this);



(function(){
	"use strict";

	var root = this,
		Chart = root.Chart,
		helpers = Chart.helpers;


	var defaultConfig = {
		//Boolean - Whether the scale should start at zero, or an order of magnitude down from the lowest value
		scaleBeginAtZero : true,

		//Boolean - Whether grid lines are shown across the chart
		scaleShowGridLines : true,

		//String - Colour of the grid lines
		scaleGridLineColor : "rgba(0,0,0,.05)",

		//Number - Width of the grid lines
		scaleGridLineWidth : 1,

		//Boolean - Whether to show horizontal lines (except X axis)
		scaleShowHorizontalLines: true,

		//Boolean - Whether to show vertical lines (except Y axis)
		scaleShowVerticalLines: true,

		//Boolean - If there is a stroke on each bar
		barShowStroke : true,

		//Number - Pixel width of the bar stroke
		barStrokeWidth : 2,

		//Number - Spacing between each of the X value sets
		barValueSpacing : 5,

		//Number - Spacing between data sets within X values
		barDatasetSpacing : 1,

		//String - A legend template
		legendTemplate : "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<datasets.length; i++){%><li><span style=\"background-color:<%=datasets[i].fillColor%>\"><%if(datasets[i].label){%><%=datasets[i].label%><%}%></span></li><%}%></ul>"

	};


	Chart.Type.extend({
		name: "Bar",
		defaults : defaultConfig,
		initialize:  function(data){

			//Expose options as a scope variable here so we can access it in the ScaleClass
			var options = this.options;

			this.ScaleClass = Chart.Scale.extend({
				offsetGridLines : true,
				calculateBarX : function(datasetCount, datasetIndex, barIndex){
					//Reusable method for calculating the xPosition of a given bar based on datasetIndex & width of the bar
					var xWidth = this.calculateBaseWidth(),
						xAbsolute = this.calculateX(barIndex) - (xWidth/2),
						barWidth = this.calculateBarWidth(datasetCount);

					return xAbsolute + (barWidth * datasetIndex) + (datasetIndex * options.barDatasetSpacing) + barWidth/2;
				},
				calculateBaseWidth : function(){
					return (this.calculateX(1) - this.calculateX(0)) - (2*options.barValueSpacing);
				},
				calculateBarWidth : function(datasetCount){
					//The padding between datasets is to the right of each bar, providing that there are more than 1 dataset
					var baseWidth = this.calculateBaseWidth() - ((datasetCount - 1) * options.barDatasetSpacing);

					return (baseWidth / datasetCount);
				}
			});

			this.datasets = [];

			//Set up tooltip events on the chart
			if (this.options.showTooltips){
				helpers.bindEvents(this, this.options.tooltipEvents, function(evt){
					var activeBars = (evt.type !== 'mouseout') ? this.getBarsAtEvent(evt) : [];

					this.eachBars(function(bar){
						bar.restore(['fillColor', 'strokeColor']);
					});
					helpers.each(activeBars, function(activeBar){
						activeBar.fillColor = activeBar.highlightFill;
						activeBar.strokeColor = activeBar.highlightStroke;
					});
					this.showTooltip(activeBars);
				});
			}

			//Declare the extension of the default point, to cater for the options passed in to the constructor
			this.BarClass = Chart.Rectangle.extend({
				strokeWidth : this.options.barStrokeWidth,
				showStroke : this.options.barShowStroke,
				ctx : this.chart.ctx
			});

			//Iterate through each of the datasets, and build this into a property of the chart
			helpers.each(data.datasets,function(dataset,datasetIndex){

				var datasetObject = {
					label : dataset.label || null,
					fillColor : dataset.fillColor,
					strokeColor : dataset.strokeColor,
					bars : []
				};

				this.datasets.push(datasetObject);

				helpers.each(dataset.data,function(dataPoint,index){
					//Add a new point for each piece of data, passing any required data to draw.
					datasetObject.bars.push(new this.BarClass({
						value : dataPoint,
						label : data.labels[index],
						datasetLabel: dataset.label,
						strokeColor : dataset.strokeColor,
						fillColor : dataset.fillColor,
						highlightFill : dataset.highlightFill || dataset.fillColor,
						highlightStroke : dataset.highlightStroke || dataset.strokeColor
					}));
				},this);

			},this);

			this.buildScale(data.labels);

			
			if (this.options.barBeginAtOrigin && this.scale.min < 0) {
			    this.BarClass.prototype.base = (parseFloat(this.scale.max) /
				((this.scale.max - this.scale.min) * 1.00) *
				(this.scale.endPoint - this.scale.startPoint) +
				this.scale.startPoint);
			} else {
			    this.BarClass.prototype.base = this.scale.endPoint;
			}

			this.eachBars(function(bar, index, datasetIndex){
				helpers.extend(bar, {
					width : this.scale.calculateBarWidth(this.datasets.length),
					x: this.scale.calculateBarX(this.datasets.length, datasetIndex, index),
					y: bar.base
				});
				bar.save();
			}, this);

			this.render();
		},
		update : function(){
			this.scale.update();
			// Reset any highlight colours before updating.
			helpers.each(this.activeElements, function(activeElement){
				activeElement.restore(['fillColor', 'strokeColor']);
			});

			this.eachBars(function(bar){
				bar.save();
			});
			this.render();
		},
		eachBars : function(callback){
			helpers.each(this.datasets,function(dataset, datasetIndex){
				helpers.each(dataset.bars, callback, this, datasetIndex);
			},this);
		},
		getBarsAtEvent : function(e){
			var barsArray = [],
				eventPosition = helpers.getRelativePosition(e),
				datasetIterator = function(dataset){
					barsArray.push(dataset.bars[barIndex]);
				},
				barIndex;

			for (var datasetIndex = 0; datasetIndex < this.datasets.length; datasetIndex++) {
				for (barIndex = 0; barIndex < this.datasets[datasetIndex].bars.length; barIndex++) {
					if (this.datasets[datasetIndex].bars[barIndex].inRange(eventPosition.x,eventPosition.y)){
						helpers.each(this.datasets, datasetIterator);
						return barsArray;
					}
				}
			}

			return barsArray;
		},
		buildScale : function(labels){
			var self = this;

			var dataTotal = function(){
				var values = [];
				self.eachBars(function(bar){
					values.push(bar.value);
				});
				return values;
			};

			var scaleOptions = {
				templateString : this.options.scaleLabel,
				height : this.chart.height,
				width : this.chart.width,
				ctx : this.chart.ctx,
				textColor : this.options.scaleFontColor,
				fontSize : this.options.scaleFontSize,
				fontStyle : this.options.scaleFontStyle,
				fontFamily : this.options.scaleFontFamily,
				valuesCount : labels.length,
				beginAtZero: this.options.scaleBeginAtZero,
				beginAtOrigin: this.options.barBeginAtOrigin,
				integersOnly : this.options.scaleIntegersOnly,
				calculateYRange: function(currentHeight){
					var updatedRanges = helpers.calculateScaleRange(
						dataTotal(),
						currentHeight,
						this.fontSize,
						this.beginAtZero,
						this.integersOnly
					);
					helpers.extend(this, updatedRanges);
				},
				xLabels : labels,
				font : helpers.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
				lineWidth : this.options.scaleLineWidth,
				lineColor : this.options.scaleLineColor,
				showHorizontalLines : this.options.scaleShowHorizontalLines,
				showVerticalLines : this.options.scaleShowVerticalLines,
				gridLineWidth : (this.options.scaleShowGridLines) ? this.options.scaleGridLineWidth : 0,
				gridLineColor : (this.options.scaleShowGridLines) ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
				padding : (this.options.showScale) ? 0 : (this.options.barShowStroke) ? this.options.barStrokeWidth : 0,
				showLabels : this.options.scaleShowLabels,
				display : this.options.showScale
			};

			if (this.options.scaleOverride){
				helpers.extend(scaleOptions, {
					calculateYRange: helpers.noop,
					steps: this.options.scaleSteps,
					stepValue: this.options.scaleStepWidth,
					min: this.options.scaleStartValue,
					max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
				});
			}

			this.scale = new this.ScaleClass(scaleOptions);
		},
		addData : function(valuesArray,label){
			//Map the values array for each of the datasets
			helpers.each(valuesArray,function(value,datasetIndex){
				//Add a new point for each piece of data, passing any required data to draw.
				this.datasets[datasetIndex].bars.push(new this.BarClass({
					value : value,
					label : label,
					datasetLabel: this.datasets[datasetIndex].label,
					x: this.scale.calculateBarX(this.datasets.length, datasetIndex, this.scale.valuesCount+1),
					y: this.scale.endPoint,
					width : this.scale.calculateBarWidth(this.datasets.length),
					base : this.scale.endPoint,
					strokeColor : this.datasets[datasetIndex].strokeColor,
					fillColor : this.datasets[datasetIndex].fillColor
				}));
			},this);

			this.scale.addXLabel(label);
			//Then re-render the chart.
			this.update();
		},
		removeData : function(){
			this.scale.removeXLabel();
			//Then re-render the chart.
			helpers.each(this.datasets,function(dataset){
				dataset.bars.shift();
			},this);
			this.update();
		},
		reflow : function(){
			helpers.extend(this.BarClass.prototype,{
				y: this.scale.endPoint,
				base : this.scale.endPoint
			});
			var newScaleProps = helpers.extend({
				height : this.chart.height,
				width : this.chart.width
			});
			this.scale.update(newScaleProps);
		},
		draw : function(ease){
			var easingDecimal = ease || 1;
			this.clear();

			var ctx = this.chart.ctx;

			this.scale.draw(easingDecimal);

			//Draw all the bars for each dataset
			helpers.each(this.datasets,function(dataset,datasetIndex){
				helpers.each(dataset.bars,function(bar,index){
					if (bar.hasValue()){
					    
					    if (this.options.barBeginAtOrigin && this.scale.min < 0) {
					        helpers.noop();
					    }
					    else {
					        bar.base = this.scale.endPoint;
					    }
						//Transition then draw
						bar.transition({
							x : this.scale.calculateBarX(this.datasets.length, datasetIndex, index),
							y : this.scale.calculateY(bar.value),
							width : this.scale.calculateBarWidth(this.datasets.length)
						}, easingDecimal).draw();
					}
				},this);

			},this);
		}
	});


}).call(this);



(function(){
	"use strict";

	var root = this,
		Chart = root.Chart,
		//Cache a local reference to Chart.helpers
		helpers = Chart.helpers;

	var defaultConfig = {
		//Boolean - Whether we should show a stroke on each segment
		segmentShowStroke : true,

		//String - The colour of each segment stroke
		segmentStrokeColor : "#fff",

		//Number - The width of each segment stroke
		segmentStrokeWidth : 2,

		//The percentage of the chart that we cut out of the middle.
		percentageInnerCutout : 50,

		//Number - Amount of animation steps
		animationSteps : 100,

		//String - Animation easing effect
		animationEasing : "easeOutBounce",

		//Boolean - Whether we animate the rotation of the Doughnut
		animateRotate : true,

		//Boolean - Whether we animate scaling the Doughnut from the centre
		animateScale : false,

		//String - A legend template
		legendTemplate : "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<segments.length; i++){%><li><span style=\"background-color:<%=segments[i].fillColor%>\"><%if(segments[i].label){%><%=segments[i].label%><%}%></span></li><%}%></ul>"

	};

	Chart.Type.extend({
		//Passing in a name registers this chart in the Chart namespace
		name: "Doughnut",
		//Providing a defaults will also register the deafults in the chart namespace
		defaults : defaultConfig,
		//Initialize is fired when the chart is initialized - Data is passed in as a parameter
		//Config is automatically merged by the core of Chart.js, and is available at this.options
		initialize:  function(data){

			//Declare segments as a static property to prevent inheriting across the Chart type prototype
			this.segments = [];
			this.outerRadius = (helpers.min([this.chart.width,this.chart.height]) -	this.options.segmentStrokeWidth/2)/2;

			this.SegmentArc = Chart.Arc.extend({
				ctx : this.chart.ctx,
				x : this.chart.width/2,
				y : this.chart.height/2
			});

			//Set up tooltip events on the chart
			if (this.options.showTooltips){
				helpers.bindEvents(this, this.options.tooltipEvents, function(evt){
					var activeSegments = (evt.type !== 'mouseout') ? this.getSegmentsAtEvent(evt) : [];

					helpers.each(this.segments,function(segment){
						segment.restore(["fillColor"]);
					});
					helpers.each(activeSegments,function(activeSegment){
						activeSegment.fillColor = activeSegment.highlightColor;
					});
					this.showTooltip(activeSegments);
				});
			}
			this.calculateTotal(data);

			helpers.each(data,function(datapoint, index){
				if (!datapoint.color) {
					datapoint.color = 'hsl(' + (360 * index / data.length) + ', 100%, 50%)';
				}
				this.addData(datapoint, index, true);
			},this);

			this.render();
		},
		getSegmentsAtEvent : function(e){
			var segmentsArray = [];

			var location = helpers.getRelativePosition(e);

			helpers.each(this.segments,function(segment){
				if (segment.inRange(location.x,location.y)) segmentsArray.push(segment);
			},this);
			return segmentsArray;
		},
		addData : function(segment, atIndex, silent){
			var index = atIndex || this.segments.length;
			this.segments.splice(index, 0, new this.SegmentArc({
				value : segment.value,
				outerRadius : (this.options.animateScale) ? 0 : this.outerRadius,
				innerRadius : (this.options.animateScale) ? 0 : (this.outerRadius/100) * this.options.percentageInnerCutout,
				fillColor : segment.color,
				highlightColor : segment.highlight || segment.color,
				showStroke : this.options.segmentShowStroke,
				strokeWidth : this.options.segmentStrokeWidth,
				strokeColor : this.options.segmentStrokeColor,
				startAngle : Math.PI * 1.5,
				circumference : (this.options.animateRotate) ? 0 : this.calculateCircumference(segment.value),
				label : segment.label
			}));
			if (!silent){
				this.reflow();
				this.update();
			}
		},
		calculateCircumference : function(value) {
			if ( this.total > 0 ) {
				return (Math.PI*2)*(value / this.total);
			} else {
				return 0;
			}
		},
		calculateTotal : function(data){
			this.total = 0;
			helpers.each(data,function(segment){
				this.total += Math.abs(segment.value);
			},this);
		},
		update : function(){
			this.calculateTotal(this.segments);

			// Reset any highlight colours before updating.
			helpers.each(this.activeElements, function(activeElement){
				activeElement.restore(['fillColor']);
			});

			helpers.each(this.segments,function(segment){
				segment.save();
			});
			this.render();
		},

		removeData: function(atIndex){
			var indexToDelete = (helpers.isNumber(atIndex)) ? atIndex : this.segments.length-1;
			this.segments.splice(indexToDelete, 1);
			this.reflow();
			this.update();
		},

		reflow : function(){
			helpers.extend(this.SegmentArc.prototype,{
				x : this.chart.width/2,
				y : this.chart.height/2
			});
			this.outerRadius = (helpers.min([this.chart.width,this.chart.height]) -	this.options.segmentStrokeWidth/2)/2;
			helpers.each(this.segments, function(segment){
				segment.update({
					outerRadius : this.outerRadius,
					innerRadius : (this.outerRadius/100) * this.options.percentageInnerCutout
				});
			}, this);
		},
		draw : function(easeDecimal){
			var animDecimal = (easeDecimal) ? easeDecimal : 1;
			this.clear();
			helpers.each(this.segments,function(segment,index){
				segment.transition({
					circumference : this.calculateCircumference(segment.value),
					outerRadius : this.outerRadius,
					innerRadius : (this.outerRadius/100) * this.options.percentageInnerCutout
				},animDecimal);

				segment.endAngle = segment.startAngle + segment.circumference;

				segment.draw();
				if (index === 0){
					segment.startAngle = Math.PI * 1.5;
				}
				//Check to see if it's the last segment, if not get the next and update the start angle
				if (index < this.segments.length-1){
					this.segments[index+1].startAngle = segment.endAngle;
				}
			},this);
			this.options.onAnimationComplete.call(this);
		}
	});

	Chart.types.Doughnut.extend({
		name : "Pie",
		defaults : helpers.merge(defaultConfig,{percentageInnerCutout : 0})
	});

}).call(this);



Chart.types.Line.extend({
    name: "LineToday",
    initialize: function () {
        var originalDatasets = null;
        var originalLabels = null;
        if (arguments.length == 0) {
            arguments[0] = {};
            arguments[0].datasets = this.originalDatasets;
            arguments[0].labels = this.originalLabels;
            arguments[0].lineTodayAtIndex = this.lineTodayAtIndex;
            arguments[0].lineTodayColor = this.lineTodayColor;
            arguments.length = 1;
        }
        else {
            originalDatasets = arguments[0].datasets;
            originalLabels = arguments[0].labels;
        }
        var newdataSets = [];
        for (i = 0; i < arguments[0].datasets.length; i++) {
            if (arguments[0].datasets[i].hide != null && arguments[0].datasets[i].hide)
                continue;
            newdataSets[newdataSets.length] = arguments[0].datasets[i];
        };
        arguments[0].datasets = newdataSets;
        Chart.types.Line.prototype.initialize.apply(this, arguments);
        this.lineTodayAtIndex = arguments[0].lineTodayAtIndex;
        this.lineTodayColor = arguments[0].lineTodayColor;
        if (originalDatasets != null) {
            this.originalDatasets = originalDatasets;
            this.originalLabels = originalLabels;
        }
    },
    drawLineToday: function () {
        if (this.lineTodayAtIndex == null)
            return;

        var ctx = this.chart.ctx;
        var scale = this.scale;

        // draw line today
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.strokeStyle = this.lineTodayColor == null ? '#00b000' : this.lineTodayColor;
        ctx.moveTo(scale.calculateX(this.lineTodayAtIndex), scale.startPoint - 3);
        ctx.lineTo(scale.calculateX(this.lineTodayAtIndex), scale.endPoint + 5);
        ctx.stroke();
    },
    draw: function () {
        Chart.types.Line.prototype.draw.apply(this, arguments);
        this.drawLineToday();
    },
});


Chart.types.Line.extend({
    name: "LineBarToday",
    initialize: function () {
        var originalDatasets = null;
        var originalLabels = null;
        if (arguments.length == 0) {
            arguments[0] = {};
            arguments[0].datasets = this.originalDatasets;
            arguments[0].labels = this.originalLabels;
            arguments[0].lineTodayAtIndex = this.lineTodayAtIndex;
            arguments[0].lineTodayColor = this.lineTodayColor;
            arguments.length = 1;
        }
        else {
            originalDatasets = arguments[0].datasets;
            originalLabels = arguments[0].labels;
        }
        var newdataSets = [];
        for (var i = 0; i < arguments[0].datasets.length; i++) {
            if (arguments[0].datasets[i].hide != null && arguments[0].datasets[i].hide)
                continue;
            newdataSets[newdataSets.length] = arguments[0].datasets[i];
        };
        arguments[0].datasets = newdataSets;
        Chart.types.Line.prototype.initialize.apply(this, arguments);
        this.lineTodayAtIndex = arguments[0].lineTodayAtIndex;
        this.lineTodayColor = arguments[0].lineTodayColor;
        if (originalDatasets != null) {
            this.originalDatasets = originalDatasets;
            this.originalLabels = originalLabels;
        }
    },
    drawLineToday: function () {
        if (this.lineTodayAtIndex == null)
            return;

        var ctx = this.chart.ctx;
        var scale = this.scale;

        // draw line today
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.strokeStyle = this.lineTodayColor == null ? '#00b000' : this.lineTodayColor;
        ctx.moveTo(scale.calculateX(this.lineTodayAtIndex), scale.startPoint - 3);
        ctx.lineTo(scale.calculateX(this.lineTodayAtIndex), scale.endPoint + 5);
        ctx.stroke();
    },
    drawNullLine: function () {
        var ctx = this.chart.ctx;
        var scale = this.scale;
        var options = this.options;
        
        // draw line null
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.strokeStyle = options.scaleGridLineColor;
        ctx.moveTo(Math.round(scale.xScalePaddingLeft) - 5, scale.calculateY(0));
        ctx.lineTo(scale.width, scale.calculateY(0));
        ctx.stroke();
    },
    draw: function (ease) {
        var helpers = Chart.helpers;
        var scale = this.scale;

        var easingDecimal = ease || 1;
        this.clear();

        var ctx = this.chart.ctx;

        // Some helper methods for getting the next/prev points
        var hasValue = function (item) {
            return item.value !== null;
        };

        if (scale != null)
            scale.draw(easingDecimal);


        this.drawNullLine();
        this.drawLineToday();
        
        helpers.each(this.datasets, function (dataset) {
            var originalDataset = null;
            for (var i = 0; i < this.originalDatasets.length; i++) {
                if (dataset.label == this.originalDatasets[i].label) {
                    originalDataset = this.originalDatasets[i];
                    break;
                }
            }


            var pointsWithValues = helpers.where(dataset.points, hasValue);

            //Transition each point first so that the line and point drawing isn't out of sync
            //We can use this extra loop to calculate the control points of this dataset also in this loop

            helpers.each(dataset.points, function (point, index) {
                if (point.hasValue()) {
                    point.transition({
                        y: scale.calculateY(point.value),
                        x: scale.calculateX(index)
                    }, easingDecimal);
                }
            }, this);

            
            var y0 = ((scale.calculateY(0) - dataset.points[0]._saved["y"]) * easingDecimal) + dataset.points[0]._saved["y"];

            //Draw the line between all the points
            ctx.lineWidth = this.options.datasetStrokeWidth;
            ctx.strokeStyle = dataset.strokeColor;
            ctx.beginPath();

            var isImpulse = originalDataset == null ? false : originalDataset.impulse;

            helpers.each(pointsWithValues, function (point, index) {
                if (index === 0 && !isImpulse) {
                    ctx.moveTo(point.x, point.y);
                }
                else {
                    if (dataset.dashStyle instanceof Array) {
                        //helpers.drawDashedLine(ctx, dataset.points[index - 1].x, dataset.points[index - 1].y, point.x, point.y, dataset.dashStyle);
                        if (isImpulse) {
                            if (dataset.points[index].value != 0) {
                                helpers.drawDashedLine(ctx, point.x, y0, point.x, point.y, dataset.dashStyle);
                            }
                        } else {
                            helpers.drawDashedLine(ctx, dataset.points[index - 1].x, dataset.points[index - 1].y, point.x, dataset.points[index - 1].y, dataset.dashStyle);
                            helpers.drawDashedLine(ctx, point.x, dataset.points[index - 1].y, point.x, point.y, dataset.dashStyle);
                        }
                    } else {
                        //ctx.lineTo(point.x, point.y);
                        if (isImpulse) {
                            if (dataset.points[index].value != 0) {
                                ctx.moveTo(point.x, y0);
                                ctx.lineTo(point.x, point.y);
                            }
                        } else {
                            ctx.lineTo(point.x, dataset.points[index - 1].y);
                            ctx.lineTo(point.x, point.y);
                        }
                    }
                }
            }, this);

            ctx.stroke();

            //Draw the candles from the base to the point
            if (this.options.candles) {
                ctx.lineWidth = this.options.candleStrokeWidth;
                ctx.strokeStyle = dataset.candleStrokeColor;
                helpers.each(dataset.points, function(point, index) {
                    ctx.beginPath();
                    ctx.moveTo(point.x, scale.endPoint);
                    ctx.lineTo(point.x, point.y);
                    ctx.stroke();
                }, this);
            }
            //Now draw the points over the line
            //A little inefficient double looping, but better than the line
            //lagging behind the point positions
            helpers.each(pointsWithValues, function (point) {
                point.draw();
            });
        }, this);
    },
});


/* jstz.min.js Version: 1.0.6 Build date: 2015-11-04 */
!function(e){var a=function(){"use strict";var e="s",s={DAY:864e5,HOUR:36e5,MINUTE:6e4,SECOND:1e3,BASELINE_YEAR:2014,MAX_SCORE:864e6,AMBIGUITIES:{"America/Denver":["America/Mazatlan"],"Europe/London":["Africa/Casablanca"],"America/Chicago":["America/Mexico_City"],"America/Asuncion":["America/Campo_Grande","America/Santiago"],"America/Montevideo":["America/Sao_Paulo","America/Santiago"],"Asia/Beirut":["Asia/Amman","Asia/Jerusalem","Europe/Helsinki","Asia/Damascus","Africa/Cairo","Asia/Gaza","Europe/Minsk"],"Pacific/Auckland":["Pacific/Fiji"],"America/Los_Angeles":["America/Santa_Isabel"],"America/New_York":["America/Havana"],"America/Halifax":["America/Goose_Bay"],"America/Godthab":["America/Miquelon"],"Asia/Dubai":["Asia/Yerevan"],"Asia/Jakarta":["Asia/Krasnoyarsk"],"Asia/Shanghai":["Asia/Irkutsk","Australia/Perth"],"Australia/Sydney":["Australia/Lord_Howe"],"Asia/Tokyo":["Asia/Yakutsk"],"Asia/Dhaka":["Asia/Omsk"],"Asia/Baku":["Asia/Yerevan"],"Australia/Brisbane":["Asia/Vladivostok"],"Pacific/Noumea":["Asia/Vladivostok"],"Pacific/Majuro":["Asia/Kamchatka","Pacific/Fiji"],"Pacific/Tongatapu":["Pacific/Apia"],"Asia/Baghdad":["Europe/Minsk","Europe/Moscow"],"Asia/Karachi":["Asia/Yekaterinburg"],"Africa/Johannesburg":["Asia/Gaza","Africa/Cairo"]}},i=function(e){var a=-e.getTimezoneOffset();return null!==a?a:0},r=function(){var a=i(new Date(s.BASELINE_YEAR,0,2)),r=i(new Date(s.BASELINE_YEAR,5,2)),n=a-r;return 0>n?a+",1":n>0?r+",1,"+e:a+",0"},n=function(){var e,a;if("undefined"!=typeof Intl&&"undefined"!=typeof Intl.DateTimeFormat&&(e=Intl.DateTimeFormat(),"undefined"!=typeof e&&"undefined"!=typeof e.resolvedOptions))return a=e.resolvedOptions().timeZone,a&&(a.indexOf("/")>-1||"UTC"===a)?a:void 0},o=function(e){for(var a=new Date(e,0,1,0,0,1,0).getTime(),s=new Date(e,12,31,23,59,59).getTime(),i=a,r=new Date(i).getTimezoneOffset(),n=null,o=null;s-864e5>i;){var t=new Date(i),A=t.getTimezoneOffset();A!==r&&(r>A&&(n=t),A>r&&(o=t),r=A),i+=864e5}return n&&o?{s:u(n).getTime(),e:u(o).getTime()}:!1},u=function l(e,a,i){"undefined"==typeof a&&(a=s.DAY,i=s.HOUR);for(var r=new Date(e.getTime()-a).getTime(),n=e.getTime()+a,o=new Date(r).getTimezoneOffset(),u=r,t=null;n-i>u;){var A=new Date(u),c=A.getTimezoneOffset();if(c!==o){t=A;break}u+=i}return a===s.DAY?l(t,s.HOUR,s.MINUTE):a===s.HOUR?l(t,s.MINUTE,s.SECOND):t},t=function(e,a,s,i){if("N/A"!==s)return s;if("Asia/Beirut"===a){if("Africa/Cairo"===i.name&&13983768e5===e[6].s&&14116788e5===e[6].e)return 0;if("Asia/Jerusalem"===i.name&&13959648e5===e[6].s&&14118588e5===e[6].e)return 0}else if("America/Santiago"===a){if("America/Asuncion"===i.name&&14124816e5===e[6].s&&1397358e6===e[6].e)return 0;if("America/Campo_Grande"===i.name&&14136912e5===e[6].s&&13925196e5===e[6].e)return 0}else if("America/Montevideo"===a){if("America/Sao_Paulo"===i.name&&14136876e5===e[6].s&&1392516e6===e[6].e)return 0}else if("Pacific/Auckland"===a&&"Pacific/Fiji"===i.name&&14142456e5===e[6].s&&13961016e5===e[6].e)return 0;return s},A=function(e,i){for(var r=function(a){for(var r=0,n=0;n<e.length;n++)if(a.rules[n]&&e[n]){if(!(e[n].s>=a.rules[n].s&&e[n].e<=a.rules[n].e)){r="N/A";break}if(r=0,r+=Math.abs(e[n].s-a.rules[n].s),r+=Math.abs(a.rules[n].e-e[n].e),r>s.MAX_SCORE){r="N/A";break}}return r=t(e,i,r,a)},n={},o=a.olson.dst_rules.zones,u=o.length,A=s.AMBIGUITIES[i],c=0;u>c;c++){var m=o[c],l=r(o[c]);"N/A"!==l&&(n[m.name]=l)}for(var f in n)if(n.hasOwnProperty(f))for(var d=0;d<A.length;d++)if(A[d]===f)return f;return i},c=function(e){var s=function(){for(var e=[],s=0;s<a.olson.dst_rules.years.length;s++){var i=o(a.olson.dst_rules.years[s]);e.push(i)}return e},i=function(e){for(var a=0;a<e.length;a++)if(e[a]!==!1)return!0;return!1},r=s(),n=i(r);return n?A(r,e):e},m=function(){var e=n();return e||(e=a.olson.timezones[r()],"undefined"!=typeof s.AMBIGUITIES[e]&&(e=c(e))),{name:function(){return e}}};return{determine:m}}();a.olson=a.olson||{},a.olson.timezones={"-720,0":"Etc/GMT+12","-660,0":"Pacific/Pago_Pago","-660,1,s":"Pacific/Apia","-600,1":"America/Adak","-600,0":"Pacific/Honolulu","-570,0":"Pacific/Marquesas","-540,0":"Pacific/Gambier","-540,1":"America/Anchorage","-480,1":"America/Los_Angeles","-480,0":"Pacific/Pitcairn","-420,0":"America/Phoenix","-420,1":"America/Denver","-360,0":"America/Guatemala","-360,1":"America/Chicago","-360,1,s":"Pacific/Easter","-300,0":"America/Bogota","-300,1":"America/New_York","-270,0":"America/Caracas","-240,1":"America/Halifax","-240,0":"America/Santo_Domingo","-240,1,s":"America/Asuncion","-210,1":"America/St_Johns","-180,1":"America/Godthab","-180,0":"America/Argentina/Buenos_Aires","-180,1,s":"America/Montevideo","-120,0":"America/Noronha","-120,1":"America/Noronha","-60,1":"Atlantic/Azores","-60,0":"Atlantic/Cape_Verde","0,0":"UTC","0,1":"Europe/London","60,1":"Europe/Berlin","60,0":"Africa/Lagos","60,1,s":"Africa/Windhoek","120,1":"Asia/Beirut","120,0":"Africa/Johannesburg","180,0":"Asia/Baghdad","180,1":"Europe/Moscow","210,1":"Asia/Tehran","240,0":"Asia/Dubai","240,1":"Asia/Baku","270,0":"Asia/Kabul","300,1":"Asia/Yekaterinburg","300,0":"Asia/Karachi","330,0":"Asia/Kolkata","345,0":"Asia/Kathmandu","360,0":"Asia/Dhaka","360,1":"Asia/Omsk","390,0":"Asia/Rangoon","420,1":"Asia/Krasnoyarsk","420,0":"Asia/Jakarta","480,0":"Asia/Shanghai","480,1":"Asia/Irkutsk","525,0":"Australia/Eucla","525,1,s":"Australia/Eucla","540,1":"Asia/Yakutsk","540,0":"Asia/Tokyo","570,0":"Australia/Darwin","570,1,s":"Australia/Adelaide","600,0":"Australia/Brisbane","600,1":"Asia/Vladivostok","600,1,s":"Australia/Sydney","630,1,s":"Australia/Lord_Howe","660,1":"Asia/Kamchatka","660,0":"Pacific/Noumea","690,0":"Pacific/Norfolk","720,1,s":"Pacific/Auckland","720,0":"Pacific/Majuro","765,1,s":"Pacific/Chatham","780,0":"Pacific/Tongatapu","780,1,s":"Pacific/Apia","840,0":"Pacific/Kiritimati"},a.olson.dst_rules={years:[2008,2009,2010,2011,2012,2013,2014],zones:[{name:"Africa/Cairo",rules:[{e:12199572e5,s:12090744e5},{e:1250802e6,s:1240524e6},{e:12858804e5,s:12840696e5},!1,!1,!1,{e:14116788e5,s:1406844e6}]},{name:"Africa/Casablanca",rules:[{e:12202236e5,s:12122784e5},{e:12508092e5,s:12438144e5},{e:1281222e6,s:12727584e5},{e:13120668e5,s:13017888e5},{e:13489704e5,s:1345428e6},{e:13828392e5,s:13761e8},{e:14142888e5,s:14069448e5}]},{name:"America/Asuncion",rules:[{e:12050316e5,s:12243888e5},{e:12364812e5,s:12558384e5},{e:12709548e5,s:12860784e5},{e:13024044e5,s:1317528e6},{e:1333854e6,s:13495824e5},{e:1364094e6,s:1381032e6},{e:13955436e5,s:14124816e5}]},{name:"America/Campo_Grande",rules:[{e:12032172e5,s:12243888e5},{e:12346668e5,s:12558384e5},{e:12667212e5,s:1287288e6},{e:12981708e5,s:13187376e5},{e:13302252e5,s:1350792e6},{e:136107e7,s:13822416e5},{e:13925196e5,s:14136912e5}]},{name:"America/Goose_Bay",rules:[{e:122559486e4,s:120503526e4},{e:125704446e4,s:123648486e4},{e:128909886e4,s:126853926e4},{e:13205556e5,s:129998886e4},{e:13520052e5,s:13314456e5},{e:13834548e5,s:13628952e5},{e:14149044e5,s:13943448e5}]},{name:"America/Havana",rules:[{e:12249972e5,s:12056436e5},{e:12564468e5,s:12364884e5},{e:12885012e5,s:12685428e5},{e:13211604e5,s:13005972e5},{e:13520052e5,s:13332564e5},{e:13834548e5,s:13628916e5},{e:14149044e5,s:13943412e5}]},{name:"America/Mazatlan",rules:[{e:1225008e6,s:12074724e5},{e:12564576e5,s:1238922e6},{e:1288512e6,s:12703716e5},{e:13199616e5,s:13018212e5},{e:13514112e5,s:13332708e5},{e:13828608e5,s:13653252e5},{e:14143104e5,s:13967748e5}]},{name:"America/Mexico_City",rules:[{e:12250044e5,s:12074688e5},{e:1256454e6,s:12389184e5},{e:12885084e5,s:1270368e6},{e:1319958e6,s:13018176e5},{e:13514076e5,s:13332672e5},{e:13828572e5,s:13653216e5},{e:14143068e5,s:13967712e5}]},{name:"America/Miquelon",rules:[{e:12255984e5,s:12050388e5},{e:1257048e6,s:12364884e5},{e:12891024e5,s:12685428e5},{e:1320552e6,s:12999924e5},{e:13520016e5,s:1331442e6},{e:13834512e5,s:13628916e5},{e:14149008e5,s:13943412e5}]},{name:"America/Santa_Isabel",rules:[{e:12250116e5,s:1207476e6},{e:12564612e5,s:12389256e5},{e:12885156e5,s:12703752e5},{e:13199652e5,s:13018248e5},{e:13514148e5,s:13332744e5},{e:13828644e5,s:13653288e5},{e:1414314e6,s:13967784e5}]},{name:"America/Santiago",rules:[{e:1206846e6,s:1223784e6},{e:1237086e6,s:12552336e5},{e:127035e7,s:12866832e5},{e:13048236e5,s:13138992e5},{e:13356684e5,s:13465584e5},{e:1367118e6,s:13786128e5},{e:13985676e5,s:14100624e5}]},{name:"America/Sao_Paulo",rules:[{e:12032136e5,s:12243852e5},{e:12346632e5,s:12558348e5},{e:12667176e5,s:12872844e5},{e:12981672e5,s:1318734e6},{e:13302216e5,s:13507884e5},{e:13610664e5,s:1382238e6},{e:1392516e6,s:14136876e5}]},{name:"Asia/Amman",rules:[{e:1225404e6,s:12066552e5},{e:12568536e5,s:12381048e5},{e:12883032e5,s:12695544e5},{e:13197528e5,s:13016088e5},!1,!1,{e:14147064e5,s:13959576e5}]},{name:"Asia/Damascus",rules:[{e:12254868e5,s:120726e7},{e:125685e7,s:12381048e5},{e:12882996e5,s:12701592e5},{e:13197492e5,s:13016088e5},{e:13511988e5,s:13330584e5},{e:13826484e5,s:1364508e6},{e:14147028e5,s:13959576e5}]},{name:"Asia/Dubai",rules:[!1,!1,!1,!1,!1,!1,!1]},{name:"Asia/Gaza",rules:[{e:12199572e5,s:12066552e5},{e:12520152e5,s:12381048e5},{e:1281474e6,s:126964086e4},{e:1312146e6,s:130160886e4},{e:13481784e5,s:13330584e5},{e:13802292e5,s:1364508e6},{e:1414098e6,s:13959576e5}]},{name:"Asia/Irkutsk",rules:[{e:12249576e5,s:12068136e5},{e:12564072e5,s:12382632e5},{e:12884616e5,s:12697128e5},!1,!1,!1,!1]},{name:"Asia/Jerusalem",rules:[{e:12231612e5,s:12066624e5},{e:1254006e6,s:1238112e6},{e:1284246e6,s:12695616e5},{e:131751e7,s:1301616e6},{e:13483548e5,s:13330656e5},{e:13828284e5,s:13645152e5},{e:1414278e6,s:13959648e5}]},{name:"Asia/Kamchatka",rules:[{e:12249432e5,s:12067992e5},{e:12563928e5,s:12382488e5},{e:12884508e5,s:12696984e5},!1,!1,!1,!1]},{name:"Asia/Krasnoyarsk",rules:[{e:12249612e5,s:12068172e5},{e:12564108e5,s:12382668e5},{e:12884652e5,s:12697164e5},!1,!1,!1,!1]},{name:"Asia/Omsk",rules:[{e:12249648e5,s:12068208e5},{e:12564144e5,s:12382704e5},{e:12884688e5,s:126972e7},!1,!1,!1,!1]},{name:"Asia/Vladivostok",rules:[{e:12249504e5,s:12068064e5},{e:12564e8,s:1238256e6},{e:12884544e5,s:12697056e5},!1,!1,!1,!1]},{name:"Asia/Yakutsk",rules:[{e:1224954e6,s:120681e7},{e:12564036e5,s:12382596e5},{e:1288458e6,s:12697092e5},!1,!1,!1,!1]},{name:"Asia/Yekaterinburg",rules:[{e:12249684e5,s:12068244e5},{e:1256418e6,s:1238274e6},{e:12884724e5,s:12697236e5},!1,!1,!1,!1]},{name:"Asia/Yerevan",rules:[{e:1224972e6,s:1206828e6},{e:12564216e5,s:12382776e5},{e:1288476e6,s:12697272e5},{e:13199256e5,s:13011768e5},!1,!1,!1]},{name:"Australia/Lord_Howe",rules:[{e:12074076e5,s:12231342e5},{e:12388572e5,s:12545838e5},{e:12703068e5,s:12860334e5},{e:13017564e5,s:1317483e6},{e:1333206e6,s:13495374e5},{e:13652604e5,s:1380987e6},{e:139671e7,s:14124366e5}]},{name:"Australia/Perth",rules:[{e:12068136e5,s:12249576e5},!1,!1,!1,!1,!1,!1]},{name:"Europe/Helsinki",rules:[{e:12249828e5,s:12068388e5},{e:12564324e5,s:12382884e5},{e:12884868e5,s:1269738e6},{e:13199364e5,s:13011876e5},{e:1351386e6,s:13326372e5},{e:13828356e5,s:13646916e5},{e:14142852e5,s:13961412e5}]},{name:"Europe/Minsk",rules:[{e:12249792e5,s:12068352e5},{e:12564288e5,s:12382848e5},{e:12884832e5,s:12697344e5},!1,!1,!1,!1]},{name:"Europe/Moscow",rules:[{e:12249756e5,s:12068316e5},{e:12564252e5,s:12382812e5},{e:12884796e5,s:12697308e5},!1,!1,!1,!1]},{name:"Pacific/Apia",rules:[!1,!1,!1,{e:13017528e5,s:13168728e5},{e:13332024e5,s:13489272e5},{e:13652568e5,s:13803768e5},{e:13967064e5,s:14118264e5}]},{name:"Pacific/Fiji",rules:[!1,!1,{e:12696984e5,s:12878424e5},{e:13271544e5,s:1319292e6},{e:1358604e6,s:13507416e5},{e:139005e7,s:1382796e6},{e:14215032e5,s:14148504e5}]},{name:"Europe/London",rules:[{e:12249828e5,s:12068388e5},{e:12564324e5,s:12382884e5},{e:12884868e5,s:1269738e6},{e:13199364e5,s:13011876e5},{e:1351386e6,s:13326372e5},{e:13828356e5,s:13646916e5},{e:14142852e5,s:13961412e5}]}]},"undefined"!=typeof module&&"undefined"!=typeof module.exports?module.exports=a:"undefined"!=typeof define&&null!==define&&null!=define.amd?define([],function(){return a}):"undefined"==typeof e?window.jstz=a:e.jstz=a}();


function showUserInfo(id) {
    createAndLoadWindow('UserInfoWindow', { title: SR.T("Информация о пользователе"), width: 800 }, '/Security/User/ProfileInfo/' + id);
}
function showUserGroupInfo(id) {
    createAndLoadWindow('UserGroupInfoWindow', { title: SR.T("Информация о группе"), width: 800 }, '/Security/UserGroup/ViewInfo/' + id);
}
elma.showUserInfoActions = function (show) {
    if (!show) {
        $('#UserInfo_Main').removeClass('Expanded');
    } else {
        $('#UserInfo_AdditionalInfo').width($('#UserInfo_CommonInfo').width());
        $('#UserInfo_Main').addClass('Expanded');
    }
}
elma.showOrHideUserInfoActions = function () {
    var expanded = $('#UserInfo_Main').hasClass('Expanded');
    elma.showUserInfoActions(!expanded);
}
elma.updateUserPanelState = function () {
    var toolbarRowWidth = $('#MainToolbarRow').innerWidth();
    var toolbarWidth = $('#td_toolbar').outerWidth(true);
    var userPhoto = $('#UserInfo_Photo');
    var userPanelMainWidth =
                        $('#UserInfo_Main').outerWidth()
                        - (userPhoto.css('display') != 'none' ? userPhoto.outerWidth() : 0)
                        + $('#UserInfo_Settings').outerWidth();
    var freeWidth = toolbarRowWidth - toolbarWidth - userPanelMainWidth;
    var requiredWidth = 88;
    userPhoto.css('display', freeWidth > requiredWidth ? 'table-cell' : 'none');
    //var rightWidth = freeWidth - requiredWidth - 10;
    //$('#UserInfo_Right').css('display', freeWidth > requiredWidth + 11 ? 'table-cell' : 'none');
};

function showOrgItemInfo(id) {
    createAndLoadWindow('OrgStructureInfoWindow', { title: SR.T("Список пользователей"), width: 800 }, '/Security/OrgStructure/Info/' + id);
}

$(document).ready(function () {
    elma.updateUserPanelState();
});
$(document).mousedown(function (e) {
    var expanded = $('#UserInfo_Main').hasClass('Expanded');
    if (expanded && $(e.target).parents('#UserInfo_Main').length == 0) {
        elma.showUserInfoActions(false);
    }
});
$(window).resize(function () { elma.updateUserPanelState(); });


elma.setUserCustomTimeZone = function (e, inputId) {
    if (e == null)
        return;

    var div = $("#customTimeZoneDiv_" + inputId);

    var userData = elma.EntitySelector.Manager.get(e.currentTarget.id).getSelected()[0].data();

    if (userData == null || userData.TimeZone == null) {
        div.hide();
        return;
    }

    var offset = userData.TimeZone.Offset;

    var userTimeZoneOffset = elma.timeZone.getUserOffset();
    var timeZoneDisplay = userData.TimeZoneDisplay;

    if (offset == userTimeZoneOffset) {
        div.hide();
        return;
    }

    div.html('<span class="note">' + SR.T("Часовой пояс:") + ' ' + timeZoneDisplay + "</span>");
    div.show();
}



elma.userPanelCountsUpdate = function (d) {
    elma.menuCountsUpdate(d);
};



var tinyMCE_GZ = {
    settings: {
        themes: '',
        plugins: '',
        languages: '',
        disk_cache: true,
        page_name: 'tiny_mce_gzip.ashx',
        debug: false,
        suffix: ''
    },

    cbList: [],

    init: function (s, cb, sc) {
        var t = this, n, i, nl = document.getElementsByTagName('script');

        for (n in s)
            t.settings[n] = s[n];

        s = t.settings;

        if (window.tinyMCEPreInit) {
            t.baseURL = window.tinyMCEPreInit.base;
        } else {
            for (i = 0; i < nl.length; i++) {
                n = nl[i];

                if (n.src && n.src.indexOf('tiny_mce') != -1)
                    t.baseURL = n.src.substring(0, n.src.lastIndexOf('/'));
            }
        }

        if (!t.coreLoaded)
            t.loadScripts(1, s.themes, s.plugins, s.languages, cb, sc);
        else if (!t.loaded)
            t.cbList.push({ "callback": cb, "scope": sc });
        else
            cb();
    },

    loadScripts: function (co, th, pl, la, cb, sc) {
        var t = this, x, w = window, q, c = 0, ti, s = t.settings;

        t.cbList.push({ "callback": cb, "scope": sc });

        function get(s) {
            x = 0;

            try {
                x = new ActiveXObject(s);
            } catch (s) {
            }

            return x;
        };

        // Build query string
        q = 'js=true&diskcache=' + (s.disk_cache ? 'true' : 'false') + '&core=' + (co ? 'true' : 'false') + '&suffix=' + escape(s.suffix) + '&themes=' + escape(th) + '&plugins=' + escape(pl) + '&languages=' + escape(la);

        if (co)
            t.coreLoaded = 1;

        // Send request
        x = w.XMLHttpRequest ? new XMLHttpRequest() : get('Msxml2.XMLHTTP') || get('Microsoft.XMLHTTP');
        x.overrideMimeType && x.overrideMimeType('text/javascript');
        x.open('GET', t.baseURL + '/' + s.page_name + '?' + q, !!cb);
        //		x.setRequestHeader('Content-Type', 'text/javascript');
        x.send('');

        // Handle asyncronous loading
        if (t.cbList.length > 0) {
            // Wait for response
            ti = w.setInterval(function () {
                if (x.readyState == 4 || c++ > 10000) {
                    w.clearInterval(ti);

                    if (c < 10000 && x.status == 200) {
                        t.eval(x.responseText);
                        tinymce.dom.Event.domLoaded = true;
                        for (var i = 0; i < t.cbList.length; i++) {
                            t.cbList[i]["callback"].call(t.cbList[i]["scope"] || t, x);
                        }
                        t.loaded = 1;
                    }

                    ti = x = null;
                }
            }, 10);
        } else
            t.eval(x.responseText);
    },

    start: function () {
        var t = this, each = tinymce.each, s = t.settings, ln = s.languages.split(',');

        tinymce.suffix = s.suffix;

        function load(u) {
            tinymce.ScriptLoader.markDone(window.tinyMCE.baseURI.toAbsolute(u));
        };

        // Add core languages
        each(ln, function (c) {
            if (c)
                load('langs/' + c + '.js');
        });

        // Add themes with languages
        each(s.themes.split(','), function (n) {
            if (n) {
                load('themes/' + n + '/editor_template' + s.suffix + '.js');

                each(ln, function (c) {
                    if (c)
                        load('themes/' + n + '/langs/' + c + '.js');
                });
            }
        });

        // Add plugins with languages
        each(s.plugins.split(','), function (n) {
            if (n) {
                load('plugins/' + n + '/editor_plugin' + s.suffix + '.js');

                each(ln, function (c) {
                    if (c)
                        load('plugins/' + n + '/langs/' + c + '.js');
                });
            }
        });
    },

    end: function () {
    },

    eval: function (co) {
        var se = document.createElement('script');

        // Create script
        se.type = 'text/javascript';
        se.text = co;

        // Add it to evaluate it and remove it
        (document.getElementsByTagName('head')[0] || document.documentElement).appendChild(se);
        se.parentNode.removeChild(se);
    }
};



elma.LeftMenu = function (options) {
    var width = options.width;
    var menu = jQuery('#div_main_menu');
    var menutd = jQuery('td.td_main_menu');
    var arr = jQuery('#arrow', $(".td_main_menu_splitter"));
    var tdarr = $(".td_main_menu_splitter");
    var colCls = options.collapseCss;
    var hovCls = 'hovered';
    var ccName = options.collapseCookie;
    var collapsed = options.collapsed;
    var startButtonTd = $('#page_start');
    var tdToolbar = $('td.td_toolbar');

    return {
        setWidth: function (w) {

            if (!menutd.hasClass(colCls)) {
                width = Math.ceil(w);
                menutd.width(width);
                startButtonTd.width(width);
                $("div.t-treeview", menu).width(menu.innerWidth() + 'px');
            }
        },

        resizeEvent: function () {
            $(document).trigger("resizeLayout");
            $(window).trigger("resize");
            if (!options.isMobile) {
                $.ajax({
                    url: options.saveStateUrl,
                    data: ({ Id: options.menuId, Collapsed: collapsed, Width: width }),
                    dataType: "json"
                });
            }
        },

        toggle: function () {
            if (menutd.hasClass(colCls)) {
                menutd.removeClass(colCls);
                tdToolbar.removeClass('collapsed');
                menu.width(width);
                startButtonTd.width(width);
                menutd.width(width);
                $(".ui-resizable-handle").show();
                menu.resizable("option", "maxWidth", options.maxWidth);
                menu.resizable("option", "minWidth", options.minWidth);
                arr.removeClass(colCls);
                tdarr.css("cursor", "e-resize");
                collapsed = false;
                if (options.isMobile) {
                    jQuery.cookie(ccName, '');
                }
                this.destroyTooltips();
            } else {
                menutd.addClass(colCls);
                tdToolbar.addClass('collapsed');
                menu.width(options.collapsedWidth);
                startButtonTd.width(options.collapsedWidth);
                menutd.width(options.collapsedWidth);
                $(".ui-resizable-handle").hide();
                menu.resizable("option", "maxWidth", options.collapsedWidth);
                menu.resizable("option", "minWidth", options.collapsedWidth);
                arr.addClass(colCls);
                tdarr.css("cursor", "");
                collapsed = true;
                if (options.isMobile) {
                    jQuery.cookie(ccName, 1);
                }
                this.initTooltips();
            }
            mainMenu.resizeEvent();
        },

        itemHover: function (item) {
            if (menu.hasClass(colCls)) {
                jQuery(item).addClass(hovCls);
            }
        },

        itemOut: function (item) {
            if (menu.hasClass(colCls))
                jQuery(item).removeClass(hovCls);
        },

        redraw: function () {
            $("#rootTable").height(0);
            $("#div_main_menu").height(0);
            this.toFullHeight();
        },

        toFullHeight: function () {
            var height = $(document).height() - $("#beforeRootTable").outerHeight(true) - $("#rootToolBarDiv").outerHeight(true);
            $("#rootTable").height(height);
            $("#div_main_menu").height(height);

            $('div[fullheight]').each(function (i, a) {
                var par = $(a).parent();
                var prevPar = $(a);
                while (par && (par.attr("height") == null) && (par[0].style.height == "")) {
                    prevPar = par;
                    par = $(par).parent();
                }
                if (par) {
                    var prevElementHeight = 0;
                    prevPar.prevAll().each(function (y, c) {
                        prevElementHeight += $(c).outerHeight(true);
                    });
                    $(a).height(par.innerHeight() - prevElementHeight - 25);
                }
            });
        },

        initTooltips: function () {
            elma.initQTip(menu.find('[left-menu-tooltip]'), null, 'left-menu-tooltip');
        },

        destroyTooltips: function () {
            menu.find('[left-menu-tooltip]').each(function (i, e) {
                var qtipData = $(e).data('qtip');
                if (qtipData) {
                    qtipData.destroy();
                }
            });
        },

        init: function () {
            var thisMenu = this;
            $("#div_main_menu").resizable({
                maxWidth: options.maxWidth,
                minWidth: options.minWidth,
                handles: 'e',
                helper: 'main_menu_splitter_drag',
                stop: function (event, ui) {
                    thisMenu.setWidth(ui.size.width);
                    thisMenu.resizeEvent();
                }
            });

            if (menutd.hasClass(colCls)) {
                menu.resizable("option", "maxWidth", options.collapsedWidth);
                menu.resizable("option", "minWidth", options.collapsedWidth);
                tdarr.css("cursor", "");
            }
            $("div.t-treeview", menu).width(width);

            $(window).resize(this.toFullHeight);
            $(document).ready(function () {
                thisMenu.toFullHeight();
                if (collapsed) {
                    thisMenu.initTooltips();
                }
            });
        },

        menu: function () {
            return menu;
        }
    };
};



elma.updateStartMenuSize = function (startMenu) {
    if (!startMenu) {
        startMenu = $('#StartMenu');
    }
    if (!startMenu.is(":visible")) {
        return;
    }
    startMenu.css("top", $("#beforeRootTable").outerHeight(true));
}
elma.updateStartMenuOverlaySize = function (startMenuOverlay) {
    if (!startMenuOverlay) {
        startMenuOverlay = $('#StartMenuOverlay');
    }
    if (!startMenuOverlay.is(":visible")) {
        return;
    }
    startMenuOverlay.css("width", $(document).width());
    startMenuOverlay.css("height", $(document).height() - $("#beforeRootTable").outerHeight(true));
    startMenuOverlay.css("top", $("#beforeRootTable").outerHeight(true));
}
elma.beforeShowStartMenu = function(startMenuOverlay) {
    if (!startMenuOverlay) {
        startMenuOverlay = $('#StartMenuOverlay');
    }
    scrollTo(0, 0);
    elma.hideMenuButton();
    elma.ElmaMenuMgr.hideAll();
    startMenuOverlay.show();
    elma.updateStartMenuOverlaySize(startMenuOverlay);
}
elma.showStartMenu = function (startMenu) {
    if (!startMenu) {
        startMenu = $('#StartMenu');
    }
    if (elma.showStartMenuClick || elma.isIPad) {
        startMenu.addClass('ShowAll');
        elma.showStartMenuClick = false;
    } else {
        startMenu.removeClass('ShowAll');
    }
    startMenu.show();
    elma.updateStartMenuSize(startMenu);
    $('#rootToolBar #page_start_button').attr('title', SR.T("Закрыть меню"));
}
elma.hideStartMenu = function () {
    var startMenu = $('#StartMenu');
    var startMenuOverlay = $('#StartMenuOverlay');
    startMenu.hide();
    startMenuOverlay.hide();
    if ($('#page_start_button').is(":hover")) {
        elma.startButtonMouseenter();
    } else {
        elma.hideMenuButton();
    }
    $('#page_start_button').attr('title', /*elma.isHomePage() ? SR.T("Открыть меню") : */SR.T("Открыть главную страницу"));
}

elma.startMenuButtonTimer = function (interval) {
    if (elma.menuButtonTimerStarted) {
        return;
    }
    elma.menuButtonTimerStarted = true;
    elma.resumeMenuButtonTimer(interval ? interval : 50);
}
elma.hideMenuButton = function () {
    $('#rootToolBar #page_start_menu').css('left', '0px');
    $('#rootToolBar #page_start_menu').css('display', 'none');
    elma.startMenuButtonLeft = 0;
    elma.showStartMenuButton = false;
}
elma.resumeMenuButtonTimer = function (interval) {
    setTimeout(function () {
        if (elma.showStartMenuButton) {
            if (elma.startMenuButtonLeft < 68) {
                elma.startMenuButtonLeft += 16;
                if (elma.startMenuButtonLeft > 68) {
                    elma.startMenuButtonLeft = 68;
                }
                $('#rootToolBar #page_start_menu').css('display', '');
                $('#rootToolBar #page_start_menu').css('left', elma.startMenuButtonLeft + 'px');
                elma.resumeMenuButtonTimer();
            } else {
                elma.menuButtonTimerStarted = false;
            }
        } else {
            if (elma.startMenuButtonLeft > 0) {
                elma.startMenuButtonLeft -= 16;
                if (elma.startMenuButtonLeft < 0) {
                    elma.startMenuButtonLeft = 0;
                }
                $('#rootToolBar #page_start_menu').css('left', elma.startMenuButtonLeft + 'px');
                elma.resumeMenuButtonTimer();
            } else {
                elma.menuButtonTimerStarted = false;
                elma.hideMenuButton();
            }
        }
    }, interval ? interval : 50);
}
$().ready(function () {
    if ($('#rootToolBar #page_start_button').length == 0) {
        return;
    }
    elma.isIPad = /iPad/i.test(navigator.userAgent);
    $('#rootToolBar #page_start_button').attr('title', /*elma.isHomePage() ? SR.T("Открыть меню") : */SR.T("Открыть главную страницу"));
    $('#rootToolBar #page_start_button').click(elma.startButtonClick);
    $('#rootToolBar #page_start_button, #rootToolBar #page_start_menu').mouseenter(elma.startButtonMouseenter);
    $('#rootToolBar #page_start_menu').click(elma.showAndLoadStartMenu);
    $('#rootToolBar #page_start_menu').mouseenter(elma.startMenuMouseenter);
    $('#rootToolBar #page_start_menu, body').mouseleave(function () {
        elma.showMenu = false;
    });
    elma.startMenuButtonLeft = 0;
    $('#rootToolBar #page_start_button_container, #rootToolBar #page_start_menu, body').mouseleave(function () {
        elma.showStartMenuButton = false;
        elma.startMenuButtonTimer();
    });
    $(window).mouseleave(function () {
        elma.showStartMenuButton = false;
        elma.showMenu = false;
        elma.startMenuButtonTimer();
    });
    $('#rootToolBar #page_start_button').mouseenter(function () {
        $('#rootToolBar #page_start_button_container').addClass('hover');
    });
    $('#rootToolBar #page_start_button').mouseleave(function () {
        $('#rootToolBar #page_start_button_container').removeClass('hover');
    });
    $(document).click(function (e) {
        var startButton = $('#rootToolBar #page_start_button');
        if (startButton.length > 0 && e.target != $('#rootToolBar #page_start_button')[0]) {
            elma.hideMenuButton();
        }
        return true;
    });
})
elma.startButtonClick = function (e) {
    var startMenu = $('#StartMenu');
    if (startMenu.is(":visible")) {
        elma.hideStartMenu();
        return false;
    }
    if (elma.startMenuButtonLeft > 16) {
        return true;
    }
    elma.showStartMenuClick = true;
    elma.startButtonMouseenter();
    return false;
}
elma.startButtonMouseenter = function (e) {
    var startMenu = $('#StartMenu');
    if (startMenu.is(":visible"))
        return true;
    elma.showStartMenuButton = true;
    elma.startMenuButtonTimer();
    return true;
}
elma.startMenuMouseenter = function(e) {
    elma.showMenu = true;
    if (elma.menuTimerStarted) {
        return;
    }
    elma.menuTimerStarted = true;
    setTimeout(function () {
        if (elma.showMenu) {
            elma.showAndLoadStartMenu();
        }
        elma.menuTimerStarted = false;
    }, 200);
}
elma.showAndLoadStartMenu = function () {
    elma.showMenu = false;
    var menuLoading = false;
    if (menuLoading) {
        return;
    }
    var startMenuOverlay = $('#StartMenuOverlay');
    if (startMenuOverlay.length == 0) {
        $(document.body).append('<div id="StartMenuOverlay" onclick="elma.hideStartMenu()"></div>');
        startMenuOverlay = $('#StartMenuOverlay');
    }
    elma.beforeShowStartMenu(startMenuOverlay);
    var startMenu = $('#StartMenu');
    if (startMenu.length == 0) {
        $(document.body).append('<div id="StartMenu"><table class="loading"><tr><td id="StartMenu_Padding"></td><td id="StartMenu_Create"><div id="div_create_menu"><div id="create_menu_header"><div>' + SR.T("Загрузка") + '</div></div></div></td></tr></table></div>');
        startMenu = $('#StartMenu');
        startMenu.show();
        elma.updateStartMenuSize(startMenu);
        menuLoading = true;
        $.ajax({
            global: true,
            cache: true,
            type: 'GET',
            url: '/ContentArea/Menu/StartMenu/' + startMenuHashCode + '?culture=' + JsLocalizator.CurrentLocale(),
            dataType: 'html',
            headers: {
                "Elma-RegisteredContent": ""
            },
            success: function (data) {
                startMenu.remove();
                $(document.body).append(data);
                startMenu = $('#StartMenu');
                $(window).resize(function () {
                    elma.updateStartMenuSize(startMenu);
                    elma.updateStartMenuOverlaySize(startMenuOverlay);
                });
                elma.showStartMenu(startMenu);
                menuLoading = false;
            },
            error: function (data) {
                menuLoading = false;
                container.html(SR.T("Не удалось загрузить стартовое меню: ") + data.statusText + " (" + data.status + ")");
            }
        });
        return;
    }
    if (!startMenu.is(":visible")) {
        elma.showStartMenu(startMenu);
    }
};



elma.menuCountsUpdate = function (d) {
    try {
        var data = eval(d);
        for (var i = 0; i < data.length; i++) {
            it = data[i];
            var counterElem = $('#' + it.code + "_count");
            var containerElem = counterElem.parent();
            if (it.c === null) {
                containerElem.hide();
            } else {
                var v = it.c;
                var cInt = it.c / 1;
                if (cInt && cInt > 99) {
                    v = "99+";
                }
                counterElem.html(v);
                containerElem.attr('class', containerElem.attr('defaultClass') + ' ' + it.cssClass);
                containerElem.show();
            }
            try {
                if (it.f) {
                    var func = eval(it.f);
                    func(it.c);
                }
            } catch (e) {
                alert(e);
            }
        }
    }
    catch (e) {
        alert(e);
    }
};



if (elma.artb == null) {
    elma.artb = function () {
        return {
            Setup: function (element) {
                var container = $(element).parents("div[id=AutoResizeTextbox_Container]:first");
                var textarea = container.find('[id=AutoResizeTextbox_Input]');
                var ta = textarea[0];
                if (textarea[0].AutoResizeSetup) return;

                var isFocusedClassName = "art-isFocused";

                var autoResizeTextArea = function () {
                    if (textarea[0] && textarea[0].style && textarea[0].style.width) {
                        textarea.width(textarea[0].style.width);
                    } else {
                        textarea.width(textarea.width());
                    }
                    
                    var maxHeight = textarea[0].AutoResizeSettings.MaxHeight;
                    if (maxHeight <= 0) maxHeight = 1000;
                    textarea.autoResize({
                        extraSpace: 0,
                        animateDuration: 200,
                        limit: maxHeight,
                        onResize: function () {
                            $(this).css({ opacity: 0.8 });
                        }
                    });
                };

                var initEventsTextArea = function (isFocus) {
                    if (!textarea.attr("EventsInit")) {
                        textarea.attr("EventsInit", true);
                        textarea.focus(function (event) {
                            ta.setupAfterFocus();
                        }).change(function (event) {
                            if (ta.Validate(true)) {
                                ta.ClearValidateOrExists();
                            }
                            var hdnValue = container.find('input[type=hidden]:first');
                            hdnValue.val(textarea.val());
                            ta.OnChange();
                        }).keypress(function (event) {
                            var hdnValue = container.find('input[type=hidden]:first');
                            hdnValue.val(textarea.val());
                        });

                        if (isFocus) {
                            ta.setupAfterFocus();
                        }
                    }
                };


                var initTextAreaForInput = function (reset) {
                    if (reset) {
                        setUnActive();
                    } else {
                        if (textarea.attr("InitTextAreaForInput") != null) return;
                        if (textarea.length > 0) {
                            textarea.val("");
                        }
                    }
                };

                var setUnActive = function () {
                    textarea.removeAttr("InitTextAreaForInput");
                    showComment(false);
                };

                var setActive = function (showCommentary) {
                    textarea.attr("InitTextAreaForInput", "true");
                    showComment(showCommentary == null ? true : showCommentary);

                    ta.OnFocus();

                    if (ta.IsFocused()) return;
                    container.addClass(isFocusedClassName);
                    ta.lastFocusTime = new Date().getTime();
                };

                ta.SetActive = setActive;
                
                ta.ClearFocus = function () {
                    if (elma.GrCtrlsCont.IsLockActive(ta))
                        return;

                    container.removeClass(isFocusedClassName);

                    if (!elma.GrCtrlsCont.IsActive()) {
                        ta.OnFocusOut();
                    }
                };

                ta.Validate = function (onlyTest) {
                    var isValidText = true;
                    var value = jQuery.trim(textarea.val());
                    if (value == "") {
                        if (onlyTest == null || !onlyTest) {
                            container.find("[id=AutoResizeTextbox_Input_validationMessage]").show();
                        }
                        isValidText = false;
                    }

                    var validate = { isValid: true, target: ta, onlyTest: onlyTest };
                    $(ta).trigger('AutoResizeTextboxValidate', validate);
                    return validate.isValid && isValidText;
                };

                ta.ClearValidateOrExists = function () {
                    container.find("[id=AutoResizeTextbox_Input_validationMessage]").hide();
                    $(ta).trigger('AutoResizeTextboxClearValidate', { target: ta });
                };

                ta.IsFocused = function () {
                    return container.hasClass(isFocusedClassName);
                };

                ta.OnFocus = function () {
                    $(ta).trigger('AutoResizeTextboxOnFocus', { target: ta });
                };

                ta.OnFocusOut = function () {
                    ta.ClearValidateOrExists();
                    $(ta).trigger('AutoResizeTextboxOnFocusOut', { target: ta });
                    showComment(false);
                };

                ta.OnChange = function () {
                    var hdnValue = container.find('input[type=hidden]:first');
                    if (hdnValue.attr("prevChange") === undefined) {
                        hdnValue.attr("prevChange", hdnValue.attr("oldvalue"));
                    }
                    if (hdnValue.attr("prevChange") != hdnValue.val()) {
                        $(ta).trigger('AutoResizeTextboxOnChange', { target: ta });
                        hdnValue.attr("prevChange", hdnValue.val());
                    }
                };

                var showComment = function (value) {
                    var divComments = container.find('.AutoResizeTextboxDescription');
                    if (divComments.length != 0) {
                        if (value) {
                            divComments.addClass("AutoResizeTextboxDescriptionShow");
                        } else {
                            //window.setTimeout(function () {
                            if (elma.GrCtrlsCont.IsActive(divComments))
                                return;
                            divComments.removeClass("AutoResizeTextboxDescriptionShow");
                            //}, 50);
                        }
                    }
                };

                ta.setupAfterFocus = function () {
                    initTextAreaForInput();
                    setActive(true);
                };

                ta.AutoResizeSetSize = function () {
                    initEventsTextArea(false);
                    var v = $(ta).val();
                    $(ta).val("");
                    ta.SetSizeToText();
                    $(ta).val(v);
                    ta.UpdateSize();
                    setActive(!ta.AutoResizeSettings.ShowCommentOnlyFocus);
                };

                ta.IsEmpty = function () {
                    return $(ta).val() == null || $(ta).val() == "";
                };

                ta.TextAreaClearAndBlur = function (fullClear) {
                    var hdnValue = container.find('input[type=hidden]:first');

                    if (fullClear) {
                        hdnValue.attr("oldvalue", "");
                        textarea.val("");
                        ta.UpdateSize();
                    } else if (hdnValue.attr("oldvalue") != textarea.val()) {
                        textarea.val(hdnValue.attr("oldvalue"));
                        ta.UpdateSize();
                    }
                    hdnValue.val(textarea.val());

                    ta.ClearFocus();

                    //window.setTimeout(function () {
                    textarea.blur();
                    elma.GrCtrlsCont.SetActiveContainer();
                    //}, 100);
                };

                ta.SetValueText = function (value) {
                    var hdnValue = container.find('input[type=hidden]:first');
                    textarea.val(value);
                    hdnValue.val(value);
                    hdnValue.attr("oldvalue", value);
                    ta.UpdateSize();
                    //setActive();
                    if (value == null || value == "") {
                        ta.TextAreaClearAndBlur(true);
                    }
                };

                $(document).ready(function () {
                    if (ta.AutoResizeSetup) return;
                    ta.AutoResizeSetup = true;

                    var settings = new Object();
                    ta.AutoResizeSettings = settings;

                    settings.DescriptionText = textarea.attr("descriptionText");
                    settings.PostCommentEnterKey = textarea.attr("postCommentEnterKey") == "true";
                    settings.ShowCommentOnlyFocus = textarea.attr("showCommentOnlyFocus") == "true";
                    settings.MaxHeight = parseInt(textarea.attr("maxHeight"));

                    textarea.removeAttr("descriptionText");
                    textarea.removeAttr("postCommentEnterKey");
                    textarea.removeAttr("showCommentOnlyFocus");
                    textarea.removeAttr("maxHeight");

                    if (settings.DescriptionText != null && settings.DescriptionText != "") {
                        container.append("<div class='AutoResizeTextboxDescription'>" + settings.DescriptionText + "</div>");
                    }
                    var hdnValue = container.find('input[type=hidden]:first');

                    autoResizeTextArea();
                    if (hdnValue.val() == "") {
                        initEventsTextArea(false);
                        textarea.val("");
                    } else {
                        ta.AutoResizeSetSize();
                    }
                });
            },
            ClearAndBlur: function (element, fullClear) {
                $(element).parents("div[id=AutoResizeTextbox_Container]:first")
                .find('[id=AutoResizeTextbox_Input]')[0].TextAreaClearAndBlur(fullClear);
            },
            SetText: function (element, value) {
                var textarea = $(element).parents("div[id=AutoResizeTextbox_Container]:first").find('[id=AutoResizeTextbox_Input]')[0];
                elma.artb.Setup(textarea);
                textarea.SetValueText(value);
                textarea.SetSizeToText();
                textarea.SetActive(false);
            },
            SetSize: function () {
                var parentsSelector = "div[id=AutoResizeTextbox_Container]";
                var hdnInputs = $(parentsSelector).find('input[type=hidden]:not([value=""]):first');
                for (var i = 0; i < hdnInputs.length; i++) {
                    var textarea = $(hdnInputs[i]).parents(parentsSelector).find("[id=AutoResizeTextbox_Input]:first");
                    elma.artb.Setup(textarea[0]);
                }
            }
        };
    }();
}

$("div.AutoResizeTextbox").find("textarea:visible").live("keydown", function (e) {
    var textarea = $(this);
    var ta = textarea[0];
    var postCommentEnterKey = textarea[0].AutoResizeSettings.PostCommentEnterKey;
    if (e.keyCode == "13" && ((!e.shiftKey && postCommentEnterKey) || (e.shiftKey && !postCommentEnterKey))) {
        if (!ta.Validate()) {
            e.keyCode = null;
            return false;
        } else {
            ta.ClearValidateOrExists();
        }
        textarea.blur();

        var text = textarea.parents(".AutoResizeTextbox:first").find("input[type=hidden]:first").val();
        if (text != null && text.replace(/^\\s+/, "\\").replace(/\\s+$/, "\\") != "\\") {
            var obj = { target: ta, isPost: false };
            $(ta).trigger('AutoResizeTextboxPost', obj);
            if (obj.isPost) {
                e.keyCode = null;
                return false;
            }
        };

    } else if (e.keyCode == "27") {
        elma.artb.ClearAndBlur(ta);
        ta.OnChange();
        e.keyCode = null;
        return false;
    }

    return true;
});
$("div.AutoResizeTextbox").live("click", function (e) {
    var container = $(this).hasClass("AutoResizeTextbox") ? $(this) : $(this).parents(".AutoResizeTextbox:first");

    var textarea = container.find('[id=AutoResizeTextbox_Input]');

    elma.artb.Setup(textarea[0]);

    textarea[0].setupAfterFocus();

    var tag = e.currentTarget.tagName.toLowerCase();
    if (tag == "input" || tag == "a" || tag == "textarea")
        return;

    textarea[0].OnFocus();

    textarea.focus();
});
$(window).resize(function (event) {
    $("div.AutoResizeTextbox").find("textarea:visible").each(function (index, value) {
        if (value.UpdateSize === undefined)
            return;
        $(value).width("100%");
        value.UpdateSize();
    });
});
$('.GroupControlsContainer').live('activeOff', function (e) {
    var textarea = $(e.currentTarget).find('[id=AutoResizeTextbox_Input]');
    if (textarea.length == 0)
        return;
    var ta = textarea[0];
    if (ta.ClearFocus != null)
        ta.ClearFocus();
});





elma.GrCtrlsCont = new Object();
elma.GrCtrlsCont.lastActive = null;
elma.GrCtrlsCont.containerClass = "GroupControlsContainer";
elma.GrCtrlsCont.containerActiveClass = "GroupControlsContainer-Active";
elma.GrCtrlsCont.containerParentAttr = "groupcontrolscontainer";
elma.GrCtrlsCont.containerForAttr = "forgroupcontrolscontainer";

$(document).mousedown(function (event) {
    elma.GrCtrlsCont.focus(event.target, arguments);
});
$(document).focusin(function (event) {
    elma.GrCtrlsCont.focus(event.target, arguments);
});

elma.GrCtrlsCont.focus = function (element, args) {
    var getElement = function (el, elArgs) {
        if (elArgs != null) {
            if ($.isArray(elArgs) || elArgs.length != null) {
                for (var i = elArgs.length - 1; i >= 0; i--) {
                    if (elArgs[i] != null) {
                        var el2 = getElement(el, elArgs[i]);
                        if (el2 != null)
                            return el2;
                    }
                }
            } else {
                if (elArgs.target != null)
                    return elArgs.target;
            }
        }
        return null;
    }

    var currentElement = getElement(element, args);
    if (currentElement == null)
        currentElement = element;

    if (elma.GrCtrlsCont.HasContainerClass(currentElement, "t-window") || elma.GrCtrlsCont.HasContainerClass(currentElement, "t-overlay") || elma.GrCtrlsCont.HasContainerClass(currentElement, "t-popup"))
        return null;

    var currentContainerActive = elma.GrCtrlsCont.CurrentContainer();
    if (currentContainerActive != null && elma.GrCtrlsCont.IsLockActive(currentContainerActive))
        return null;

    var container = elma.GrCtrlsCont.GetContainer(currentElement);
    elma.GrCtrlsCont.SetActiveContainer(container);
};
elma.GrCtrlsCont.HasContainerClass = function(element, className) {
    if (element == null)
        return false;
    if ($(element).hasClass(className))
        return true;
    return $(element).parents("." + className).length != 0;
};
elma.GrCtrlsCont.SetLockActive = function(element, value) {
    var container = elma.GrCtrlsCont.GetContainer(element);
    if (container != null)
        container.IsLockActiveContainer = value;
};
elma.GrCtrlsCont.IsLockActive = function(element) {
    var container = elma.GrCtrlsCont.GetContainer(element);
    return container != null && container.IsLockActiveContainer;
};
elma.GrCtrlsCont.GetContainer = function(element) {
    if (element == null)
        return null;

    var container = $(element).hasClass(elma.GrCtrlsCont.containerClass) ? $(element) : null;
    var containerLast = $(element).parents("." + elma.GrCtrlsCont.containerClass + ":last");
    if (container == null || (containerLast.length != 0 && container.length != 0 && containerLast[0] != container[0]))
        container = containerLast;

    if (container != null) {
        var attr = container.attr(elma.GrCtrlsCont.containerForAttr);
        if (attr != null) {
            var parentContainer = $("." + elma.GrCtrlsCont.containerClass + "[" + elma.GrCtrlsCont.containerParentAttr + "=" + attr + "]");
            if (parentContainer.length != 0)
                container = parentContainer;
        }
    }
    
    return container == null || container.length == 0
        ? null
        : container[0];
};
elma.GrCtrlsCont.CurrentContainer = function() {
    return elma.GrCtrlsCont.GetContainer(elma.GrCtrlsCont.lastActive);
};
elma.GrCtrlsCont.SetActiveContainer = function (element) {
    var container = elma.GrCtrlsCont.GetContainer(element);

    var currentContainerActive = elma.GrCtrlsCont.CurrentContainer();
    if (currentContainerActive != null) {
        if (container == currentContainerActive)
            return;

        $(currentContainerActive).removeClass(elma.GrCtrlsCont.containerActiveClass);
        elma.GrCtrlsCont.lastActive = null;

        try {
            $(currentContainerActive).trigger('activeOff');
        } catch (e) {
            
        } 
    }
    if (container == null)
        return;

    $(container).addClass(elma.GrCtrlsCont.containerActiveClass);
    elma.GrCtrlsCont.lastActive = container;

    try {
        $(container).trigger('activeOn');
    } catch (e) {

    } 
};
elma.GrCtrlsCont.IsActive = function(element) {
    var container = elma.GrCtrlsCont.GetContainer(element);
    return container == null ? false : $(container).hasClass(elma.GrCtrlsCont.containerActiveClass);
};


if (elma.BigText == null) {
    elma.BigText = function () {
        var initProcess = false;

        var initialization = function () {
            if (initProcess)
                return;
            initProcess = true;

            $(document).ready(function () {
                $.each($('.BigText[init!=true]'), function (index, value) {
                    var v = $(value);
                    v.attr("init", "true");
                    if (v.find('.BigTextInnerContainer').actual('height') > v.find('.BigTextContainer').actual('height')) {
                        v.find(".BigTextReadNext").show();
                    } else {
                        v.addClass("BigTextFullSize");
                    }
                });

                initProcess = false;
            });
        };

        return {
            Init: function () {
                initialization();
            },
            NextClick: function (button) {
                $(button).parents("div.BigText:first").addClass("BigTextFullSize");
            }
        };
    }();
}



$(document).ready(function () {

    $("body").append("<div id='scrollup' title='" + SR.T('Наверх') + "'></div>");

    $(window).scroll(function () {
        if (0 < $(window).scrollTop()) {
            $("#scrollup").fadeIn();
        } else {
            $("#scrollup").fadeOut();
        }
    });

    $("#scrollup").click(function () {
        $("html, body").animate({ scrollTop: 0 }, 300);
        return false;
    });

});



function showResourceCalendar(id) {
    createAndLoadWindow('ResourceCalendarViewPopup', { title: SR.T("Календарь"), width: 600 }, '/Projects/EntityCalendar/Details/' + id);
}

function showWorkForce(id) {
    createAndLoadWindow('WorkForceViewPopup', { title: SR.T("Трудовой ресурс"), width: 600 }, '/Projects/WorkForce/Details/' + id);
}

function showTechnicalRecource(id) {
    createAndLoadWindow('TechnicalResourceViewPopup', { title: SR.T("Технический ресурс"), width: 600 }, '/Projects/TechnicalResource/Details/' + id);
}

function showMaterialRecource(id) {
    createAndLoadWindow('MaterialRecourceViewPopup', { title: SR.T("Материальный ресурс"), width: 600 }, '/Projects/MaterialResource/Details/' + id);
}



elma.CompletePercent = new Object();

elma.CompletePercent.CompletePersentInput = function (target) {
    return $(target).parents(".completePersentContainer:first").find('input');
}

elma.CompletePercent.Init = function () {
    var containers = $('.completePersentContainer:not([isInit="true"])');
    containers.each(function (index, v) {
        $(v).attr("isInit", "true");
        var percentValue = parseInt($(v).attr("percentValue"));
        var onChangeFunctionName = $(v).attr("onchange");
        
        var completePersentInput = elma.CompletePercent.CompletePersentInput($(v).find("input"));
        completePersentInput[0].CompletePercentOnChangeFunctionName = onChangeFunctionName;
        completePersentInput.val(percentValue);

        completePersentInput[0].SliderInput = $(v).find(".completePersentSlider").slider({
            range: "min",
            value: percentValue,
            min: 0,
            max: 100,
            slide: function (event, ui) {
                var input = completePersentInput.data("tTextBox");
                input.value(ui.value);
                elma.CompletePercent.ChangeCompletePersent(event.target);
            }
        });

        jQuery('.ui-slider .ui-slider-handle').css('z-index', 'auto');
        jQuery('.ui-slider .ui-slider-range').css('z-index', 'auto');
    });
}

elma.CompletePercent.OnChangeCompletePercent = function (e) {
    elma.CompletePercent.CompletePersentInput(e.target)[0].SliderInput.slider("value", e.newValue);
    elma.CompletePercent.ChangeCompletePersent(e.target);
}

elma.CompletePercent.ChangeCompletePersent = function (target) {
    var functionName = elma.CompletePercent.CompletePersentInput(target)[0].CompletePercentOnChangeFunctionName;
    if (functionName != null && functionName != "") {
        window[functionName](target);
    }
}



if (elma.BudgetChart == null) {
    elma.BudgetChart = function() {
        var lineChartData = [];
        var options = [];
        var myLine = [];
        return {
            Options: function (chartId, gridLineColor, tooltipFillColor, planIncomeLegend, planExpenceLegend, planSaldoLegend, factIncomeLegend, factExpenseLegend, factSaldoLegend, legendOnClick) {
                options[chartId] = {
                    ///Boolean - Whether grid lines are shown across the chart
                    scaleShowGridLines: true,

                    //String - Colour of the grid lines
                    scaleGridLineColor: gridLineColor,

                    // String - Colour of the scale line
                    scaleLineColor: gridLineColor, //Number - Width of the grid lines
                    scaleGridLineWidth: 1, //Boolean - Whether to show horizontal lines (except X axis)
                    scaleShowHorizontalLines: true, //Boolean - Whether to show vertical lines (except Y axis)
                    scaleShowVerticalLines: true, // Interpolated JS string - can access value
                    scaleLabel: "<%=value%>", // Boolean - whether or not the chart should be responsive and resize when the browser does.
                    responsive: true,

                    //Boolean - Whether the line is curved between points
                    bezierCurve: false,

                    //Number - Tension of the bezier curve between points
                    bezierCurveTension: 0.4,

                    //Boolean - Whether to show a dot for each point
                    pointDot: true,

                    //Number - Radius of each point dot in pixels
                    pointDotRadius: 5,

                    //Number - Pixel width of point dot stroke
                    pointDotStrokeWidth: 2,

                    //Number - amount extra to add to the radius to cater for hit detection outside the drawn point
                    pointHitDetectionRadius: 1,

                    //Boolean - Whether to show a stroke for datasets
                    datasetStroke: true,

                    //Number - Pixel width of dataset stroke
                    datasetStrokeWidth: 3,

                    //Boolean - Whether to fill the dataset with a colour
                    datasetFill: false,

                    customTooltips: function(tooltip) {
                        var tooltipEl = $('.chartjs-tooltip');

                        if (!tooltip) {
                            tooltipEl.css({
                                opacity: 0
                            });
                            return;
                        }

                        tooltipEl.removeClass('above below');
                        tooltipEl.addClass(tooltip.yAlign);

                        var innerHtml;
                        if (tooltip.title) {
                            innerHtml = '<span class="chartjs-tooltip-title">' + tooltip.title + '</span>';
                            if (tooltip.labels != null) {
                                for (var i = 0; i < tooltip.labels.length; i++) {
                                    var toolTipValueArr = tooltip.labels[i].split(":");
                                    var toolTipLegend = toolTipValueArr[0];
                                    var toolTipValue = Number(toolTipValueArr[1]).toFixed(2);
                                    var toolipClass = toolTipLegend == planIncomeLegend || toolTipLegend == factIncomeLegend
                                        ? "dashed"
                                        : (toolTipLegend == planExpenceLegend || toolTipLegend == factExpenseLegend
                                            ? "dotted"
                                            : "solid");
                                    innerHtml += [
                                        '<div class="chartjs-tooltip-section">',
                                        '	<span class="line-legend-line line-legend-' + toolipClass + '" style="padding-top:-7px"><div class="line-legend-line" style="color:' + tooltip.legendColors[i].fill + '"></div></span>',
                                        '	<span class="legend-line-text legend-line-value">' + toolTipValue + '</span>',
                                        '   <span class="legend-line-text-name">(' + toolTipLegend + ')</span>',
                                        '</div>'
                                    ].join('');
                                }
                            }
                        } else {
                            innerHtml = '<span class="chartjs-tooltip-title">' + tooltip.text + '</span>';
                        }
                        tooltipEl.html(innerHtml);

                        if (tooltip.title) {
                            //Decide whether to align left or right based on position on canvas
                            if (tooltip.OriginalX > tooltip.chart.width / 2) {
                                tooltip.x = tooltip.OriginalX + tooltip.xOffset - (tooltipEl.width() / 3);
                            } else {
                                tooltip.x = tooltip.OriginalX + tooltip.xOffset + (tooltipEl.width() / 4);
                            }
                        }

                        tooltipEl.css({
                            opacity: 1,
                            left: $(tooltip.chart.canvas).offset().left + parseInt(tooltip.x) + 'px',
                            top: $(tooltip.chart.canvas).offset().top + parseInt(tooltip.y) + 'px',
                            fontFamily: tooltip.fontFamily,
                            fontSize: tooltip.fontSize,
                            fontStyle: tooltip.fontStyle,
                        });
                    },

                    // Number - Tooltip label font size in pixels
                    tooltipFontSize: 11,

                    // String - Tooltip background colour
                    tooltipFillColor: tooltipFillColor,

                    // String - Tooltip label font colour
                    tooltipFontColor: "#000",

                    // Number - Tooltip title font size in pixels
                    tooltipTitleFontSize: 12,

                    // String - Tooltip title font colour
                    tooltipTitleFontColor: "#000",

                    // Number - Pixel radius of the tooltip border
                    tooltipCornerRadius: 3,

                    // String - Template string for single tooltips
                    tooltipTemplate: "<%if (label){%><%=label%>: <%}%><%= value %>",

                    // String - Template string for single tooltips
                    multiTooltipTemplate: "<%if (datasetLabel){%><%=datasetLabel%>: <%}%><%= value %>",

                    //String - A legend template
                    legendTemplate: '<div class="line-legend">'
                        + '<% for (var i=0; i<originalDatasets.length; i++) { %>'
                        + '<div class="line-legend-element line-legend-'
                        + '<% if (originalDatasets[i].label == "' + planIncomeLegend + '" || originalDatasets[i].label == "' + factIncomeLegend + '") { %>dashed<% } %>'
                        + '<% if (originalDatasets[i].label == "' + planExpenceLegend + '" || originalDatasets[i].label == "' + factExpenseLegend + '") { %>dotted<% } %>'
                        + '<% if (originalDatasets[i].label == "' + planSaldoLegend + '" || originalDatasets[i].label == "' + factSaldoLegend + '") { %>solid<% } %>'
                        + '">'
                        + '<div class="line-legend-color"><div class="line-legend-line" style="color:<%=originalDatasets[i].strokeColor%>"></div></div>'
                        + '<% if (originalDatasets[i].label) { %><a href="javascript:void(0)" onclick="' + legendOnClick + '(this, <%= i %>);return false;"><span class="legend-line-text'
                        + '<% if (originalDatasets[i].hide) { %> legend-line-text-hide<% } %>'
                        + '"><%= originalDatasets[i].label %></span></a><% } %>'
                        + '</div>'
                        + '<% } %>'
                        + '</div>'
                };
                return options[chartId];
            },
            Init: function (chartId, isLoad, data, canvasId, legendId, chartOnClickScript) {
                if (!isLoad && window["myLine_" + chartId] != null)
                    return;

                lineChartData[chartId] = data;

                var canvas = $("#" + canvasId)[0];

                var ctx = canvas.getContext("2d");
                var myLineChart = new Chart(ctx).LineBarToday(lineChartData[chartId], options[chartId]);
                $("#" + legendId).html(myLineChart.generateLegend());

                myLine[chartId] = myLineChart;

                if (chartOnClickScript != '') {
                    canvas.onclick = function (evt) {
                        var activePoints = myLineChart.getPointsAtEvent(evt);
                        for (var i = 0; i < myLine[chartId].originalLabels.length; i++){
                            if (activePoints[0] != null && myLine[chartId].originalLabels[i] == activePoints[0].label) {
                                window[chartOnClickScript](i);
                                break;
                            }
                        }
                    };
                }
            },
            Update: function (chartId, data) {
                var line = myLine[chartId];
                for (var i = 0; i < line.originalDatasets.length; i++){
                    data.datasets[i].hide = line.originalDatasets[i].hide;
                }
                lineChartData[chartId] = data;
                line.initialize(data);
            },
            VisibleChange: function (chartId, url, label, index) {
                var line = myLine[chartId];
                line.originalDatasets[index].hide = !line.originalDatasets[index].hide;
                line.initialize();
                var labelSpan = $(label).find("span:first");
                if (line.originalDatasets[index].hide) {
                    labelSpan.addClass("legend-line-text-hide");
                } else {
                    labelSpan.removeClass("legend-line-text-hide");
                }
                if (url != null && url != "") {
                    var postData = [];
                    postData["index"] = index;
                    postData["hide"] = line.originalDatasets[index].hide;
                    $.ajax({
                        url: url,
                        data: $.extend({}, postData),
                        type: "POST"
                    });
                }
            }
        }
    }();
}



elma.messagesCount = -1;

elma.blinkPinnedTab = function (count) {
    var title = document.title;
    var newTitle = document.title + '(' + count + ')';

    window.setTimeout(function() {
        document.title = newTitle;
        window.setTimeout(function() {
            document.title = title;
        }, 1);
    }, 1);
};

elma.messagesCountUpdated = function(count) {
    var cnt = count == null ? 0 : count * 1;
    if (elma.messagesCount >= 0 && cnt > elma.messagesCount) {
        elma.blinkPinnedTab(count);
        window.focus();
    }
    elma.messagesCount = cnt;
};



$('#pagerForm .t-numeric .t-link').live("mouseover", function (e, param) {
    $(e.currentTarget).addClass("t-state-hover");
});
$('#pagerForm .t-numeric .t-link').live("mouseout", function (e, param) {
    $(e.currentTarget).removeClass("t-state-hover");
});
$('.ChannelMessageFeedBlock .AutoResizeTextbox textarea[id]').live("AutoResizeTextboxPost", function (e, param) {
    ChannelMessageAddComment(param.target);
});
function ChannelMessageAddComment(target) {
    var infoContainer = $(target).parents(".FeedFieldComments:first");
    var modelFormId = infoContainer.attr("modelFormId");
    var fastCommentId = infoContainer.attr("fastCommentId");
    $('#form_' + modelFormId + ' #TextPostMessage').val($('#' + fastCommentId).val());
    FeedSendFastComment($('#form_' + modelFormId), fastCommentId, $('#fastComment' + modelFormId));
}


$('.ChannelMessageInfo .AutoResizeTextbox textarea[id]').live("AutoResizeTextboxPost", function (e, param) {
    ChannelMessageSendFastComment();
});
function ChannelMessageSendFastComment() {
    $('#formFastComment #TextPostComment')[0].value = $('#Comment')[0].value; $('#formFastComment').submit();
}
$('.FeedParentMessageObject .FeedFavorite').live("click", function (e) {
    var element = $(e.target);
    var objectId = element.parents("#FeedParentBody:first").attr("objectId");
    var like = !$(element).hasClass("FeedFavoriteLike");

    var controllerUrl = "/Messages/BaseMessage";
    var url = controllerUrl + "/FavoriteLikeAjax?objectId=" + objectId + "&like=" + like;
    $.ajax({
        global: true,
        cache: false,
        type: 'GET',
        url: url,
        success: function (data) {
            if (data.success) {
                if (like) {
                    $(element).addClass("FeedFavoriteLike");
                } else {
                    $(element).removeClass("FeedFavoriteLike");
                }
            } else {
                if (like) {
                    elma.AjaxError.show(SR.T("Сообщение не удалось добавить в избранное."));
                } else {
                    elma.AjaxError.show(SR.T("Сообщение не удалось удалить из избранного."));
                }
            }
        }
    });

});




function AddChannelMessage(channelId, userId, subject, url) {
    var ch = '';
    if (channelId != undefined && channelId) {
        if (Object.prototype.toString.call(channelId) === '[object Array]') {
            for (var i = 0; i < channelId.length; i++) {
                if (i > 0) ch += '&';
                ch += 'channels[' + i + ']=' + channelId[i];

            }
        } else {
            ch = 'channels[0]=' + channelId;
        }
    }

    var rc = '';
    if (userId != undefined && userId) {
        if (Object.prototype.toString.call(userId) === '[object Array]') {
            for (var i = 0; i < userId.length; i++) {
                if (i > 0) rc += '&';
                rc += 'recipients[' + i + ']=' + userId[i];

            }
        } else {
            rc = 'recipients[0]=' + userId;
        }
    }

    var sbj = '';
    if (subject != undefined && subject) {
        sbj = 'subject=' + encodeURIComponent(subject);
    }

    refreshPopup('AddChannelMessageWindow', url + (ch ? '&' + ch : '') + (rc > '' ? '&' + rc : '')+ (sbj > '' ? '&' + sbj : ''));
}




$("div.FeedCommentsLoadButtons-Container div").live("click", function (e) {
    elma.Feed.LoadCommentsList(this);
});
$("div.FeedCommentsLoadButtons-Container").live("mouseover", function (e) {
    $(this).addClass("FeedCommentsLoadButtons-Light");
});

$("div.FeedCommentsLoadButtons-Container").live("mouseout", function (e) {
    $(this).removeClass("FeedCommentsLoadButtons-Light");
});

$("div.FeedLoadButtons").live("mouseover", function (e) {
    $(this).addClass("FeedLoadButtons-Light");
});

$("div.FeedLoadButtons").live("mouseout", function (e) {
    $(this).removeClass("FeedLoadButtons-Light");
});
$('.Feed .AutoResizeTextbox textarea[id]').live("AutoResizeTextboxValidate", function (e, param) {
    param.isValid = elma.Feed.SendCommentValidate(param.target, param.onlyTest);
}).live("AutoResizeTextboxClearValidate", function (e, param) {
    param.isValid = elma.Feed.RecipientValidateClear(param.target);
}).live("AutoResizeTextboxOnFocusOut", function (e, param) {
    elma.Feed.OnFocusOutComment(param.target);
}).live("AutoResizeTextboxOnFocus", function (e, param) {
    elma.Feed.OnFocusComment(param.target);
}).live("AutoResizeTextboxPost", function (e, param) {
    elma.Feed.SendCommentToMessage(param.target);
});
$('.Feed .FeedFavorite').live("click", function (e) {
    elma.Feed.ChangeFavorite(this);
});

$("td.FeedRecipient-Editor input[type=text]").live("keydown", function (e) {
    if (e.keyCode == "13") {
        if (!elma.Feed.SendCommentValidate(this)) {
            e.keyCode = null;
            return false;
        }

        e.keyCode = null;
        elma.Feed.RecipientValidateClear(this);

        return false;
    }

    return true;
});

$("#FeedParentBody,div.FeedCommentMessage").live("click", function (e) {
    if ((e.target.tagName.toLowerCase() == "a" || $(e.target).parents("a:first").length > 0) && !elma.GrCtrlsCont.HasContainerClass(e.target, "FeedMessageTextReadNext"))
        return;
    if (elma.GrCtrlsCont.HasContainerClass(e.target, "cmenu"))
        return;
    if ($(e.target).hasClass("FeedFavorite"))
        return;
    elma.Feed.SetAsReadMessages(this);
});

$(".FeedCreateComment,.FeedCreateQuestion").live("click", function (e) {
    if ($(e.target).hasClass('FeedCreateComment')) {
        elma.Feed.CreateCommentPlaceHolderClick(e.target);
    } else {
        elma.Feed.CreateQuestionPlaceHolderClick(e.target);
    }
});



elma.FeedSearch = new function () {
    var getFilter = function () {
        var form = $(".filter-search-form");
        if (form.length == 0)
            return null;

        var searchString = $.trim(form.find(".FeedFastSearch input[type=text]").val());
        if (searchString.length > 255)
            searchString = searchString.substring(0, 255);

        var dateChangeFrom = form.find("#Filter_ChangeDate_From_date").data("tDatePicker").value();
        var dateChangeTo = form.find("#Filter_ChangeDate_To_date").data("tDatePicker").value();

        var creationAuthors = new Array();
        $(elma.EntitySelector.Manager.get('Filter_CreationAuthor_Id').getSelected()).each(function (index, value) {
            creationAuthors[index] = value.val;
        });

        return {
            searchString: searchString,
            dateChangeFrom: dateChangeFrom,
            dateChangeTo: dateChangeTo,
            creationAuthors: creationAuthors,
            isEmpty: searchString == "" && dateChangeFrom == null && dateChangeTo == null && creationAuthors.length == 0
        };
    };


    return {
        Search: function (changeDateHash) {
            var feed = elma.Feed.GetFeedElement();

            var info = elma.Feed.GetNextMessagesInfo(feed.find("#feedNextMessages"));
            if (changeDateHash != null && info == null)
                return;

            var isNewSearch = changeDateHash == null;
            var newFilter = getFilter();

            var favorites = elma.FeedSearch.IsFavorites();

            if (isNewSearch) {
                if ((newFilter == null || newFilter.isEmpty)) {
                    if (elma.FeedSearch.IsSearch()) {
                        location.href = elma.Feed.controllerUrl;
                    }
                    return;
                }

                var query = "";
                var strQueryAdd = function (str) {
                    if (str == "") return;
                    query += (query == "" ? "?" : "&") + str;
                };

                var searchStringValidate = $("#Filter_SearchString_validationMessage");
                searchStringValidate.hide();
                if (newFilter.searchString != "") {
                    if (newFilter.searchString.length < 3) {
                        searchStringValidate.show();
                        return;
                    }
                    strQueryAdd("Filter.SearchString=" + encodeURIComponent(newFilter.searchString));
                }

                var changeDateValidate = $("#Filter_ChangeDate_validation");
                changeDateValidate.hide();
                if (newFilter.dateChangeFrom == null) {
                    changeDateValidate.show();
                    return;
                }

                if (newFilter.dateChangeFrom != null)
                    strQueryAdd("Filter.ChangeDate.From=" + $.telerik.formatString('{0:d}', newFilter.dateChangeFrom));
                if (newFilter.dateChangeTo != null)
                    strQueryAdd("Filter.ChangeDate.To=" + $.telerik.formatString('{0:d}', newFilter.dateChangeTo));
                if (newFilter.creationAuthors != null) {
                    $(newFilter.creationAuthors).each(function (index, value) {
                        strQueryAdd("Filter.CreationAuthor[" + index + "].Id=" + value);
                    });
                }

                if (favorites) {
                    query += "&favorites=True";
                }
                if (elma.FeedSearch.IsAllMessages()) {
                    query += "&onlyunread=False";
                }

                location.href = elma.Feed.controllerUrl + query;
                return;
            }

            var dataArray = [];
            dataArray["changeDateHash"] = changeDateHash;
            dataArray["favorites"] = favorites

            $.ajax({
                global: true,
                cache: false,
                type: 'POST',
                url: elma.Feed.controllerUrl + "/SearchListAjax" + window.location.search,
                data: $.extend({}, dataArray),
                success: function (data) {
                    feed = elma.Feed.GetFeedElement();
                    var feedNextMessages = feed.find("#feedNextMessages");
                    var blocks = feed.find("div.FeedCommentsBlock");
                    elma.Feed.AfterLoadMessagesList(feedNextMessages, false, feed, blocks, data, isNewSearch, null, false, favorites);
                }
            });
        },

        IsSearch: function () {
            var form = $("#FeedSearchForm");
            return form.length != 0 && form.attr("isSearch") == "true";
        },

        IsFavorites: function () {
            var form = $("#FeedSearchForm");
            return form.length != 0 && form.attr("isFavorites") == "true";
        },

        IsOnlyUnread: function () {
            var form = $("#FeedSearchForm");
            return form.length != 0 && form.attr("isOnlyUnread") == "true";
        },

        IsAllMessages: function () {
            return !elma.FeedSearch.IsFavorites() && !elma.FeedSearch.IsOnlyUnread();
        },

        FilterCurrentGet: function () {
            var formSearch = $(".filter-search-form");
            if (formSearch.length == null)
                return null;

            return formSearch[0].FeedCurrentFilter;
        },

        FilterCurrentSet: function (filter) {
            $(".filter-search-form")[0].FeedCurrentFilter = filter == null || filter.isEmpty ? null : filter;
        }
    };
};



elma.Feed = new function () {
    var controllerUrl = "/Messages/Feed";

    var feedUpdateRefreshRead = function (element, changeDateHash) {
        window.setTimeout(function () {
            elma.CalcPing(true);
        }, 500);
        var feedBlock = $(element).parents("div.FeedBlock");
        feedBlock.find("#FeedParentBody").addClass("FeedIsRead");
        if (changeDateHash == null || changeDateHash == "")
            return;
        feedBlock.find("div.FeedCommentContainer:not(.FeedIsRead)")
            .each(function (index, value) {
                var v = $(value);
                if (v.attr("changeDateHash") <= changeDateHash)
                    v.addClass("FeedIsRead");
            });
    };

    var feedMessageInfo = function (element) {
        var feedBlock = $(element).parents("div.FeedBlock:first");
        if (feedBlock == null)
            feedBlock = $(element);
        var feedPrevComments = feedBlock.find("div.FeedCommentsBlock").find(".feedPrevComments");
        var feedCommentsList = feedBlock.find(".feedCommentsList");
        return {
            IsRead: feedBlock.find(".FeedParentMessage").first().hasClass("FeedIsRead"),
            ActionObjectId: feedBlock.attr("actionObjectId"),
            ActionObjectUid: feedBlock.attr("actionObjectUid"),
            LoadCommentCount: feedPrevComments.attr("loadCommentCount"),
            ParentChildCount: feedPrevComments.attr("parentChildCount"),
            ParentChildUnreadCount: feedPrevComments.attr("parentChildUnreadCount"),
            CommentChangeDateHash: feedCommentsList.length == 0 || feedCommentsList.attr("changeDateHash") == "" ? feedBlock.attr("changeDateHash") : feedCommentsList.attr("changeDateHash")
        };
    };

    var feedFastCommentFocus = function (element, isShowRecipients) {
        var feedBlock = $(element).parents("div.FeedBlock:first");
        var fastComment = feedBlock.find("div.FeedComment:first").find("textarea[id]");

        var tableComments = feedBlock.find("#tableFeedComment");
        if (isShowRecipients) {
            tableComments.addClass("tableFeedCommentRecipient");
            tableComments.removeClass("tableFeedComment");
        } else {
            tableComments.addClass("tableFeedComment");
            tableComments.removeClass("tableFeedCommentRecipient");
        }

        initCommentTextBox(fastComment);
        fastComment.click();

        feedCommentUpdateSize(element);

        elma.Feed.RecipientValidateClear(element);

        return feedGetCommentInfo(element);
    };

    var feedGetCommentInfo = function (element) {
        var feedBlock = $(element).parents("div.FeedBlock:first");
        var fastComment = feedBlock.find("div.FeedComment:first").find("textarea[id]");

        var recipientId;
        var tableFeedComment = feedBlock.find("#tableFeedComment");
        var isQuestion = tableFeedComment.hasClass("tableFeedCommentRecipient");

        var tdRecipient = tableFeedComment.find(".FeedRecipient-Editor");
        var recipient = tdRecipient.find("#" + tdRecipient.find("input[type=text]")[0].id.replace("-input", ""));
        recipientId = recipient.data("tComboBox").value();
        if (recipientId == "")
            recipientId = null;

        return {
            FeedBlock: feedBlock,
            FastComment: fastComment,
            Recipient: recipient,
            RecipientId: recipientId,
            isQuestion: isQuestion
        };
    };

    var feedCommentUpdateSize = function (element) {
        var feedBlock = $(element).parents("div.FeedBlock:first");
        var fastComment = feedBlock.find("div.FeedComment:first").find("textarea[id]");
        if (fastComment[0].UpdateSize === undefined) {
            initCommentTextBox(element);
        }
        fastComment.width("100%");
        fastComment[0].UpdateSize();
    };

    var initCommentTextBox = function (element) {
        var feedBlock = $(element).parents("div.FeedBlock:first");
        var fastComment = feedBlock.find("div.FeedComment:first").find("textarea[id]");
        elma.artb.Setup(fastComment);
    };


    return {
        controllerUrl: controllerUrl,

        GetNextMessagesInfo: function (element) {
            var feed = elma.Feed.GetFeedElement(element);
            var feedNextMessages = feed.find("#feedNextMessages");

            if (feedNextMessages.length == 0)
                return null;

            return {
                ChangeDateHashPrevious: feedNextMessages.attr("changeDateHashPrevious"),
                ChangeDateHash: feedNextMessages.attr("changeDateHash"),
                PriorityEnabled: feedNextMessages.attr("priorityEnabled"),
                LastMessageDate: feedNextMessages.attr("lastMessageDate"),
                LastFaforiteHash: feedNextMessages.attr("lastFaforiteHash")
            };
        },

        GetFeedElement: function (element) {
            if (element != null) {
                var feed = $(element).parents("div.Feed:first");
                if (feed.length == 1)
                    return feed;
            }
            return $("div.Feed:first");
        },

        SetAsReadAllMessages: function (element) {
            var feed = elma.Feed.GetFeedElement(element);

            var info = elma.Feed.GetNextMessagesInfo(element);
            if (info == null)
                return;

            jConfirm(SR.T("Отметить все сообщения прочитанными?"), SR.T("Подтверждение"), function (r) {
                if (r) {
                    elma.openPleaseWait(false);
                    
                    var blocks = feed.find("div.FeedCommentsBlock");

                    var url = controllerUrl + "/FeedSetAsReadAll?changeDateHash=" + info.ChangeDateHashPrevious;
                    $.ajax({
                        global: true,
                        async: true,
                        cache: false,
                        type: 'GET',
                        url: url,
                        success: function (data) {
                            if (data.success) {
                                elma.CalcPing(true);
                                $.each(blocks, function(index, value) {
                                    feedUpdateRefreshRead(value, info.ChangeDateHashPrevious);
                                });
                                window.setTimeout(function() {
                                    elma.closePleaseWait(false);
                                }, 200);
                            } else {
                                elma.closePleaseWait(false);
                                elma.AjaxError.show(SR.T("Сообщения не удалось отметить прочитанными."));
                            }
                        },
                    });
                }
            });
        },

        ScrollToTop : function() {
            $("html, body").animate({
                scrollTop: 0
            }, "fast");
        },

        LoadMessagesList: function (element, onlyUnread, isPortlet, favorites) {
            if ($(element).hasClass("feed-button-next-wait"))
                return;

            $(element).addClass("feed-button-next-wait");

            var info = elma.Feed.GetNextMessagesInfo(element);
            if (info == null)
                return;

            var feed = elma.Feed.GetFeedElement(element);
            var feedNextMessages = feed.find("#feedNextMessages");
            var blocks = feed.find("div.FeedCommentsBlock");

            var changeDateHash = favorites ? info.LastFaforiteHash : info.ChangeDateHash;

            if (elma.FeedSearch.IsSearch()) {
                // поиск
                elma.FeedSearch.Search(changeDateHash);
                return;
            }
			
            var url = controllerUrl + "/ListAjax?changeDateHash=" + changeDateHash + "&changeDateHashPrevious=" + info.ChangeDateHashPrevious + "&priorityEnabled=" + info.PriorityEnabled + "&onlyUnread=" + onlyUnread + "&isFavorites=" + favorites;
            $.ajax({
                global: true,
                cache: false,
                type: 'GET',
                url: url,
                success: function (data) {
                    elma.Feed.AfterLoadMessagesList(feedNextMessages, onlyUnread, feed, blocks, data, false, info.ChangeDateHashPrevious, isPortlet, favorites);
                }
            });
        },

        AfterLoadMessagesList: function (feedNextMessages, onlyUnread, feed, blocks, data, fullFeed, changeDateHashPrevious, isPortlet, favorites) {
            var jsonData = eval('(' + data + ')');

            if (!isPortlet && jsonData.UrlRedirect != null && jsonData.UrlRedirect != "") {
                location.href = jsonData.UrlRedirect;
                return;
            }

            if (fullFeed) {
                feed.html(jsonData.ViewResult);
            } else {
                feedNextMessages.replaceWith(jsonData.ViewResult);
            }

            elma.Feed.MessagesTextInitialize(feed);

            if (!favorites && onlyUnread && changeDateHashPrevious != null) {
                $.each(blocks, function (index, value) {
                    feedUpdateRefreshRead(value, changeDateHashPrevious);
                });
            }
        },

        ChangeFavorite: function(element) {
            var messageInfo = feedMessageInfo(element);
            var like = !$(element).hasClass("FeedFavoriteLike");
            var url = controllerUrl + "/FavoriteLikeAjax?actionObjectId=" + messageInfo.ActionObjectId + "&actionObjectUid=" + messageInfo.ActionObjectUid + "&like=" + like;
            $.ajax({
                global: true,
                cache: false,
                type: 'GET',
                url: url,
                success: function (data) {
                    if (data.success) {
                        if (like) {
                            $(element).addClass("FeedFavoriteLike");
                        } else {
                            $(element).removeClass("FeedFavoriteLike");
                        }
                    } else {
                        if (like) {
                            elma.AjaxError.show(SR.T("Сообщение не удалось добавить в избранное."));
                        } else {
                            elma.AjaxError.show(SR.T("Сообщение не удалось удалить из избранного."));
                        }
                    }
                }
            });
        },

        LoadCommentsList: function (element) {
            var parentElement = $(element).parents(".FeedCommentsLoadButtons-Container:first");

            if (parentElement.find("a").length > 0)
                return;

            if (parentElement.hasClass("feed-button-next-wait"))
                return;

            parentElement.addClass("feed-button-next-wait");

            var changeDateHash = parentElement.attr("lastMessageChangeDateHash");

            var messageInfo = feedMessageInfo(element);
            var url = controllerUrl + "/CommentsListAjax?changeDateHash=" + changeDateHash + "&actionObjectId=" + messageInfo.ActionObjectId + "&actionObjectUid=" + messageInfo.ActionObjectUid + "&loadCommentCount=" + messageInfo.LoadCommentCount + "&commentChangeDateHash=" + messageInfo.CommentChangeDateHash + "&parentChildCount=" + messageInfo.ParentChildCount + "&parentChildUnreadCount=" + messageInfo.ParentChildUnreadCount;
            $.ajax({
                global: true,
                cache: false,
                type: 'GET',
                url: url,
                success: function (data) {
                    var feedCommentsBlock = $(element).parents("div.FeedBlock").find("div.FeedCommentsBlock");
                    feedCommentsBlock.find(".feedPrevComments").replaceWith(data);
                    elma.Feed.MessagesTextInitialize(feedCommentsBlock);
                    feedUpdateRefreshRead(feedCommentsBlock, messageInfo.CommentChangeDateHash);
                }
            });
        },

        SetAsReadMessages: function (element) {
            var messageInfo = feedMessageInfo(element);
            var feedBlock = $(element).parents("div.FeedBlock:first");
            var feedParentMessage = feedBlock.find("div.FeedParentMessage");
            if ((messageInfo.CommentChangeDateHash == null || messageInfo.CommentChangeDateHash == "") && feedParentMessage.length != 0)
                return;

            if (messageInfo.IsRead && feedBlock.find("div.FeedCommentContainer:not(.FeedIsRead)").length == 0)
                return;

            var url = controllerUrl + "/SetAsRead?actionObjectId=" + messageInfo.ActionObjectId + "&actionObjectUid=" + messageInfo.ActionObjectUid + "&changeDateHash=" + messageInfo.CommentChangeDateHash;
            $.ajax({
                global: true,
                cache: false,
                type: 'GET',
                url: url,
                success: function (data) {
                    feedUpdateRefreshRead(element, messageInfo.CommentChangeDateHash);
                }
            });
        },

        SendCommentToMessage: function (element) {
            var urlCreateComment = controllerUrl + "/SendComment";
            var urlCreateQuestion = controllerUrl + "/SendQuestion";

            var feedBlock = $(element).parents("div.FeedBlock");
            var feedCommentsBlock = feedBlock.find("div.FeedCommentsBlock");
            var feedComment = feedCommentsBlock.find(".FeedComment");

            var fComment = feedBlock.find("div.FeedComment:first").find("textarea[id]");
            if (fComment.length == 0)
                return;

            initCommentTextBox(element);

            var fastComment = fComment[0];

            if (!fastComment.Validate())
                return;

            var text = $.trim($(fastComment).val());

            if (!elma.Feed.SendCommentValidate(fastComment))
                return;

            var commentInfo = feedGetCommentInfo(fastComment);
            var messageInfo = feedMessageInfo(fastComment);

            var dataArray = [];
            dataArray["comment"] = text;
            dataArray["actionObjectId"] = messageInfo.ActionObjectId;
            dataArray["actionObjectUid"] = messageInfo.ActionObjectUid;
            dataArray["changeDateHash"] = messageInfo.CommentChangeDateHash;

            var url = urlCreateComment;
            if (commentInfo.isQuestion) {
                url = urlCreateQuestion;
                dataArray["recipientId"] = commentInfo.RecipientId;
            }

            feedComment.find("textarea,input[type=text],input[type=button]").attr("disabled", "disabled");

            $.ajax({
                global: true,
                cache: false,
                type: 'POST',
                url: url,
                data: $.extend({}, dataArray),
                success: function (data) {
                    var jsonData = eval('(' + data + ')');

                    if (jsonData.ViewResult != null && jsonData.ViewResult != "") {
                        feedCommentsBlock.find("#feedNewComments").replaceWith(jsonData.ViewResult);
                    }

                    elma.Feed.MessagesTextInitialize(feedBlock);

                    var tableFeedComment = feedBlock.find("#tableFeedComment");
                    if (jsonData.CanCreateQuestion) {
                        if (!tableFeedComment.hasClass("FeedNotCanQuestionRecipient"))
                            tableFeedComment.addClass("FeedNotCanQuestionRecipient");
                    } else {
                        if (tableFeedComment.hasClass("FeedNotCanQuestionRecipient"))
                            tableFeedComment.removeClass("FeedNotCanQuestionRecipient");
                    }

                    feedComment.find("textarea,input[type=text],input[type=button]").removeAttr("disabled");

                    if (jsonData.Error != null && jsonData.Error != "") {
                        if (!jsonData.CanCreateNextComment) {
                            feedComment.hide();
                        }

                        elma.showajaxerror({ responseText: jsonData.Error });
                        return;
                    }

                    fastComment.TextAreaClearAndBlur();

                    feedUpdateRefreshRead(fastComment, messageInfo.CommentChangeDateHash);

                    if (!jsonData.CanCreateNextComment) {
                        feedComment.hide();
                    }
                }
            });
        },

        CreateCommentPlaceHolderClick: function (element) {
            feedFastCommentFocus(element, false);
        },

        CreateQuestionPlaceHolderClick: function (element) {
            feedFastCommentFocus(element, true);
        },

        OnFocusComment: function (element) {
            var feedBlock = $(element).parents("div.FeedBlock:first");
            feedBlock.find(".FeedCommentPlaceHolder").hide();
        },

        OnFocusOutComment: function (element) {
            var feedBlock = $(element).parents("div.FeedBlock:first");
            var fastComment = feedBlock.find("div.FeedComment:first").find("textarea[id]");
            if (fastComment.val() == "") {
                feedBlock.find(".FeedCommentPlaceHolder").show();
                var tableComments = feedBlock.find("#tableFeedComment");
                tableComments.addClass("tableFeedComment");
                tableComments.removeClass("tableFeedCommentRecipient");

                feedCommentUpdateSize(element);
            }
        },

        SendCommentValidate: function (element, onlyTest) {
            var feedBlock = $(element).parents("div.FeedBlock:first");

            var info = feedGetCommentInfo(element);

            if (!info.isQuestion)
                return true;

            if (info.RecipientId == null) {
                feedBlock.find("td.FeedRecipient-Editor input[type=text]").focus();

                if (onlyTest == null || !onlyTest) {
                    feedBlock.find(".FeedRecipient-Editor #User_validationMessage").show();
                }
                return false;
            }

            feedBlock.find(".FeedRecipient-Editor #User_validationMessage").hide();
            return true;
        },

        RecipientsExpand: function (element) {
            var container = $(element).parents("table.FeedObjectTypeTitle:first").find("div.FeedParent-Recipients");
            if (container.hasClass("FeedParent-Recipients-Expand")) {
                container.removeClass("FeedParent-Recipients-Expand");
                $(element).removeClass("FeedParent-Recipients-Expand");
            } else {
                container.addClass("FeedParent-Recipients-Expand");
                $(element).addClass("FeedParent-Recipients-Expand");
            }
        },

        MessagesTextInitialize: function (container) {
            container = container != null ? $(container) : jQuery;
            $.each(container.find('.FeedText[init!=true]'), function (index, value) {
                var v = $(value);
                v.attr("init", "true");
                if (v.find('.FeedMessageTextInnerContainer').actual('height') > v.find('.FeedMessageTextContainer').actual('height')) {
                    v.find(".FeedMessageTextReadNext").show();
                } else {
                    v.addClass("FeedMessageTextFullSize");
                }
            });
        },

        MessageTextReadNextClick: function (button) {
            $(button).parents("div.FeedText:first").addClass("FeedMessageTextFullSize");
        },

        RecipientValidateClear: function (element) {
            $(element).parents("div.FeedBlock:first").find(".FeedRecipient-Editor #User_validationMessage").hide();
        }
    };
};



elma.DocumentButtonAgent = new Object();


elma.DocumentButtonAgent.documentButtonAgentClickCache = new Array();


elma.DocumentButtonAgent.documentButtonAgentShowMenu = function (button, currentVersion, notVisibleArray, lock) {
    elma.ElmaMenuMgr.show('DocumentButtonAgentMenu', { currentVersion: currentVersion }, button, '', { notvisible: notVisibleArray }, lock);
};


elma.DocumentButtonAgent.DocumentButtonAgentClick = function (button, documentId, versionId) {
    var o = elma.DocumentButtonAgent.documentButtonAgentClickCache[documentId];
    if (o != null) {
        elma.DocumentButtonAgent.documentButtonAgentShowMenu(button, o.currentVersion, o.notVisibleArray);
        return;
    }
    elma.DocumentButtonAgent.documentButtonAgentShowMenu(button, null, "btnEAgentBlockEditVer,btnEAgentEditVer,btnEAgentReadVer,btnEAgentNewVer,btnEAgentBlockNewVer,btnToCompare".split(","), true);
    var url = '/Documents/Document/ElmaAgentMenuPermission?';
    if (versionId) {
        url += 'versionId=' + versionId;
    } else {
        url += 'documentId=' + documentId;
    }
    $.ajax({
        global: true,
        cache: false,
        type: 'GET',
        url: url,
        success: function (data) {
            if (data.currentVersion != 0) {
                var notVisibleArray = data.notVisibleItems != null && data.notVisibleItems != "" ? data.notVisibleItems.split(",") : new Array();
                notVisibleArray[notVisibleArray.length] = "btnWait";
                o = new Object();
                o.currentVersion = data.currentVersion;
                elma.DocumentButtonAgent.documentButtonAgentClickCache[documentId] = o;
                o.notVisibleArray = notVisibleArray;
                elma.DocumentButtonAgent.documentButtonAgentShowMenu(button, o.currentVersion, o.notVisibleArray, false);
            } else {
                window.setTimeout(function () {
                    elma.ElmaMenuMgr.hideAll(button);
                    var conf = {
                        content: {
                            text: data.message ? data.message : SR.T('Нет доступных действий с версией документа')
                        },
                        position: {
                            my: 'top left',  // Position my top left...
                            at: 'bottom right',
                            viewport: true
                        }
                    };
                    var qtip = $(button).qtip(conf);
                    $(qtip).qtip('show');
                }, 1500);
            }
        }
    });
};


$(".DocumentAgentButton").live("mouseup", function (e) {
    elma.DocumentButtonAgent.DocumentButtonAgentClick(this, $(this).attr("documentId"), $(this).attr("versionId"));
});

$(".DocumentAgentButtonNoCss").live("mouseup", function (e) {
    elma.DocumentButtonAgent.DocumentButtonAgentClick(this, $(this).attr("documentId"), $(this).attr("versionId"));
});

elma.DocumentButtonAgent.GetItems = function () {
    return [
        {
            id: 'btnEAgentBlockEditVer',
            caption: SR.T('Блокировать и изменить'),
            visible: true,
            icon: '/Content/Images/x16/doc_lock.png',
            execute: function(sender) {
            },
            hrefRep: 'elmadms:vedbl={sender.currentVersion}'
        },
        {
            id: 'btnEAgentEditVer',
            caption: SR.T('Изменить'),
            visible: true,
            icon: '/Content/Images/x16/edit.png',
            execute: function(sender) {
            },
            hrefRep: 'elmadms:ved={sender.currentVersion}'
        },
        {
            id: 'btnEAgentReadVer',
            caption: SR.T('Просмотреть'),
             visible: true,
             icon: '/Content/Images/x16/details2.png',
             execute: function (sender) {
             },
             hrefRep: 'elmadms:ved={sender.currentVersion}'
         },
        {
            id: 'btnEAgentNewVer',
            caption: SR.T('Новая версия (из текущей)'),
            visible: true,
            icon: '/Content/Images/x16/Add.png',
            execute: function(sender) {
            },
            hrefRep: 'elmadms:vnew={sender.currentVersion}'
        },
        {
            id: 'btnEAgentBlockNewVer',
            caption: SR.T('Блокировать и создать'),
            visible: true,
            icon: '/Content/Images/x16/Add.png',
            execute: function (sender) {
            },
            hrefRep: 'elmadms:vnewbl={sender.currentVersion}'
        },
        {
            id: 'btnToCompare',
            caption: SR.T('Сравнить'),
            visible: true,
            icon: '/Content/Images/x16/to_compare.png',
            execute: function (sender) { refreshPopup('ToCompare', '/Documents/DocumentVersion/ToCompare?versionId=' + sender.currentVersion); },
            hrefRep: ''
        }
    ];
};


$(document).ready(function () {
    var menuEaItems = [
        {
            id: 'btnWait',
            caption: SR.T('Пожалуйста, подождите...'),
            icon: '/Content/Images/x16/wait.gif',
            visible: true,
            disabled: true,
            execute: function(sender) {
            }
        }
    ];
    $.each(elma.DocumentButtonAgent.GetItems(), function (i, a) {
        menuEaItems.push(a);
    });
    
    elma.ElmaMenuMgr.init('DocumentButtonAgentMenu', {},
        menuEaItems
    );
});



elma.DocumentMenu = new Object();
elma.DocumentMenu.documentMenuExtButtons = '';
elma.DocumentMenu.documentMenuClickCache = new Array();
elma.DocumentMenu.documentReferenceMenuClickCache = new Array();
elma.DocumentMenu.folderMenuClickCache = new Array();
elma.DocumentMenu.folderReferenceClickCache = new Array();

elma.DocumentMenu.DocumentMenuShowMenu = function (button, object, notVisibleArray, lock) {
    elma.ElmaMenuMgr.show('document_menu', object, button, '', { notvisible: notVisibleArray }, lock);
};

elma.DocumentMenu.DocumentReferenceMenuShowMenu = function (button, object, notVisibleArray, lock) {
    elma.ElmaMenuMgr.show('documentreference_menu', object, button, '', { notvisible: notVisibleArray }, lock);
};

elma.DocumentMenu.FolderMenuShowMenu = function (button, object, notVisibleArray, lock) {
    elma.ElmaMenuMgr.show('folder_menu', object, button, '', { notvisible: notVisibleArray }, lock);
};

elma.DocumentMenu.FolderReferenceMenuShowMenu = function (button, object, notVisibleArray, lock) {
    elma.ElmaMenuMgr.show('folderreference_menu', object, button, '', { notvisible: notVisibleArray }, lock);
};

elma.DocumentMenu.DmsObjectMenuClick = function (button, dmsObjectId, url, cache, showMenu, allItems, extButtons) {
    $(button).qtip('hide');
    var o = cache[dmsObjectId];
    if (o != null) {
        showMenu(button, { id: o.id, versionId: o.currentVersion }, o.notVisibleArray);
        return;
    }
    if (extButtons) {
        allItems += "," + extButtons;
    }
    showMenu(button, { id: dmsObjectId, versionId: 0 }, allItems.split(","), true);
    $.ajax({
        global: true,
        cache: false,
        type: 'GET',
        url: url + dmsObjectId,
        success: function (data) {
            if (data.noaccess) {
                window.setTimeout(function () {
                    elma.ElmaMenuMgr.hideAll(button);
                    var conf = {
                        content: {
                            text: SR.T('Нет прав доступа к документу')
                        },
                        position: {
                            my: 'top left',  // Position my top left...
                            at: 'bottom right',
                            viewport: true
                        }
                    };
                    var qtip = $(button).qtip(conf);
                    $(qtip).qtip('show');
                }, 1500);
                return;
            }
            var notVisibleArray = data.notVisibleItems != null && data.notVisibleItems != "" ? data.notVisibleItems.split(",") : new Array();
            notVisibleArray[notVisibleArray.length] = "btnWait";
            o = new Object();
            o.currentVersion = data.currentVersion;
            o.id = data.id;
            cache[dmsObjectId] = o;
            o.notVisibleArray = notVisibleArray;
            showMenu(button, { id: o.id, versionId: o.currentVersion }, o.notVisibleArray, false);
        }
    });
};

elma.DocumentMenu.DocumentMenuClick = function (button, documentId) {
    elma.DocumentMenu.DmsObjectMenuClick(button, documentId,
        '/Documents/Document/DocumentMenuPermission?documentId=',
        elma.DocumentMenu.documentMenuClickCache, elma.DocumentMenu.DocumentMenuShowMenu,
        "btnElmaAgent,btnDocumentFavorites,btnViewDocumentLink,btnCreateReference,btnMoveDocument,btnArchiveDocument,btnUnArchiveDocument,btnDeleteDmsObject,btnCopyDocument",
        elma.DocumentMenu.documentMenuExtButtons);
};

elma.DocumentMenu.DocumentReferenceMenuClick = function (button, refId) {
    elma.DocumentMenu.DmsObjectMenuClick(button, refId,
        '/Documents/DocumentReference/DocumentReferenceMenuPermission?refId=',
        elma.DocumentMenu.documentReferenceMenuClickCache, elma.DocumentMenu.DocumentReferenceMenuShowMenu,
        "btnElmaAgent,btnDeleteDocumentLink,btnEditLink,btnMoveLink,btnCopyReference");
};

elma.DocumentMenu.FolderMenuClick = function (button, folderId) {
    elma.DocumentMenu.DmsObjectMenuClick(button, folderId,
        '/Documents/Folder/FolderMenuPermission?folderId=',
        elma.DocumentMenu.folderMenuClickCache, elma.DocumentMenu.FolderMenuShowMenu,
        "btnFolderFavorites,btnCreateFolderLink,btnMoveDmsObjects,btnDeleteFolder,btnAccessFolder,btnEditActionFolder,btnEditFolder");
};

elma.DocumentMenu.FolderReferenceMenuClick = function (button, folderId) {
    elma.DocumentMenu.DmsObjectMenuClick(button, folderId,
        '/Documents/Folder/FolderMenuPermission?folderId=',
        elma.DocumentMenu.folderReferenceClickCache, elma.DocumentMenu.FolderReferenceMenuShowMenu,
        "btnDeleteFolderLink,btnEditLink,btnMoveLink,btnCopyReference");
};

$(".DocumentContextMenu").live("mouseup", function (e) {
    elma.DocumentMenu.DocumentMenuClick(this, $(this).attr("objectId"));
});

$(".DocumentReferenceContextMenu").live("mouseup", function (e) {
    elma.DocumentMenu.DocumentReferenceMenuClick(this, $(this).attr("objectId"));
});

$(".FolderContextMenu").live("mouseup", function (e) {
    elma.DocumentMenu.FolderMenuClick(this, $(this).attr("objectId"));
});

$(".FolderReferenceContextMenu").live("mouseup", function (e) {
    elma.DocumentMenu.FolderReferenceMenuClick(this, $(this).attr("objectId"));
});

elma.DownloadCurrentVersion = function(documentId, versionId, preparedFileUid) {
    var hasPreviewUrl = documentId > 0 ? '/Documents/DocumentVersion/HasPreview?documentId=' + documentId :
        '/Documents/DocumentVersion/HasPreview/' + versionId;
    elma.openPleaseWait(true);
    $.ajax({
        global: true,
        cache: false,
        type: 'GET',
        url: hasPreviewUrl,
        success: function (data) {
            elma.closePleaseWait(true);
            if (data.result) {
                if (data.hideSelector) {
                    var previewPopupUrl = '/SDK.Action/BinaryFiles/PreviewPopup/' + data.fileUid + '?uniqueGlobalPrefix=' + data.uniquePreviewGlobalPrefix;
                    refreshPopup('PreviewPopup', previewPopupUrl, null, data.fileName ? data.fileName : SR.T("Предпросмотр"), 'PreviewAjaxBinding("' + data.renderer + '", "' + data.uniquePreviewGlobalPrefix + preparedFileUid + '")', null, null, true, true);
                } else {
                    var selectorUrl = documentId > 0 ? '/Documents/DocumentVersion/DownloadPreviewSelectorPopup?documentId=' + documentId : '/Documents/DocumentVersion/DownloadPreviewSelectorPopup/' + versionId;
                    refreshPopup('DownloadPreviewSelector', selectorUrl, null, data.fileName ? data.fileName : SR.T("Выберите действие"), null, null, null, true, true);
                }
            }
            else if (data.errorMessage) {
                jAlert(data.errorMessage, SR.T('Ошибка доступа'));
            } else {
                location.href = '/Documents/Document/DownloadCurrentVersion/' + documentId;
            }
        }
    });
};





var KPIMControls = {};

function SetVisible(id, openImgId, closeImgId) {
    var panel = $("#" + id);
    var openImg = $("#" + openImgId);
    var closeImg = $("#" + closeImgId);

    panel.toggle();
    openImg.toggle();
    closeImg.toggle();
}


function getScrollXY() {
    var scrOfX = 0, scrOfY = 0;
    if (typeof (window.pageYOffset) == "number") {
        //Netscape compliant
        scrOfY = window.pageYOffset;
        scrOfX = window.pageXOffset;
    } else if (document.body && (document.body.scrollLeft || document.body.scrollTop)) {
        //DOM compliant
        scrOfY = document.body.scrollTop;
        scrOfX = document.body.scrollLeft;
    } else if (document.documentElement && (document.documentElement.scrollLeft || document.documentElement.scrollTop)) {
        //IE6 standards compliant mode
        scrOfY = document.documentElement.scrollTop;
        scrOfX = document.documentElement.scrollLeft;
    }
    return [scrOfX, scrOfY];
}

var infoWin = null;
var infoWinCache = {};
var lastRenderId = "";

function closeInfoPanel() {
    $("#infopanel").parent().css("width", "0");
    $("#infopanel").hide();
    $("#infopanel").empty();
    $("#infopanelcloser").hide();
}

function InfoWindow(id, type) {

    if (type === "Target") {
        elma.openPleaseWait();
        $.ajax({
            url: BaseUrl + "KPI/Target/TargetTabs/" + id,
            success: function (responseText) {
                $("#infopanel").html(responseText);
                $("#infopanel").parent().css("width", "33%");
                $("#infopanel").show();
                $("#infopanelcloser").show();
            },
            error: function (XMLHttpRequest, textStatus, errorThrown) {
                console.log(textStatus);
                elma.showajaxerror(textStatus, errorThrown);
            },
            complete: function () {
                elma.closePleaseWait();
            }
        });
        return;
    }
    if (type === "Action") {
        elma.openPleaseWait();
        $.ajax({
            url: BaseUrl + "KPI/Action/ActionTabs/" + id,
            success: function (responseText) {
                $("#infopanel").html(responseText);
                $("#infopanel").parent().css("width", "33%");
                $("#infopanel").show();
                $("#infopanelcloser").show();
            },
            error: function (XMLHttpRequest, textStatus, errorThrown) {
                console.log(textStatus);
                elma.showajaxerror(textStatus, errorThrown);
            },
            complete: function () {
                elma.closePleaseWait();
            }
        });
        return;
    }

    var posY = document.body.clientHeight + getScrollXY()[1] - 285;
    var posX = $("#div_main_menu").width();

    if (lastRenderId != id + type) {
        lastRenderId = id + type;
    } else {
        infoWin.open();
        $("#infoWinId").hide().css({ position: "absolute", top: posY + "px", left: posX + "px" }).show();
        return;
    }
    var url = null;
    var title = null;

    switch (type) {
        case "Indicator":
            url = "KPI/Indicator/IndicatorTabs/";
            title = Lang.Indicator;
            break;
        case "Target":
            url = "KPI/Target/TargetTabs/";
            title = Lang.Target;
            break;
        case "ObjectManagement":
            url = "KPI/ObjectManagement/ObjectManagementTabs/";
            title = Lang.ObjectManagement;
            break;
        case "Process":
            url = "KPI/Process/ProcessTabs/";
            title = Lang.Process;
            break;
    }
    if (id == null || id.length === 0 || url == null || title == null) {
        Ext.Msg.show({
            title: Lang.Error,
            msg: Lang.UnknownType,
            buttons: Ext.Msg.OK,
            icon: Ext.MessageBox.ERROR
        });
        return;
    }
    if (infoWinCache[id + type] != null) {
        infoWin.removeAll(false);
        infoWin.add(infoWinCache[id + type]);
        infoWin.open();
        return;
    }
    elma.openPleaseWait();

    if (infoWin == null) {
        var width = document.body.clientWidth - posX - 5;
        infoWin = createWindow("infoWinId", {
            title: title,
            width: width,
            top: posY,
            left: posX,
            height: 280,
            modal: false
        });

        $("#infoWinId").hide().css({ position: "absolute", top: posY + "px", left: posX + "px" }).show();
    }

    $.ajax({
        url: BaseUrl + url + id,
        success: function (responseText) {
            $("#infoWinId>div.t-window-content").html(responseText);
        },
        error: function (XMLHttpRequest, textStatus, errorThrown) {
            console.log(textStatus);
            elma.showajaxerror(textStatus, errorThrown);
        },
        complete: function () {
            var newTitle = $("#" + id + type + "Title").length > 0 ? $("#" + id + type + "Title").html() : title;
            $("#infoWinId").find("span.t-window-title").html(newTitle);
            elma.closePleaseWait();
        }
    });
}
function InfoWindowShow(content, cacheId) {
    if (infoWin == null)
        return;
    if (content == null) {
        console.log(SR.T("Ошибка инициализации объекта"));
    } else {
        infoWin.content = content;
        infoWin.open();

        var posY = document.body.clientHeight + getScrollXY()[1] - 285;
        var posX = $("#div_main_menu").width();
        var width = document.body.clientWidth - posX - 5;
        $("#infoWinId").hide().css({ position: "absolute", top: posY + "px", left: posX + "px" }).show();
        infoWin.x = posX;
        infoWin.y = posY;
        infoWin.width = width;
        infoWin.height = 280;
    }
    elma.closePleaseWait();
}

function closeIndicatorInputValuePortlet(indicatorId) {
    if (Ext.get("ValueInputPopUp_" + indicatorId)) {
        hideBlockerDiv();
        var el = Ext.get("ValueInputPopUp_" + indicatorId);
        el.remove();
    }
}

function exportSummaryTable(indicatorName) {
    var iframe = document.getElementById("iframeSummaryTable").contentDocument;
    iframe.getElementById("Format").value = document.getElementById("ddlFormat").value;
    iframe.getElementById("PrintHeaders").value = document.getElementById("cbPrintHeaders").checked;
    iframe.getElementById("PrintFilterHeaders").value = document.getElementById("cbPrintFilterHeaders").checked;
    iframe.getElementById("PrintColumnHeaders").value = document.getElementById("cbPrintColumnHeaders").checked;
    iframe.getElementById("PrintRowHeaders").value = document.getElementById("cbPrintRowHeaders").checked;
    iframe.getElementById("PrintDataHeaders").value = document.getElementById("cbPrintDataHeaders").checked;
    iframe.getElementById("IndicatorName").value = indicatorName;
    closeWindow("SummaryTableExportPopup");
    iframe.getElementById("btnExport").click();
}

function showExportDialog() {
    if (Ext.get("ExportPopUp") != null) {
        showBlockerDiv(Ext.getDom("ExportPopUp"));
    }
}

function openIndicatorInputValuePortlet(id, indicatorId, subject, responsibleId, sdate, periodicityId) {
    if (Ext.get("ValueInputPopUp_" + indicatorId)) {
        openWindow("ValueInputPopUp_" + indicatorId, "", "");
        /*showBlockerDiv($("ValueInputPopUp_" + indicatorId));*/
    }
    else {
        elma.openPleaseWait();

        Ext.UpdateManager.defaults.loadScripts = true;
        Ext.Ajax.timeout = 120000;
        Ext.Ajax.request({
            url: BaseUrl + "KPI/Indicator/SetIndicatorValuePopUp",
            method: "POST",
            scripts: true,
            success: function (result, request) {
                if (Ext.query("#PutValueRednder").length === 0) {
                    Ext.DomHelper.append(document.body, { tag: "div", id: "PutValueRednder", style: "display:none;width:1px;height:1px;" });
                }
                var render = Ext.get("PutValueRednder");
                render.update(result.responseText, true, null);
                if (Ext.get("ValueInputPopUp_" + request.params.id)) {
                    openWindow("ValueInputPopUp_" + indicatorId, "", "");
                }
                elma.closePleaseWait();
            },
            failure: function (result, request) {
                elma.showajaxerror(result, request);
            },
            params: {
                id: indicatorId,
                subject: subject,
                responsibleId: responsibleId,
                sdate: sdate,
                periodicityId: periodicityId
            }
        });

    }
}

$(document).ready(function () {
    var targetCollapse = $("img[id*=target_expand_]");
    if (targetCollapse && targetCollapse.length > 0) {
        for (var i = 0; i < targetCollapse.length; i++) {
            initTargetCollapse($(targetCollapse[i]));
        }
    }
});

function initTargetCollapse(el) {
    var targetId = el.attr("entityId");
    var eButton = $("#target_expand_" + targetId);
    var cButton = $("#target_collapse_" + targetId);

    el.click(function () {
        $("tr[parentTargetId=" + targetId + "]").show();
        el.hide();
        if (eButton.length > 0) {
            eButton.hide();
        }
        if (cButton.length > 0) {
            cButton.show();
        }
    });
    
    if (cButton.length > 0) {
        cButton.click(function () {
            $("tr[parentTargetId=" + targetId + "]").hide();
            el.hide();
            if (eButton.length > 0) {
                eButton.show();
            }
            if (cButton.length > 0) {
                cButton.hide();
            }
        });
    }
}

// равернуть узлы в дереве показателей
function Expand(id) {
    var indicators = $("tr[parentId=" + id + "]");
    if (indicators && indicators.length > 0) {
        for (var i = 0; i < indicators.length; i++) {
            var indicatorEl = $(indicators[i]);
            indicatorEl.show();

            var innerId = indicatorEl.attr("id");
            if (innerId !== id) {

                var nodeexpand = indicatorEl.attr("nodeexpand");
                if (nodeexpand === "true") {

                    Expand(innerId);

                    var cButton = $("#indicator_collapse_" + innerId);
                    if (cButton) {
                        SetSubnodeExpandStatus(innerId, true);
                    }
                }

                if ($("tr[parentId=" + innerId + "]").length > 0) {
                    Expand(innerId);
                }
            }
        }
    }
}

// свернуть узлы в дереве показателей
function Collapse(id, ignore_personal) {
    var indicators = $("tr[parentId=" + id + "]");

    if (indicators && indicators.length > 0) {
        for (var i = 0; i < indicators.length; i++) {
            var indicatorEl = $(indicators[i]);

            var isPersonal = indicatorEl.attr("personal") != null || indicatorEl.attr("personal") != undefined;

            if (ignore_personal && isPersonal)
                continue;

            indicatorEl.hide();
            var innerId = indicatorEl.attr("id");
            if (innerId !== id) {
                var nodeexpand = indicatorEl.attr("nodeexpand");
                if (nodeexpand === "true") {

                    Collapse(innerId, false);

                    var cButton = $("#indicator_expand_" + innerId);
                    if (cButton) {
                        SetSubnodeExpandStatus(innerId, false);
                    }
                }

                if ($("tr[parentId=" + innerId + "]").length > 0) {
                    Collapse(innerId, false);
                }
            }

        }
    }
}

// подгрузить подузлы у текущего показателя в дереве показателей
function LoadSubIndicators(el, renderPeriod, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderPlanValue, renderValueEditor, renderPlanValueEditor, showMetrics, index) {
    LoadIndicators(el, renderPeriod, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderPlanValue, renderValueEditor, renderPlanValueEditor, showMetrics, index, "false", false, false);
}

// загрузить список показателей
function LoadIndicators(el, renderPeriod, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderPlanValue, renderValueEditor, renderPlanValueEditor, showMetrics, index, level, isPersonal, noMorePluses) {
    
    // clickObj - элемент, на который кликнули
    var clickObj = $(el);
    
    var id = clickObj.attr("indicatorId");

    var curClassName = clickObj.attr("class");
    var antoClassName;
    // tr содержащая clickObj   
    var tr = $(clickObj.parents("tr").get(0));
    if (tr.attr("personal") != undefined) {
        antoClassName = curClassName === "persCollapse" ? "persExpand" : "persCollapse";
    } else {
        antoClassName = curClassName === "collapse" ? "expand" : "collapse";
    }
    
    // атрибут, отвечающий развернут ли узел
    var nodeexpand = !(tr.attr("nodeexpand") === "false" || tr.attr("nodeexpand") === "False");

    // узел не развернут
    if (nodeexpand === false) {

        // атрибут, отвечающий подгружены ли уже подузлы, если false - подгружаем
        var showChildren = !(tr.attr("showChildren") === "false" || tr.attr("showChildren") === "False");

        // подузлы не подгружены
        if (showChildren === false) {

            elma.openPleaseWait(true);

            // метод в IndicatorController в который уходит запрос
            var url = "KPI/Indicator/LoadIndicators";

            // скрытая таблица, в нее загружаем подузлы (tr-ки), которые потом вставляем в основную таблицу под текущую tr
            // соответственно если ее еще нет, добавляем в документ
            if ($("#infoTrsRednder").length === 0) {
                $("body").append($("<div id=\"infoTrsRednder\" style=\"display:none\" />"));
            }

            var render = $("#infoTrsRednder");
            console.log("send ajax for Load Indicators");
            // запрос
            $.ajax({
                url: BaseUrl + url,
                async: true,
                //timeout: 500000,
                // обработка успешного ответа
                success: function (responseText) {
                    // помечаем tr, что подузлы уже подгружены
                    tr.attr("showChildren", "true");
                    // вставляем tr-ки из ответа в скрытую таблицу
                    render.append(responseText);
                    // получаем список tr-ок и помещаем их в основную таблицу друг за другом

                    var trs = $("#infoTrsRednder tr");
                    var per_tr = $("tr#per_" + id);
                    if (trs && trs.length > 0) {
                        // lastTr - предыдущая ячейка
                        var lastTr = per_tr.length > 0 ? per_tr : tr;
                        for (var i = 0; i < trs.length; i++) {
                            var subtr = $(trs[i]);
                            subtr.insertAfter(lastTr);
                            var nextIndex = subtr.attr("nestingIndex");
                            // подгружаем подузлы до уровня level
                            if ((level == null) || (parseInt(nextIndex) + 2 <= parseInt(level))) {
                                ExpandSubNodes(subtr, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderValueEditor, renderPlanValueEditor, showMetrics, level);
                            }
                            lastTr = subtr;
                        }
                    }

                    // показываем узлы после загрузки
                    tr.attr("nodeexpand", "true");
                    Expand(id);
                    if (!isPersonal) {
                        SetSubnodeExpandStatus(id, true);
                    }

                    RevertImg(curClassName, antoClassName, id);

                    elma.closePleaseWait(true);
                },
                // обработка ответа с ошибкой
                error: function (result, request) {
                    elma.showajaxerror(result, request);
                },
                // параметры запроса
                data: {
                    id: id,
                    renderPeriod: renderPeriod,
                    renderPeriodicity: renderPeriodicity,
                    renderStateDiagram: renderStateDiagram,
                    renderTrend: renderTrend,
                    renderResponsible: renderResponsible,
                    renderPlanValue: renderPlanValue,
                    renderValueEditor: renderValueEditor,
                    showMetrics: showMetrics,
                    renderPlanValueEditor: renderPlanValueEditor,
                    index: index,
                    isPersonal: isPersonal != null ? isPersonal : false,
                    noMorePluses: noMorePluses != null ? noMorePluses : false
                }
            });
        }
        else {
            // показываем подузлы
            tr.attr("nodeexpand", "true");
            Expand(id);
            SetSubnodeExpandStatus(id, true);
            // меняем картинку с + на -
            RevertImg(curClassName, antoClassName, id);
        }
    }
    // узел развернут
    else {
        // скрываем подузлы
        tr.attr("nodeexpand", "false");
        Collapse(id, true);
        if (!isPersonal) {
            SetSubnodeExpandStatus(id, false);
        }
        RevertImg(curClassName, antoClassName, id);
    }
}

function RevertImg(hideClass, showClass, indicatorId) {
    // меняем картинку с - на +
    $("img." + hideClass + "[indicatorid='" + indicatorId + "']").hide();
    var buttons = $("img." + showClass + "[indicatorid='" + indicatorId + "']");
    if (buttons.length > 0) {
        buttons.show();
    }
}

function SetSubnodeExpandStatus(indicatorId, expanded) {
    var url = "KPI/Indicator/SetIndicatorNodeExpandedStatus/";
    $.ajax({
        url: BaseUrl + url,
        async: true,
        timeout: 500000,
        // обработка успешного ответа
        success: function (result, request) {
            //
        },
        // обработка ответа с ошибкой
        error: function (result, request) {
            elma.showajaxerror(result, request);
        },
        // параметры запроса
        data: { indicatorId: indicatorId, expanded: expanded }
    });
}

// развернуть все узлы в дереве показателей
function ExpandAllIndicators(renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderValueEditor, renderPlanValueEditor, showMetrics) {
    var trs = $("#treeIndicators tr[nodeexpand=false]");
    if (trs && trs.length > 0) {
        for (var i = 0; i < trs.length; i++) {
            var tr = $(trs[i]);
            ExpandSubNodes(tr, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderValueEditor, renderPlanValueEditor, showMetrics, null);
        }
    }
}

// развернуть подузлы
function ExpandSubNodes(tr, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderValueEditor, renderPlanValueEditor, showMetrics, level) {
    elma.openPleaseWait();
    var id = tr.attr("id");
    var index = tr.attr("nestingIndex");
    var img = $("#indicator_expand_" + id);
    if (img.length > 0) {
        LoadIndicators(img, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderValueEditor, renderPlanValueEditor, showMetrics, index, level);
    }
    elma.closePleaseWait();
}

// свернуть все узлы в дереве показателей
function CollapseAllIndicators(renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderValueEditor, renderPlanValueEditor, showMetrics) {
    var trs = $("#treeIndicators tr[nodeexpand=true]");
    if (trs && trs.length > 0) {
        for (var i = 0; i < trs.length; i++) {
            var tr = $(trs[i]);
            // сворачиваем до 1-го уровня => level = 1
            CollapseSubNodes(tr, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderValueEditor, renderPlanValueEditor, showMetrics, 1);
        }
    }
}

// свернуть подузлы
function CollapseSubNodes(tr, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderValueEditor, renderPlanValueEditor, showMetrics, level) {
    elma.openPleaseWait();
    var id = tr.attr("id");

    var index = tr.attr("nestingIndex");
    var img = $("#indicator_collapse_" + id);
    if (img.length > 0) {
        LoadIndicators(img, renderPeriodicity, renderStateDiagram, renderTrend, renderResponsible, renderValueEditor, renderPlanValueEditor, showMetrics, index, level);
    }
    elma.closePleaseWait();
}

PeriodsTree = function (params) {
    this.params = params;
    this.tree = null;

    this.init = function () {
        this.tree = new Ext.tree.TreePanel({
            animate: true,
            autoScroll: true,
            loader: new Ext.tree.TreeLoader({
                dataUrl: "/KPI/Indicator/GetPeriods",
                listeners: {
                    beforeload: function (treeLoader, node) {
                        var tree = KPIMControls["tree_selector"];
                        this.baseParams.indicatorPeriodicityId = tree.params.indicatorPeriod;
                        this.baseParams.indicatorId = tree.params.withValues ? tree.params.id : null;
                        this.baseParams.periodicityId = node.attributes.period;
                        this.baseParams.sdate = node.attributes.start;
                        this.baseParams.edate = node.attributes.end;
                        this.baseParams.subject = tree.params.type;
                        tree = node.getOwnerTree();
                        this.baseParams.responsibles = (Ext.get("responsible_" + tree.params.id) && tree.params.withValues) ? true : false;
                    }
                }
            }),
            enableDD: false,
            containerScroll: true,
            border: true,
            width: 250,
            height: 300,
            id: "ext_tree",
            params: this.params,
            width: "100%",
            listeners: {
                click: this.treeNodeClick
            }
        });
        if (typeof (params.treeData) != "undefined" && params.treeData != null) {
            var root = new Ext.tree.AsyncTreeNode({
                text: "Выбор периода",
                children: params.treeData,
                expanded: true,
                disabled: true,
                id: "root"
            });
        } else {
            root = new Ext.tree.AsyncTreeNode({
                text: "Выбор периода",
                disabled: true,
                id: "root"
            });
        }

        this.tree.setRootNode(root);
        this.tree.render("tree_render");
        this.tree.expand(false, false);

        var nodeid = Ext.get("nodeid_tree").getValue();
        var path = Ext.get("path_tree").getValue();
        this.expandNodeById(nodeid, path);

    };

    this.setupParams = function (params) {
        this.params = params;
        Ext.get("sdate_tree").dom.value = params.sdate;
        Ext.get("edate_tree").dom.value = params.edate;
        Ext.get("periodicity_tree").dom.value = params.periodicity;
        Ext.get("nodeid_tree").dom.value = params.nodeid;
        Ext.get("path_tree").dom.value = params.path;
        if (typeof (params.treeData) != "undefined" && params.treeData != null) {
            var root = new Ext.tree.AsyncTreeNode({
                text: "Выбор периода",
                children: params.treeData,
                expanded: true,
                disabled: true,
                id: "root"
            });
        } else {
            root = new Ext.tree.AsyncTreeNode({
                text: "Выбор периода",
                expanded: true,
                disabled: true,
                id: "root"
            });
        }
        this.tree.setRootNode(root);
        this.tree.getRootNode().reload();
        this.expandNodeById(params.nodeid, params.path);
    };

    this.expandNodeById = function (nodeid, path) {
        if (!this.tree.getNodeById(nodeid)) {
            this.tree.expandPath(path, "id", function (bSuccess, oLastNode) {
                if (bSuccess) {
                    oLastNode.select();
                }
            });
        } else {
            this.tree.getNodeById(nodeid).ensureVisible();
            this.tree.getNodeById(nodeid).select();
        }
    };

    this.treeNodeClick = function (node, event) {
        if (this.params.onlyLeaf && node.isLeaf()) {
            Ext.get("btnSelect_Period").dom.removeAttribute("disabled");
        } else if (this.onlyLeaf && !node.isLeaf()) {
            Ext.get("btnSelect_Period").set({ disabled: "disabled" });
        } else {
            Ext.get("btnSelect_Period").dom.removeAttribute("disabled");
        }

        this.getNodeById(node.id).ensureVisible();
    };

    this.setPeriodValue = function (node) {
        if (this.params.withValues) {
            if (Ext.getCmp("value_" + this.params.id)) {
                if (typeof (node.attributes.values) != "undefined") {
                    if (node.attributes.values != null) {
                        //var responsibleId = Ext.getCmp("ext_responsible_" + this.params.id).value;
                        var responsibleId = Ext.getDom("responsibleId_" + this.params.id).value;
                        for (var i = 0; i < node.attributes.values.length; i++) {
                            if (node.attributes.values[i].responsibleId == responsibleId) {
                                if (this.params.type == "Plan") Ext.getCmp("value_" + this.params.id).setValue(node.attributes.values[i].planValue);
                                else Ext.getCmp("value_" + this.params.id).setValue(node.attributes.values[i].value);
                            }
                        }
                    } else {
                        if (this.params.type == "Plan") Ext.getCmp("value_" + this.params.id).setValue(node.attributes.planValue);
                        else Ext.getCmp("value_" + this.params.id).setValue(node.attributes.value);
                    }
                } else {
                    if (this.params.type == "Plan") Ext.getCmp("value_" + this.params.id).setValue(node.attributes.planValue);
                    else Ext.getCmp("value_" + this.params.id).setValue(node.attributes.value);
                }
            }
        }
    };

    this.setSelectedValues = function() {
        var ExtTree = Ext.getCmp("ext_tree");
        var node = ExtTree.selModel.getSelectedNode();

        if (node) {
            Ext.get("sdate_tree").dom.value = node.attributes.start;
            Ext.get("edate_tree").dom.value = node.attributes.end;
            if (Ext.get("sdate_" + this.params.id))
                Ext.get("sdate_" + this.params.id).dom.value = node.attributes.start;
            if (Ext.get("edate_" + this.params.id))
                Ext.get("edate_" + this.params.id).dom.value = node.attributes.end;
            Ext.get("periodicity_tree").dom.value = node.attributes.curPeriod;
            Ext.get("nodeid_tree").dom.value = node.id;
            Ext.get("path_tree").dom.value = node.getPath();

            if (Ext.get("periodRepr_" + this.params.id))
                Ext.get("periodRepr_" + this.params.id).dom.value = node.text;

            if (Ext.get("indicatorPeriodRepr_" + this.params.subject + this.params.id))
                Ext.get("indicatorPeriodRepr_" + this.params.subject + this.params.id).update(node.text);
            this.setPeriodValue(node);
        }
    };
};

/* + */
function n_setSelectedValues(psubject, pid, withValues, ptype) {
    var ExtTree = Ext.getCmp("ext_tree");
    var node = ExtTree.selModel.getSelectedNode();

    if (node) {
        $("#sdate_tree").val(node.attributes.start);
        $("#edate_tree").val(node.attributes.end);
        if ($("#sdate_" + pid).length > 0)
            $("sdate_" + pid).val(node.attributes.start);
        if ($("#edate_" + pid).length > 0)
            $("#edate_" + pid).val(node.attributes.end);
        $("#periodicity_tree").val(node.attributes.curPeriod);
        $("#nodeid_tree").val(node.id);
        $("#path_tree").val(node.getPath());

        if ($("#periodRepr_" + pid))
            $("#periodRepr_" + pid).val(node.text);

        if ($("#indicatorPeriodRepr_" + psubject + pid))
            $("#indicatorPeriodRepr_" + psubject + pid).html(node.text);

        n_setPeriodValue(node, pid, withValues, ptype);
    }
}

function n_setPeriodValue(node, pid, withValues, ptype) {
    if (withValues) {
        if ($("#value_" + pid).length > 0) {
            if (typeof (node.attributes.values) != "undefined" || node.attributes.values != null) {
                var responsibleId = $("#responsibleId_" + pid).val();
                for (var i = 0; i < node.attributes.values.length; i++) {
                    if (node.attributes.values[i].responsibleId === responsibleId) {
                        if (ptype === "Plan") {
                            $("#value_" + pid).val(node.attributes.values[i].planValue);
                        } else {
                            $("#value_" + pid).val(node.attributes.values[i].value);
                        }
                    }
                }
            }
            else {
                if (ptype === "Plan") {
                    $("#value_" + pid).val(node.attributes.planValue);
                } else {
                    $("#value_" + pid).val(node.attributes.value);
                }
            }
        }
    }
}
/* - */

var myGlobalSettings = null;
function openPeriodSelectDialogInKPI2(settings, treeData) {
    if (Ext.get("PeridosTree") && KPIMControls["tree_selector"] != null) {
        var tree = KPIMControls["tree_selector"];
        var peridosTree = Ext.getDom("PeridosTree");
        var alwaysbind = peridosTree.getAttribute("alwaysbind");
        if (tree.params.id !== settings.id || tree.params.type !== settings.type || alwaysbind === "true") {
            settings.treeData = treeData;
            tree.setupParams(settings);
        }
        openWindow("KpiGlobalPeridosTree", "", "");
    }
    else {
        myGlobalSettings = settings;
        myGlobalSettings.treeData = treeData;
        var openScript = "var tree = KPIMControls['tree_selector'];tree.setupParams(myGlobalSettings);";
        openWindow("KpiGlobalPeridosTree", openScript, "");
    }
}

function confirmPeriodSelectDialog() {
    if ($("#PeridosTree").length > 0) {
        var tree = KPIMControls["tree_selector"];
        if (tree instanceof PeriodsTree) {
            n_setSelectedValues(tree.params.subject, tree.params.id, tree.params.withValues, tree.params.type);
            
            if (tree.params.close_function.length > 0) {
                eval(tree.params.close_function);
            }
        }
        closeWindow("KpiGlobalPeridosTree");
    }
}

function SelectTreeNode(tree, selNodeId) {
    if (selNodeId !== "") {
        var selNode = tree.getNodeById(selNodeId);
        if (selNode) {
            tree.selectPath(selNode.getPath());
        }
    }
}

function elma_kpi_close_popup(name) {
    elma.appendFromPermissionPopup(name);
    $("#" + name).parent().children("a").hide();
}



function ToggleDivSave(self, id) {
    var className = $(self).attr("class").split(" ")[0];
    
    var isVisible = $("#" + id + "_open").is(":visible");
    if (isVisible) {
        $(self).closest("tr").siblings("." + className).show();
        $("#" + id + "_open").hide();
        $("#" + id + "_close").show();
    } else {
        $(self).closest("tr").siblings("." + className).hide();
        $("#" + id + "_open").show();
        $("#" + id + "_close").hide();
    }

    jQuery.cookie(id, isVisible ? "block" : "none");
}

function SaveGlobalPeriod(popupId, json) {
    /* выбранный период */
    if (json != null && json !== "") {

        var selectedPeriod = $.parseJSON(json);

        elma.openPleaseWait(true);
        $.ajax({
            url: "/KPI/Period/ChangeGlobalPeriod",
            type: "POST",
            cache: false,
            data: {
                periodicityId: selectedPeriod.periodicity,
                periodStart: selectedPeriod.periodStart,
                periodEnd: selectedPeriod.periodEnd
            },
            success: function () {
                elma.closePleaseWait(true);
                document.location.reload();
            }
        });
    }
    closeWindow(popupId);
}

function SavePeriod(popupId, json) {
    /* выбранный период */
    if (json != null && json !== "") {

        var selectedPeriod = $.parseJSON(json);

        elma.openPleaseWait(true);

        if ($("#PeriodStart").length > 0)
            $("#PeriodStart").val(selectedPeriod.periodStart);

        if ($("#Entity_PeriodStart").length > 0)
            $("#Entity_PeriodStart").val(selectedPeriod.periodStart);

        if ($("#PeriodEnd").length > 0)
            $("#PeriodEnd").val(selectedPeriod.periodEnd);

        if ($("#Entity_PeriodEnd").length > 0)
            $("#Entity_PeriodEnd").val(selectedPeriod.periodEnd);

        if ($("#PeriodText").length > 0)
            $("#PeriodText").html(selectedPeriod.text);

        if ($("#Entity_PeriodText").length > 0)
            $("#Entity_PeriodText").html(selectedPeriod.text);

        elma.closePleaseWait(true);
    }
    closeWindow(popupId);
}

function DepUsersAccordionHide() {
    $("#departmentUsers").hide();
}

function DepUsersAccordion() {
    $("#departmentUsers").show();
    $("#departmentUsers").kwicks({
        max: 200,
        spacing: 1,
        sticky: true,
        event: "click"
    });
    
    $(window).resize();
}

function FindIndicatorsByName() {
    var searchField = $("#indicatorName").val();
    if (searchField === SR.T("Название показателя..."))
        searchField = "";
    
    elma.openPleaseWait(true);
    $.ajax({
        url: BaseUrl + "KPI/Indicator/FindByName",
        data: {
            indicatorName: searchField
        },
        success: function (responseText) {
            $("#Indicators").html(responseText);
            elma.closePleaseWait(true);
        }
    });
}

function FindDepartmentUsers(url, formId) {
    elma.openPleaseWait(true);
    $.ajax({
        url: BaseUrl + url,
        data: $("#" + formId).serialize(),
        success: function (responseText) {
            $("#departmentUsers").html(responseText);
            elma.closePleaseWait(true);
            DepUsersAccordion();
        }
    });
}

function companyUsersAccordion() {
    $("#KpiCompanyUsers").kwicks({
        max: 200,
        spacing: 1,
        sticky: true,
        event: "click"
    });
    $(window).resize();
}

function FindCompanyUsers() {
    var searchField = $("#c_userFirstName").val();
    if (searchField === SR.T("Имя сотрудника..."))
        searchField = "";

    elma.openPleaseWait(true);
    $.ajax({
        url: BaseUrl + "KPI/Indicator/FindCompanyUsers",
        data: {
            userName: searchField
        },
        success: function (responseText) {
            $("#KpiCompanyUsers").html(responseText);
            elma.closePleaseWait(true);
            companyUsersAccordion();
        }
    });
}

function IndicatorDetailsPopup(id, title) {
    if (id.toString().length > 0) {
        refreshPopup("IndicatorDetailsWindow", BaseUrl + "KPI/Indicator/DetailsPopup/" + id, undefined, title);
    }
}

function AddIndicatorFavorite(indicatorId) {
    if (indicatorId != null && indicatorId !== "") {
        elma.openPleaseWait(true);
        $.ajax({
            url: "/KPI/IndicatorFavorite/AddFavorite",
            type: "POST",
            cache: false,
            data: {
                id: indicatorId
            },
            success: function (data) {
                elma.closePleaseWait(true);
                document.location.reload();
            }
        });
    }
}

function ShowHideFavorites(instanceId) {
    var ul = $("div[instanceId='" + instanceId + "'] #listIndicatorFavorites");
    var brick = ul.parents("div.brick");
    var bigbrick = ul.parents("div.bigbrick");
    
    var divBrick = brick.length > 0 ? brick.get(0) : bigbrick.get(0);

    var divHeight = brick.length > 0 ? "140px" : "215px";

    var columns = ul.children("div.column50");
    var length = columns.length;
    var i;
    if (ul.find("li:hidden").length > 0) {

        for (i = 0; i < length; i++) {
            $(columns[i]).children("li").appendTo(ul).show();
        }
        
        $(divBrick).css("height", "auto");
        $(divBrick).css("min-height", divHeight);

        ul.autocolumnlist({
            columns: 2,
            classname: "column50"
        });

    } else {
        for (i = 0; i < length; i++) {
            $(columns[i]).children("li").appendTo(ul);
        }
        
        $(divBrick).css("height", "auto");
        $(divBrick).css("min-height", "");

        ul.autocolumnlist({
            columns: 2,
            classname: "column50",
            max: 3
        });
    }
}

function ShowHideControlPanelFavorites() {

    var brick = $("#brickControlPanels").parents("div.smallbrick").get(0);
    
    var columns = $("#listControlPanelFavorites").children("div.column50");
    var length = columns.length;
    var i;
    if ($("#listControlPanelFavorites").find("li:hidden").length > 0) {
        for (i = 0; i < length; i++) {
            $(columns[i]).children("li:gt(2)").show();
        }

        $(brick).css("height", "auto");
        $(brick).css("min-height", "100px");
    } else {
        for (i = 0; i < length; i++) {
            $(columns[i]).children("li:gt(2)").hide();
        }
        
        $(brick).css("height", "100px");
        $(brick).css("min-height", "");
    }
}

function AddControlPanelFavorite(portletPageId) {
    if (portletPageId != null && portletPageId !== "") {
        elma.openPleaseWait(true);
        $.ajax({
            url: "/KPI/ControlPanel/AddFavorite",
            type: "POST",
            cache: false,
            data: {
                id: portletPageId
            },
            success: function (data) {
                elma.closePleaseWait(true);
                document.location.reload();
            }
        });
    }
}

function GoToKpiProcess(id) {
    elma.openPleaseWait(true);
    document.location.href = "/KPI/Process/Details/" + id;
}

function GoToKpiIndicator(id) {
    elma.openPleaseWait(true);
    document.location.href = "/KPI/Indicator/Details/" + id;
}

function GoToKpiPersonalIndicator(id, userId) {
    elma.openPleaseWait(true);
    document.location.href = "/KPI/Indicator/Details/" + id + "?userId=" + userId;
}

function GoToKpiDimensionIndicator(id, userId) {
    elma.openPleaseWait(true);
    document.location.href = "/KPI/Indicator/Details/" + id + "?dimensionItemId=" + userId;
}

function putPeriodValue(indicatorId, periodStart, periodEnd, userId, dimId, value, comment, type, recalc) {
    var indicatorValue = [];
    indicatorValue["Indicator.Id"] = indicatorId;
    indicatorValue["RecalcNow"] = recalc || false;
    indicatorValue["PeriodStart"] = periodStart;
    indicatorValue["PeriodEnd"] = periodEnd;
    if (userId && userId > 0) {
        indicatorValue["Responsible.Id"] = userId;
    }
    if (dimId && dimId > 0) {
        indicatorValue["DimensionId"] = dimId;
    }
    indicatorValue["Value"] = value.toString().replace(".", ",").replace(/ /g, "");
    indicatorValue["Comment"] = comment;
    indicatorValue["Subject"] = type;
    $.ajax({
        url: "/KPI/Indicator/PutPeriodValue",
        type: "POST",
        cache: false,
        data: $.extend({}, indicatorValue),
        success: function (data) {
            elma.closePleaseWait(true);
        }
    });
}

function LoadUserMatrix(divId, userId) {
    var isVisible = $("#" + divId).is(":visible");

    if (isVisible) {
        $("#" + divId).slideUp();
    } else {
    if ($("#" + divId).children().length > 0) {
        $("#" + divId).slideDown();
    } else {
        $("#" + divId).html(SR.T("Пожалуйста, подождите...")).show();
        $.ajax({
            url: BaseUrl + "KPI/Performance/UserFullMatrix",
            type: "POST",
            cache: false,
            data: { userId: userId },
            success: function(resultData) {
                $("#" + divId).html(resultData).hide().slideDown();
            }
        });
    }
    }
}

function UpdatePeriodValue(e) {
    if (typeof (e.updates) !== "undefined" && e.updates.length > 0) {
        for (var i = 0, m = e.updates.length; i < m; i++) {
            var newValue = e.updates[i].Second;
            
            var td = $("td[id=" + e.updates[i].First + "]");
            for (var t = 0, tm = td.length; t < tm; t++) {
                var td_a = $(td[t]).find("a");
                
                if (td_a.length === 0) {
                    $(td[t]).html(newValue);
                } else {
                    td_a.html(newValue);
                }
            }
        }
    }
    
    $("td[id=" + e.cellId + "]").css("background-color", "#FAEEC3").attr("title", SR.T("Значение было изменено")).find("a").html(e.value);

    $("#IndicatorTabs-1").html("");

    closeWindow(e.popupName, false, true);
}

function selectIndicatorRow() {
    var objId = $("input[id='IndicatorValueUniqueKey']").val();
    $("*[id$=Cell_" + objId + "]").closest("tr")/*.css("background-color", "lightgoldenrodyellow")*/.attr("active", "true");
}

function unSelectIndicatorRow(closeData) {
    if (!closeData)
        return;
    
    $("tr[active=true]").css("background-color", "").removeAttr("active");
}

// charts.js
function findEntryByDatasetLabel(label, dataset) {
    var key;
    for (key in dataset) {
        if (dataset[key].label == label) {
            return dataset[key];
        }
    }
    return null;
}

function findEntryByLabelAndValue(label, value, dataset) {
    var key;
    for (key in dataset) {
        if (dataset[key].label == label && dataset[key].value == value) {
            return dataset[key];
        }
    }
    return null;
}

function GetIndicatorId(evt, activeBars, dataset, plusX) {
    var mouse = { x: evt.offsetX + (plusX|0) * 0.5, y: evt.offsetY };
    
    if (isset(activeBars)) {
        var activeBar = null;

        if (isset(activeBars[0]) && isset(activeBars[0].outerRadius)) {
            activeBar = findEntryByLabelAndValue(activeBars[0].label, activeBars[0].value, dataset);
        }
        else {
            activeBars.forEach(function (item, index, arr) {
                var limitY = (item.height | 0) * 0.5;
                var limitX = (item.width | 0) * 0.5;
                var divY = Math.abs(item.y + limitY - mouse.y);
                var divX = Math.abs(item.x + limitX - mouse.x);

                var pointer = divY <= 6 && divX <= 6;

                var barer = item.x <= mouse.x && item.x + item.width >= mouse.x;

                if (isset(item.width) ? barer : pointer) {
                    activeBar = findEntryByDatasetLabel(item.datasetLabel, dataset);
                }
            });
        }
        
        if (isset(activeBar) && isset(activeBar.indicatorId)) {
            return activeBar.indicatorId;
        }
        
    }
    return null;
}


  var device,
    previousDevice,
    addClass,
    documentElement,
    find,
    handleOrientation,
    hasClass,
    orientationEvent,
    removeClass,
    userAgent;

  // Save the previous value of the device variable.
  previousDevice = window.device;

  device = {};

  // Add device as a global object.
  window.device = device;

  // The <html> element.
  documentElement = window.document.documentElement;

  // The client user agent string.
  // Lowercase, so we can use the more efficient indexOf(), instead of Regex
  userAgent = window.navigator.userAgent.toLowerCase();

  // Main functions
  // --------------

  device.ios = function () {
    return device.iphone() || device.ipod() || device.ipad();
  };

  device.iphone = function () {
    return !device.windows() && find('iphone');
  };

  device.ipod = function () {
    return find('ipod');
  };

  device.ipad = function () {
    return find('ipad');
  };

  device.android = function () {
    return !device.windows() && find('android');
  };

  device.androidPhone = function () {
    return device.android() && find('mobile');
  };

  device.androidTablet = function () {
    return device.android() && !find('mobile');
  };

  device.blackberry = function () {
    return find('blackberry') || find('bb10') || find('rim');
  };

  device.blackberryPhone = function () {
    return device.blackberry() && !find('tablet');
  };

  device.blackberryTablet = function () {
    return device.blackberry() && find('tablet');
  };

  device.windows = function () {
    return find('windows');
  };

  device.windowsPhone = function () {
    return device.windows() && find('phone');
  };

  device.windowsTablet = function () {
    return device.windows() && (find('touch') && !device.windowsPhone());
  };

  device.fxos = function () {
    return (find('(mobile;') || find('(tablet;')) && find('; rv:');
  };

  device.fxosPhone = function () {
    return device.fxos() && find('mobile');
  };

  device.fxosTablet = function () {
    return device.fxos() && find('tablet');
  };

  device.meego = function () {
    return find('meego');
  };

  device.cordova = function () {
    return window.cordova && location.protocol === 'file:';
  };

  device.nodeWebkit = function () {
    return typeof window.process === 'object';
  };

  device.mobile = function () {
    return device.androidPhone() || device.iphone() || device.ipod() || device.windowsPhone() || device.blackberryPhone() || device.fxosPhone() || device.meego();
  };

  device.tablet = function () {
    return device.ipad() || device.androidTablet() || device.blackberryTablet() || device.windowsTablet() || device.fxosTablet();
  };

  device.desktop = function () {
    return !device.tablet() && !device.mobile();
  };

  device.television = function() {
    var i, television = [
      "googletv",
      "viera",
      "smarttv",
      "internet.tv",
      "netcast",
      "nettv",
      "appletv",
      "boxee",
      "kylo",
      "roku",
      "dlnadoc",
      "roku",
      "pov_tv",
      "hbbtv",
      "ce-html"
    ];

    i = 0;
    while (i < television.length) {
      if (find(television[i])) {
        return true;
      }
      i++;
    }
    return false;
  };

  device.portrait = function () {
    return (window.innerHeight / window.innerWidth) > 1;
  };

  device.landscape = function () {
    return (window.innerHeight / window.innerWidth) < 1;
  };

  // Private Utility Functions
  // -------------------------

  // Simple UA string search
  find = function (needle) {
    return userAgent.indexOf(needle) !== -1;
  };


var RouteApprovement = function (containerId, url, scriptPostfix, htmlPrefix) {

    this.AddStage = function(prefix) {
        var rows = $('#' + containerId + '  > .editRouteApprovementContainer table.stageApprovementTable > tbody > tr');
        var count = rows.length;
        var index = 0;
        rows.each(function(i, ui) {
            if (index < $(ui).data('index')) {
                index = $(ui).data('index');
            }
        });
        index += 1;
        elma.openPleaseWait(true);
        $.ajax({
            url: url + "/CreateNewStage?scriptPostfix=" + scriptPostfix + "&prefix="+prefix,
            data: { 'containerId': containerId, 'stageNumber': count + 1, 'index': index },
            success: function (data) {
                $('#' + containerId + '  > .editRouteApprovementContainer table.stageApprovementTable > tbody').append(data);
                elma.closePleaseWait(true);
                recalculateIndexes();
            }
        });
        return false;
    }

    this.SaveRouteApprovement = function (id) {
        elma.ValidationRulesManager.disible(id.replace("_Id", ""), id);
        if ($('form').valid()) {
            jConfirm(SR.T("Вы действительно хотите сохранить запись?"), SR.T("Сохранение маршрута согласования"),
                function (r) {
                    var idval = $('#' + id).val();
                    if (r == true) {
                        elma.openPleaseWait(true);
                        $.ajax({
                            url: url + "/SaveRouteApprovement",
                            type: "POST",
                            data: $('form').serialize(),
                            success: function(data) {
                                $('#' + id).data('tComboBox').reloadSelect(data);
                                elma.closePleaseWait(true);
                            }
                        });
                    } else {
                        $('#' + id).val(idval);
                    }
                }
            );
        }
        elma.ValidationRulesManager.enable(id, id + "_Id");
    }

    this.PickUpRouteApprovementRow = function (arrow) {        
        var currentRowIndex = $(arrow).closest('tr').find('td.cellWithIndex input').first().val() - 1;
        if (containerId != null && currentRowIndex != 0) {
            var row = $('#' + containerId + '  > .editRouteApprovementContainer table.stageApprovementTable > tbody > tr')[currentRowIndex];
            var prevIndex = currentRowIndex - 1;
            var previousRow = $('#' + containerId + ' table.stageApprovementTable > tbody > tr')[prevIndex];
            row.after(previousRow);
            recalculateIndexes();
        }
    }

    this.PutDownRouteApprovementRow = function(arrow) {
        var currentRowIndex = $(arrow).closest('tr').find('td.cellWithIndex input').first().val() - 1;
        if (containerId != null && currentRowIndex < $('#' + containerId + ' table.stageApprovementTable > tbody > tr').length - 1) {
            var row = $('#' + containerId + '  > .editRouteApprovementContainer table.stageApprovementTable > tbody > tr')[currentRowIndex];
            var nextIndex = currentRowIndex + 1;
            var nextRow = $('#' + containerId + '  > .editRouteApprovementContainer table.stageApprovementTable > tbody > tr')[nextIndex];
            row.before(nextRow);
            recalculateIndexes();
        }
    }

    function recalculateIndexes() {
        var rows = $('#' + containerId + ' > .editRouteApprovementContainer table.stageApprovementTable > tbody > tr');
        rows.each(function (index, row) {
            var elem = $(row).find('td.cellWithIndex input').first();
            elem.next('span').html(index + 1);
            elem.val(index + 1);
            var inputs = $(row).find('input');
            inputs.each(function (i, input) {
                var name = $(input).attr('name');
                if (name != "" && name != undefined) {
                    var str = "StageApprovementList";
                    var index1 = name.lastIndexOf(str) + str.length + 1;
                    var firstPart = name.substr(0, index1);
                    var index2 = name.replace(firstPart, "").indexOf("]");
                    var newName = name.substr(0, index1) + index + name.substr(index1 + index2);
                    $(input).attr('name', newName);
                }
            });
        });
        checkValidation();
    }

    this.RemoveRow = function (item, id) {
        var count = $(item).closest('tbody').children('tr').length;
        if (count == 1) {
            jAlert(SR.T("Невозможно удалить последнюю запись"), SR.T("Удаление"));
        } else {
            jConfirm(SR.T("Удалить запись?"), SR.T("Удаление"),
                function (r) {
                    if (r == true) {
                        $(item).closest('tr').remove();
                        recalculateIndexes();
                    }
                }
            );
        }

    }

    this.LoadRouteApprovement = function (id, prefix, canEditOrAdd, inputId, openForEditStages, saveToGlobal) {        
        if (!elma.ValidationRulesManager.hasInRules(inputId)) {
            elma.ValidationRulesManager.enable(inputId.replace("_Id", ""), inputId);
        }
        var saveRouteContainer = prefix + '_saveRouteContainer';
        if (id === "") {
            $('#' + containerId + ' > .editRouteApprovementContainer').html("");
            $('#' + containerId + ' > #' + saveRouteContainer).hide();
        } else {
            if (!elma.ValidationRulesManager.hasInRules(inputId)) {
                elma.ValidationRulesManager.enable(inputId.replace("_Id", ""), inputId);
            }
            var readonly = canEditOrAdd == "false" || openForEditStages == "false";
            elma.openPleaseWait(true);
            $.ajax({
                url: url + "/Grid?id=" + id + "&scriptPostfix=" + scriptPostfix + "&prefix=" + prefix + "&readOnly=" + readonly,
                success: function (data) {
                    if (saveToGlobal) {
                        $('#' + saveRouteContainer).show();
                    } else {
                        $('#' + saveRouteContainer).hide();
                    }
                    $('#' + containerId + ' > .editRouteApprovementContainer').html(data);
                    checkValidation();
                    elma.closePleaseWait(true);
                }
            });
        }
    }

    this.ChangePosition = function (item) {
        var index = $(item).val();
        if (index != "") {
            var row = $(item).closest('tr');
            var rows = row.parent('tbody').children('tr');
            var oldIndex = 0;
            rows.each(function (i, ui) {
                if (row[0] == $(ui)[0]) {
                    oldIndex = i + 1;
                }
            });
            var rowsLength = rows.length;
            if (index > rowsLength) {
                index = rowsLength;
            }
            var row1 = $('#' + containerId + ' table.stageApprovementTable > tbody > tr:nth-child(' + index + ')');
            if (oldIndex < index) {
                row1.after(row);
            } else if (oldIndex > index) {
                row1.before(row);
            }
        }
        recalculateIndexes();
    }

    this.ResetInput = function (id) {
        var combobox = $('#' + id).data("tComboBox");
        if (combobox != null) {
            combobox.previousValue = 0;
            combobox.previousText = 0;
            combobox.clearSelect();
            combobox.trigger.change();
            combobox.value(0);
        }
        elma.ValidationRulesManager.disible(id.replace("_Id", ""), id);
    }


    this.ChangeApprovers = function () {
        recalculateIndexes();
    }

    function checkValidation() {
        var rows = $('#' + containerId + ' > .editRouteApprovementContainer table.stageApprovementTable > tbody > tr');
        for (var i = 0; i < rows.length; i++) {
            var userStr = htmlPrefix + "_StageApprovementList_" + i + "__Users";
            var userGroupsStr = htmlPrefix + "_StageApprovementList_" + i + "__UserGroups";
            var organizationItemsStr = htmlPrefix + "_StageApprovementList_" + i + "__OrganizationItems";
            try {
                if (!elma.ValidationRulesManager.hasInRules(userStr)) {
                    elma.ValidationRulesManager.addRule(userStr, 'add', { required: true, messages: { required: SR.T("Выберите согласующих") } });
                }
                if ($('#div-' + userStr + '_Id').html().replace(/[\s{2,}‌​]+/g, '') != "" ||
                    $('#div-' + userGroupsStr + '_Id').html().replace(/[\s{2,}‌​]+/g, '') != "" ||
                    $('#div-' + organizationItemsStr + '_Id').html().replace(/[\s{2,}‌​]+/g, '') != "") {
                    elma.ValidationRulesManager.disible(userStr, userStr + "_Id");
                } else {
                    elma.ValidationRulesManager.enable(userStr, userStr + "_Id");
                }
            } catch (ex) {
                continue;
            }
        }
    }

}


var Docflow = {
    findConnector: function (selectedConnectorUid, connectors) {
        var foundСonnector = {};
        $.each(connectors, function (_, connector) {
            if (connector.uid == selectedConnectorUid) {
                foundСonnector = connector;
                return false;
            }
        });
        return foundСonnector;
    },
    isCommentRequired: function (selectedConnectorUid, connectors) {
        var connector = Docflow.findConnector(selectedConnectorUid, connectors);
        return !!connector.commentRequired;
    },
    addCommentRule: function(commentId, commentRequired) {
        if (commentRequired) {
            $('#' + commentId).rules('add', { required: true, messages: { required: SR.T('Заполните обязательное поле') } });
        }
    },
    removeCommentRule: function (commentId) {
        $('#' + commentId).rules("remove", "required reqfield");
        $('#' + commentId + '_validationMessage').empty();
    },

    enableComment: function (selectedConnectorUid, connectors) {
	    var connector = Docflow.findConnector(selectedConnectorUid, connectors);
	    return !!connector.enableComment;
	},
	
    getSignText: function (formId, commentId, url, sucessCb, errorCb) {
        var formModel = [];
        if (formId.length > 0) {
            var formFields = $('#' + formId).serializeArray();
            $.each(formFields, $.proxy(function (_, field) {
                formModel[field.name] = field.value;
            }, this));
        }
        $.ajax({
            url: url,
            type: "POST",
            dataType: 'json',
            data: $.extend(commentId.length > 0 ? { 'comment': $('#' + commentId).val() } : {}, formModel),
            cache: false,
            success: function (data) {
                if (data.success) {
                    sucessCb(data.text);
                } else {
                    var msg = SR.T('При получении текста сообщения произошла ошибка.<br/>Проверьте правильность составления шаблона подписи.');
                    errorCb(msg);
                }
            },
            error: function () {
                var msg = SR.T('При получении текста сообщения произошла ошибка.<br/>Проверьте доступность сервера.');
                errorCb(msg);
            }
        });
    },

    getVersionHash: function (url, successCb, errorCb) {
        $.ajax({
            url: url,
            type: "GET",
            dataType: 'json',
            cache: false,
            success: function (data) {
                if (data.error) {
                    var msg = SR.T('При получении хеша данных произошла ошибка.') + data.error;
                    errorCb(msg);
                } else {
                    successCb(data.hash);
                }
            },
            error: function () {
                var msg = SR.T('При получении хеша данных произошла ошибка.');
                errorCb(msg);
            }
        });
    },

    getVersionPreview: function (previewUrl, successCb, errorCb) {
        $.ajax({
            url: previewUrl,
            type: "GET",
            cache: false,
            success: function (data) {
                successCb(data);
            },
            error: function () {
                var msg = SR.T('При получении предпросмотра содержимого версии произошла ошибка.');
                errorCb(msg);
            }
        });
    }
}

//End files
